<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AcquireSRWLockExclusive">
    <summary>Acquires a slim reader/writer (SRW) lock in exclusive mode.</summary>
    <param name="SRWLock">A pointer to the SRW lock.</param>
  </member>
  <member name="Windows.AcquireSRWLockShared">
    <summary>Acquires a slim reader/writer (SRW) lock in shared mode.</summary>
    <param name="SRWLock">A pointer to the SRW lock.</param>
  </member>
  <member name="Windows.CancelWaitableTimer">
    <summary>Sets the specified waitable timer to the inactive state.</summary>
    <param name="hTimer">A handle to the timer object. The<see cref="CreateWaitableTimer" /> or<see cref="OpenWaitableTimer" /> function returns this handle. The handle must have the <b>TIMER_MODIFY_STATE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEvent">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the<see cref="ResetEvent" /> function to set the event state to nonsignaled. If this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and the system automatically resets the event state to nonsignaled after a single waiting thread has been released.</param>
    <param name="bInitialState">If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests the <b>EVENT_ALL_ACCESS</b> access right. In this case, the<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored because they have already been set by the creating process. If the<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEventA">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the<see cref="ResetEvent" /> function to set the event state to nonsignaled. If this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and the system automatically resets the event state to nonsignaled after a single waiting thread has been released.</param>
    <param name="bInitialState">If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests the <b>EVENT_ALL_ACCESS</b> access right. In this case, the<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored because they have already been set by the creating process. If the<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEventW">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the<see cref="ResetEvent" /> function to set the event state to nonsignaled. If this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and the system automatically resets the event state to nonsignaled after a single waiting thread has been released.</param>
    <param name="bInitialState">If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests the <b>EVENT_ALL_ACCESS</b> access right. In this case, the<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored because they have already been set by the creating process. If the<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEventEx">
    <summary>Creates or opens a named or unnamed event object and returns a handle to the object.</summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The initial state of the event object is signaled; otherwise, it is nonsignaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of waiting threads, or threads that subsequently begin wait operations for the specified event object, can be released while the object's state is signaled.<para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the event object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEventExA">
    <summary>Creates or opens a named or unnamed event object and returns a handle to the object.</summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The initial state of the event object is signaled; otherwise, it is nonsignaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of waiting threads, or threads that subsequently begin wait operations for the specified event object, can be released while the object's state is signaled.<para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the event object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEventExW">
    <summary>Creates or opens a named or unnamed event object and returns a handle to the object.</summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The initial state of the event object is signaled; otherwise, it is nonsignaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of waiting threads, or threads that subsequently begin wait operations for the specified event object, can be released while the object's state is signaled.<para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the event object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEventEx">
    <summary>Creates or opens a named or unnamed event object and returns a handle to the object.</summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The initial state of the event object is signaled; otherwise, it is nonsignaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of waiting threads, or threads that subsequently begin wait operations for the specified event object, can be released while the object's state is signaled.<para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the event object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEventExA">
    <summary>Creates or opens a named or unnamed event object and returns a handle to the object.</summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The initial state of the event object is signaled; otherwise, it is nonsignaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of waiting threads, or threads that subsequently begin wait operations for the specified event object, can be released while the object's state is signaled.<para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the event object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEventExW">
    <summary>Creates or opens a named or unnamed event object and returns a handle to the object.</summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The initial state of the event object is signaled; otherwise, it is nonsignaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of waiting threads, or threads that subsequently begin wait operations for the specified event object, can be released while the object's state is signaled.<para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the event object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEvent">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the<see cref="ResetEvent" /> function to set the event state to nonsignaled. If this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and system automatically resets the event state to nonsignaled after a single waiting thread has been released.</param>
    <param name="bInitialState">If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests the <b>EVENT_ALL_ACCESS</b> access right. In this case, the<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored because they have already been set by the creating process. If the<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEventA">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the<see cref="ResetEvent" /> function to set the event state to nonsignaled. If this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and system automatically resets the event state to nonsignaled after a single waiting thread has been released.</param>
    <param name="bInitialState">If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests the <b>EVENT_ALL_ACCESS</b> access right. In this case, the<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored because they have already been set by the creating process. If the<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateEventW">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the<see cref="ResetEvent" /> function to set the event state to nonsignaled. If this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and system automatically resets the event state to nonsignaled after a single waiting thread has been released.</param>
    <param name="bInitialState">If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests the <b>EVENT_ALL_ACCESS</b> access right. In this case, the<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored because they have already been set by the creating process. If the<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutex">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutexA">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutexW">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutexEx">
    <summary>Creates or opens a named or unnamed mutex object and returns a handle to the object.</summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The object creator is the initial owner of the mutex.</description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the mutex object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutexExA">
    <summary>Creates or opens a named or unnamed mutex object and returns a handle to the object.</summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The object creator is the initial owner of the mutex.</description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the mutex object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutexExW">
    <summary>Creates or opens a named or unnamed mutex object and returns a handle to the object.</summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The object creator is the initial owner of the mutex.</description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the mutex object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutexEx">
    <summary>Creates or opens a named or unnamed mutex object and returns a handle to the object.</summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The object creator is the initial owner of the mutex.</description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the mutex object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutexExA">
    <summary>Creates or opens a named or unnamed mutex object and returns a handle to the object.</summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The object creator is the initial owner of the mutex.</description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the mutex object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutexExW">
    <summary>Creates or opens a named or unnamed mutex object and returns a handle to the object.</summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The object creator is the initial owner of the mutex.</description>
        </listheader>
      </list>
    </param>
    <param name="dwDesiredAccess">The access mask for the mutex object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutex">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutexA">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateMutexW">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
  </member>
  <member name="Windows.CreateSemaphoreExA">
    <summary>Creates or opens a named or unnamed semaphore object and returns a handle to the object.</summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the semaphore handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the<see cref="ReleaseSemaphore" /> function.</param>
    <param name="lMaximumCount">The maximum count for the semaphore object. This value must be greater than zero.</param>
    <param name="lpName">
      <para>A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">This parameter is reserved and must be 0.</param>
    <param name="dwDesiredAccess">The access mask for the semaphore object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSemaphoreExW">
    <summary>Creates or opens a named or unnamed semaphore object and returns a handle to the object.</summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the semaphore handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the<see cref="ReleaseSemaphore" /> function.</param>
    <param name="lMaximumCount">The maximum count for the semaphore object. This value must be greater than zero.</param>
    <param name="lpName">
      <para>A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">This parameter is reserved and must be 0.</param>
    <param name="dwDesiredAccess">The access mask for the semaphore object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSemaphoreA">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateSemaphoreEx" /> function.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the<see cref="ReleaseSemaphore" /> function.</param>
    <param name="lMaximumCount">The maximum count for the semaphore object. This value must be greater than zero.</param>
    <param name="lpName">
      <para>The name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, this function requests the <b>SEMAPHORE_ALL_ACCESS</b> access right. In this case, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSemaphoreW">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateSemaphoreEx" /> function.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the<see cref="ReleaseSemaphore" /> function.</param>
    <param name="lMaximumCount">The maximum count for the semaphore object. This value must be greater than zero.</param>
    <param name="lpName">
      <para>The name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, this function requests the <b>SEMAPHORE_ALL_ACCESS</b> access right. In this case, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateWaitableTimer">
    <summary>
      <para>Creates or opens a waitable timer object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateWaitableTimerEx" /> function.</para>
    </summary>
    <param name="lpTimerAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new timer object and determines whether child processes can inherit the returned handle.</para>
      <para>If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">If this parameter is <b>TRUE</b>, the timer is a manual-reset notification timer. Otherwise, the timer is a synchronization timer.</param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name.</para>
      <para>If <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and<see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateWaitableTimerA">
    <summary>
      <para>Creates or opens a waitable timer object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateWaitableTimerEx" /> function.</para>
    </summary>
    <param name="lpTimerAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new timer object and determines whether child processes can inherit the returned handle.</para>
      <para>If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">If this parameter is <b>TRUE</b>, the timer is a manual-reset notification timer. Otherwise, the timer is a synchronization timer.</param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name.</para>
      <para>If <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and<see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateWaitableTimerW">
    <summary>
      <para>Creates or opens a waitable timer object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateWaitableTimerEx" /> function.</para>
    </summary>
    <param name="lpTimerAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new timer object and determines whether child processes can inherit the returned handle.</para>
      <para>If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">If this parameter is <b>TRUE</b>, the timer is a manual-reset notification timer. Otherwise, the timer is a synchronization timer.</param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name.</para>
      <para>If <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and<see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteCriticalSection">
    <summary>Releases all resources used by an unowned critical section object.</summary>
    <param name="lpCriticalSection">A pointer to the critical section object. The object must have been previously initialized with the<see cref="InitializeCriticalSection" /> function.</param>
  </member>
  <member name="Windows.DeleteSynchronizationBarrier">
    <summary>Deletes a synchronization barrier.</summary>
    <param name="lpBarrier">A pointer to the synchronization barrier to delete.</param>
    <returns>The <b>DeleteSynchronizationBarrier</b> function always returns <b>TRUE</b>.</returns>
  </member>
  <member name="Windows.EnterCriticalSection">
    <summary>Waits for ownership of the specified critical section object. The function returns when the calling thread is granted ownership.</summary>
    <param name="lpCriticalSection">A pointer to the critical section object.</param>
    <returns>
      <para>This function does not return a value.</para>
      <para>This function can raise <b>EXCEPTION_POSSIBLE_DEADLOCK</b>, also known as <b>STATUS_POSSIBLE_DEADLOCK</b>, if a wait operation on the critical section times out. The timeout interval is specified by the following registry value: <b>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager</b>\<b>CriticalSectionTimeout</b>. Do not handle a possible deadlock exception; instead, debug the application.</para>
    </returns>
  </member>
  <member name="Windows.EnterSynchronizationBarrier">
    <summary>Causes the calling thread to wait at a synchronization barrier until the maximum number of threads have entered the barrier.</summary>
    <param name="lpBarrier">A pointer to an initialized synchronization barrier. Use the<see cref="InitializeSynchronizationBarrier" />function to initialize the barrier. <b>SYNCHRONIZATION_BARRIER</b> is an opaque structure that should not be modified by the application.</param>
    <param name="dwFlags">
      <para>Flags that control the behavior of threads that enter this barrier. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY</b>
                </term>
              </listheader>
              <listheader></listheader>
            </list>
          </description>
          <description>Specifies that the thread entering the barrier should block immediately until the last thread enters the barrier. For more information, see Remarks.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY</b>
                </term>
              </listheader>
              <listheader></listheader>
            </list>
          </description>
          <description>Specifies that the thread entering the barrier should spin until the last thread enters the barrier, even if the spinning thread exceeds the barrier's maximum spin count. For more information, see Remarks.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE</b>
                </term>
              </listheader>
              <listheader></listheader>
            </list>
          </description>
          <description>Specifies that the function can skip the work required to ensure that it is safe to delete the barrier, which can improve performance. All threads that enter this barrier must specify the flag; otherwise, the flag is ignored. This flag should be used only if the barrier will never be deleted.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <b>TRUE</b> for the last thread to signal the barrier. Threads that signal the barrier before the last thread signals it receive a return value of <b>FALSE</b>.</returns>
  </member>
  <member name="Windows.InitializeConditionVariable">
    <summary>Initializes a condition variable.</summary>
    <param name="ConditionVariable">A pointer to the condition variable.</param>
  </member>
  <member name="Windows.InitializeCriticalSection">
    <summary>Initializes a critical section object.</summary>
    <param name="lpCriticalSection">A pointer to the critical section object.</param>
    <returns>
      <para>This function does not return a value.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>In low memory situations,<b>InitializeCriticalSection</b> can raise a <b>STATUS_NO_MEMORY</b> exception. Starting with Windows Vista, this exception was eliminated and <b>InitializeCriticalSection</b> always succeeds, even in low memory situations.</para>
    </returns>
  </member>
  <member name="Windows.InitializeCriticalSectionAndSpinCount">
    <summary>Initializes a critical section object and sets the spin count for the critical section. When a thread tries to acquire a critical section that is locked, the thread <i>spins</i>: it enters a loop which iterates spin count times, checking to see if the lock is released. If the lock is not released before the loop finishes, the thread goes to sleep to wait for the lock to be released.</summary>
    <param name="lpCriticalSection">A pointer to the critical section object.</param>
    <param name="dwSpinCount">The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to 0 (zero). On multiprocessor systems, if the critical section is unavailable, the calling thread spins <i>dwSpinCount</i> times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</param>
    <returns>
      <para>This function always succeeds and returns a nonzero value.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />. Starting with Windows Vista, the <b>InitializeCriticalSectionAndSpinCount</b> function always succeeds, even in low memory situations.</para>
    </returns>
  </member>
  <member name="Windows.InitializeCriticalSectionEx">
    <summary>Initializes a critical section object with a spin count and optional flags.</summary>
    <param name="lpCriticalSection">A pointer to the critical section object.</param>
    <param name="dwSpinCount">The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to 0 (zero). On multiprocessor systems, if the critical section is unavailable, the calling thread spin <i>dwSpinCount</i> times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</param>
    <param name="Flags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CRITICAL_SECTION_NO_DEBUG_INFO</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The critical section is created without debug information.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.InitializeSRWLock">
    <summary>Initialize a slim reader/writer (SRW) lock.</summary>
    <param name="SRWLock">A pointer to the SRW lock.</param>
  </member>
  <member name="Windows.InitializeSynchronizationBarrier">
    <summary>Initializes a new synchronization barrier.</summary>
    <param name="lpBarrier">A pointer to the <b>SYNCHRONIZATION_BARRIER</b> structure to initialize. This is an opaque structure that should not be modified by applications.</param>
    <param name="lTotalThreads">The maximum number of threads that can enter this barrier. After the maximum number of threads have entered the barrier, all threads continue.</param>
    <param name="lSpinCount">The number of times an individual thread should spin while waiting for other threads to arrive at the barrier. If this parameter is -1, the thread spins 2000 times. If the thread exceeds<i>lSpinCount</i>, the thread blocks unless it called<see cref="EnterSynchronizationBarrier" /> with<b>SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY</b>.</param>
    <returns>
      <b>TRUE</b> if the barrier was successfully initialized. If the barrier was not successfully initialized, this function returns <b>FALSE</b>. Use<see cref="GetLastError" /> to get extended error information.</returns>
  </member>
  <member name="Windows.InitOnceBeginInitialize">
    <summary>Begins one-time initialization.</summary>
    <param name="lpInitOnce">A pointer to the one-time initialization structure.</param>
    <param name="dwFlags">
      <para>This parameter can have a value of 0, or one or more of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>INIT_ONCE_ASYNC</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002UL</term>
              </listheader>
            </list>
          </description>
          <description>Enables multiple initialization attempts to execute in parallel. If this flag is used, subsequent calls to this function will fail unless this flag is also specified.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>INIT_ONCE_CHECK_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001UL</term>
              </listheader>
            </list>
          </description>
          <description>This function call does not begin initialization. The return value indicates whether initialization has already completed. If the function returns <b>TRUE</b>, the <i>lpContext</i> parameter receives the data.</description>
        </listheader>
      </list>
    </param>
    <param name="fPending">
      <para>If the function succeeds, this parameter indicates the current initialization status.</para>
      <para>If this parameter is <b>TRUE</b> and <i>dwFlags</i> contains <b>INIT_ONCE_CHECK_ONLY</b>, the initialization is pending and the context data is invalid.</para>
      <para>If this parameter is <b>FALSE</b>, initialization has already completed and the caller can retrieve the context data from the <i>lpContext</i> parameter.</para>
      <para>If this parameter is <b>TRUE</b> and <i>dwFlags</i> does not contain <b>INIT_ONCE_CHECK_ONLY</b>, initialization has been started and the caller can perform the initialization tasks.</para>
    </param>
    <param name="lpContext">An optional parameter that receives the data stored with the one-time initialization structure upon success. The low-order <b>INIT_ONCE_CTX_RESERVED_BITS</b> bits of the data are always zero.</param>
    <returns>
      <para>If <b>INIT_ONCE_CHECK_ONLY</b> is not specified and the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If <b>INIT_ONCE_CHECK_ONLY</b> is specified and initialization has completed, the return value is <b>TRUE</b>.</para>
      <para>Otherwise, the return value is <b>FALSE</b>.</para>
      <para>To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.InitOnceComplete">
    <summary>Completes one-time initialization started with the <see cref="InitOnceBeginInitialize" /> function.</summary>
    <param name="lpInitOnce">A pointer to the one-time initialization structure.</param>
    <param name="dwFlags">
      <para>This parameter can be one of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>INIT_ONCE_ASYNC</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002UL</term>
              </listheader>
            </list>
          </description>
          <description>Operate in asynchronous mode. This enables multiple completion attempts to execute in parallel. This flag must match the flag passed in the corresponding call to the <see cref="InitOnceBeginInitialize" /> function. This flag may not be combined with <b>INIT_ONCE_INIT_FAILED</b>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>INIT_ONCE_INIT_FAILED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004UL</term>
              </listheader>
            </list>
          </description>
          <description>The initialization attempt failed. This flag may not be combined with <b>INIT_ONCE_ASYNC</b>. To fail an asynchronous initialization, merely abandon it (that is, do not call the <b>InitOnceComplete</b> function).</description>
        </listheader>
      </list>
    </param>
    <param name="lpContext">A pointer to the data to be stored with the one-time initialization structure. This data is returned in the <i>lpContext</i> parameter passed to subsequent calls to the <see cref="InitOnceBeginInitialize" /> function. If <i>lpContext</i> points to a value, the low-order <b>INIT_ONCE_CTX_RESERVED_BITS</b> of the value must be zero. If <i>lpContext</i> points to a data structure, the data structure must be <b>DWORD</b>-aligned.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.InitOnceExecuteOnce">
    <summary>When multiple threads call InitOnceExecuteOnce passing the same one-time initialization block, only one thread will execute the callback function specified by <i>InitFn</i>. The remaining threads will block until the callback function completes. If the callback function returns <b>TRUE</b> to indicate success, InitOnceExecuteOnce will return <b>TRUE</b> back to all callers at once. If, however, the callback returns <b>FALSE</b> to indicate failure, InitOnceExecuteOnce will return <b>FALSE</b> to only the single thread which executed the callback function. At this same time one of the remaining blocked threads will unblock and execute <i>InitFn</i> once again. Thus, in a scenario where <i>InitFn</i> can fail intermittently and retries are desired, all threads should continue calling InitOnceExecuteOnce until <b>TRUE</b> is returned.</summary>
    <param name="InitOnce">A pointer to the one-time initialization structure.</param>
    <param name="InitFn">A pointer to an application-defined <a href="https://docs.microsoft.com//windows/desktop/api/synchapi/nc-synchapi-pinit_once_fn">InitOnceCallback</a> function.</param>
    <param name="Parameter">A parameter to be passed to the callback function.</param>
    <param name="Context">A parameter that receives data stored with the one-time initialization structure upon success. The low-order <b>INIT_ONCE_CTX_RESERVED_BITS</b> bits of the data are always zero. If <i>Context</i> points to a data structure, the data structure must be <b>DWORD</b>-aligned. <i>Context</i> must not be a code pointer on Arm32, because Arm32 code pointers always have the least significant bit set, see the <a href="https://docs.microsoft.com//cpp/build/overview-of-arm-abi-conventions?view=msvc-170#instruction-set">Arm32 ABI</a> for details.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.InitOnceInitialize">
    <summary>Initializes a one-time initialization structure.</summary>
    <param name="InitOnce">A pointer to the one-time initialization structure.</param>
  </member>
  <member name="Windows.LeaveCriticalSection">
    <summary>Releases ownership of the specified critical section object.</summary>
    <param name="lpCriticalSection">A pointer to the critical section object.</param>
  </member>
  <member name="Windows.OpenEvent">
    <summary>Opens an existing named event object.</summary>
    <param name="dwDesiredAccess">The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenEventA">
    <summary>Opens an existing named event object.</summary>
    <param name="dwDesiredAccess">The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenEventW">
    <summary>Opens an existing named event object.</summary>
    <param name="dwDesiredAccess">The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenEvent">
    <summary>Opens an existing named event object.</summary>
    <param name="dwDesiredAccess">The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenEventA">
    <summary>Opens an existing named event object.</summary>
    <param name="dwDesiredAccess">The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenEventW">
    <summary>Opens an existing named event object.</summary>
    <param name="dwDesiredAccess">The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenMutex">
    <summary>Opens an existing named mutex object.</summary>
    <param name="dwDesiredAccess">The access to the mutex object. Only the <b>SYNCHRONIZE</b> access right is required to use a mutex; to change the mutex's security, specify <b>MUTEX_ALL_ACCESS</b>. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the mutex to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If a named mutex does not exist, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
  </member>
  <member name="Windows.OpenMutexA">
    <summary>Opens an existing named mutex object.</summary>
    <param name="dwDesiredAccess">The access to the mutex object. Only the <b>SYNCHRONIZE</b> access right is required to use a mutex; to change the mutex's security, specify <b>MUTEX_ALL_ACCESS</b>. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the mutex to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If a named mutex does not exist, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
  </member>
  <member name="Windows.OpenMutexW">
    <summary>Opens an existing named mutex object.</summary>
    <param name="dwDesiredAccess">The access to the mutex object. Only the <b>SYNCHRONIZE</b> access right is required to use a mutex; to change the mutex's security, specify <b>MUTEX_ALL_ACCESS</b>. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the mutex to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If a named mutex does not exist, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
  </member>
  <member name="Windows.OpenSemaphore">
    <summary>Opens an existing named semaphore object.</summary>
    <param name="dwDesiredAccess">The access to the semaphore object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the semaphore to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenSemaphoreA">
    <summary>Opens an existing named semaphore object.</summary>
    <param name="dwDesiredAccess">The access to the semaphore object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the semaphore to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenSemaphoreW">
    <summary>Opens an existing named semaphore object.</summary>
    <param name="dwDesiredAccess">The access to the semaphore object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the semaphore to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenWaitableTimer">
    <summary>Opens an existing named waitable timer object.</summary>
    <param name="dwDesiredAccess">The access to the timer object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenWaitableTimerA">
    <summary>Opens an existing named waitable timer object.</summary>
    <param name="dwDesiredAccess">The access to the timer object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenWaitableTimerW">
    <summary>Opens an existing named waitable timer object.</summary>
    <param name="dwDesiredAccess">The access to the timer object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ReleaseMutex">
    <summary>Releases ownership of the specified mutex object.</summary>
    <param name="hMutex">
      <para>A handle to the mutex object. The<see cref="CreateMutex" /> or</para>
      <para>
        <see cref="OpenMutex" /> function returns this handle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ReleaseSemaphore">
    <summary>Increases the count of the specified semaphore object by a specified amount.</summary>
    <param name="hSemaphore">
      <para>A handle to the semaphore object. The<see cref="CreateSemaphore" /> or<see cref="OpenSemaphore" /> function returns this handle.</para>
      <para>This handle must have the <b>SEMAPHORE_MODIFY_STATE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lReleaseCount">The amount by which the semaphore object's current count is to be increased. The value must be greater than zero. If the specified amount would cause the semaphore's count to exceed the maximum count that was specified when the semaphore was created, the count is not changed and the function returns <b>FALSE</b>.</param>
    <param name="lpPreviousCount">A pointer to a variable to receive the previous count for the semaphore. This parameter can be <b>NULL</b> if the previous count is not required.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ReleaseSRWLockExclusive">
    <summary>Releases a slim reader/writer (SRW) lock that was acquired in exclusive mode.</summary>
    <param name="SRWLock">A pointer to the SRW lock.</param>
  </member>
  <member name="Windows.ReleaseSRWLockShared">
    <summary>Releases a slim reader/writer (SRW) lock that was acquired in shared mode.</summary>
    <param name="SRWLock">A pointer to the SRW lock.</param>
  </member>
  <member name="Windows.RtlReleaseSRWLockShared">
    <summary>Releases a slim reader/writer (SRW) lock that was acquired in shared mode.</summary>
    <param name="SRWLock">A pointer to the SRW lock.</param>
  </member>
  <member name="Windows.ResetEvent">
    <summary>Sets the specified event object to the nonsignaled state.</summary>
    <param name="hEvent">
      <para>A handle to the event object. The<see cref="CreateEvent" /> or<see cref="OpenEvent" /> function returns this handle.</para>
      <para>The handle must have the EVENT_MODIFY_STATE access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetCriticalSectionSpinCount">
    <summary>Sets the spin count for the specified critical section. Spinning means that when a thread tries to acquire a critical section that is locked, the thread enters a loop, checks to see if the lock is released, and if the lock is not released, the thread goes to sleep.</summary>
    <param name="lpCriticalSection">A pointer to the critical section object.</param>
    <param name="dwSpinCount">The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to zero (0). On multiprocessor systems, if the critical section is unavailable, the calling thread spins <i>dwSpinCount</i> times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</param>
    <returns>The function returns the previous spin count for the critical section.</returns>
  </member>
  <member name="Windows.SetEvent">
    <summary>Sets the specified event object to the signaled state.</summary>
    <param name="hEvent">
      <para>A handle to the event object. The<see cref="CreateEvent" /> or<see cref="OpenEvent" /> function returns this handle.</para>
      <para>The handle must have the EVENT_MODIFY_STATE access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetWaitableTimer">
    <summary>Activates the specified waitable timer. When the due time arrives, the timer is signaled and the thread that set the timer calls the optional completion routine.</summary>
    <param name="hTimer">
      <para>A handle to the timer object. The<see cref="CreateWaitableTimer" /> or<see cref="OpenWaitableTimer" /> function returns this handle.</para>
      <para>The handle must have the <b>TIMER_MODIFY_STATE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpDueTime">The time after which the state of the timer is to be set to signaled, in 100 nanosecond intervals. Use the format described by the<see cref="FILETIME" /> structure. Positive values indicate absolute time. Be sure to use a UTC-based absolute time, as the system uses UTC-based time internally. Negative values indicate relative time. The actual timer accuracy depends on the capability of your hardware. For more information about UTC-based time, see<a href="https://docs.microsoft.com//windows/desktop/SysInfo/system-time">System Time</a>.</param>
    <param name="lPeriod">The period of the timer, in milliseconds. If <i>lPeriod</i> is zero, the timer is signaled once. If <i>lPeriod</i> is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled using the<see cref="CancelWaitableTimer" /> function or reset using<b>SetWaitableTimer</b>. If <i>lPeriod</i> is less than zero, the function fails.</param>
    <param name="pfnCompletionRoutine">A pointer to an optional completion routine. The completion routine is application-defined function of type <b>PTIMERAPCROUTINE</b> to be executed when the timer is signaled. For more information on the timer callback function, see<a href="https://docs.microsoft.com//windows/desktop/api/synchapi/nc-synchapi-ptimerapcroutine">TimerAPCProc</a>. For more information about APCs and thread pool threads, see Remarks.</param>
    <param name="lpArgToCompletionRoutine">A pointer to a structure that is passed to the completion routine.</param>
    <param name="fResume">If this parameter is <b>TRUE</b>, restores a system in suspended power conservation mode when the timer state is set to signaled. Otherwise, the system is not restored. If the system does not support a restore, the call succeeds, but <see cref="GetLastError" /> returns <b>ERROR_NOT_SUPPORTED</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetWaitableTimerEx">
    <summary>Activates the specified waitable timer and provides context information for the timer. When the due time arrives, the timer is signaled and the thread that set the timer calls the optional completion routine.</summary>
    <param name="hTimer">
      <para>A handle to the timer object. The <see cref="CreateWaitableTimer" /> or <see cref="OpenWaitableTimer" /> function returns this handle.</para>
      <para>The handle must have the <b>TIMER_MODIFY_STATE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpDueTime">The time after which the state of the timer is to be set to signaled, in 100 nanosecond intervals. Use the format described by the<see cref="FILETIME" /> structure. Positive values indicate absolute time. Be sure to use a UTC-based absolute time, as the system uses UTC-based time internally. Negative values indicate relative time. The actual timer accuracy depends on the capability of your hardware. For more information about UTC-based time, see<a href="https://docs.microsoft.com//windows/desktop/SysInfo/system-time">System Time</a>.</param>
    <param name="lPeriod">The period of the timer, in milliseconds. If <i>lPeriod</i> is zero, the timer is signaled once. If <i>lPeriod</i> is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled using the<see cref="CancelWaitableTimer" /> function or reset using<b>SetWaitableTimerEx</b>. If <i>lPeriod</i> is less than zero, the function fails.</param>
    <param name="pfnCompletionRoutine">A pointer to an optional completion routine. The completion routine is application-defined function of type <b>PTIMERAPCROUTINE</b> to be executed when the timer is signaled. For more information on the timer callback function, see<a href="https://docs.microsoft.com//windows/desktop/api/synchapi/nc-synchapi-ptimerapcroutine">TimerAPCProc</a>. For more information about APCs and thread pool threads, see Remarks.</param>
    <param name="lpArgToCompletionRoutine">A pointer to a structure that is passed to the completion routine.</param>
    <param name="WakeContext">Pointer to a <see cref="REASON_CONTEXT" /> structure that contains context information for the timer.</param>
    <param name="TolerableDelay">The tolerable delay for expiration time, in milliseconds.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SignalObjectAndWait">
    <summary>Signals one object and waits on another object as a single operation.</summary>
    <param name="hObjectToSignal">
      <para>A handle to the object to be signaled. This object can be a semaphore, a mutex, or an event.</para>
      <para>If the handle is a semaphore, the <b>SEMAPHORE_MODIFY_STATE</b> access right is required. If the handle is an event, the <b>EVENT_MODIFY_STATE</b> access right is required. If the handle is a mutex and the caller does not own the mutex, the function fails with <b>ERROR_NOT_OWNER</b>.</para>
    </param>
    <param name="hObjectToWaitOn">A handle to the object to wait on. The <b>SYNCHRONIZE</b> access right is required; for more information, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>. For a list of the object types whose handles you can specify, see the Remarks section.</param>
    <param name="dwMilliseconds">The time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state is nonsignaled and no completion or asynchronous procedure call (APC) objects are queued. If <i>dwMilliseconds</i> is zero, the function tests the object's state, checks for queued completion routines or APCs, and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses.</param>
    <param name="bAlertable">
      <para>If this parameter is <b>TRUE</b>, the function returns when the system queues an I/O completion routine or APC function, and the thread calls the function. If <b>FALSE</b>, the function does not return, and the thread does not call the completion routine or APC function.</para>
      <para>A completion routine is queued when the function call that queued the APC has completed. This function returns and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b>, and the calling thread is the thread that queued the APC.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_ABANDONED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000080L</term>
              </listheader>
            </list>
          </description>
          <description>The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.<para>If the mutex was protecting persistent state information, you should check it for consistency.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_IO_COMPLETION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x000000C0L</term>
              </listheader>
            </list>
          </description>
          <description>The wait was ended by one or more user-mode <a href="https://docs.microsoft.com//windows/desktop/Sync/asynchronous-procedure-calls">asynchronous procedure calls</a> (APC) queued to the thread.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_OBJECT_0</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000L</term>
              </listheader>
            </list>
          </description>
          <description>The state of the specified object is signaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_TIMEOUT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000102L</term>
              </listheader>
            </list>
          </description>
          <description>The time-out interval elapsed, and the object's state is nonsignaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_FAILED</b>
                </term>
              </listheader>
              <listheader>
                <term>(<b>DWORD</b>)0xFFFFFFFF</term>
              </listheader>
            </list>
          </description>
          <description>The function has failed. To get extended error information, call <see cref="GetLastError" />.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.Sleep">
    <summary>
      <para>Suspends the execution of the current thread until the time-out interval elapses.</para>
      <para>To enter an alertable wait state, use the<see cref="SleepEx" /> function.</para>
    </summary>
    <param name="dwMilliseconds">
      <para>The time interval for which execution is to be suspended, in milliseconds.</para>
      <para>A value of zero causes the thread to relinquish the remainder of its time slice to any other thread that is ready to run. If there are no other threads ready to run, the function returns immediately, and the thread continues execution. <b>Windows XP:</b> A value of zero causes the thread to relinquish the remainder of its time slice to any other thread of equal priority that is ready to run. If there are no other threads of equal priority ready to run, the function returns immediately, and the thread continues execution. This behavior changed starting with Windows Server 2003.</para>
      <para>A value of INFINITE indicates that the suspension should not time out.</para>
    </param>
  </member>
  <member name="Windows.SleepConditionVariableCS">
    <summary>Sleeps on the specified condition variable and releases the specified critical section as an atomic operation.</summary>
    <param name="ConditionVariable">A pointer to the condition variable. This variable must be initialized using the <see cref="InitializeConditionVariable" /> function.</param>
    <param name="CriticalSection">A pointer to the critical section object. This critical section must be entered exactly once by the caller at the time <b>SleepConditionVariableCS</b> is called.</param>
    <param name="dwMilliseconds">The time-out interval, in milliseconds. If the time-out interval elapses, the function re-acquires the critical section and returns zero. If <i>dwMilliseconds</i> is zero, the function tests the states of the specified objects and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses. For more information, see Remarks.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails or the time-out interval elapses, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include <b>ERROR_TIMEOUT</b>, which indicates that the time-out interval has elapsed before another thread has attempted to wake the sleeping thread.</para>
    </returns>
  </member>
  <member name="Windows.SleepConditionVariableSRW">
    <summary>Sleeps on the specified condition variable and releases the specified lock as an atomic operation.</summary>
    <param name="ConditionVariable">A pointer to the condition variable. This variable must be initialized using the <see cref="InitializeConditionVariable" /> function.</param>
    <param name="SRWLock">A pointer to the lock. This lock must be held in the manner specified by the <i>Flags</i> parameter.</param>
    <param name="dwMilliseconds">The time-out interval, in milliseconds. The function returns if the interval elapses. If <i>dwMilliseconds</i> is zero, the function tests the states of the specified objects and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses.</param>
    <param name="Flags">If this parameter is <b>CONDITION_VARIABLE_LOCKMODE_SHARED</b>, the SRW lock is in shared mode. Otherwise, the lock is in exclusive mode.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the timeout expires the function returns FALSE and <see cref="GetLastError" /> returns ERROR_TIMEOUT.</para>
    </returns>
  </member>
  <member name="Windows.SleepEx">
    <summary>
      <para>Suspends the current thread until the specified condition is met. Execution resumes when one of the following occurs:</para>
      <list type="bullet">
        <item>
          <description>An I/O completion callback function is called.</description>
        </item>
        <item>
          <description>An asynchronous procedure call (APC) is queued to the thread.</description>
        </item>
        <item>
          <description>The time-out interval elapses.</description>
        </item>
      </list>
    </summary>
    <param name="dwMilliseconds">
      <para>The time interval for which execution is to be suspended, in milliseconds.</para>
      <para>A value of zero causes the thread to relinquish the remainder of its time slice to any other thread that is ready to run. If there are no other threads ready to run, the function returns immediately, and the thread continues execution.<b>Windows XP:</b>A value of zero causes the thread to relinquish the remainder of its time slice to any other thread of equal priority that is ready to run. If there are no other threads of equal priority ready to run, the function returns immediately, and the thread continues execution. This behavior changed starting with Windows Server 2003.</para>
      <para>A value of INFINITE indicates that the suspension should not time out.</para>
    </param>
    <param name="bAlertable">
      <para>If this parameter is FALSE, the function does not return until the time-out period has elapsed. If an I/O completion callback occurs, the function does not immediately return and the I/O completion function is not executed. If an APC is queued to the thread, the function does not immediately return and the APC function is not executed.</para>
      <para>If the parameter is TRUE and the thread that called this function is the same thread that called the extended I/O function (<see cref="ReadFileEx" /> or<see cref="WriteFileEx" />), the function returns when either the time-out period has elapsed or when an I/O completion callback function occurs. If an I/O completion callback occurs, the I/O completion function is called. If an APC is queued to the thread (<see cref="QueueUserAPC" />), the function returns when either the time-out period has elapsed or when the APC function is called.</para>
    </param>
    <returns>
      <para>The return value is zero if the specified time interval expired.</para>
      <para>The return value is <b>WAIT_IO_COMPLETION</b> if the function returned due to one or more I/O completion callback functions. This can happen only if <i>bAlertable</i> is TRUE, and if the thread that called the<b>SleepEx</b> function is the same thread that called the extended I/O function.</para>
    </returns>
  </member>
  <member name="Windows.TryAcquireSRWLockExclusive">
    <summary>Attempts to acquire a slim reader/writer (SRW) lock in exclusive mode. If the call is successful, the calling thread takes ownership of the lock.</summary>
    <param name="SRWLock">A pointer to the SRW lock.</param>
    <returns>
      <para>If the lock is successfully acquired, the return value is nonzero.</para>
      <para>if the current thread could not acquire the lock, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.RtlTryAcquireSRWLockShared">
    <summary>Attempts to acquire a slim reader/writer (SRW) lock in shared mode. If the call is successful, the calling thread takes ownership of the lock.</summary>
    <param name="SRWLock">A pointer to the SRW lock.</param>
    <returns>
      <para>If the lock is successfully acquired, the return value is nonzero.</para>
      <para>if the current thread could not acquire the lock, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.TryAcquireSRWLockShared">
    <summary>Attempts to acquire a slim reader/writer (SRW) lock in shared mode. If the call is successful, the calling thread takes ownership of the lock.</summary>
    <param name="SRWLock">A pointer to the SRW lock.</param>
    <returns>
      <para>If the lock is successfully acquired, the return value is nonzero.</para>
      <para>if the current thread could not acquire the lock, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.TryEnterCriticalSection">
    <summary>Attempts to enter a critical section without blocking. If the call is successful, the calling thread takes ownership of the critical section.</summary>
    <param name="lpCriticalSection">A pointer to the critical section object.</param>
    <returns>
      <para>If the critical section is successfully entered or the current thread already owns the critical section, the return value is nonzero.</para>
      <para>If another thread already owns the critical section, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.WaitForMultipleObjects">
    <summary>
      <para>Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses.</para>
      <para>To enter an alertable wait state, use the<see cref="WaitForMultipleObjectsEx" /> function.</para>
    </summary>
    <param name="nCount">The number of object handles in the array pointed to by <i>lpHandles</i>. The maximum number of object handles is <b>MAXIMUM_WAIT_OBJECTS</b>. This parameter cannot be zero.</param>
    <param name="lpHandles">
      <para>An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles to objects of different types. It may not contain multiple copies of the same handle.</para>
      <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
      <para>The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
    </param>
    <param name="bWaitAll">If this parameter is <b>TRUE</b>, the function returns when the state of all objects in the <i>lpHandles</i> array is signaled. If <b>FALSE</b>, the function returns when the state of any one of the objects is set to signaled. In the latter case, the return value indicates the object whose state caused the function to return.</param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the specified objects are not signaled; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the specified objects are signaled.</para>
      <para>
        <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
      <para>
        <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined as 0x00000080L.)</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_OBJECT_0</b> to (<b>WAIT_OBJECT_0</b> + <i>nCount</i>– 1)</term>
              </listheader>
            </list>
          </description>
          <description>If <i>bWaitAll</i> is <b>TRUE</b>, a return value within the specified range indicates that the state of all specified objects is signaled. <para>If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_OBJECT_0</b> indicates the <i>lpHandles</i> array index of the object that satisfied the wait. If more than one object became signaled during the call, this is the array index of the signaled object with the smallest index value of all the signaled objects.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_ABANDONED_0</b> to (<b>WAIT_ABANDONED_0</b> + <i>nCount</i>– 1)</term>
              </listheader>
            </list>
          </description>
          <description>If <i>bWaitAll</i> is <b>TRUE</b>, a return value within the specified range indicates that the state of all specified objects is signaled and at least one of the objects is an abandoned mutex object. <para>If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <see cref="WAIT_ABANDONED_0" /> indicates the <i>lpHandles</i> array index of an abandoned mutex object that satisfied the wait. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.</para><para>If a mutex was protecting persistent state information, you should check it for consistency.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_TIMEOUT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000102L</term>
              </listheader>
            </list>
          </description>
          <description>The time-out interval elapsed and the conditions specified by the <i>bWaitAll</i> parameter are not satisfied.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_FAILED</b>
                </term>
              </listheader>
              <listheader>
                <term>(<b>DWORD</b>)0xFFFFFFFF</term>
              </listheader>
            </list>
          </description>
          <description>The function has failed. To get extended error information, call <see cref="GetLastError" />.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.WaitForMultipleObjectsEx">
    <summary>Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses.</summary>
    <param name="nCount">The number of object handles to wait for in the array pointed to by <i>lpHandles</i>. The maximum number of object handles is <b>MAXIMUM_WAIT_OBJECTS</b>. This parameter cannot be zero.</param>
    <param name="lpHandles">
      <para>An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle.</para>
      <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
      <para>The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
    </param>
    <param name="bWaitAll">If this parameter is <b>TRUE</b>, the function returns when the state of all objects in the <i>lpHandles</i> array is set to signaled. If <b>FALSE</b>, the function returns when the state of any one of the objects is set to signaled. In the latter case, the return value indicates the object whose state caused the function to return.</param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled, an I/O completion routine or APC is queued, or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the specified objects are signaled or an I/O completion routine or APC is queued.</para>
      <para>
        <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
      <para>
        <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
    </param>
    <param name="bAlertable">
      <para>If this parameter is <b>TRUE</b> and the thread is in the waiting state, the function returns when the system queues an I/O completion routine or APC, and the thread runs the routine or function. Otherwise, the function does not return and the completion routine or APC function is not executed.</para>
      <para>A completion routine is queued when the<see cref="ReadFileEx" /> or<see cref="WriteFileEx" /> function in which it was specified has completed. The wait function returns and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b> and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call<see cref="QueueUserAPC" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined as 0x00000080L.)</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_OBJECT_0</b> to (<b>WAIT_OBJECT_0</b> + <i>nCount</i>– 1)</term>
              </listheader>
            </list>
          </description>
          <description>If <i>bWaitAll</i> is <b>TRUE</b>, a return value in this range indicates that the state of all specified objects is signaled. <para>If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_OBJECT_0</b> indicates the <i>lpHandles</i> array index of the object that satisfied the wait. If more than one object became signaled during the call, this is the array index of the signaled object with the smallest index value of all the signaled objects.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_ABANDONED_0</b> to (<b>WAIT_ABANDONED_0</b> + <i>nCount</i>– 1)</term>
              </listheader>
            </list>
          </description>
          <description>If <i>bWaitAll</i> is <b>TRUE</b>, a return value in this range indicates that the state of all specified objects is signaled, and at least one of the objects is an abandoned mutex object. <para>If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_ABANDONED_0</b> indicates the <i>lpHandles</i> array index of an abandoned mutex object that satisfied the wait. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.</para><para>If a mutex was protecting persistent state information, you should check it for consistency.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_IO_COMPLETION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x000000C0L</term>
              </listheader>
            </list>
          </description>
          <description>The wait was ended by one or more user-mode <a href="https://docs.microsoft.com//windows/desktop/Sync/asynchronous-procedure-calls">asynchronous procedure calls</a> (APC) queued to the thread.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_TIMEOUT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000102L</term>
              </listheader>
            </list>
          </description>
          <description>The time-out interval elapsed, the conditions specified by the <i>bWaitAll</i> parameter were not satisfied, and no completion routines are queued.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_FAILED</b>
                </term>
              </listheader>
              <listheader>
                <term>(<b>DWORD</b>)0xFFFFFFFF</term>
              </listheader>
            </list>
          </description>
          <description>The function has failed. To get extended error information, call <see cref="GetLastError" />.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.WaitForSingleObject">
    <summary>
      <para>Waits until the specified object is in the signaled state or the time-out interval elapses.</para>
      <para>To enter an alertable wait state, use the<see cref="WaitForSingleObjectEx" /> function. To wait for multiple objects, use<see cref="WaitForMultipleObjects" />.</para>
    </summary>
    <param name="hHandle">
      <para>A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.</para>
      <para>If this handle is closed while the wait is still pending, the function's behavior is undefined.</para>
      <para>The handle must have the <b>SYNCHRONIZE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the object is signaled.</para>
      <para>
        <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
      <para>
        <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_ABANDONED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000080L</term>
              </listheader>
            </list>
          </description>
          <description>The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled.<para>If the mutex was protecting persistent state information, you should check it for consistency.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_OBJECT_0</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000L</term>
              </listheader>
            </list>
          </description>
          <description>The state of the specified object is signaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_TIMEOUT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000102L</term>
              </listheader>
            </list>
          </description>
          <description>The time-out interval elapsed, and the object's state is nonsignaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_FAILED</b>
                </term>
              </listheader>
              <listheader>
                <term>(DWORD)0xFFFFFFFF</term>
              </listheader>
            </list>
          </description>
          <description>The function has failed. To get extended error information, call <see cref="GetLastError" />.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.WaitForSingleObjectEx">
    <summary>
      <para>Waits until the specified object is in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses.</para>
      <para>To wait for multiple objects, use the<see cref="WaitForMultipleObjectsEx" />.</para>
    </summary>
    <param name="hHandle">
      <para>A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.</para>
      <para>If this handle is closed while the wait is still pending, the function's behavior is undefined.</para>
      <para>The handle must have the <b>SYNCHRONIZE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled, an I/O completion routine or APC is queued, or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the object is signaled or an I/O completion routine or APC is queued.</para>
      <para>
        <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
      <para>
        <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
    </param>
    <param name="bAlertable">
      <para>If this parameter is <b>TRUE</b> and the thread is in the waiting state, the function returns when the system queues an I/O completion routine or APC, and the thread runs the routine or function. Otherwise, the function does not return, and the completion routine or APC function is not executed.</para>
      <para>A completion routine is queued when the<see cref="ReadFileEx" /> or<see cref="WriteFileEx" /> function in which it was specified has completed. The wait function returns and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b>, and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call<see cref="QueueUserAPC" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_ABANDONED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000080L</term>
              </listheader>
            </list>
          </description>
          <description>The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread and the mutex is set to nonsignaled.<para>If the mutex was protecting persistent state information, you should check it for consistency.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_IO_COMPLETION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x000000C0L</term>
              </listheader>
            </list>
          </description>
          <description>The wait was ended by one or more user-mode <a href="https://docs.microsoft.com//windows/desktop/Sync/asynchronous-procedure-calls">asynchronous procedure calls</a> (APC) queued to the thread.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_OBJECT_0</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000L</term>
              </listheader>
            </list>
          </description>
          <description>The state of the specified object is signaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_TIMEOUT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000102L</term>
              </listheader>
            </list>
          </description>
          <description>The time-out interval elapsed, and the object's state is nonsignaled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WAIT_FAILED</b>
                </term>
              </listheader>
              <listheader>
                <term>(<b>DWORD</b>)0xFFFFFFFF</term>
              </listheader>
            </list>
          </description>
          <description>The function has failed. To get extended error information, call <see cref="GetLastError" />.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.WaitOnAddress">
    <summary>Waits for the value at the specified address to change.</summary>
    <param name="Address">The address on which to wait. If the value at <i>Address</i> differs from the value at <i>CompareAddress</i>, the function returns immediately. If the values are the same, the function does not return until another thread in the same process signals that the value at Address has changed by calling <see cref="WakeByAddressSingle" /> or <see cref="WakeByAddressAll" /> or the timeout elapses, whichever comes first.</param>
    <param name="CompareAddress">A pointer to the location of the previously observed value at <i>Address</i>. The function returns when the value at <i>Address</i> differs from the value at <i>CompareAddress</i>.</param>
    <param name="AddressSize">The size of the value, in bytes. This parameter can be 1, 2, 4, or 8.</param>
    <param name="dwMilliseconds">The number of milliseconds to wait before the operation times out. If this parameter is <b>INFINITE</b>, the thread waits indefinitely.</param>
    <returns>TRUE if the wait succeeded. If the operation fails, the function returns FALSE. If the wait fails, call <see cref="GetLastError" /> to obtain extended error information. In particular, if the operation times out, <b>GetLastError</b> returns <b>ERROR_TIMEOUT</b>.</returns>
  </member>
  <member name="Windows.WakeAllConditionVariable">
    <summary>Wake all threads waiting on the specified condition variable.</summary>
    <param name="ConditionVariable">A pointer to the condition variable.</param>
  </member>
  <member name="Windows.WakeByAddressAll">
    <summary>Wakes all threads that are waiting for the value of an address to change.</summary>
    <param name="Address">The address to signal. If any threads have previously called<see cref="WaitOnAddress" /> for this address, the system wakes all of the waiting threads.</param>
  </member>
  <member name="Windows.WakeByAddressSingle">
    <summary>Wakes one thread that is waiting for the value of an address to change.</summary>
    <param name="Address">The address to signal. If another thread has previously called<see cref="WaitOnAddress" /> for this address, the system wakes the waiting thread. If multiple threads are waiting for this address, the system wakes the first thread to wait.</param>
  </member>
  <member name="Windows.WakeConditionVariable">
    <summary>Wake a single thread waiting on the specified condition variable.</summary>
    <param name="ConditionVariable">A pointer to the condition variable.</param>
  </member>
</doc>