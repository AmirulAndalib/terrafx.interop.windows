<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AcquireSRWLockExclusive">
    <summary>
      <para>Acquires a slim reader/writer (SRW) lock in exclusive mode.</para>
    </summary>
    <param name="SRWLock">
      <para>A pointer to the SRW lock.</para>
    </param>
    <seealso cref="ReleaseSRWLockExclusive" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/slim-reader-writer--srw--locks">Slim Reader/Writer (SRW) Locks</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.AcquireSRWLockShared">
    <summary>
      <para>Acquires a slim reader/writer (SRW) lock in shared mode.</para>
    </summary>
    <param name="SRWLock">
      <para>A pointer to the SRW lock.</para>
    </param>
    <seealso cref="ReleaseSRWLockShared" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/slim-reader-writer--srw--locks">Slim Reader/Writer (SRW) Locks</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CancelWaitableTimer">
    <summary>
      <para>Sets the specified waitable timer to the inactive state.</para>
    </summary>
    <param name="hTimer">
      <para>A handle to the timer object. The
<see cref="CreateWaitableTimer" /> or
<see cref="OpenWaitableTimer" /> function returns this handle. The handle must have the <b>TIMER_MODIFY_STATE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>CancelWaitableTimer</b> function does not change the signaled state of the timer. It stops the timer before it can be set to the signaled state and cancels outstanding APCs. Therefore, threads performing a wait operation on the timer remain waiting until they time out or the timer is reactivated and its state is set to signaled. If the timer is already in the signaled state, it remains in that state.</para>
      <para>To reactivate the timer, call the
<see cref="SetWaitableTimer" /> function.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="CreateWaitableTimer" />
    <seealso cref="OpenWaitableTimer" />
    <seealso cref="SetWaitableTimer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/waitable-timer-objects">Waitable Timer Objects</seealso>
  </member>
  <member name="Windows.CreateEvent">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">
      <para>If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the
<see cref="ResetEvent" /> function to set the event state to nonsignaled. If
this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and system automatically resets the
event state to nonsignaled after a single waiting thread has been released.</para>
    </param>
    <param name="bInitialState">
      <para>If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests
the <b>EVENT_ALL_ACCESS</b> access right. In this case, the
<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored
because they have already been set by the creating process. If the
<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be
inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by <b>CreateEvent</b> has the
<b>EVENT_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to
an event object, provided that the caller has been granted access. If an event is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the event when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security
and Access Rights</a>.</para>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>bInitialState</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>When the state of an auto-reset event object is signaled, it remains signaled until a single waiting thread is
released; the system then automatically resets the state to nonsignaled. If no threads are waiting, the event
object's state remains signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>CreateEvent</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-event-objects">Using Event Objects</a>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEventEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenEvent" />
    <seealso cref="ResetEvent" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateEventA">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">
      <para>If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the
<see cref="ResetEvent" /> function to set the event state to nonsignaled. If
this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and system automatically resets the
event state to nonsignaled after a single waiting thread has been released.</para>
    </param>
    <param name="bInitialState">
      <para>If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests
the <b>EVENT_ALL_ACCESS</b> access right. In this case, the
<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored
because they have already been set by the creating process. If the
<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be
inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by <b>CreateEvent</b> has the
<b>EVENT_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to
an event object, provided that the caller has been granted access. If an event is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the event when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security
and Access Rights</a>.</para>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>bInitialState</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>When the state of an auto-reset event object is signaled, it remains signaled until a single waiting thread is
released; the system then automatically resets the state to nonsignaled. If no threads are waiting, the event
object's state remains signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>CreateEvent</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-event-objects">Using Event Objects</a>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEventEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenEvent" />
    <seealso cref="ResetEvent" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateEventW">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">
      <para>If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the
<see cref="ResetEvent" /> function to set the event state to nonsignaled. If
this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and system automatically resets the
event state to nonsignaled after a single waiting thread has been released.</para>
    </param>
    <param name="bInitialState">
      <para>If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests
the <b>EVENT_ALL_ACCESS</b> access right. In this case, the
<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored
because they have already been set by the creating process. If the
<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be
inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by <b>CreateEvent</b> has the
<b>EVENT_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to
an event object, provided that the caller has been granted access. If an event is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the event when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security
and Access Rights</a>.</para>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>bInitialState</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>When the state of an auto-reset event object is signaled, it remains signaled until a single waiting thread is
released; the system then automatically resets the state to nonsignaled. If no threads are waiting, the event
object's state remains signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>CreateEvent</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-event-objects">Using Event Objects</a>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEventEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenEvent" />
    <seealso cref="ResetEvent" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateEventEx">
    <summary>
      <para>Creates or opens a named or unnamed event object and returns a handle to the object.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
            <para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the event object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>dwFlags</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.
</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.
</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.
</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEventEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateEventExA">
    <summary>
      <para>Creates or opens a named or unnamed event object and returns a handle to the object.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
            <para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the event object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>dwFlags</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.
</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.
</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.
</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEventEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateEventExW">
    <summary>
      <para>Creates or opens a named or unnamed event object and returns a handle to the object.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
            <para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the event object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>dwFlags</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.
</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.
</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.
</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEventEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateEventEx">
    <summary>
      <para>Creates or opens a named or unnamed event object and returns a handle to the object.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
            <para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the event object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>dwFlags</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.
</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.
</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.
</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEventEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateEventExA">
    <summary>
      <para>Creates or opens a named or unnamed event object and returns a handle to the object.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
            <para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the event object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>dwFlags</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.
</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.
</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.
</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEventEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateEventExW">
    <summary>
      <para>Creates or opens a named or unnamed event object and returns a handle to the object.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
<i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_INITIAL_SET</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_EVENT_MANUAL_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The event must be manually reset using the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
            <para>If this flag is not specified, the system automatically resets the event after releasing a single waiting thread.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the event object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>dwFlags</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.
</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.
</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.
</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEventEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateEvent">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">
      <para>If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the
<see cref="ResetEvent" /> function to set the event state to nonsignaled. If
this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and system automatically resets the
event state to nonsignaled after a single waiting thread has been released.</para>
    </param>
    <param name="bInitialState">
      <para>If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests
the <b>EVENT_ALL_ACCESS</b> access right. In this case, the
<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored
because they have already been set by the creating process. If the
<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be
inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by <b>CreateEvent</b> has the
<b>EVENT_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to
an event object, provided that the caller has been granted access. If an event is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the event when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security
and Access Rights</a>.</para>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>bInitialState</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>When the state of an auto-reset event object is signaled, it remains signaled until a single waiting thread is
released; the system then automatically resets the state to nonsignaled. If no threads are waiting, the event
object's state remains signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>CreateEvent</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-event-objects">Using Event Objects</a>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEventEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenEvent" />
    <seealso cref="ResetEvent" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateEventA">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">
      <para>If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the
<see cref="ResetEvent" /> function to set the event state to nonsignaled. If
this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and system automatically resets the
event state to nonsignaled after a single waiting thread has been released.</para>
    </param>
    <param name="bInitialState">
      <para>If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests
the <b>EVENT_ALL_ACCESS</b> access right. In this case, the
<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored
because they have already been set by the creating process. If the
<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be
inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by <b>CreateEvent</b> has the
<b>EVENT_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to
an event object, provided that the caller has been granted access. If an event is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the event when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security
and Access Rights</a>.</para>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>bInitialState</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>When the state of an auto-reset event object is signaled, it remains signaled until a single waiting thread is
released; the system then automatically resets the state to nonsignaled. If no threads are waiting, the event
object's state remains signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>CreateEvent</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-event-objects">Using Event Objects</a>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEventEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenEvent" />
    <seealso cref="ResetEvent" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateEventW">
    <summary>
      <para>Creates or opens a named or unnamed event object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateEventEx" /> function.</para>
    </summary>
    <param name="lpEventAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If
this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new
event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor.
The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">
      <para>If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the
<see cref="ResetEvent" /> function to set the event state to nonsignaled. If
this parameter is <b>FALSE</b>, the function creates an auto-reset event object, and system automatically resets the
event state to nonsignaled after a single waiting thread has been released.</para>
    </param>
    <param name="bInitialState">
      <para>If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is nonsignaled.</para>
    </param>
    <param name="lpName">
      <para>The name of the event object. The name is limited to
<b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named event object, this function requests
the <b>EVENT_ALL_ACCESS</b> access right. In this case, the
<i>bManualReset</i> and <i>bInitialState</i> parameters are ignored
because they have already been set by the creating process. If the
<i>lpEventAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be
inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the event object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or
file-mapping object), the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). For more
information, see <a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined
for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object. If the named event object existed
before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns
<b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by <b>CreateEvent</b> has the
<b>EVENT_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to
an event object, provided that the caller has been granted access. If an event is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the event when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security
and Access Rights</a>.</para>
      <para>Any thread of the calling process can specify the event-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return
when the state of the specified object is signaled. The multiple-object wait functions can be instructed to
return either when any one or when all of the specified objects are signaled. When a wait function returns, the
waiting thread is released to continue its execution.</para>
      <para>The initial state of the event object is specified by the <i>bInitialState</i> parameter. Use
the <see cref="SetEvent" /> function to set the state of an event object to
signaled. Use the <see cref="ResetEvent" /> function to reset
the state of an event object to nonsignaled.</para>
      <para>When the state of a manual-reset event object is signaled, it remains signaled until it is explicitly reset to
nonsignaled by the <see cref="ResetEvent" /> function. Any number of
waiting threads, or threads that subsequently begin wait operations for the specified event object, can be
released while the object's state is signaled.</para>
      <para>When the state of an auto-reset event object is signaled, it remains signaled until a single waiting thread is
released; the system then automatically resets the state to nonsignaled. If no threads are waiting, the event
object's state remains signaled.</para>
      <para>Multiple processes can have handles of the same event object, enabling use of the object for interprocess
synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the <see cref="CreateProcess" /> function
can inherit a handle to an event object if the <i>lpEventAttributes</i> parameter of
<b>CreateEvent</b> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the event-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate
handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of an event object in a call to the
<see cref="OpenEvent" /> or <b>CreateEvent</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The event object is destroyed when its last
handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>CreateEvent</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-event-objects">Using Event Objects</a>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEventEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenEvent" />
    <seealso cref="ResetEvent" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutex">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">
      <para>If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>CreateMutex</b> has the <b>MUTEX_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a mutex object, provided that the caller has been granted access. If a mutex is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the mutex when you create it, or change the default security descriptor for the creating process by changing its  default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>bInitialOwner</i> flag to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<b>CreateMutex</b> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should set the <i>bInitialOwner</i> flag to <b>FALSE</b>; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<b>CreateMutex</b> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to [OpenMutex](./nf-synchapi-openmutexw.md) or <b>CreateMutex</b> to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <h4>Examples</h4>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Sync/using-mutex-objects">Using Mutex Objects</a> for an example of <b>CreateMutex</b>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateMutexEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenMutex" />
    <seealso cref="ReleaseMutex" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutexA">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">
      <para>If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>CreateMutex</b> has the <b>MUTEX_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a mutex object, provided that the caller has been granted access. If a mutex is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the mutex when you create it, or change the default security descriptor for the creating process by changing its  default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>bInitialOwner</i> flag to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<b>CreateMutex</b> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should set the <i>bInitialOwner</i> flag to <b>FALSE</b>; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<b>CreateMutex</b> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to [OpenMutex](./nf-synchapi-openmutexw.md) or <b>CreateMutex</b> to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <h4>Examples</h4>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Sync/using-mutex-objects">Using Mutex Objects</a> for an example of <b>CreateMutex</b>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateMutexEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenMutex" />
    <seealso cref="ReleaseMutex" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutexW">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">
      <para>If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>CreateMutex</b> has the <b>MUTEX_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a mutex object, provided that the caller has been granted access. If a mutex is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the mutex when you create it, or change the default security descriptor for the creating process by changing its  default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>bInitialOwner</i> flag to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<b>CreateMutex</b> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should set the <i>bInitialOwner</i> flag to <b>FALSE</b>; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<b>CreateMutex</b> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to [OpenMutex](./nf-synchapi-openmutexw.md) or <b>CreateMutex</b> to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <h4>Examples</h4>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Sync/using-mutex-objects">Using Mutex Objects</a> for an example of <b>CreateMutex</b>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateMutexEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenMutex" />
    <seealso cref="ReleaseMutex" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutexEx">
    <summary>
      <para>Creates or opens a named or unnamed mutex object and returns a handle to the object.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The object creator is the initial owner of the mutex.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the mutex object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>dwFlags</i> parameter to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<see cref="CreateMutex" /> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should not use the <b>CREATE_MUTEX_INITIAL_OWNER</b> flag; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<see cref="CreateMutex" /> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to the
[OpenMutex](./nf-synchapi-openmutexw.md) or
<see cref="CreateMutex" /> function to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutexEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutexExA">
    <summary>
      <para>Creates or opens a named or unnamed mutex object and returns a handle to the object.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The object creator is the initial owner of the mutex.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the mutex object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>dwFlags</i> parameter to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<see cref="CreateMutex" /> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should not use the <b>CREATE_MUTEX_INITIAL_OWNER</b> flag; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<see cref="CreateMutex" /> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to the
[OpenMutex](./nf-synchapi-openmutexw.md) or
<see cref="CreateMutex" /> function to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutexEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutexExW">
    <summary>
      <para>Creates or opens a named or unnamed mutex object and returns a handle to the object.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The object creator is the initial owner of the mutex.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the mutex object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>dwFlags</i> parameter to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<see cref="CreateMutex" /> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should not use the <b>CREATE_MUTEX_INITIAL_OWNER</b> flag; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<see cref="CreateMutex" /> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to the
[OpenMutex](./nf-synchapi-openmutexw.md) or
<see cref="CreateMutex" /> function to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutexEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutexEx">
    <summary>
      <para>Creates or opens a named or unnamed mutex object and returns a handle to the object.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The object creator is the initial owner of the mutex.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the mutex object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>dwFlags</i> parameter to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<see cref="CreateMutex" /> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should not use the <b>CREATE_MUTEX_INITIAL_OWNER</b> flag; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<see cref="CreateMutex" /> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to the
[OpenMutex](./nf-synchapi-openmutexw.md) or
<see cref="CreateMutex" /> function to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutexEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutexExA">
    <summary>
      <para>Creates or opens a named or unnamed mutex object and returns a handle to the object.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The object creator is the initial owner of the mutex.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the mutex object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>dwFlags</i> parameter to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<see cref="CreateMutex" /> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should not use the <b>CREATE_MUTEX_INITIAL_OWNER</b> flag; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<see cref="CreateMutex" /> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to the
[OpenMutex](./nf-synchapi-openmutexw.md) or
<see cref="CreateMutex" /> function to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutexEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutexExW">
    <summary>
      <para>Creates or opens a named or unnamed mutex object and returns a handle to the object.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the mutex handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_MUTEX_INITIAL_OWNER</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The object creator is the initial owner of the mutex.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the mutex object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>dwFlags</i> parameter to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<see cref="CreateMutex" /> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should not use the <b>CREATE_MUTEX_INITIAL_OWNER</b> flag; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<see cref="CreateMutex" /> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to the
[OpenMutex](./nf-synchapi-openmutexw.md) or
<see cref="CreateMutex" /> function to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutexEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutex">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">
      <para>If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object,
and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>CreateMutex</b> has the <b>MUTEX_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a mutex object, provided that the caller has been granted access. If a mutex is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the mutex when you create it, or change the default security descriptor for the creating process by changing its  default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>bInitialOwner</i> flag to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<b>CreateMutex</b> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should set the <i>bInitialOwner</i> flag to <b>FALSE</b>; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<b>CreateMutex</b> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to the
[OpenMutex](./nf-synchapi-openmutexw.md) or
<b>CreateMutex</b> function to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>CreateMutex</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-mutex-objects">Using Mutex Objects</a>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateMutexEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenMutex" />
    <seealso cref="ReleaseMutex" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutexA">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">
      <para>If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object,
and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>CreateMutex</b> has the <b>MUTEX_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a mutex object, provided that the caller has been granted access. If a mutex is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the mutex when you create it, or change the default security descriptor for the creating process by changing its  default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>bInitialOwner</i> flag to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<b>CreateMutex</b> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should set the <i>bInitialOwner</i> flag to <b>FALSE</b>; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<b>CreateMutex</b> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to the
[OpenMutex](./nf-synchapi-openmutexw.md) or
<b>CreateMutex</b> function to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>CreateMutex</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-mutex-objects">Using Mutex Objects</a>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateMutexEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenMutex" />
    <seealso cref="ReleaseMutex" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateMutexW">
    <summary>
      <para>Creates or opens a named or unnamed mutex object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateMutexEx" /> function.</para>
    </summary>
    <param name="lpMutexAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInitialOwner">
      <para>If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named mutex object, this function requests the <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object,
and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>CreateMutex</b> has the <b>MUTEX_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a mutex object, provided that the caller has been granted access. If a mutex is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the mutex when you create it, or change the default security descriptor for the creating process by changing its  default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>If you are using a named mutex to limit your application to a single instance, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
      <para>Any thread of the calling process can specify the mutex-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution.</para>
      <para>The state of a mutex object is signaled when it is not owned by any thread. The creating thread can use the <i>bInitialOwner</i> flag to request immediate ownership of the mutex. Otherwise, a thread must use one of the wait functions to request ownership. When the mutex's state is signaled, one waiting thread is granted ownership, the mutex's state changes to nonsignaled, and the wait function returns. Only one thread can own a mutex at any given time. The owning thread uses the
<see cref="ReleaseMutex" /> function to release its ownership.</para>
      <para>The thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. Typically, you would not wait repeatedly for the same mutex, but this mechanism prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<see cref="ReleaseMutex" /> once for each time that the mutex satisfied a wait.</para>
      <para>Two or more processes can call
<b>CreateMutex</b> to create the same named mutex. The first process actually creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility of ensuring that the creating process is started first. When using this technique, you should set the <i>bInitialOwner</i> flag to <b>FALSE</b>; otherwise, it can be difficult to be certain which process has initial ownership.</para>
      <para>Multiple processes can have handles of the same mutex object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a mutex object if the <i>lpMutexAttributes</i> parameter of
<b>CreateMutex</b> enabled inheritance. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify the handle to a mutex object in a call to the <see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process. This mechanism works for both named and unnamed mutexes.</description>
        </item>
        <item>
          <description>A process can specify a named mutex in a call to the
[OpenMutex](./nf-synchapi-openmutexw.md) or
<b>CreateMutex</b> function to retrieve a handle to the mutex object.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>CreateMutex</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-mutex-objects">Using Mutex Objects</a>.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines CreateMutex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateMutexEx" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenMutex" />
    <seealso cref="ReleaseMutex" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateSemaphoreExA">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object and returns a handle to the object.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the semaphore handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">
      <para>The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the
<see cref="ReleaseSemaphore" /> function.</para>
    </param>
    <param name="lMaximumCount">
      <para>The maximum count for the semaphore object. This value must be greater than zero.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter is reserved and must be 0.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the semaphore object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count is equal to zero. The <i>lInitialCount</i> parameter specifies the initial count. The count can never be less than zero or greater than the value specified in the <i>lMaximumCount</i> parameter.</para>
      <para>Any thread of the calling process can specify the semaphore-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. Each time a thread completes a wait for a semaphore object, the count of the semaphore object is decremented by one. When the thread has finished, it calls the <see cref="ReleaseSemaphore" /> function, which increments the count of the semaphore object.</para>
      <para>Multiple processes can have handles of the same semaphore object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a semaphore object if the <i>lpSemaphoreAttributes</i> parameter of
<b>CreateSemaphoreEx</b> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the semaphore-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a semaphore object in a call to the
<see cref="OpenSemaphore" /> or
<b>CreateSemaphoreEx</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateSemaphoreExW">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object and returns a handle to the object.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the semaphore handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">
      <para>The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the
<see cref="ReleaseSemaphore" /> function.</para>
    </param>
    <param name="lMaximumCount">
      <para>The maximum count for the semaphore object. This value must be greater than zero.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter is reserved and must be 0.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the semaphore object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count is equal to zero. The <i>lInitialCount</i> parameter specifies the initial count. The count can never be less than zero or greater than the value specified in the <i>lMaximumCount</i> parameter.</para>
      <para>Any thread of the calling process can specify the semaphore-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. Each time a thread completes a wait for a semaphore object, the count of the semaphore object is decremented by one. When the thread has finished, it calls the <see cref="ReleaseSemaphore" /> function, which increments the count of the semaphore object.</para>
      <para>Multiple processes can have handles of the same semaphore object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a semaphore object if the <i>lpSemaphoreAttributes</i> parameter of
<b>CreateSemaphoreEx</b> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the semaphore-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a semaphore object in a call to the
<see cref="OpenSemaphore" /> or
<b>CreateSemaphoreEx</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateSemaphoreA">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateSemaphoreEx" /> function.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child
processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor
for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">
      <para>The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the
<see cref="ReleaseSemaphore" /> function.</para>
    </param>
    <param name="lMaximumCount">
      <para>The maximum count for the semaphore object. This value must be greater than zero.</para>
    </param>
    <param name="lpName">
      <para>The name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, this function requests the <b>SEMAPHORE_ALL_ACCESS</b> access right. In this case, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>CreateSemaphore</b> has the <b>SEMAPHORE_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a semaphore object, provided that the caller has been granted access. If a semaphore is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the semaphore when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count is equal to zero. The <i>lInitialCount</i> parameter specifies the initial count. The count can never be less than zero or greater than the value specified in the <i>lMaximumCount</i> parameter.</para>
      <para>Any thread of the calling process can specify the semaphore-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. Each time a thread completes a wait for a semaphore object, the count of the semaphore object is decremented by one. When the thread has finished, it calls the <see cref="ReleaseSemaphore" /> function, which increments the count of the semaphore object.</para>
      <para>Multiple processes can have handles of the same semaphore object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a semaphore object if the <i>lpSemaphoreAttributes</i> parameter of
<b>CreateSemaphore</b> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the semaphore-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a semaphore object in a call to the
OpenSemaphore or
<b>CreateSemaphore</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>CreateSemaphore</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-semaphore-objects">Using Semaphore Objects</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateSemaphoreEx" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="ReleaseSemaphore" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateSemaphoreW">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateSemaphoreEx" /> function.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child
processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor
for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">
      <para>The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the
<see cref="ReleaseSemaphore" /> function.</para>
    </param>
    <param name="lMaximumCount">
      <para>The maximum count for the semaphore object. This value must be greater than zero.</para>
    </param>
    <param name="lpName">
      <para>The name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, this function requests the <b>SEMAPHORE_ALL_ACCESS</b> access right. In this case, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>CreateSemaphore</b> has the <b>SEMAPHORE_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a semaphore object, provided that the caller has been granted access. If a semaphore is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the semaphore when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count is equal to zero. The <i>lInitialCount</i> parameter specifies the initial count. The count can never be less than zero or greater than the value specified in the <i>lMaximumCount</i> parameter.</para>
      <para>Any thread of the calling process can specify the semaphore-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. Each time a thread completes a wait for a semaphore object, the count of the semaphore object is decremented by one. When the thread has finished, it calls the <see cref="ReleaseSemaphore" /> function, which increments the count of the semaphore object.</para>
      <para>Multiple processes can have handles of the same semaphore object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a semaphore object if the <i>lpSemaphoreAttributes</i> parameter of
<b>CreateSemaphore</b> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the semaphore-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a semaphore object in a call to the
OpenSemaphore or
<b>CreateSemaphore</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>CreateSemaphore</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-semaphore-objects">Using Semaphore Objects</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateSemaphoreEx" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="ReleaseSemaphore" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateWaitableTimerEx">
    <summary>
      <para>Creates or opens a waitable timer object and returns a handle to the object.</para>
    </summary>
    <param name="lpTimerAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the timer handle cannot be inherited by child processes.</para>
      <para>If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name.</para>
      <para>If <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and
<see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_WAITABLE_TIMER_MANUAL_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The timer must be manually reset. Otherwise, the system automatically resets the timer after releasing a single waiting thread.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the timer object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Any thread of the calling process can specify the timer object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>.</para>
      <para>Multiple processes can have handles to the same timer object, enabling use of the object for interprocess synchronization.</para>
      <list type="bullet">
        <item>
          <description>A process created by the
<see cref="CreateProcess" /> function can inherit a handle to a timer object if the <i>lpTimerAttributes</i> parameter of
<b>CreateWaitableTimerEx</b> enables inheritance.</description>
        </item>
        <item>
          <description>A process can specify the timer object handle in a call to the <see cref="DuplicateHandle" /> function. The resulting handle can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a timer object in a call to the
[OpenWaitableTimer](./nf-synchapi-openwaitabletimerw.md) or
<b>CreateWaitableTimerEx</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed.</para>
      <para>To associate a timer with a window, use the <see cref="SetTimer" /> function.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/waitable-timer-objects">Waitable Timer Objects</seealso>
  </member>
  <member name="Windows.CreateWaitableTimerExA">
    <summary>
      <para>Creates or opens a waitable timer object and returns a handle to the object.</para>
    </summary>
    <param name="lpTimerAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the timer handle cannot be inherited by child processes.</para>
      <para>If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name.</para>
      <para>If <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and
<see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_WAITABLE_TIMER_MANUAL_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The timer must be manually reset. Otherwise, the system automatically resets the timer after releasing a single waiting thread.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the timer object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Any thread of the calling process can specify the timer object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>.</para>
      <para>Multiple processes can have handles to the same timer object, enabling use of the object for interprocess synchronization.</para>
      <list type="bullet">
        <item>
          <description>A process created by the
<see cref="CreateProcess" /> function can inherit a handle to a timer object if the <i>lpTimerAttributes</i> parameter of
<b>CreateWaitableTimerEx</b> enables inheritance.</description>
        </item>
        <item>
          <description>A process can specify the timer object handle in a call to the <see cref="DuplicateHandle" /> function. The resulting handle can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a timer object in a call to the
[OpenWaitableTimer](./nf-synchapi-openwaitabletimerw.md) or
<b>CreateWaitableTimerEx</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed.</para>
      <para>To associate a timer with a window, use the <see cref="SetTimer" /> function.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/waitable-timer-objects">Waitable Timer Objects</seealso>
  </member>
  <member name="Windows.CreateWaitableTimerExW">
    <summary>
      <para>Creates or opens a waitable timer object and returns a handle to the object.</para>
    </summary>
    <param name="lpTimerAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the timer handle cannot be inherited by child processes.</para>
      <para>If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name.</para>
      <para>If <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and
<see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_WAITABLE_TIMER_MANUAL_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The timer must be manually reset. Otherwise, the system automatically resets the timer after releasing a single waiting thread.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the timer object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Any thread of the calling process can specify the timer object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>.</para>
      <para>Multiple processes can have handles to the same timer object, enabling use of the object for interprocess synchronization.</para>
      <list type="bullet">
        <item>
          <description>A process created by the
<see cref="CreateProcess" /> function can inherit a handle to a timer object if the <i>lpTimerAttributes</i> parameter of
<b>CreateWaitableTimerEx</b> enables inheritance.</description>
        </item>
        <item>
          <description>A process can specify the timer object handle in a call to the <see cref="DuplicateHandle" /> function. The resulting handle can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a timer object in a call to the
[OpenWaitableTimer](./nf-synchapi-openwaitabletimerw.md) or
<b>CreateWaitableTimerEx</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed.</para>
      <para>To associate a timer with a window, use the <see cref="SetTimer" /> function.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/waitable-timer-objects">Waitable Timer Objects</seealso>
  </member>
  <member name="Windows.CreateWaitableTimer">
    <summary>
      <para>Creates or opens a waitable timer object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateWaitableTimerEx" /> function.</para>
    </summary>
    <param name="lpTimerAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new timer object and determines whether child processes can inherit the returned handle.</para>
      <para>If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">
      <para>If this parameter is <b>TRUE</b>, the timer is a manual-reset notification timer. Otherwise, the timer is a synchronization timer.</para>
    </param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name.</para>
      <para>If <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and
<see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>CreateWaitableTimer</b> is created with the <b>TIMER_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a timer object, provided that the caller has been granted access. If a timer is created from a service or thread that is impersonating a different user, you can either apply a security descriptor to the timer when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>Any thread of the calling process can specify the timer object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>.</para>
      <para>Multiple processes can have handles to the same timer object, enabling use of the object for interprocess synchronization.</para>
      <list type="bullet">
        <item>
          <description>A process created by the
<see cref="CreateProcess" /> function can inherit a handle to a timer object if the <i>lpTimerAttributes</i> parameter of
<b>CreateWaitableTimer</b> enables inheritance.</description>
        </item>
        <item>
          <description>A process can specify the timer object handle in a call to the <see cref="DuplicateHandle" /> function. The resulting handle can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a timer object in a call to the <see cref="OpenWaitableTimer" /> or <b>CreateWaitableTimer</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>To associate a timer with a window, use the <see cref="SetTimer" /> function.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>CreateWaitableTimer</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-waitable-timer-objects">Using Waitable Timer Objects</a>.</para>
    </remarks>
    <seealso cref="CancelWaitableTimer" />
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateWaitableTimerEx" />
    <seealso cref="DuplicateHandle" />
    <seealso cref="FILETIME" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenWaitableTimer" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetWaitableTimer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/waitable-timer-objects">Waitable Timer Objects</seealso>
  </member>
  <member name="Windows.CreateWaitableTimerA">
    <summary>
      <para>Creates or opens a waitable timer object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateWaitableTimerEx" /> function.</para>
    </summary>
    <param name="lpTimerAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new timer object and determines whether child processes can inherit the returned handle.</para>
      <para>If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">
      <para>If this parameter is <b>TRUE</b>, the timer is a manual-reset notification timer. Otherwise, the timer is a synchronization timer.</para>
    </param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name.</para>
      <para>If <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and
<see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>CreateWaitableTimer</b> is created with the <b>TIMER_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a timer object, provided that the caller has been granted access. If a timer is created from a service or thread that is impersonating a different user, you can either apply a security descriptor to the timer when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>Any thread of the calling process can specify the timer object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>.</para>
      <para>Multiple processes can have handles to the same timer object, enabling use of the object for interprocess synchronization.</para>
      <list type="bullet">
        <item>
          <description>A process created by the
<see cref="CreateProcess" /> function can inherit a handle to a timer object if the <i>lpTimerAttributes</i> parameter of
<b>CreateWaitableTimer</b> enables inheritance.</description>
        </item>
        <item>
          <description>A process can specify the timer object handle in a call to the <see cref="DuplicateHandle" /> function. The resulting handle can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a timer object in a call to the <see cref="OpenWaitableTimer" /> or <b>CreateWaitableTimer</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>To associate a timer with a window, use the <see cref="SetTimer" /> function.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>CreateWaitableTimer</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-waitable-timer-objects">Using Waitable Timer Objects</a>.</para>
    </remarks>
    <seealso cref="CancelWaitableTimer" />
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateWaitableTimerEx" />
    <seealso cref="DuplicateHandle" />
    <seealso cref="FILETIME" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenWaitableTimer" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetWaitableTimer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/waitable-timer-objects">Waitable Timer Objects</seealso>
  </member>
  <member name="Windows.CreateWaitableTimerW">
    <summary>
      <para>Creates or opens a waitable timer object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateWaitableTimerEx" /> function.</para>
    </summary>
    <param name="lpTimerAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new timer object and determines whether child processes can inherit the returned handle.</para>
      <para>If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="bManualReset">
      <para>If this parameter is <b>TRUE</b>, the timer is a manual-reset notification timer. Otherwise, the timer is a synchronization timer.</para>
    </param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name.</para>
      <para>If <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the function fails and
<see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object. If the named timer object exists before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>CreateWaitableTimer</b> is created with the <b>TIMER_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a timer object, provided that the caller has been granted access. If a timer is created from a service or thread that is impersonating a different user, you can either apply a security descriptor to the timer when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>Any thread of the calling process can specify the timer object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>.</para>
      <para>Multiple processes can have handles to the same timer object, enabling use of the object for interprocess synchronization.</para>
      <list type="bullet">
        <item>
          <description>A process created by the
<see cref="CreateProcess" /> function can inherit a handle to a timer object if the <i>lpTimerAttributes</i> parameter of
<b>CreateWaitableTimer</b> enables inheritance.</description>
        </item>
        <item>
          <description>A process can specify the timer object handle in a call to the <see cref="DuplicateHandle" /> function. The resulting handle can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a timer object in a call to the <see cref="OpenWaitableTimer" /> or <b>CreateWaitableTimer</b> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>To associate a timer with a window, use the <see cref="SetTimer" /> function.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>CreateWaitableTimer</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-waitable-timer-objects">Using Waitable Timer Objects</a>.</para>
    </remarks>
    <seealso cref="CancelWaitableTimer" />
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateWaitableTimerEx" />
    <seealso cref="DuplicateHandle" />
    <seealso cref="FILETIME" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenWaitableTimer" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetWaitableTimer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/waitable-timer-objects">Waitable Timer Objects</seealso>
  </member>
  <member name="Windows.DeleteCriticalSection">
    <summary>
      <para>Releases all resources used by an unowned critical section object.</para>
    </summary>
    <param name="lpCriticalSection">
      <para>A pointer to the critical section object. The object must have been previously initialized with the
<see cref="InitializeCriticalSection" /> function.</para>
    </param>
    <remarks>
      <para>Deleting a critical section object releases all system resources used by the object. The caller is responsible for ensuring that the critical section object is unowned and the specified CRITICAL_SECTION structure is not being accessed by any critical section functions called by other threads in the process.</para>
      <para>After a critical section object has been deleted, do not reference the object in any function that operates on critical sections (such as <see cref="EnterCriticalSection" />, <see cref="TryEnterCriticalSection" />, and <see cref="LeaveCriticalSection" />) other than <see cref="InitializeCriticalSection" /> and <see cref="InitializeCriticalSectionAndSpinCount" />. If you attempt to do so, memory corruption and other unexpected errors can occur.</para>
      <para>If a critical section is deleted while it is still owned, the state of the threads waiting for ownership of the deleted critical section is undefined.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>DeleteCriticalSection</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-critical-section-objects">Using Critical Section Objects</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/critical-section-objects">Critical Section Objects</seealso>
    <seealso cref="EnterCriticalSection" />
    <seealso cref="InitializeCriticalSection" />
    <seealso cref="LeaveCriticalSection" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso cref="TryEnterCriticalSection" />
  </member>
  <member name="Windows.DeleteSynchronizationBarrier">
    <summary>
      <para>Deletes a synchronization barrier.</para>
    </summary>
    <param name="lpBarrier">
      <para>A pointer to the synchronization barrier to delete.</para>
    </param>
    <returns>
      <para>The <b>DeleteSynchronizationBarrier</b> function always returns <b>TRUE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>DeleteSynchronizationBarrier</b> releases a synchronization barrier when it is no longer needed. It is safe to call <b>DeleteSynchronizationBarrier</b> immediately after calling <see cref="EnterSynchronizationBarrier" /> because that function ensures that all threads in the barrier have finished using it before allowing the barrier to be released.</para>
      <para>If a synchronization barrier will never be deleted, threads can specify the <b>SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE</b> flag when they enter the barrier. This flag causes the function to skip the extra work required for deletion safety, which can improve performance. All threads using the barrier must specify this flag; if any thread does not, the flag is ignored. Be careful when using <b>SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE</b>, because deleting a barrier while this flag is in effect  may result in an invalid handle access and cause one or more threads to become permanently blocked.</para>
    </remarks>
    <seealso cref="EnterSynchronizationBarrier" />
    <seealso cref="InitializeSynchronizationBarrier" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-barriers">Synchronization Barriers</seealso>
  </member>
  <member name="Windows.EnterCriticalSection">
    <summary>
      <para>Waits for ownership of the specified critical section object. The function returns when the calling thread is granted ownership.</para>
    </summary>
    <param name="lpCriticalSection">
      <para>A pointer to the critical section object.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
      <para>This function can raise <b>EXCEPTION_POSSIBLE_DEADLOCK</b> if a wait operation on the critical section times out. The timeout interval is specified by the following registry value: <b>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager</b>\<b>CriticalSectionTimeout</b>. Do not handle a possible deadlock exception; instead, debug the application.</para>
    </returns>
    <remarks>
      <para>The threads of a single process can use a critical section object for mutual-exclusion synchronization. The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type <b>CRITICAL_SECTION</b>. Before using a critical section, some thread of the process must call
<see cref="InitializeCriticalSection" /> or
<see cref="InitializeCriticalSectionAndSpinCount" /> to initialize the object.</para>
      <para>To enable mutually exclusive access to a shared resource, each thread calls the
<b>EnterCriticalSection</b> or
<see cref="TryEnterCriticalSection" /> function to request ownership of the critical section before executing any section of code that accesses the protected resource. The difference is that
<b>TryEnterCriticalSection</b> returns immediately, regardless of whether it obtained ownership of the critical section, while
<b>EnterCriticalSection</b> blocks until the thread can take ownership of the critical section. When it has finished executing the protected code, the thread uses the
<see cref="LeaveCriticalSection" /> function to relinquish ownership, enabling another thread to become owner and access the protected resource. There is no guarantee about the order in which waiting threads will acquire ownership of the critical section.</para>
      <para>After a thread has ownership of a critical section, it can make additional calls to
<b>EnterCriticalSection</b> or
<see cref="TryEnterCriticalSection" /> without blocking its execution. This prevents a thread from deadlocking itself while waiting for a critical section that it already owns. The thread enters the critical section each time
<b>EnterCriticalSection</b> and
<b>TryEnterCriticalSection</b> succeed. A thread must call
<see cref="LeaveCriticalSection" /> once for each time that it entered the critical section.</para>
      <para>Any thread of the process can use the
<see cref="DeleteCriticalSection" /> function to release the system resources that were allocated when the critical section object was initialized. After this function has been called, the critical section object can no longer be used for synchronization.</para>
      <para>If a thread terminates while it has ownership of a critical section, the state of the critical section is undefined.</para>
      <para>If a critical section is deleted while it is still owned, the state of the threads waiting for ownership of the deleted critical section is undefined.</para>
      <para>While a process is exiting, if a call to <b>EnterCriticalSection</b> would block, it will instead terminate the process immediately. This may cause global destructors to not be called.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>EnterCriticalSection</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-critical-section-objects">Using Critical Section Objects</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/critical-section-objects">Critical Section Objects</seealso>
    <seealso cref="DeleteCriticalSection" />
    <seealso cref="InitializeCriticalSection" />
    <seealso cref="InitializeCriticalSectionAndSpinCount" />
    <seealso cref="LeaveCriticalSection" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso cref="TryEnterCriticalSection" />
  </member>
  <member name="Windows.EnterSynchronizationBarrier">
    <summary>
      <para>Causes the calling thread to wait at a synchronization barrier until the maximum number of threads
have entered the barrier.</para>
    </summary>
    <param name="lpBarrier">
      <para>A pointer to an initialized synchronization barrier. Use the
<see cref="InitializeSynchronizationBarrier" /></para>
      <para>function to initialize the barrier. <b>SYNCHRONIZATION_BARRIER</b> is an opaque
structure that should not be modified by the application.</para>
    </param>
    <param name="dwFlags">
      <para>Flags that control the behavior of threads that enter this barrier. This parameter can be one or more of
the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY</b>
                </description>
              </item>
              <item>
                <description></description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the thread entering the barrier should block immediately until the last thread enters the
barrier. For more information, see Remarks.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY</b>
                </description>
              </item>
              <item>
                <description></description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the thread entering the barrier should spin until the last thread enters the barrier, even
if the spinning thread exceeds the barrier's maximum spin count. For more information, see Remarks.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE</b>
                </description>
              </item>
              <item>
                <description></description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the function can skip the work required to ensure that it is safe to delete the barrier,
which can improve performance. All threads that enter this barrier must specify the flag; otherwise, the flag
is ignored. This flag should be used only if the barrier will never be deleted.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>
        <b>TRUE</b> for the last thread to signal the barrier. Threads that signal the barrier
before the last thread signals it receive a return value of <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The default behavior for threads entering a synchronization barrier is to spin until the maximum spin count of
the barrier is reached, and then block. This allows threads to resume quickly if the last thread enters the
barrier in a relatively short time.  However, if the last thread takes relatively longer to arrive, threads
already in the barrier block so they stop consuming processor time while waiting.</para>
      <para>A thread can override the default behavior of the barrier by specifying
<b>SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY</b> or
<b>SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY</b>. However, keep in mind that using these flags
can affect performance. Spinning indefinitely keeps a processor from servicing other threads, while premature
blocking incurs the overhead of swapping the thread off the processor, awakening the thread when it unblocks, and
swapping it back onto the processor again. In general it is better to allow the barrier to manage threads and use
these flags only if performance testing indicates the application would benefit from them.</para>
    </remarks>
    <seealso cref="DeleteSynchronizationBarrier" />
    <seealso cref="InitializeSynchronizationBarrier" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-barriers">Synchronization Barriers</seealso>
  </member>
  <member name="Windows.InitializeConditionVariable">
    <summary>
      <para>Initializes a condition variable.</para>
    </summary>
    <param name="ConditionVariable">
      <para>A pointer to the condition variable.</para>
    </param>
    <remarks>
      <para>Threads  can atomically release a lock and enter the sleeping state using the <see cref="SleepConditionVariableCS" /> or <see cref="SleepConditionVariableSRW" /> function. The threads are woken using the <see cref="WakeConditionVariable" /> or <see cref="WakeAllConditionVariable" /> function.</para>
      <para>Condition variables are user-mode objects that cannot be shared across processes.</para>
      <para>A condition variable cannot be moved or copied while in use. The process must not modify the object, and must instead treat it as logically opaque. Only use the condition variable functions to manage condition variables.</para>
      <para>A condition variable with no waiting threads is in its initial state and can be copied, moved, and forgotten without being explicitly destroyed.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/Sync/using-condition-variables">Using Condition Variables</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/condition-variables">Condition Variables</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InitializeCriticalSection">
    <summary>
      <para>Initializes a critical section object.</para>
    </summary>
    <param name="lpCriticalSection">
      <para>A pointer to the critical section object.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>In low memory situations,
<b>InitializeCriticalSection</b> can raise a <b>STATUS_NO_MEMORY</b> exception. Starting with Windows Vista, this exception was eliminated and <b>InitializeCriticalSection</b> always succeeds, even in low memory situations.</para>
    </returns>
    <remarks>
      <para>The threads of a single process can use a critical section object for mutual-exclusion synchronization. There is no guarantee about the order in which threads will obtain ownership of the critical section, however, the system will be fair to all threads.</para>
      <para>The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type <b>CRITICAL_SECTION</b>. Before using a critical section, some thread of the process must initialize the object.</para>
      <para>After a critical section object has been initialized, the threads of the process can specify the object in the
<see cref="EnterCriticalSection" />,
<see cref="TryEnterCriticalSection" />, or
<see cref="LeaveCriticalSection" /> function to provide mutually exclusive access to a shared resource. For similar synchronization between the threads of different processes, use a mutex object.</para>
      <para>A critical section object cannot be moved or copied. The process must also not modify the object, but must treat it as logically opaque. Use only the critical section functions to manage critical section objects. When you have finished using the critical section, call the
<see cref="DeleteCriticalSection" /> function.</para>
      <para>A critical section object must be deleted before it can be reinitialized. Initializing a critical section that has already been initialized results in undefined behavior.</para>
    </remarks>
    <seealso cref="CreateMutex" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/critical-section-objects">Critical Section Objects</seealso>
    <seealso cref="DeleteCriticalSection" />
    <seealso cref="EnterCriticalSection" />
    <seealso cref="InitializeCriticalSectionAndSpinCount" />
    <seealso cref="LeaveCriticalSection" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso cref="TryEnterCriticalSection" />
  </member>
  <member name="Windows.InitializeCriticalSectionAndSpinCount">
    <summary>
      <para>Initializes a critical section object and sets the spin count for the critical section. When a thread tries to acquire a critical section that is locked, the thread <i>spins</i>: it enters a loop which iterates spin count times, checking to see if the lock is released. If the lock is not released before  the loop finishes, the thread goes to sleep to wait for the lock to be released.</para>
    </summary>
    <param name="lpCriticalSection">
      <para>A pointer to the critical section object.</para>
    </param>
    <param name="dwSpinCount">
      <para>The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to 0 (zero). On multiprocessor systems, if the critical section is unavailable, the calling thread spins <i>dwSpinCount</i> times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</para>
    </param>
    <returns>
      <para>This function always succeeds and returns a nonzero value.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.  Starting with Windows Vista, the <b>InitializeCriticalSectionAndSpinCount</b> function always succeeds, even in low memory situations.</para>
    </returns>
    <remarks>
      <para>The threads of a single process can use a critical section object for mutual-exclusion synchronization. There is no guarantee about the order that threads obtain ownership of the critical section. However, the system is fair to all threads.</para>
      <para>The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type <b>CRITICAL_SECTION</b>. Before using a critical section, some thread of the process must initialize the object. You can subsequently modify the spin count by calling the
<see cref="SetCriticalSectionSpinCount" /> function.</para>
      <para>After a critical section object is initialized, the threads of the process can specify the object in the <see cref="EnterCriticalSection" />, <see cref="TryEnterCriticalSection" />, or
<see cref="LeaveCriticalSection" /> function to provide mutually exclusive access to a shared resource. For similar synchronization between the threads of different processes, use a mutex object.</para>
      <para>A critical section object cannot be moved or copied. The process must also not modify the object, but must treat it as logically opaque. Use only the critical section functions to manage critical section objects. When you have finished using the critical section, call the
<see cref="DeleteCriticalSection" /> function.</para>
      <para>A critical section object must be deleted before it can be reinitialized. Initializing a critical section that is already  initialized results in undefined behavior.</para>
      <para>The spin count is useful for critical sections of short duration that can experience high levels of contention. Consider a worst-case scenario, in which an application on an SMP system has two or three threads constantly allocating and releasing memory from the heap. The application serializes the heap with a critical section. In the worst-case scenario, contention for the critical section is constant, and each thread makes a processing-intensive call to the
<see cref="WaitForSingleObject" /> function. However, if the spin count is set properly, the calling thread does not immediately call
<b>WaitForSingleObject</b> when contention occurs. Instead, the calling thread can acquire ownership of the critical section if it is released during the spin operation.</para>
      <para>You can improve performance significantly by choosing a small spin count for a critical section of short duration. For example, the heap manager uses a spin count of roughly 4,000 for its per-heap critical sections.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0403 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>InitializeCriticalSectionAndSpinCount</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-critical-section-objects">Using Critical Section Objects</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/critical-section-objects">Critical Section Objects</seealso>
    <seealso cref="DeleteCriticalSection" />
    <seealso cref="InitializeCriticalSection" />
    <seealso cref="InitializeCriticalSectionEx" />
    <seealso cref="SetCriticalSectionSpinCount" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso cref="WaitForSingleObject" />
  </member>
  <member name="Windows.InitializeCriticalSectionEx">
    <summary>
      <para>Initializes a critical section object with a spin count and optional flags.</para>
    </summary>
    <param name="lpCriticalSection">
      <para>A pointer to the critical section object.</para>
    </param>
    <param name="dwSpinCount">
      <para>The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to 0 (zero). On multiprocessor systems, if the critical section is unavailable, the calling thread spin <i>dwSpinCount</i> times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</para>
    </param>
    <param name="Flags">
      <para>This parameter can be 0 or the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>CRITICAL_SECTION_NO_DEBUG_INFO</b>
          </description>
          <description>
            <para>The critical section is created without debug information.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The threads of a single process can use a critical section object for mutual-exclusion synchronization. There is no guarantee about the order that threads obtain ownership of the critical section, however, the system is fair to all threads.</para>
      <para>The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type <b>CRITICAL_SECTION</b>. Before using a critical section, some thread of the process must initialize the object. You can subsequently modify the spin count by calling the
<see cref="SetCriticalSectionSpinCount" /> function.</para>
      <para>After a critical section object is initialized, the threads of the process can specify the object in the <see cref="EnterCriticalSection" />, <see cref="TryEnterCriticalSection" />, or
<see cref="LeaveCriticalSection" /> function to provide mutually exclusive access to a shared resource. For similar synchronization between the threads of different processes, use a mutex object.</para>
      <para>A critical section object cannot be moved or copied. The process must also not modify the object, but must treat it as logically opaque. Use only the critical section functions to manage critical section objects. When you have finished using the critical section, call the
<see cref="DeleteCriticalSection" /> function.</para>
      <para>A critical section object must be deleted before it can be reinitialized. Initializing a critical section that is already  initialized results in undefined behavior.</para>
      <para>The spin count is useful for critical sections of short duration that can experience high levels of contention. Consider a worst-case scenario, in which an application on an SMP system has two or three threads constantly allocating and releasing memory from the heap. The application serializes the heap with a critical section. In the worst-case scenario, contention for the critical section is constant, and each thread makes a processing-intensive call to the
<see cref="WaitForSingleObject" /> function. However, if the spin count is set properly, the calling thread does not immediately call
<b>WaitForSingleObject</b> when contention occurs. Instead, the calling thread can acquire ownership of the critical section if it is released during the spin operation.</para>
      <para>You can improve performance significantly by choosing a small spin count for a critical section of short duration. The heap manager uses a spin count of roughly 4000 for its per-heap critical sections. This gives great performance and scalability in almost all worst-case scenarios.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/critical-section-objects">Critical Section Objects</seealso>
    <seealso cref="DeleteCriticalSection" />
  </member>
  <member name="Windows.InitializeSRWLock">
    <summary>
      <para>Initialize a slim reader/writer (SRW) lock.</para>
    </summary>
    <param name="SRWLock">
      <para>A pointer to the SRW lock.</para>
    </param>
    <remarks>
      <para>An SRW lock must be initialized before it is used. The InitializeSRWLock function is used to initialize a SRW lock dynamically. To initialize the structure statically, assign the constant <b>SRWLOCK_INIT</b> to the structure variable.</para>
      <para>An SRW lock cannot be moved or copied while in use. The process must not modify the object, and must instead treat it as logically opaque. Only use the SRW functions to manage SRW locks.</para>
      <para>An unlocked SRW lock with no waiting threads is in its initial state and can be copied, moved, and forgotten without being explicitly destroyed.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/slim-reader-writer--srw--locks">Slim Reader/Writer (SRW) Locks</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InitializeSynchronizationBarrier">
    <summary>
      <para>Initializes a new synchronization barrier.</para>
    </summary>
    <param name="lpBarrier">
      <para>A pointer to the <b>SYNCHRONIZATION_BARRIER</b> structure to initialize. This is an
opaque structure that should not be modified by applications.</para>
    </param>
    <param name="lTotalThreads">
      <para>The maximum number of threads that can enter this barrier. After the maximum number of threads have entered
the barrier, all threads continue.</para>
    </param>
    <param name="lSpinCount">
      <para>The number of times an individual thread should spin while waiting for other threads to arrive at the
barrier. If this parameter is -1, the thread spins 2000 times. If the thread exceeds
<i>lSpinCount</i>, the thread blocks unless it called
<see cref="EnterSynchronizationBarrier" /> with
<b>SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY</b>.</para>
    </param>
    <returns>
      <para>
        <b>TRUE </b> if the barrier was successfully initialized. If the barrier was not
successfully initialized, this function returns <b>FALSE</b>. Use
<see cref="GetLastError" /> to get extended error information.</para>
    </returns>
    <seealso cref="DeleteSynchronizationBarrier" />
    <seealso cref="EnterSynchronizationBarrier" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-barriers">Synchronization Barriers</seealso>
  </member>
  <member name="Windows.InitOnceBeginInitialize">
    <summary>
      <para>Begins one-time initialization.</para>
    </summary>
    <param name="lpInitOnce">
      <para>A pointer to the one-time initialization structure.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can have a value of 0, or one or more of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>INIT_ONCE_ASYNC</b>
                </description>
              </item>
              <item>
                <description>0x00000002UL</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables multiple initialization attempts to execute in parallel. If this flag is used, subsequent calls to this function will fail unless this flag is also specified.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>INIT_ONCE_CHECK_ONLY</b>
                </description>
              </item>
              <item>
                <description>0x00000001UL</description>
              </item>
            </list>
          </description>
          <description>
            <para>This function call does not begin initialization. The return value indicates whether initialization has already completed. If the function returns <b>TRUE</b>, the <i>lpContext</i> parameter receives the data.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="fPending">
      <para>If the function succeeds, this parameter indicates the current initialization status.</para>
      <para>If this parameter is <b>TRUE</b> and <i>dwFlags</i> contains <b>INIT_ONCE_CHECK_ONLY</b>, the initialization is pending and the context data is invalid.</para>
      <para>If this parameter is <b>FALSE</b>, initialization has already completed and the caller can retrieve the context data from the <i>lpContext</i> parameter.</para>
      <para>If this parameter is <b>TRUE</b> and <i>dwFlags</i> does not contain <b>INIT_ONCE_CHECK_ONLY</b>, initialization has been started and the caller can perform the initialization tasks.</para>
    </param>
    <param name="lpContext">
      <para>An optional parameter that receives the data stored with the one-time initialization structure upon success. The low-order <b>INIT_ONCE_CTX_RESERVED_BITS</b> bits of the data are always zero.</para>
    </param>
    <returns>
      <para>If <b>INIT_ONCE_CHECK_ONLY</b> is not specified and the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If <b>INIT_ONCE_CHECK_ONLY</b> is specified and initialization has completed, the return value is <b>TRUE</b>.</para>
      <para>Otherwise, the return value is <b>FALSE</b>.</para>
      <para>To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function can be used for either synchronous or asynchronous one-time initialization. For asynchronous one-time initialization, use the <b>INIT_ONCE_ASYNC</b> flag. To specify a callback function to execute during synchronous one-time initialization, see the <see cref="InitOnceExecuteOnce" /> function.</para>
      <para>If this function succeeds, the thread can create a synchronization object and specify in the <i>lpContext</i> parameter of the <see cref="InitOnceComplete" /> function.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>A one-time initialization object cannot be moved or copied. The process must not modify the initialization object, and must instead treat it as logically opaque. Only use the one-time initialization functions to manage one-time initialization objects.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/Sync/using-one-time-initialization">Using One-Time Initialization</a></para>
    </remarks>
    <seealso cref="InitOnceComplete" />
    <seealso cref="InitOnceExecuteOnce" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/one-time-initialization">One-Time Initialization</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InitOnceComplete">
    <summary>
      <para>Completes one-time initialization started with the <see cref="InitOnceBeginInitialize" /> function.</para>
    </summary>
    <param name="lpInitOnce">
      <para>A pointer to the one-time initialization structure.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>INIT_ONCE_ASYNC</b>
                </description>
              </item>
              <item>
                <description>0x00000002UL</description>
              </item>
            </list>
          </description>
          <description>
            <para>Operate in asynchronous mode. This enables multiple completion attempts to execute in parallel. This flag must match the flag passed in the corresponding call to the <see cref="InitOnceBeginInitialize" /> function. This flag may not be combined with <b>INIT_ONCE_INIT_FAILED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>INIT_ONCE_INIT_FAILED</b>
                </description>
              </item>
              <item>
                <description>0x00000004UL</description>
              </item>
            </list>
          </description>
          <description>
            <para>The initialization attempt failed. This flag may not be combined with <b>INIT_ONCE_ASYNC</b>. To fail an asynchronous initialization, merely abandon it (that is, do not call the <b>InitOnceComplete</b> function).</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpContext">
      <para>A pointer to the data to be stored with the one-time initialization structure. This data is returned in the <i>lpContext</i> parameter passed to subsequent calls to the <see cref="InitOnceBeginInitialize" /> function. If <i>lpContext</i> points to a value, the low-order <b>INIT_ONCE_CTX_RESERVED_BITS</b> of the value must be zero. If <i>lpContext</i>  points to a data structure, the data structure must be <b>DWORD</b>-aligned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>For an example that uses
this function, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-one-time-initialization">Using One-Time Initialization</a>.</para>
    </remarks>
    <seealso cref="InitOnceBeginInitialize" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/one-time-initialization">One-Time Initialization</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InitOnceExecuteOnce">
    <summary>
      <para>Executes the specified function successfully one time. No other threads that specify the same one-time initialization structure can execute the specified function while it is being executed by the current thread.</para>
    </summary>
    <param name="InitOnce">
      <para>A pointer to the one-time initialization structure.</para>
    </param>
    <param name="InitFn">
      <para>A pointer to an application-defined <a href="https://docs.microsoft.com//windows/desktop/api/synchapi/nc-synchapi-pinit_once_fn">InitOnceCallback</a> function.</para>
    </param>
    <param name="Parameter">
      <para>A parameter to be passed to the callback function.</para>
    </param>
    <param name="Context">
      <para>A parameter that receives data stored with the one-time initialization structure upon success. The low-order <b>INIT_ONCE_CTX_RESERVED_BITS</b> bits of the data are always zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is used for synchronous one-time initialization. For asynchronous one-time initialization, use the <see cref="InitOnceBeginInitialize" /> function with the <b>INIT_ONCE_ASYNC</b> flag.</para>
      <para>Only one thread at a time can execute the callback function specified by <i>InitFn</i>. Other threads that specify the same one-time initialization structure block until the callback finishes.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>For an example that uses
this function, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-one-time-initialization">Using One-Time Initialization</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/synchapi/nc-synchapi-pinit_once_fn">InitOnceCallback</seealso>
    <seealso cref="InitOnceInitialize" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/one-time-initialization">One-Time Initialization</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InitOnceInitialize">
    <summary>
      <para>Initializes a one-time initialization structure.</para>
    </summary>
    <param name="InitOnce">
      <para>A pointer to the one-time initialization structure.</para>
    </param>
    <remarks>
      <para>The <b>InitOnceInitialize</b> function is used to initialize a one-time initialization structure dynamically. To initialize the structure statically, assign the constant <b>INIT_ONCE_STATIC_INIT</b> to the structure variable.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>A one-time initialization object cannot be moved or copied. The process must not modify the initialization object, and must instead treat it as logically opaque. Only use the one-time initialization functions to manage one-time initialization objects.</para>
      <h4>Examples</h4>
      <para>The following example calls <b>InitOnceInitialize</b> to initialize the one-time initialization structure named <code>InitOnce</code>. Alternatively, the structure can be declared as a global variable as shown in <a href="https://docs.microsoft.com//windows/desktop/Sync/using-one-time-initialization">Using One-Time Initialization</a>.</para>
      <code>
//Requires Windows Vista, Windows Server 2008 or later
#define _WIN32_WINNT 0x0600

#include &lt;windows.h&gt;

BOOL StartInitialization()
{
    INIT_ONCE InitOnce;

    InitOnceInitialize(&amp;amp;amp;amp;amp;amp;InitOnce);

    //...
    return TRUE;
}

</code>
    </remarks>
    <seealso cref="InitOnceExecuteOnce" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/one-time-initialization">One-Time Initialization</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.LeaveCriticalSection">
    <summary>
      <para>Releases ownership of the specified critical section object.</para>
    </summary>
    <param name="lpCriticalSection">
      <para>A pointer to the critical section object.</para>
    </param>
    <remarks>
      <para>The threads of a single process can use a critical-section object for mutual-exclusion synchronization. The process is responsible for allocating the memory used by a critical-section object, which it can do by declaring a variable of type <b>CRITICAL_SECTION</b>. Before using a critical section, some thread of the process must call the
<see cref="InitializeCriticalSection" /> or
<see cref="InitializeCriticalSectionAndSpinCount" /> function to initialize the object.</para>
      <para>A thread uses the
<see cref="EnterCriticalSection" /> or
<see cref="TryEnterCriticalSection" /> function to acquire ownership of a critical section object. To release its ownership, the thread must call
<b>LeaveCriticalSection</b> once for each time that it entered the critical section.</para>
      <para>If a thread calls
<b>LeaveCriticalSection</b> when it does not have ownership of the specified critical section object, an error occurs that may cause another thread using
<see cref="EnterCriticalSection" /> to wait indefinitely.</para>
      <para>Any thread of the process can use the
<see cref="DeleteCriticalSection" /> function to release the system resources that were allocated when the critical section object was initialized. After this function has been called, the critical section object can no longer be used for synchronization.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>LeaveCriticalSection</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-critical-section-objects">Using Critical Section Objects</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/critical-section-objects">Critical Section Objects</seealso>
    <seealso cref="DeleteCriticalSection" />
    <seealso cref="EnterCriticalSection" />
    <seealso cref="InitializeCriticalSection" />
    <seealso cref="InitializeCriticalSectionAndSpinCount" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso cref="TryEnterCriticalSection" />
  </member>
  <member name="Windows.OpenEvent">
    <summary>
      <para>Opens an existing named event object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The  name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenEvent</b> function enables multiple processes to open handles of the same event object. The function succeeds only if some process has already created the event by using the
<see cref="CreateEvent" /> function. The calling process can use the returned handle in any function that requires a handle to an event object, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The event object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines OpenEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEvent" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="PulseEvent" />
    <seealso cref="ResetEvent" />
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenEventA">
    <summary>
      <para>Opens an existing named event object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The  name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenEvent</b> function enables multiple processes to open handles of the same event object. The function succeeds only if some process has already created the event by using the
<see cref="CreateEvent" /> function. The calling process can use the returned handle in any function that requires a handle to an event object, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The event object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines OpenEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEvent" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="PulseEvent" />
    <seealso cref="ResetEvent" />
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenEventW">
    <summary>
      <para>Opens an existing named event object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The  name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenEvent</b> function enables multiple processes to open handles of the same event object. The function succeeds only if some process has already created the event by using the
<see cref="CreateEvent" /> function. The calling process can use the returned handle in any function that requires a handle to an event object, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The event object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines OpenEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEvent" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="PulseEvent" />
    <seealso cref="ResetEvent" />
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenEvent">
    <summary>
      <para>Opens an existing named event object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The  name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenEvent</b> function enables multiple processes to open handles of the same event object. The function succeeds only if some process has already created the event by using the
<see cref="CreateEvent" /> function. The calling process can use the returned handle in any function that requires a handle to an event object, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The event object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines OpenEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEvent" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="PulseEvent" />
    <seealso cref="ResetEvent" />
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenEventA">
    <summary>
      <para>Opens an existing named event object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The  name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenEvent</b> function enables multiple processes to open handles of the same event object. The function succeeds only if some process has already created the event by using the
<see cref="CreateEvent" /> function. The calling process can use the returned handle in any function that requires a handle to an event object, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The event object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines OpenEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEvent" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="PulseEvent" />
    <seealso cref="ResetEvent" />
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenEventW">
    <summary>
      <para>Opens an existing named event object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the event object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The  name of the event to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenEvent</b> function enables multiple processes to open handles of the same event object. The function succeeds only if some process has already created the event by using the
<see cref="CreateEvent" /> function. The calling process can use the returned handle in any function that requires a handle to an event object, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The event object is destroyed when its last handle has been closed.</para>
      <blockquote>
        <para>[!NOTE]
The synchapi.h header defines OpenEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEvent" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="PulseEvent" />
    <seealso cref="ResetEvent" />
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenMutex">
    <summary>
      <para>Opens an existing named mutex object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the mutex object. Only the <b>SYNCHRONIZE</b> access right is required to use a mutex; to change the mutex's security, specify <b>MUTEX_ALL_ACCESS</b>. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If a named mutex does not exist, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenMutex</b> function enables multiple processes to open handles of the same mutex object. The function succeeds only if some process has already created the mutex by using the
<see cref="CreateMutex" /> function. The calling process can use the returned handle in any function that requires a handle to a mutex object, such as the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <para>If your multithreaded application must repeatedly create, open, and close a named mutex object, a race condition can occur. In this situation, it is better to use <see cref="CreateMutex" /> instead of <b>OpenMutex</b>, because <b>CreateMutex</b> opens a mutex if it exists and creates it if it does not.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>OpenMutex</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-named-objects">Using Named Objects</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateMutex" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="ReleaseMutex" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenMutexA">
    <summary>
      <para>Opens an existing named mutex object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the mutex object. Only the <b>SYNCHRONIZE</b> access right is required to use a mutex; to change the mutex's security, specify <b>MUTEX_ALL_ACCESS</b>. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If a named mutex does not exist, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenMutex</b> function enables multiple processes to open handles of the same mutex object. The function succeeds only if some process has already created the mutex by using the
<see cref="CreateMutex" /> function. The calling process can use the returned handle in any function that requires a handle to a mutex object, such as the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <para>If your multithreaded application must repeatedly create, open, and close a named mutex object, a race condition can occur. In this situation, it is better to use <see cref="CreateMutex" /> instead of <b>OpenMutex</b>, because <b>CreateMutex</b> opens a mutex if it exists and creates it if it does not.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>OpenMutex</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-named-objects">Using Named Objects</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateMutex" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="ReleaseMutex" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenMutexW">
    <summary>
      <para>Opens an existing named mutex object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the mutex object. Only the <b>SYNCHRONIZE</b> access right is required to use a mutex; to change the mutex's security, specify <b>MUTEX_ALL_ACCESS</b>. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The name of the mutex to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mutex object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If a named mutex does not exist, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenMutex</b> function enables multiple processes to open handles of the same mutex object. The function succeeds only if some process has already created the mutex by using the
<see cref="CreateMutex" /> function. The calling process can use the returned handle in any function that requires a handle to a mutex object, such as the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The mutex object is destroyed when its last handle has been closed.</para>
      <para>If your multithreaded application must repeatedly create, open, and close a named mutex object, a race condition can occur. In this situation, it is better to use <see cref="CreateMutex" /> instead of <b>OpenMutex</b>, because <b>CreateMutex</b> opens a mutex if it exists and creates it if it does not.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>OpenMutex</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-named-objects">Using Named Objects</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateMutex" />
    <seealso cref="CreateProcess" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="ReleaseMutex" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenSemaphore">
    <summary>
      <para>Opens an existing named semaphore object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the semaphore object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The name of the semaphore to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenSemaphore</b> function enables multiple processes to open handles of the same semaphore object. The function succeeds only if some process has already created the semaphore by using the
<see cref="CreateSemaphore" /> function. The calling process can use the returned handle in any function that requires a handle to a semaphore object, such as the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateSemaphore" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="ReleaseSemaphore" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenSemaphoreA">
    <summary>
      <para>Opens an existing named semaphore object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the semaphore object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The name of the semaphore to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenSemaphore</b> function enables multiple processes to open handles of the same semaphore object. The function succeeds only if some process has already created the semaphore by using the
<see cref="CreateSemaphore" /> function. The calling process can use the returned handle in any function that requires a handle to a semaphore object, such as the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateSemaphore" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="ReleaseSemaphore" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenSemaphoreW">
    <summary>
      <para>Opens an existing named semaphore object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the semaphore object. The function fails if the security descriptor of the specified object does not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The name of the semaphore to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenSemaphore</b> function enables multiple processes to open handles of the same semaphore object. The function succeeds only if some process has already created the semaphore by using the
<see cref="CreateSemaphore" /> function. The calling process can use the returned handle in any function that requires a handle to a semaphore object, such as the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateSemaphore" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="ReleaseSemaphore" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.OpenWaitableTimer">
    <summary>
      <para>Opens an existing named waitable timer object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the timer object. The function fails if the security descriptor of the specified object does
not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenWaitableTimer</b> function enables multiple processes to open handles to the same timer object. The function succeeds only if some process has already created the timer using the
<see cref="CreateWaitableTimer" /> function. The calling process can use the returned handle in any function that requires the handle to a timer object, such as the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The returned handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="CancelWaitableTimer" />
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateWaitableTimer" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="SetWaitableTimer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/waitable-timer-objects">Waitable Timer Objects</seealso>
  </member>
  <member name="Windows.OpenWaitableTimerA">
    <summary>
      <para>Opens an existing named waitable timer object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the timer object. The function fails if the security descriptor of the specified object does
not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenWaitableTimer</b> function enables multiple processes to open handles to the same timer object. The function succeeds only if some process has already created the timer using the
<see cref="CreateWaitableTimer" /> function. The calling process can use the returned handle in any function that requires the handle to a timer object, such as the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The returned handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="CancelWaitableTimer" />
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateWaitableTimer" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="SetWaitableTimer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/waitable-timer-objects">Waitable Timer Objects</seealso>
  </member>
  <member name="Windows.OpenWaitableTimerW">
    <summary>
      <para>Opens an existing named waitable timer object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the timer object. The function fails if the security descriptor of the specified object does
not permit the requested access for the calling process. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpTimerName">
      <para>The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>
        <b>Note</b>  Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the timer object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>OpenWaitableTimer</b> function enables multiple processes to open handles to the same timer object. The function succeeds only if some process has already created the timer using the
<see cref="CreateWaitableTimer" /> function. The calling process can use the returned handle in any function that requires the handle to a timer object, such as the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, subject to the limitations of the access specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>The returned handle can be duplicated by using the <see cref="DuplicateHandle" /> function. Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The timer object is destroyed when its last handle has been closed.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="CancelWaitableTimer" />
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateWaitableTimer" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="SetWaitableTimer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/waitable-timer-objects">Waitable Timer Objects</seealso>
  </member>
  <member name="Windows.ReleaseMutex">
    <summary>
      <para>Releases ownership of the specified mutex object.</para>
    </summary>
    <param name="hMutex">
      <para>A handle to the mutex object. The
<see cref="CreateMutex" /> or</para>
      <para>
        <see cref="OpenMutex" /> function returns this handle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>ReleaseMutex</b> function fails if the calling thread does not own the mutex object.</para>
      <para>A thread obtains ownership of a mutex either by creating it with the <i>bInitialOwner</i> parameter set to <b>TRUE</b> or by specifying its handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. When the thread no longer needs to own the mutex object, it calls the
<b>ReleaseMutex</b> function so that another thread can acquire ownership.</para>
      <para>A thread  can specify a  mutex that it already owns in a call to one of the wait functions without blocking its execution. This prevents a thread from deadlocking itself while waiting for a mutex that it already owns. However, to release its ownership, the thread must call
<b>ReleaseMutex</b> one time for each time that it obtained ownership (either through <see cref="CreateMutex" /> or a wait function).</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>ReleaseMutex</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-mutex-objects">Using Mutex Objects</a>.</para>
    </remarks>
    <seealso cref="CreateMutex" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.ReleaseSemaphore">
    <summary>
      <para>Increases the count of the specified semaphore object by a specified amount.</para>
    </summary>
    <param name="hSemaphore">
      <para>A handle to the semaphore object. The
<see cref="CreateSemaphore" /> or
<see cref="OpenSemaphore" /> function returns this handle.</para>
      <para>This handle must have the <b>SEMAPHORE_MODIFY_STATE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lReleaseCount">
      <para>The amount by which the semaphore object's current count is to be increased. The value must be greater than zero. If the specified amount would cause the semaphore's count to exceed the maximum count that was specified when the semaphore was created, the count is not changed and the function returns <b>FALSE</b>.</para>
    </param>
    <param name="lpPreviousCount">
      <para>A pointer to a variable to receive the previous count for the semaphore. This parameter can be <b>NULL</b> if the previous count is not required.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The state of a semaphore object is signaled when its count is greater than zero and nonsignaled when its count is equal to zero. The process that calls the
<see cref="CreateSemaphore" /> function specifies the semaphore's initial count. Each time a waiting thread is released because of the semaphore's signaled state, the count of the semaphore is decreased by one.</para>
      <para>Typically, an application uses a semaphore to limit the number of threads using a resource. Before a thread uses the resource, it specifies the semaphore handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. When the wait function returns, it decreases the semaphore's count by one. When the thread has finished using the resource, it calls
<b>ReleaseSemaphore</b> to increase the semaphore's count by one.</para>
      <para>Another use of
<b>ReleaseSemaphore</b> is during an application's initialization. The application can create a semaphore with an initial count of zero. This sets the semaphore's state to nonsignaled and blocks all threads from accessing the protected resource. When the application finishes its initialization, it uses
<b>ReleaseSemaphore</b> to increase the count to its maximum value, to permit normal access to the protected resource.</para>
      <para>It is not possible to reduce the semaphore object count using
<b>ReleaseSemaphore</b>, because <i>lReleaseCount</i> cannot be a negative number. To temporarily restrict or reduce access, create a loop in which you call the
<see cref="WaitForSingleObject" /> function with a time-out interval of zero until the semaphore count has been reduced sufficiently. (Note that other threads can reduce the count while this loop is being executed.) To restore access, call
<b>ReleaseSemaphore</b> with the release count equal to the number of times
<b>WaitForSingleObject</b> was called in the loop.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>ReleaseSemaphore</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-semaphore-objects">Using Semaphore Objects</a>.</para>
    </remarks>
    <seealso cref="CreateSemaphore" />
    <seealso cref="OpenSemaphore" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.ReleaseSRWLockExclusive">
    <summary>
      <para>Releases a slim reader/writer (SRW) lock that was acquired in exclusive mode.</para>
    </summary>
    <param name="SRWLock">
      <para>A pointer to the SRW lock.</para>
    </param>
    <remarks>
      <para>The SRW lock must be released by the same thread that acquired it. You can use <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> to help verify that your program uses SRW locks correctly (enable Locks checker from Basic group).</para>
    </remarks>
    <seealso cref="AcquireSRWLockExclusive" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/slim-reader-writer--srw--locks">Slim Reader/Writer (SRW) Locks</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.ReleaseSRWLockShared">
    <summary>
      <para>Releases a slim reader/writer (SRW) lock that was acquired in shared mode.</para>
    </summary>
    <param name="SRWLock">
      <para>A pointer to the SRW lock.</para>
    </param>
    <remarks>
      <para>The SRW lock must be released by the same thread that acquired it. You can use <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> to help verify that your program uses SRW locks correctly (enable Locks checker from Basic group).</para>
    </remarks>
    <seealso cref="AcquireSRWLockShared" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/slim-reader-writer--srw--locks">Slim Reader/Writer (SRW) Locks</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.RtlReleaseSRWLockShared">
    <summary>
      <para>Releases a slim reader/writer (SRW) lock that was acquired in shared mode.</para>
    </summary>
    <param name="SRWLock">
      <para>A pointer to the SRW lock.</para>
    </param>
    <remarks>
      <para>The SRW lock must be released by the same thread that acquired it. You can use <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> to help verify that your program uses SRW locks correctly (enable Locks checker from Basic group).</para>
    </remarks>
    <seealso cref="AcquireSRWLockShared" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/slim-reader-writer--srw--locks">Slim Reader/Writer (SRW) Locks</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.ResetEvent">
    <summary>
      <para>Sets the specified event object to the nonsignaled state.</para>
    </summary>
    <param name="hEvent">
      <para>A handle to the event object. The
<see cref="CreateEvent" /> or
<see cref="OpenEvent" /> function returns this handle.</para>
      <para>The handle must have the EVENT_MODIFY_STATE access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The state of an event object remains nonsignaled until it is explicitly set to signaled by the
<see cref="SetEvent" /> or
<see cref="PulseEvent" /> function. This nonsignaled state blocks the execution of any threads that have specified the event object in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>.</para>
      <para>The
<b>ResetEvent</b> function is used primarily for manual-reset event objects, which must be set explicitly to the nonsignaled state. Auto-reset event objects automatically change from signaled to nonsignaled after a single waiting thread is released.</para>
      <para>Resetting an event that is already reset has no effect.</para>
    </remarks>
    <seealso cref="CreateEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso cref="OpenEvent" />
    <seealso cref="PulseEvent" />
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.SetCriticalSectionSpinCount">
    <summary>
      <para>Sets the spin count for the specified critical section. Spinning means that when a thread tries to acquire a critical section that is locked, the thread enters a loop, checks to see if the lock is released, and if the lock is not released, the thread goes to sleep.</para>
    </summary>
    <param name="lpCriticalSection">
      <para>A pointer to the critical section object.</para>
    </param>
    <param name="dwSpinCount">
      <para>The spin count for the critical section object. On single-processor systems, the spin count is ignored and the critical section spin count is set to zero (0). On multiprocessor systems, if the critical section is unavailable, the calling thread spins <i>dwSpinCount</i> times before performing a wait operation on a semaphore associated with the critical section. If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</para>
    </param>
    <returns>
      <para>The function returns the previous spin count for the critical section.</para>
    </returns>
    <remarks>
      <para>The threads of a single process can use a critical section object for mutual-exclusion synchronization. The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type <b>CRITICAL_SECTION</b>. Before using a critical section, some thread of the process must call the
<see cref="InitializeCriticalSection" /> or
<see cref="InitializeCriticalSectionAndSpinCount" /> function to initialize the object. You can subsequently modify the spin count by calling the
<b>SetCriticalSectionSpinCount</b> function.</para>
      <para>The spin count is useful for critical sections of short duration that can experience high levels of contention. Consider a worst-case scenario, in which an application on an SMP system has two or three threads constantly allocating and releasing memory from the heap. The application serializes the heap with a critical section. In the worst-case scenario, contention for the critical section is constant, and each thread makes a processing-intensive call to the
<see cref="WaitForSingleObject" /> function. However, if the spin count is set properly, the calling thread does not immediately call
<b>WaitForSingleObject</b> when contention occurs. Instead, the calling thread can acquire ownership of the critical section if it is released during the spin operation.</para>
      <para>You can improve performance significantly by choosing a small spin count for a critical section of short duration. The heap manager uses a spin count of roughly 4000 for its per-heap critical sections. This gives great performance and scalability in almost all worst-case scenarios.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0403 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/critical-section-objects">Critical Section Objects</seealso>
    <seealso cref="InitializeCriticalSection" />
    <seealso cref="InitializeCriticalSectionAndSpinCount" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso cref="WaitForSingleObject" />
  </member>
  <member name="Windows.SetEvent">
    <summary>
      <para>Sets the specified event object to the signaled state.</para>
    </summary>
    <param name="hEvent">
      <para>A handle to the event object. The
<see cref="CreateEvent" /> or
<see cref="OpenEvent" /> function returns this handle.</para>
      <para>The handle must have the EVENT_MODIFY_STATE access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The state of a manual-reset event object remains signaled until it is set explicitly to the nonsignaled state by the
<see cref="ResetEvent" /> function. Any number of waiting threads, or threads that subsequently begin wait operations for the specified event object by calling one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, can be released while the object's state is signaled.</para>
      <para>The state of an auto-reset event object remains signaled until a single waiting thread is released, at which time the system automatically sets the state to nonsignaled. If no threads are waiting, the event object's state remains signaled.</para>
      <para>Setting an event that is already set has no effect.</para>
      <para>Windows Store apps can respond to named events and semaphores as described in <a href="https://docs.microsoft.com//previous-versions/windows/apps/jj248674(v=win.10)">How to respond to named events and semaphores</a>.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>SetEvent</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-event-objects">Using Event Objects</a>.</para>
    </remarks>
    <seealso cref="CreateEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso cref="OpenEvent" />
    <seealso cref="PulseEvent" />
    <seealso cref="ResetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.SetWaitableTimer">
    <summary>
      <para>Activates the specified waitable timer. When the due time arrives, the timer is signaled and the thread that set the timer calls the optional completion routine.</para>
    </summary>
    <param name="hTimer">
      <para>A handle to the timer object. The
<see cref="CreateWaitableTimer" /> or
<see cref="OpenWaitableTimer" /> function returns this handle.</para>
      <para>The handle must have the <b>TIMER_MODIFY_STATE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpDueTime">
      <para>The time after which the state of the timer is to be set to signaled, in 100 nanosecond intervals. Use the format described by the
<see cref="FILETIME" /> structure. Positive values indicate absolute time. Be sure to use a UTC-based absolute time, as the system uses UTC-based time internally. Negative values indicate relative time. The actual timer accuracy depends on the capability of your hardware. For more information about UTC-based time, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/system-time">System Time</a>.</para>
    </param>
    <param name="lPeriod">
      <para>The period of the timer, in milliseconds. If <i>lPeriod</i> is zero, the timer is signaled once. If <i>lPeriod</i> is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled using the
<see cref="CancelWaitableTimer" /> function or reset using
<b>SetWaitableTimer</b>. If <i>lPeriod</i> is less than zero, the function fails.</para>
    </param>
    <param name="pfnCompletionRoutine">
      <para>A pointer to an optional completion routine. The completion routine is application-defined function of type <b>PTIMERAPCROUTINE</b> to be executed when the timer is signaled. For more information on the timer callback function, see
<a href="https://docs.microsoft.com//windows/desktop/api/synchapi/nc-synchapi-ptimerapcroutine">TimerAPCProc</a>. For more information about APCs and thread pool threads, see Remarks.</para>
    </param>
    <param name="lpArgToCompletionRoutine">
      <para>A pointer to a structure that is passed to the completion routine.</para>
    </param>
    <param name="fResume">
      <para>If this parameter is <b>TRUE</b>, restores a system in suspended power conservation mode when the timer state is set to signaled. Otherwise, the system is not restored. If the system does not support a restore, the call succeeds, but <see cref="GetLastError" /> returns <b>ERROR_NOT_SUPPORTED</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Timers are initially inactive. To activate a timer, call
<b>SetWaitableTimer</b>. If the timer is already active when you call
<b>SetWaitableTimer</b>, the timer is stopped, then it is reactivated. Stopping the timer in this manner does not set the timer state to signaled, so threads blocked in a wait operation on the timer remain blocked. However, it does cancel any pending completion routines.</para>
      <para>When the specified due time arrives, the timer becomes inactive and the optional APC is queued to the thread that set the timer. The state of the timer is set to signaled, the timer is reactivated using the specified period, and the thread that set the timer calls the completion routine when it enters an alertable wait state. If the timer is set before the thread enters an alertable wait state, the APC is canceled. For more information, see
<see cref="QueueUserAPC" />. Note that APCs do not work as well as other signaling mechanisms  for thread pool threads because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered. Instead of using the <i>pfnCompletionRoutine</i> parameter or another APC-based signaling mechanism, use a waitable object such as a timer created with <see cref="CreateThreadpoolTimer" />. For I/O, use  an I/O completion object created with <see cref="CreateThreadpoolIo" /> or an <i>hEvent</i>-based <see cref="OVERLAPPED" /> structure where the event can be passed to the <see cref="SetThreadpoolWait" /> function.</para>
      <para>If the thread that set the timer terminates and there is an associated completion routine, the timer is canceled. However, the state of the timer remains unchanged. If there is no completion routine, then terminating the thread has no effect on the timer.</para>
      <para>When a manual-reset timer is set to the signaled state, it remains in this state until
<b>SetWaitableTimer</b> is called to reset the timer. As a result, a periodic manual-reset timer is set to the signaled state when the initial due time arrives and remains signaled until it is reset. When a synchronization timer is set to the signaled state, it remains in this state until a thread completes a wait operation on the timer object.</para>
      <para>If the system time is adjusted, the due time of any outstanding absolute timers is adjusted.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>To use a timer to schedule an event for a window, use the <see cref="SetTimer" /> function.</para>
      <para>APIs that deal with timers use various different hardware clocks. These clocks may have resolutions significantly different from what you expect: some may be measured in milliseconds (for those that use an RTC-based timer chip), to those measured in nanoseconds (for those that use ACPI or TSC counters). You can change the resolution of your API with a  call to the <see cref="timeBeginPeriod" /> and <see cref="timeEndPeriod" /> functions. How precise you can change the resolution depends on which hardware clock the particular API uses. For more information, check your hardware documentation.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>SetWaitableTimer</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-waitable-timer-objects">Using Waitable Timer Objects</a>.</para>
    </remarks>
    <seealso cref="CancelWaitableTimer" />
    <seealso cref="CreateWaitableTimer" />
    <seealso cref="OpenWaitableTimer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/synchapi/nc-synchapi-ptimerapcroutine">TimerAPCProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/waitable-timer-objects">Waitable Timer Objects</seealso>
  </member>
  <member name="Windows.SetWaitableTimerEx">
    <summary>
      <para>Activates the specified waitable timer and provides context information for the timer. When the due time arrives, the timer is signaled and the thread that set the timer calls the optional completion routine.</para>
    </summary>
    <param name="hTimer">
      <para>A handle to the timer object. The <see cref="CreateWaitableTimer" /> or <see cref="OpenWaitableTimer" /> function returns this handle.</para>
      <para>The handle must have the <b>TIMER_MODIFY_STATE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="lpDueTime">
      <para>The time after which the state of the timer is to be set to signaled, in 100 nanosecond intervals. Use the format described by the
<see cref="FILETIME" /> structure. Positive values indicate absolute time. Be sure to use a UTC-based absolute time, as the system uses UTC-based time internally. Negative values indicate relative time. The actual timer accuracy depends on the capability of your hardware. For more information about UTC-based time, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/system-time">System Time</a>.</para>
    </param>
    <param name="lPeriod">
      <para>The period of the timer, in milliseconds. If <i>lPeriod</i> is zero, the timer is signaled once. If <i>lPeriod</i> is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, until the timer is canceled using the
<see cref="CancelWaitableTimer" /> function or reset using
<b>SetWaitableTimerEx</b>. If <i>lPeriod</i> is less than zero, the function fails.</para>
    </param>
    <param name="pfnCompletionRoutine">
      <para>A pointer to an optional completion routine. The completion routine is application-defined function of type <b>PTIMERAPCROUTINE</b> to be executed when the timer is signaled. For more information on the timer callback function, see
<a href="https://docs.microsoft.com//windows/desktop/api/synchapi/nc-synchapi-ptimerapcroutine">TimerAPCProc</a>.  For more information about APCs and thread pool threads, see Remarks.</para>
    </param>
    <param name="lpArgToCompletionRoutine">
      <para>A pointer to a structure that is passed to the completion routine.</para>
    </param>
    <param name="WakeContext">
      <para>Pointer to a <see cref="REASON_CONTEXT" /> structure that contains context information for the timer.</para>
    </param>
    <param name="TolerableDelay">
      <para>The tolerable delay for expiration time, in milliseconds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>SetWaitableTimerEx</b> function is similar to the <see cref="SetWaitableTimer" /> function, except <b>SetWaitableTimerEx</b> can be used to specify a context string and a tolerable delay for expiration of the timer.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0601 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>Timers are initially inactive. To activate a timer, call
<b>SetWaitableTimerEx</b>. If the timer is already active when you call
<b>SetWaitableTimerEx</b>, the timer is stopped, then it is reactivated. Stopping the timer in this manner does not set the timer state to signaled, so threads blocked in a wait operation on the timer remain blocked. However, it does cancel any pending completion routines.</para>
      <para>When the specified due time arrives, the timer becomes inactive and the optional APC is queued to the thread that set the timer. The state of the timer is set to signaled, the timer is reactivated using the specified period, and the thread that set the timer calls the completion routine when it enters an alertable wait state. If the timer is set before the thread enters an alertable wait state, the APC is canceled. For more information, see
<see cref="QueueUserAPC" />. Note that APCs do not work as well as other signaling mechanisms  for thread pool threads because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered. Instead of using the <i>pfnCompletionRoutine</i> parameter or another APC-based signaling mechanism, use a waitable object such as a timer created with <see cref="CreateThreadpoolTimer" />. For I/O, use  an I/O completion object created with <see cref="CreateThreadpoolIo" /> or an <i>hEvent</i>-based <see cref="OVERLAPPED" /> structure where the event can be passed to the <see cref="SetThreadpoolWait" /> function.</para>
      <para>If the thread that set the timer terminates and there is an associated completion routine, the timer is canceled. However, the state of the timer remains unchanged. If there is no completion routine, then terminating the thread has no effect on the timer.</para>
      <para>When a manual-reset timer is set to the signaled state, it remains in this state until
<b>SetWaitableTimerEx</b> is called to reset the timer. As a result, a periodic manual-reset timer is set to the signaled state when the initial due time arrives and remains signaled until it is reset. When a synchronization timer is set to the signaled state, it remains in this state until a thread completes a wait operation on the timer object.</para>
      <para>If the system time is adjusted, the due time of any outstanding absolute timers is adjusted.</para>
      <para>If the thread that called <b>SetWaitableTimerEx</b> exits, the timer is canceled. This stops the timer before it can be set to the signaled state and cancels outstanding APCs; it does not change the signaled state of the timer.</para>
      <para>To use a timer to schedule an event for a window, use the <see cref="SetTimer" /> function.</para>
    </remarks>
    <seealso cref="REASON_CONTEXT" />
    <seealso cref="SetWaitableTimer" />
  </member>
  <member name="Windows.SignalObjectAndWait">
    <summary>
      <para>Signals one object and waits on another object as a single operation.</para>
    </summary>
    <param name="hObjectToSignal">
      <para>A handle to the object to be signaled. This object can be a semaphore, a mutex, or an event.</para>
      <para>If the handle is a semaphore, the <b>SEMAPHORE_MODIFY_STATE</b> access right is required. If the handle is an event, the <b>EVENT_MODIFY_STATE</b> access right is required. If the handle is a mutex and the caller does not own the mutex, the function fails with <b>ERROR_NOT_OWNER</b>.</para>
    </param>
    <param name="hObjectToWaitOn">
      <para>A handle to the object to wait on. The <b>SYNCHRONIZE</b> access right is required; for more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>. For a list of the object types whose handles you can specify, see the Remarks section.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state is nonsignaled and no completion or asynchronous procedure call (APC) objects are queued. If <i>dwMilliseconds</i> is zero, the function tests the object's state, checks for queued completion routines or APCs, and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses.</para>
    </param>
    <param name="bAlertable">
      <para>If this parameter is <b>TRUE</b>, the function returns when the system queues an I/O completion routine or APC function, and the thread calls the function. If <b>FALSE</b>, the function does not return, and the thread does not call the completion routine or APC function.</para>
      <para>A completion routine is queued when the
function call that queued the APC has completed. This function returns and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b>, and the calling thread is the thread that queued the APC.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_ABANDONED</b>
                </description>
              </item>
              <item>
                <description>0x00000080L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.</para>
            <para>If the mutex was protecting persistent state information, you should check it for consistency.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_IO_COMPLETION</b>
                </description>
              </item>
              <item>
                <description>0x000000C0L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The wait was ended by one or more user-mode
<a href="https://docs.microsoft.com//windows/desktop/Sync/asynchronous-procedure-calls">asynchronous procedure calls</a> (APC) queued to the thread.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_OBJECT_0</b>
                </description>
              </item>
              <item>
                <description>0x00000000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The state of the specified object is signaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_TIMEOUT</b>
                </description>
              </item>
              <item>
                <description>0x00000102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The time-out interval elapsed, and the object's state is nonsignaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_FAILED</b>
                </description>
              </item>
              <item>
                <description>(<b>DWORD</b>)0xFFFFFFFF</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function has failed. To get extended error information, call
<see cref="GetLastError" />.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>SignalObjectAndWait</b> function  provides a more efficient way to signal one object and then wait on another compared to separate function calls such as  <see cref="SetEvent" /> followed by <see cref="WaitForSingleObject" />.</para>
      <para>The
<b>SignalObjectAndWait</b> function can wait for the following objects:</para>
      <list type="bullet">
        <item>
          <description>Change notification</description>
        </item>
        <item>
          <description>Console input</description>
        </item>
        <item>
          <description>Event</description>
        </item>
        <item>
          <description>Memory resource notification</description>
        </item>
        <item>
          <description>Mutex</description>
        </item>
        <item>
          <description>Process</description>
        </item>
        <item>
          <description>Semaphore</description>
        </item>
        <item>
          <description>Thread</description>
        </item>
        <item>
          <description>Waitable timer</description>
        </item>
      </list>
      <para>For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-objects">Synchronization Objects</a>.</para>
      <para>A thread can use the <b>SignalObjectAndWait</b> function to ensure that a  worker thread is in a wait state before signaling an object. For example, a thread and a worker thread may use handles to event objects to synchronize their work. The thread executes code such as the following:</para>
      <code>  dwRet = WaitForSingleObject(hEventWorkerDone, INFINITE);
  if( WAIT_OBJECT_0 == dwRet)
    SetEvent(hEventMoreWorkToDo);

</code>
      <para>The worker thread executes code such as the following:</para>
      <code>  dwRet = SignalObjectAndWait(hEventWorkerDone,
                              hEventMoreWorkToDo,
                              INFINITE,
                              FALSE);

</code>
      <para>Note that the "signal" and "wait" are not guaranteed to be performed as an atomic operation. Threads executing on other processors can observe the signaled state of the first object before the thread calling <b>SignalObjectAndWait</b> begins its wait on the second object.</para>
      <para>Use extreme caution when using  <b>SignalObjectAndWait</b>  and <see cref="PulseEvent" /> with Windows 7, since using these APIs among multiple threads can cause an application to deadlock. Threads that are signaled by <b>SignalObjectAndWait</b>  call <b>PulseEvent</b> to signal the waiting object of the <b>SignalObjectAndWait</b> call. In some circumstances, the caller of <b>SignalObjectAndWait</b> can't receive signal state of the waiting object in time, causing a deadlock.</para>
      <para>Use caution when using the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and COM <b>CoInitialize</b>. Therefore, if you have a thread that creates windows, be sure to call <b>SignalObjectAndWait</b> from a different thread. If this is not possible, you can use
<see cref="MsgWaitForMultipleObjects" /> or
<see cref="MsgWaitForMultipleObjectsEx" />, but the functionality is not equivalent.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="MsgWaitForMultipleObjects" />
    <seealso cref="MsgWaitForMultipleObjectsEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">Wait Functions</seealso>
  </member>
  <member name="Windows.Sleep">
    <summary>
      <para>Suspends the execution of the current thread until the time-out interval elapses.</para>
      <para>To enter an alertable wait state, use the
<see cref="SleepEx" /> function.</para>
    </summary>
    <param name="dwMilliseconds">
      <para>The time interval for which execution is to be suspended, in milliseconds.</para>
      <para>A value of zero causes the thread to relinquish the remainder of its time slice to any other thread  that is ready to run. If there are no other threads ready to run, the function returns immediately, and the thread continues execution. <b>Windows XP:</b> A value of zero causes the thread to relinquish the remainder of its time slice to any other thread of equal priority that is ready to run. If there are no other threads of equal priority ready to run, the function returns immediately, and the thread continues execution. This behavior changed starting with Windows Server 2003.</para>
      <para>A value of INFINITE indicates that the suspension should not time out.</para>
    </param>
    <remarks>
      <para>This function causes a thread to relinquish the remainder of its time slice and become unrunnable for an interval based on the value of <i>dwMilliseconds</i>. The system clock "ticks" at a constant rate. If <i>dwMilliseconds</i> is less than the resolution of the system clock, the thread may sleep for less than the specified length of time. If <i>dwMilliseconds</i> is greater than one tick but less than two, the wait can be anywhere between one and two ticks, and so on. To increase the accuracy of the sleep interval, call the <b>timeGetDevCaps</b> function to determine the supported minimum timer resolution and the <b>timeBeginPeriod</b> function to set the timer resolution to its minimum. Use caution when calling <b>timeBeginPeriod</b>, as frequent calls can significantly affect the system clock, system power usage, and the scheduler. If you call <b>timeBeginPeriod</b>, call it one time early in the application and be sure to call the <b>timeEndPeriod</b> function at the very end of the application.</para>
      <para>After the sleep interval has passed, the thread is ready to run. If you specify 0 milliseconds, the thread will relinquish the remainder of its time slice but remain ready. Note that a ready thread is not guaranteed to run immediately. Consequently, the thread may not run until some time after the sleep interval elapses. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>.</para>
      <para>Be careful when using <b>Sleep</b> in the following scenarios:</para>
      <list type="bullet">
        <item>
          <description>Code  that directly or indirectly creates windows (for example, DDE and COM <b>CoInitialize</b>). If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. If you have a thread that uses
<b>Sleep</b> with infinite delay, the system will deadlock. </description>
        </item>
        <item>
          <description>Threads that are under concurrency control. For example, an I/O completion port or thread pool limits the number of associated threads that can run. If the maximum number of threads is already running, no additional associated thread can run until a running thread finishes. If a thread uses <b>Sleep</b> with an interval of zero to wait for one of the additional associated threads to accomplish some work,  the process might deadlock. </description>
        </item>
      </list>
      <para>For these scenarios, use
<see cref="MsgWaitForMultipleObjects" /> or
<see cref="MsgWaitForMultipleObjectsEx" />, rather than
<b>Sleep</b>.</para>
      <para>
        <b>Windows Phone 8.1:</b> This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later.</para>
      <para>
        <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-thread-local-storage">Using Thread Local Storage</a>.</para>
    </remarks>
    <seealso cref="MsgWaitForMultipleObjects" />
    <seealso cref="MsgWaitForMultipleObjectsEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="SleepEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/suspending-thread-execution">Suspending Thread Execution</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
    <seealso cref="WaitOnAddress" />
  </member>
  <member name="Windows.SleepConditionVariableCS">
    <summary>
      <para>Sleeps on the specified condition variable and releases the specified critical section as an atomic operation.</para>
    </summary>
    <param name="ConditionVariable">
      <para>A pointer to the condition variable. This variable must be initialized using the <see cref="InitializeConditionVariable" /> function.</para>
    </param>
    <param name="CriticalSection">
      <para>A pointer to the critical section object. This critical section must be entered exactly once by the caller at the time <b>SleepConditionVariableCS</b> is called.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. If the time-out interval elapses, the function re-acquires the critical section and returns zero. If <i>dwMilliseconds</i> is zero, the function tests the states of the specified objects and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails or the time-out interval elapses, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include <b>ERROR_TIMEOUT</b>, which indicates that the time-out interval has elapsed before another thread has attempted to wake the sleeping thread.</para>
    </returns>
    <remarks>
      <para>A thread that is sleeping on a condition variable can be woken before the specified time-out interval has elapsed  using the <see cref="WakeConditionVariable" /> or <see cref="WakeAllConditionVariable" /> function. In this case, the thread wakes when the wake processing is complete, and not when its time-out interval elapses. After the thread is woken, it re-acquires the critical section it released when the thread entered the sleeping state.</para>
      <para>Condition variables are subject to spurious wakeups (those not associated with an explicit wake) and stolen wakeups (another thread manages to run before the woken thread). Therefore, you should recheck a predicate (typically in a <b>while</b> loop) after a sleep operation returns.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/Sync/using-condition-variables">Using Condition Variables</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/condition-variables">Condition Variables</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.SleepConditionVariableSRW">
    <summary>
      <para>Sleeps on the specified condition variable and releases the specified lock as an atomic operation.</para>
    </summary>
    <param name="ConditionVariable">
      <para>A pointer to the condition variable. This variable must be initialized using the <see cref="InitializeConditionVariable" /> function.</para>
    </param>
    <param name="SRWLock">
      <para>A pointer to the lock. This lock must be held in the manner specified by the <i>Flags</i> parameter.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. The function returns if the interval elapses. If <i>dwMilliseconds</i> is zero, the function tests the states of the specified objects and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses.</para>
    </param>
    <param name="Flags">
      <para>If this parameter is <b>CONDITION_VARIABLE_LOCKMODE_SHARED</b>, the SRW lock is in shared mode. Otherwise, the lock is in exclusive mode.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the timeout expires the function returns FALSE and <see cref="GetLastError" /> returns ERROR_TIMEOUT.</para>
    </returns>
    <remarks>
      <para>If the lock is unlocked when this function is called, the function behavior is undefined.</para>
      <para>The thread can be woken using the <see cref="WakeConditionVariable" /> or <see cref="WakeAllConditionVariable" /> function. After the thread is woken, it re-acquires the lock it released when the thread entered the sleeping state.</para>
      <para>Condition variables are subject to spurious wakeups (those not associated with an explicit wake) and stolen wakeups (another thread manages to run before the woken thread). Therefore, you should recheck a predicate (typically in a <b>while</b> loop) after a sleep operation returns.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/slim-reader-writer--srw--locks">Slim Reader/Writer (SRW) Locks</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.SleepEx">
    <summary>
      <para>Suspends the current thread until the specified condition is met. Execution resumes when one of the following occurs:</para>
      <list type="bullet">
        <item>
          <description>An I/O completion callback function is called.</description>
        </item>
        <item>
          <description>An asynchronous procedure call (APC) is queued to the thread.</description>
        </item>
        <item>
          <description>The time-out interval elapses.</description>
        </item>
      </list>
    </summary>
    <param name="dwMilliseconds">
      <para>The time interval for which execution is to be suspended, in milliseconds.</para>
      <para>A value of zero, together with the bAlertable parameter set to FALSE, causes the thread to relinquish the remainder of its time slice to any other thread that is ready to run, if there are no pending user APCs on the calling thread. If there are no other threads ready to run and no user APCs are queued, the function returns immediately, and the thread continues execution.<b>Windows XP: </b>A value of zero causes the thread to relinquish the remainder of its time slice to any other thread of equal priority that is ready to run. If there are no other threads of equal priority ready to run, the function returns immediately, and the thread continues execution. This behavior changed starting with Windows Server 2003.</para>
      <para>A value of INFINITE indicates that the suspension should not time out.</para>
    </param>
    <param name="bAlertable">
      <para>If this parameter is FALSE, the function does not return until the time-out period has elapsed. If an I/O completion callback occurs, the function does not return and the I/O completion function is not executed. If an APC is queued to the thread, the function does not return and the APC function is not executed.</para>
      <para>If the parameter is TRUE and the thread that called this function is the same thread that called the extended I/O function (<see cref="ReadFileEx" /> or
<see cref="WriteFileEx" />), the function returns when either the time-out period has elapsed or when an I/O completion callback function occurs. If an I/O completion callback occurs, the I/O completion function is called. If an APC is queued to the thread (<see cref="QueueUserAPC" />), the function returns when either the timer-out period has elapsed or when the APC function is called.</para>
    </param>
    <returns>
      <para>The return value is zero if the specified time interval expired.</para>
      <para>The return value is <b>WAIT_IO_COMPLETION</b> if the function returned due to one or more I/O completion callback functions. This can happen only if <i>bAlertable</i> is TRUE, and if the thread that called the
<b>SleepEx</b> function is the same thread that called the extended I/O function.</para>
    </returns>
    <remarks>
      <para>This function causes a thread to relinquish the remainder of its time slice and become unrunnable for an interval based on the value of <i>dwMilliseconds</i>. After the sleep interval has passed, the thread is ready to run. Note that a ready thread is not guaranteed to run immediately. Consequently, the thread will not run until some arbitrary time after the sleep interval elapses, based upon the system "tick" frequency and the load factor from other processes. The system clock "ticks" at a constant rate. To increase the accuracy of the sleep interval, call the <b>timeGetDevCaps</b> function to determine the supported minimum timer resolution and the <b>timeBeginPeriod</b> function to set the timer resolution to its minimum. Use caution when calling <b>timeBeginPeriod</b>, as frequent calls can significantly affect the system clock, system power usage, and the scheduler. If you call <b>timeBeginPeriod</b>, call it one time early in the application and be sure to call the <b>timeEndPeriod</b> function at the very end of the application. If you specify 0 milliseconds, the thread will relinquish the remainder of its time slice but remain ready. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>.</para>
      <para>This function can be used with the <see cref="ReadFileEx" /> or <see cref="WriteFileEx" /> functions to suspend a thread until an I/O operation has been completed. These functions specify a completion routine that is to be executed when the I/O operation has been completed. For the completion routine to be executed, the thread that called the I/O function must be in an alertable wait state when the completion callback function occurs. A thread goes into an alertable wait state by calling either
<b>SleepEx</b>,
<see cref="MsgWaitForMultipleObjectsEx" />,
<see cref="WaitForSingleObjectEx" />, or
<see cref="WaitForMultipleObjectsEx" />, with the function's <i>bAlertable</i> parameter set to TRUE.</para>
      <para>Be careful when using <b>SleepEx</b> in the following scenarios:</para>
      <list type="bullet">
        <item>
          <description>Code  that directly or indirectly creates windows (for example, DDE and COM <b>CoInitialize</b>). If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. If you have a thread that uses
<b>SleepEx</b> with infinite delay, the system will deadlock. </description>
        </item>
        <item>
          <description>Threads that are under concurrency control. For example, an I/O completion port or thread pool limits the number of associated threads that can run. If the maximum number of threads is already running, no additional associated thread can run until a running thread finishes. If a thread uses <b>SleepEx</b> with an interval of zero to wait for one of the additional associated threads to accomplish some work,  the process might deadlock. </description>
        </item>
      </list>
      <para>For these scenarios, use
<see cref="MsgWaitForMultipleObjects" /> or
<see cref="MsgWaitForMultipleObjectsEx" />, rather than
<b>SleepEx</b>.</para>
      <para>
        <b>Windows Phone 8.1:</b> This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later.</para>
      <para>
        <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.</para>
    </remarks>
    <seealso cref="MsgWaitForMultipleObjects" />
    <seealso cref="MsgWaitForMultipleObjectsEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="QueueUserAPC" />
    <seealso cref="ReadFileEx" />
    <seealso cref="Sleep" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/suspending-thread-execution">Suspending Thread Execution</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
    <seealso cref="WaitForMultipleObjectsEx" />
    <seealso cref="WaitForSingleObjectEx" />
    <seealso cref="WaitOnAddress" />
    <seealso cref="WriteFileEx" />
  </member>
  <member name="Windows.TryAcquireSRWLockExclusive">
    <summary>
      <para>Attempts to acquire a slim reader/writer (SRW) lock in exclusive mode. If the call is successful, the calling thread takes ownership of the lock.</para>
    </summary>
    <param name="SRWLock">
      <para>A pointer to the SRW lock.</para>
    </param>
    <returns>
      <para>If the lock is successfully acquired, the return value is nonzero.</para>
      <para>if the current thread could not acquire the lock, the return value is zero.</para>
    </returns>
    <seealso cref="AcquireSRWLockExclusive" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/slim-reader-writer--srw--locks">Slim Reader/Writer (SRW) Locks</seealso>
    <seealso cref="TryAcquireSRWLockShared" />
  </member>
  <member name="Windows.RtlTryAcquireSRWLockShared">
    <summary>
      <para>Attempts to acquire a slim reader/writer (SRW) lock in shared mode. If the call is successful, the calling thread takes ownership of the lock.</para>
    </summary>
    <param name="SRWLock">
      <para>A pointer to the SRW lock.</para>
    </param>
    <returns>
      <para>If the lock is successfully acquired, the return value is nonzero.</para>
      <para>if the current thread could not acquire the lock, the return value is zero.</para>
    </returns>
    <seealso cref="AcquireSRWLockShared" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/slim-reader-writer--srw--locks">Slim Reader/Writer (SRW) Locks</seealso>
    <seealso cref="TryAcquireSRWLockExclusive" />
  </member>
  <member name="Windows.TryAcquireSRWLockShared">
    <summary>
      <para>Attempts to acquire a slim reader/writer (SRW) lock in shared mode. If the call is successful, the calling thread takes ownership of the lock.</para>
    </summary>
    <param name="SRWLock">
      <para>A pointer to the SRW lock.</para>
    </param>
    <returns>
      <para>If the lock is successfully acquired, the return value is nonzero.</para>
      <para>if the current thread could not acquire the lock, the return value is zero.</para>
    </returns>
    <seealso cref="AcquireSRWLockShared" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/slim-reader-writer--srw--locks">Slim Reader/Writer (SRW) Locks</seealso>
    <seealso cref="TryAcquireSRWLockExclusive" />
  </member>
  <member name="Windows.TryEnterCriticalSection">
    <summary>
      <para>Attempts to enter a critical section without blocking. If the call is successful, the calling thread takes ownership of the critical section.</para>
    </summary>
    <param name="lpCriticalSection">
      <para>A pointer to the critical section object.</para>
    </param>
    <returns>
      <para>If the critical section is successfully entered or the current thread already owns the critical section, the return value is nonzero.</para>
      <para>If another thread already owns the critical section, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The threads of a single process can use a critical section object for mutual-exclusion synchronization. The process is responsible for allocating the memory used by a critical section object, which it can do by declaring a variable of type <b>CRITICAL_SECTION</b>. Before using a critical section, some thread of the process must call the
<see cref="InitializeCriticalSection" /> or
<see cref="InitializeCriticalSectionAndSpinCount" /> function to initialize the object.</para>
      <para>To enable mutually exclusive use of a shared resource, each thread calls the
<see cref="EnterCriticalSection" /> or
<b>TryEnterCriticalSection</b> function to request ownership of the critical section before executing any section of code that uses the protected resource. The difference is that
<b>TryEnterCriticalSection</b> returns immediately, regardless of whether it obtained ownership of the critical section, while
<b>EnterCriticalSection</b> blocks until the thread can take ownership of the critical section. When it has finished executing the protected code, the thread uses the
<see cref="LeaveCriticalSection" /> function to relinquish ownership, enabling another thread to become the owner and gain access to the protected resource. The thread must call
<b>LeaveCriticalSection</b> once for each time that it entered the critical section.</para>
      <para>Any thread of the process can use the
<see cref="DeleteCriticalSection" /> function to release the system resources that were allocated when the critical section object was initialized. After this function has been called, the critical section object can no longer be used for synchronization.</para>
      <para>If a thread terminates while it has ownership of a critical section, the state of the critical section is undefined.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/critical-section-objects">Critical Section Objects</seealso>
    <seealso cref="DeleteCriticalSection" />
    <seealso cref="EnterCriticalSection" />
    <seealso cref="InitializeCriticalSection" />
    <seealso cref="InitializeCriticalSectionAndSpinCount" />
    <seealso cref="LeaveCriticalSection" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.WaitForMultipleObjects">
    <summary>
      <para>Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses.</para>
      <para>To enter an alertable wait state, use the
<see cref="WaitForMultipleObjectsEx" /> function.</para>
    </summary>
    <param name="nCount">
      <para>The number of object handles in the array pointed to by <i>lpHandles</i>. The maximum number of object handles is <b>MAXIMUM_WAIT_OBJECTS</b>. This parameter cannot be zero.</para>
    </param>
    <param name="lpHandles">
      <para>An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles to objects of different types. It may not contain multiple copies of the same handle.</para>
      <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
      <para>The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
    </param>
    <param name="bWaitAll">
      <para>If this parameter is <b>TRUE</b>, the function returns when the state of all objects in the <i>lpHandles</i> array is signaled. If <b>FALSE</b>, the function returns when the state of any one of the objects is set to signaled. In the latter case, the return value indicates the object whose state caused the function to return.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the specified objects are not signaled; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the specified objects are signaled.</para>
      <para>
        <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
      <para>
        <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined as 0x00000080L.)</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>WAIT_OBJECT_0</b> to (<b>WAIT_OBJECT_0</b> + <i>nCount</i>– 1)</para>
          </description>
          <description>
            <para>If <i>bWaitAll</i> is <b>TRUE</b>, a return value within the specified range indicates that the state of all specified objects is signaled.</para>
            <para>If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_OBJECT_0</b> indicates the <i>lpHandles</i> array index of the object that satisfied the wait. If more than one object became signaled during the call, this is the array index of the signaled object with the smallest index value of all the signaled objects.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>WAIT_ABANDONED_0</b> to (<b>WAIT_ABANDONED_0</b> + <i>nCount</i>– 1)</para>
          </description>
          <description>
            <para>If <i>bWaitAll</i> is <b>TRUE</b>, a return value within the specified range indicates that the state of all specified objects is signaled and at least one of the objects is an abandoned mutex object.</para>
            <para>If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <see cref="WAIT_ABANDONED_0" /> indicates the <i>lpHandles</i> array index of an abandoned mutex object that satisfied the wait. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.</para>
            <para>If a mutex was protecting persistent state information, you should check it for consistency.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_TIMEOUT</b>
                </description>
              </item>
              <item>
                <description>0x00000102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The time-out interval elapsed and the conditions specified by the <i>bWaitAll</i> parameter are not satisfied.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_FAILED</b>
                </description>
              </item>
              <item>
                <description>(<b>DWORD</b>)0xFFFFFFFF</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function has failed. To get extended error information, call
<see cref="GetLastError" />.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>WaitForMultipleObjects</b> function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses.</para>
      <para>When <i>bWaitAll</i> is <b>TRUE</b>, the function's wait operation is completed only when the states of all objects have been set to signaled. The function does not modify the states of the specified objects until the states of all objects have been set to signaled. For example, a mutex can be signaled, but the thread does not get ownership until the states of the other objects are also set to signaled. In the meantime, some other thread may get ownership of the mutex, thereby setting its state to nonsignaled.</para>
      <para>When <i>bWaitAll</i> is <b>FALSE</b>, this function checks the handles in the array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled.</para>
      <para>The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one. For more information, see the documentation for the individual synchronization objects.</para>
      <para>To wait on more than <b>MAXIMUM_WAIT_OBJECTS</b> handles, use one of the following methods:</para>
      <list type="bullet">
        <item>
          <description>Create a thread to wait on <b>MAXIMUM_WAIT_OBJECTS</b> handles, then wait on that thread plus the other handles. Use this technique to break the handles into groups of <b>MAXIMUM_WAIT_OBJECTS</b>.</description>
        </item>
        <item>
          <description>Call <see cref="RegisterWaitForSingleObject" /> to wait on each handle. A wait thread from the thread pool waits on <b>MAXIMUM_WAIT_OBJECTS</b> registered objects and assigns a worker thread after the object is signaled or the time-out interval expires.</description>
        </item>
      </list>
      <para>The
<b>WaitForMultipleObjects</b> function can specify handles of any of the following object types in the <i>lpHandles</i> array:</para>
      <list type="bullet">
        <item>
          <description>Change notification</description>
        </item>
        <item>
          <description>Console input</description>
        </item>
        <item>
          <description>Event</description>
        </item>
        <item>
          <description>Memory resource notification</description>
        </item>
        <item>
          <description>Mutex</description>
        </item>
        <item>
          <description>Process</description>
        </item>
        <item>
          <description>Semaphore</description>
        </item>
        <item>
          <description>Thread</description>
        </item>
        <item>
          <description>Waitable timer</description>
        </item>
      </list>
      <para>Use caution when calling the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and the <see cref="CoInitialize" /> function. Therefore, if you have a thread that creates windows, use
<see cref="MsgWaitForMultipleObjects" /> or
<see cref="MsgWaitForMultipleObjectsEx" />, rather than
<b>WaitForMultipleObjects</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/waiting-for-multiple-objects">Waiting for Multiple Objects</a>.</para>
    </remarks>
    <seealso cref="WAIT_ABANDONED_0" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">Wait Functions</seealso>
  </member>
  <member name="Windows.WaitForMultipleObjectsEx">
    <summary>
      <para>Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses.</para>
    </summary>
    <param name="nCount">
      <para>The number of object handles to wait for in the array pointed to by <i>lpHandles</i>. The maximum number of object handles is <b>MAXIMUM_WAIT_OBJECTS</b>. This parameter cannot be zero.</para>
    </param>
    <param name="lpHandles">
      <para>An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle.</para>
      <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
      <para>The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
    </param>
    <param name="bWaitAll">
      <para>If this parameter is <b>TRUE</b>, the function returns when the state of all objects in the <i>lpHandles</i> array is set to signaled. If <b>FALSE</b>, the function returns when the state of any one of the objects is set to signaled. In the latter case, the return value indicates the object whose state caused the function to return.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled, an I/O completion routine or APC is queued, or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the specified objects are signaled or an I/O completion routine or APC is queued.</para>
      <para>
        <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
      <para>
        <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
    </param>
    <param name="bAlertable">
      <para>If this parameter is <b>TRUE</b> and the thread is in the waiting state, the function returns when the system queues an I/O completion routine or APC, and the thread runs the routine or function. Otherwise, the function does not return and the completion routine or APC function is not executed.</para>
      <para>A completion routine is queued when the
<see cref="ReadFileEx" /> or
<see cref="WriteFileEx" /> function in which it was specified has completed. The wait function returns and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b> and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call
<see cref="QueueUserAPC" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined as 0x00000080L.)</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>WAIT_OBJECT_0</b> to (<b>WAIT_OBJECT_0</b> + <i>nCount</i>– 1)</para>
          </description>
          <description>
            <para>If <i>bWaitAll</i> is <b>TRUE</b>, a return value in this range indicates that the state of all specified objects is signaled.</para>
            <para>If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_OBJECT_0</b> indicates the <i>lpHandles</i> array index of the object that satisfied the wait. If more than one object became signaled during the call, this is the array index of the signaled object with the smallest index value of all the signaled objects.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>WAIT_ABANDONED_0</b> to (<b>WAIT_ABANDONED_0</b> + <i>nCount</i>– 1)</para>
          </description>
          <description>
            <para>If <i>bWaitAll</i> is <b>TRUE</b>, a return value in this range indicates that the state of all specified objects is signaled, and at least one of the objects is an abandoned mutex object.</para>
            <para>If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_ABANDONED_0</b> indicates the <i>lpHandles</i> array index of an abandoned mutex object that satisfied the wait. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.</para>
            <para>If a mutex was protecting persistent state information, you should check it for consistency.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_IO_COMPLETION</b>
                </description>
              </item>
              <item>
                <description>0x000000C0L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The wait was ended by one or more user-mode
<a href="https://docs.microsoft.com//windows/desktop/Sync/asynchronous-procedure-calls">asynchronous procedure calls</a> (APC) queued to the thread.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_TIMEOUT</b>
                </description>
              </item>
              <item>
                <description>0x00000102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The time-out interval elapsed, the conditions specified by the <i>bWaitAll</i> parameter were not satisfied, and no completion routines are queued.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_FAILED</b>
                </description>
              </item>
              <item>
                <description>(<b>DWORD</b>)0xFFFFFFFF</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function has failed. To get extended error information, call
<see cref="GetLastError" />.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>WaitForMultipleObjectsEx</b> function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses.</para>
      <para>When <i>bWaitAll</i> is <b>TRUE</b>, the function's wait operation is completed only when the states of all objects have been set to signaled. The function does not modify the states of the specified objects until the states of all objects have been set to signaled. For example, a mutex can be signaled, but the thread does not get ownership until the states of the other objects are also set to signaled. In the meantime, some other thread may get ownership of the mutex, thereby setting its state to nonsignaled.</para>
      <para>When <i>bWaitAll</i> is <b>FALSE</b>, this function checks the handles in the array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled.</para>
      <para>The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one. For more information, see the documentation for the individual synchronization objects.</para>
      <para>To wait on more than <b>MAXIMUM_WAIT_OBJECTS</b> handles, use one of the following methods:</para>
      <list type="bullet">
        <item>
          <description>Create a thread to wait on <b>MAXIMUM_WAIT_OBJECTS</b> handles, then wait on that thread plus the other handles. Use this technique to break the handles into groups of <b>MAXIMUM_WAIT_OBJECTS</b>.</description>
        </item>
        <item>
          <description>Call <see cref="RegisterWaitForSingleObject" /> to wait on each handle. A wait thread from the thread pool waits on <b>MAXIMUM_WAIT_OBJECTS</b> registered objects and assigns a worker thread after the object is signaled or the time-out interval expires.</description>
        </item>
      </list>
      <para>The
<b>WaitForMultipleObjectsEx</b> function can specify handles of any of the following object types in the <i>lpHandles</i> array:</para>
      <list type="bullet">
        <item>
          <description>Change notification</description>
        </item>
        <item>
          <description>Console input</description>
        </item>
        <item>
          <description>Event</description>
        </item>
        <item>
          <description>Memory resource notification</description>
        </item>
        <item>
          <description>Mutex</description>
        </item>
        <item>
          <description>Process</description>
        </item>
        <item>
          <description>Semaphore</description>
        </item>
        <item>
          <description>Thread</description>
        </item>
        <item>
          <description>Waitable timer</description>
        </item>
      </list>
      <para>Use caution when calling the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and the <see cref="CoInitialize" /> function. Therefore, if you have a thread that creates windows, use
<see cref="MsgWaitForMultipleObjects" /> or
<see cref="MsgWaitForMultipleObjectsEx" />, rather than
<b>WaitForMultipleObjectsEx</b>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">Wait Functions</seealso>
  </member>
  <member name="Windows.WaitForSingleObject">
    <summary>
      <para>Waits until the specified object is in the signaled state or the time-out interval elapses.</para>
      <para>To enter an alertable wait state, use the
<see cref="WaitForSingleObjectEx" /> function. To wait for multiple objects, use
<see cref="WaitForMultipleObjects" />.</para>
    </summary>
    <param name="hHandle">
      <para>A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.</para>
      <para>If this handle is closed while the wait is still pending, the function's behavior is undefined.</para>
      <para>The handle must have the <b>SYNCHRONIZE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the object is signaled.</para>
      <para>
        <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
      <para>
        <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_ABANDONED</b>
                </description>
              </item>
              <item>
                <description>0x00000080L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled.</para>
            <para>If the mutex was protecting persistent state information, you should check it for consistency.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_OBJECT_0</b>
                </description>
              </item>
              <item>
                <description>0x00000000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The state of the specified object is signaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_TIMEOUT</b>
                </description>
              </item>
              <item>
                <description>0x00000102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The time-out interval elapsed, and the object's state is nonsignaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_FAILED</b>
                </description>
              </item>
              <item>
                <description>(DWORD)0xFFFFFFFF</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function has failed. To get extended error information, call
<see cref="GetLastError" />.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>WaitForSingleObject</b> function checks the current state of the specified object. If the object's state is nonsignaled, the calling thread enters the wait state until the object is signaled or the time-out interval elapses.</para>
      <para>The function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one.</para>
      <para>The
<b>WaitForSingleObject</b> function can wait for the following objects:</para>
      <list type="bullet">
        <item>
          <description>Change notification</description>
        </item>
        <item>
          <description>Console input</description>
        </item>
        <item>
          <description>Event</description>
        </item>
        <item>
          <description>Memory resource notification</description>
        </item>
        <item>
          <description>Mutex</description>
        </item>
        <item>
          <description>Process</description>
        </item>
        <item>
          <description>Semaphore</description>
        </item>
        <item>
          <description>Thread</description>
        </item>
        <item>
          <description>Waitable timer</description>
        </item>
      </list>
      <para>Use caution when calling the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and the <see cref="CoInitialize" /> function. Therefore, if you have a thread that creates windows, use
<see cref="MsgWaitForMultipleObjects" /> or
<see cref="MsgWaitForMultipleObjectsEx" />, rather than
<b>WaitForSingleObject</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-mutex-objects">Using Mutex Objects</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">Wait Functions</seealso>
  </member>
  <member name="Windows.WaitForSingleObjectEx">
    <summary>
      <para>Waits until the specified object is in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses.</para>
      <para>To wait for multiple objects, use the
<see cref="WaitForMultipleObjectsEx" />.</para>
    </summary>
    <param name="hHandle">
      <para>A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.</para>
      <para>If this handle is closed while the wait is still pending, the function's behavior is undefined.</para>
      <para>The handle must have the <b>SYNCHRONIZE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled, an I/O completion routine or APC is queued, or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the object is signaled or an I/O completion routine or APC is queued.</para>
      <para>
        <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.</para>
      <para>
        <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.</para>
    </param>
    <param name="bAlertable">
      <para>If this parameter is <b>TRUE</b> and the thread is in the waiting state, the function returns when the system queues an I/O completion routine or APC, and the thread runs the routine or function. Otherwise, the function does not return, and the completion routine or APC function is not executed.</para>
      <para>A completion routine is queued when the
<see cref="ReadFileEx" /> or
<see cref="WriteFileEx" /> function in which it was specified has completed. The wait function returns and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b>, and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call
<see cref="QueueUserAPC" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_ABANDONED</b>
                </description>
              </item>
              <item>
                <description>0x00000080L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread and the mutex is set to nonsignaled.</para>
            <para>If the mutex was protecting persistent state information, you should check it for consistency.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_IO_COMPLETION</b>
                </description>
              </item>
              <item>
                <description>0x000000C0L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The wait was ended by one or more user-mode
<a href="https://docs.microsoft.com//windows/desktop/Sync/asynchronous-procedure-calls">asynchronous procedure calls</a> (APC) queued to the thread.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_OBJECT_0</b>
                </description>
              </item>
              <item>
                <description>0x00000000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The state of the specified object is signaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_TIMEOUT</b>
                </description>
              </item>
              <item>
                <description>0x00000102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The time-out interval elapsed, and the object's state is nonsignaled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WAIT_FAILED</b>
                </description>
              </item>
              <item>
                <description>(<b>DWORD</b>)0xFFFFFFFF</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function has failed. To get extended error information, call
<see cref="GetLastError" />.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>WaitForSingleObjectEx</b> function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses.</para>
      <para>The function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one.</para>
      <para>The
<b>WaitForSingleObjectEx</b> function can wait for the following objects:</para>
      <list type="bullet">
        <item>
          <description>Change notification</description>
        </item>
        <item>
          <description>Console input</description>
        </item>
        <item>
          <description>Event</description>
        </item>
        <item>
          <description>Memory resource notification</description>
        </item>
        <item>
          <description>Mutex</description>
        </item>
        <item>
          <description>Process</description>
        </item>
        <item>
          <description>Semaphore</description>
        </item>
        <item>
          <description>Thread</description>
        </item>
        <item>
          <description>Waitable timer</description>
        </item>
      </list>
      <para>Use caution when calling the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and the <see cref="CoInitialize" /> function. Therefore, if you have a thread that creates windows, use
<see cref="MsgWaitForMultipleObjects" /> or
<see cref="MsgWaitForMultipleObjectsEx" />, rather than
<b>WaitForSingleObjectEx</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/named-pipe-server-using-completion-routines">Named Pipe Server Using Completion Routines</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">Wait Functions</seealso>
  </member>
  <member name="Windows.WakeAllConditionVariable">
    <summary>
      <para>Wake all threads waiting on the specified condition variable.</para>
    </summary>
    <param name="ConditionVariable">
      <para>A pointer to the condition variable.</para>
    </param>
    <remarks>
      <para>The <b>WakeAllConditionVariable</b> wakes all
waiting threads while the <see cref="WakeConditionVariable" /></para>
      <para>wakes only a single thread. Waking one thread is similar to setting an auto-reset event, while waking all threads
is similar to pulsing a manual reset event but more reliable (see
<see cref="PulseEvent" /> for details).</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/condition-variables">Condition Variables</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.WakeByAddressAll">
    <summary>
      <para>Wakes all threads that are waiting for the value of an address to change.</para>
    </summary>
    <param name="Address">
      <para>The address to signal. If any threads have previously called
<see cref="WaitOnAddress" /> for this address, the system wakes all
of the waiting threads.</para>
    </param>
    <remarks>
      <para>Windows Store apps developers may need to obtain synchronization.lib by installing the <a href="https://developer.microsoft.com/en-us/windows/downloads/windows-8-sdk">Windows Software Development Kit (SDK) for Windows 8</a>.</para>
      <para>Only threads within the same process can be woken.</para>
    </remarks>
    <seealso cref="WaitOnAddress" />
  </member>
  <member name="Windows.WakeByAddressSingle">
    <summary>
      <para>Wakes one thread that is waiting for the value of an address to change.</para>
    </summary>
    <param name="Address">
      <para>The address to signal. If another thread has previously called
<see cref="WaitOnAddress" /> for this address, the system wakes the
waiting thread. If multiple threads are waiting for this address, the system wakes the first thread to
wait.</para>
    </param>
    <remarks>
      <para>Windows Store apps developers may need to obtain synchronization.lib by installing the <a href="https://developer.microsoft.com/en-us/windows/downloads/windows-8-sdk">Windows Software Development Kit (SDK) for Windows 8</a>.</para>
      <para>Only a thread within the same process can be woken.</para>
    </remarks>
    <seealso cref="WaitOnAddress" />
  </member>
  <member name="Windows.WakeConditionVariable">
    <summary>
      <para>Wake a single thread waiting on the specified condition variable.</para>
    </summary>
    <param name="ConditionVariable">
      <para>A pointer to the condition variable.</para>
    </param>
    <remarks>
      <para>The <see cref="WakeAllConditionVariable" /> wakes all waiting threads while the <b>WakeConditionVariable</b> wakes only a single thread. Waking one thread is similar to setting an auto-reset event, while waking all threads is similar to pulsing a manual reset event but more reliable (see <see cref="PulseEvent" /> for details).</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/Sync/using-condition-variables">Using Condition Variables</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/condition-variables">Condition Variables</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
</doc>