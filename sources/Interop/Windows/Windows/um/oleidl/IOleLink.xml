<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="IOleLink.BindIfRunning">
    <summary>
      <para>Activates the connection between the linked object and the link source if the link source is already running.</para>
    </summary>
    <returns>
      <para>This method returns S_OK on success. Other possible return values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>The link source is not running.</para>
          </description>
        </item>
      </list>
      <para>Binding the moniker might require calling <see cref="CreateBindCtx" />, <see cref="IMoniker.IsRunning" />, or <see cref="IOleLink.BindToSource" />; therefore, errors generated by these functions can also be returned.</para>
    </returns>
    <remarks>
      <para>You typically do not need to call <b>IOleLink.BindIfRunning</b>. This method is primarily called by the linked object.</para>
      <h3>Notes to Implementers</h3>
      <para>The linked object's implementation of <b>IOleLink.BindIfRunning</b> checks the running object table (ROT) to determine whether the link source is already running. It checks both the relative and absolute monikers. If the link source is running, <b>IOleLink.BindIfRunning</b> calls <see cref="IOleLink.BindToSource" /> to connect the linked object to the link source.</para>
    </remarks>
    <seealso cref="IOleLink" />
    <seealso cref="IOleLink.BindToSource" />
  </member>
  <member name="IOleLink.BindToSource">
    <summary>
      <para>Activates the connection to the link source by binding the moniker stored within the linked object.</para>
    </summary>
    <param name="bindflags">
      <para>Specifies how to proceed if the link source has a different CLSID from the last time it was bound. If this parameter is zero and the CLSIDs are different, the method fails and returns OLE_E_CLASSDIFF. If the OLELINKBIND_EVENIFCLASSDIFF value from the <see cref="OLELINKBIND" /> enumeration is specified and the CLSIDs are different, the method binds successfully and updates the CLSID stored in the linked object.</para>
    </param>
    <param name="pbc">
      <para>A pointer to the <see cref="IBindCtx" /> interface on the bind context to be used in this binding operation. This parameter can be <b>NULL</b>. The bind context caches objects bound during the binding process, contains parameters that apply to all operations using the bind context, and provides the means by which the binding implementation should retrieve information about its environment. For more information, see <b>IBindCtx</b>.</para>
    </param>
    <returns>
      <para>This method returns S_OK on success. Other possible return values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>OLE_E_CLASSDIFF</b>
            </para>
          </description>
          <description>
            <para>The link source was not bound because its CLSID has changed. This error is returned only if the OLELINKBIND_EVENIFCLASSDIFF flag is not specified in the <i>bindflags</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>MK_E_NOOBJECT</b>
            </para>
          </description>
          <description>
            <para>The link source could not be found or (if the link source's moniker is a composite) some intermediate object identified in the composite could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_UNSPEC</b>
            </para>
          </description>
          <description>
            <para>The link's moniker is <b>NULL</b>.</para>
          </description>
        </item>
      </list>
      <para>Binding the moniker might require calling the <see cref="CreateBindCtx" /> function; therefore, this method may return errors generated by <b>CreateBindCtx</b>.</para>
    </returns>
    <remarks>
      <h3>Notes to Callers</h3>
      <para>Typically, your container application does not need to call the <b>IOleLink.BindToSource</b> method directly. When it's necessary to activate the connection to the link source, your container typically calls <see cref="IOleObject.DoVerb" />, <see cref="IOleObject.Update" />, or <see cref="IOleLink.Update" />. The linked object's implementation of these methods calls <b>IOleLink.BindToSource</b>. Your container can also call the <see cref="OleRun" /> function, which calls <b>IOleLink.BindToSource</b> when called on a linked object.</para>
      <para>In each of the examples listed previously, in which <b>IOleLink.BindToSource</b> is called indirectly, the bindflags parameter is set to zero. Consequently, these calls can fail with the OLE_E_CLASSDIFF error if the class of the link source is different from what it was the last time the linked object was bound. This could happen, for example, if the original link source was an embedded Lotus spreadsheet that an end user had subsequently converted (using the Change Type dialog box) to an Excel spreadsheet.</para>
      <para>If you want your container to bind even though the link source now has a different CLSID, you can call <b>IOleLink.BindToSource</b> directly and specify OLELINKBIND_EVENIFCLASSDIFF for the bindflags parameter. This call binds to the link source and updates the link object's CLSID. Alternatively, your container can delete the existing link and use the <see cref="OleCreateLink" /> function to create a new linked object.</para>
      <h3>Notes to Implementers</h3>
      <para>The linked object caches the interface pointer to the link source acquired during binding.</para>
      <para>The linked object's <b>IOleLink.BindToSource</b> implementation first tries to bind using a moniker consisting of the compound document's moniker composed with the link source's relative moniker. If successful, it updates the link's absolute moniker. Otherwise, it tries to bind using the absolute moniker, updating the relative moniker if successful.</para>
      <para>If <b>IOleLink.BindToSource</b> binds to the link source, it calls the compound document's <see cref="IOleContainer.LockContainer" /> implementation to keep the containing compound document alive while the link source is running. <b>IOleLink.BindToSource</b> also calls the <see cref="IOleObject.Advise" /> and <see cref="IDataObject.DAdvise" /> implementations of the link source to set up advisory connections. The <see cref="IOleLink.UnbindSource" /> implementation unlocks the container and deletes the advisory connections.</para>
    </remarks>
    <seealso cref="IDataObject.DAdvise" />
    <seealso cref="IOleContainer.LockContainer" />
    <seealso cref="IOleLink" />
    <seealso cref="IOleLink.UnbindSource" />
    <seealso cref="IOleLink.Update" />
    <seealso cref="IOleObject.Advise" />
    <seealso cref="IOleObject.DoVerb" />
    <seealso cref="IOleObject.Update" />
    <seealso cref="OleRun" />
  </member>
  <member name="IOleLink.GetBoundSource">
    <summary>
      <para>Retrieves a pointer to the link source if the connection is active.</para>
    </summary>
    <param name="ppunk">
      <para>Address of <see cref="IDataObject" /> pointer variable that receives the interface pointer to the link source. When successful, the implementation must call <see cref="IUnknown.AddRef" /> on <i>ppunk</i>; it is the caller's responsibility to call <see cref="IUnknown.Release" />. If an error occurs, the implementation sets <i>ppunk</i> to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>This method returns S_OK on success. Other possible return values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>The operation failed.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You typically do not need to call <b>IOleLink.GetBoundSource</b>.</para>
    </remarks>
    <seealso cref="IOleLink" />
  </member>
  <member name="IOleLink.GetSourceDisplayName">
    <summary>
      <para>Retrieves the display name of the link source of the linked object.</para>
    </summary>
    <param name="ppszDisplayName">
      <para>Address of a pointer variable that receives a pointer to the display name of the link source. If an error occurs, <i>ppszDisplayName</i> is set to <b>NULL</b>; otherwise, the implementation must use <see cref="IMalloc.Alloc" /> to allocate the string returned in <i>ppszDisplayName</i>, and the caller is responsible for calling <see cref="IMalloc.Free" /> to free it. Both caller and called use the allocator returned by <see cref="CoGetMalloc" />.</para>
    </param>
    <returns>
      <para>This method returns S_OK on success. Other possible return values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>The operation failed.</para>
          </description>
        </item>
      </list>
      <para>Retrieving the display name requires calling these functions; therefore, this method may return errors generated by <see cref="CreateBindCtx" /> and <see cref="IMoniker.GetDisplayName" />.</para>
    </returns>
    <remarks>
      <h3>Notes to Callers</h3>
      <para>Your container application can call <b>IOleLink.GetSourceDisplayName</b> to display the current source of a link.</para>
      <para>The current source of a link is displayed in the <b>Links</b> dialog box. If you use the <see cref="OleUIEditLinks" /> function to display the <b>Links</b> dialog box, you must implement the <see cref="IOleUILinkContainer" /> interface. The dialog box calls your implementations of <see cref="IOleUILinkContainer.GetLinkSource" /> to get the string it should display. Your implementation of that method can call <b>IOleLink.GetSourceDisplayName</b>.</para>
      <h3>Notes to Implementers</h3>
      <para>The linked object's implementation of <b>IOleLink.GetSourceDisplayName</b> calls <see cref="IOleLink.GetSourceMoniker" /> to get the link source moniker, and then calls <see cref="IMoniker.GetDisplayName" /> to get that moniker's display name. This operation is potentially expensive because it might require binding the moniker. All of the system-provided monikers can return a display name without binding, but there is no guarantee that other moniker implementations can. Instead of making repeated calls to <b>IOleLink.GetSourceDisplayName</b>, your container application can cache the name and update it whenever the link source is bound.</para>
    </remarks>
    <seealso cref="IMoniker.GetDisplayName" />
    <seealso cref="IOleLink" />
    <seealso cref="IOleLink.SetSourceDisplayName" />
    <seealso cref="IOleUILinkContainer" />
    <seealso cref="OleUIEditLinks" />
  </member>
  <member name="IOleLink.GetSourceMoniker">
    <summary>
      <para>Retrieves the moniker identifying the link source of a linked object.</para>
    </summary>
    <param name="ppmk">
      <para>Address of an <see cref="IMoniker" /> pointer variable that receives the interface pointer to an absolute moniker that identifies the link source. When successful, the implementation must call <see cref="AddRef" /> on <i>ppmk</i>; it is the caller's responsibility to call <see cref="Release" />. If an error occurs the implementation must set <i>ppmk</i> to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>This method returns S_OK on success. Other possible return values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>MK_E_UNAVAILABLE</b>
            </para>
          </description>
          <description>
            <para>No moniker is available.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <h3>Notes to Callers</h3>
      <para>Your container application can call <b>IOleLink.GetSourceMoniker</b> to display the current source of a link in the <b>Links</b> dialog box. Note that this requires your container to use the <see cref="IMoniker.GetDisplayName" /> method to get the display name of the moniker. If you would rather get the display name directly, your container can call <see cref="IOleLink.GetSourceDisplayName" /> instead of <b>IOleLink.GetSourceMoniker</b>.</para>
      <para>If you use the <see cref="OleUIEditLinks" /> function to display the <b>Links</b> dialog box, you must implement the <see cref="IOleUILinkContainer" /> interface. The dialog box calls your implementations of <see cref="IOleUILinkContainer.GetLinkSource" /> to get the string it should display. Your implementation of that method can call <b>IOleLink.GetSourceMoniker</b>.</para>
      <h3>Notes to Implementers</h3>
      <para>The linked object stores both an absolute and a relative moniker for the link source. If the relative moniker is non-<b>NULL</b> and a moniker is available for the compound document, <b>IOleLink.GetSourceMoniker</b> returns the moniker created by composing the relative moniker onto the end of the compound document's moniker. Otherwise, it returns the absolute moniker or, if an error occurs, <b>NULL</b>.</para>
      <para>The container specifies the absolute moniker when it calls one of the <see cref="OleCreateLink" /> functions to create a link. The application can call <b>IOleLink.GetSourceMoniker</b> or <see cref="IOleLink.GetSourceDisplayName" /> to change the absolute moniker. In addition, the linked object automatically updates the monikers whenever it successfully binds to the link source, or when it is bound to the link source and it receives a rename notification through the <see cref="IAdviseSink.OnRename" /> method.</para>
    </remarks>
    <seealso cref="IOleLink" />
    <seealso cref="IOleLink.GetSourceDisplayName" />
    <seealso cref="IOleLink.GetSourceMoniker" />
  </member>
  <member name="IOleLink.GetUpdateOptions">
    <summary>
      <para>Retrieves a value indicating how often the linked object updates its cached data.</para>
    </summary>
    <param name="pdwUpdateOpt">
      <para>A pointer to a variable that receives the current value for the linked object's update option, indicating how often the linked object updates the cached data for the linked object. The possible values for <i>pdwUpdateOpt</i> are taken from the enumeration <see cref="OLEUPDATE" />.</para>
    </param>
    <returns>
      <para>This method returns S_OK on success.</para>
    </returns>
    <seealso cref="IOleLink" />
    <seealso cref="IOleLink.SetUpdateOptions" />
    <seealso cref="IOleUILinkContainer" />
    <seealso cref="OleUIEditLinks" />
  </member>
  <member name="IOleLink.SetSourceDisplayName">
    <summary>
      <para>Sets the display name for the link source.</para>
    </summary>
    <param name="pszStatusText">
      <para>A pointer to the display name of the new link source. This parameter cannot be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>This method returns S_OK on success.</para>
      <para>Values from <see cref="MkParseDisplayName" /> may also be returned here.</para>
    </returns>
    <remarks>
      <h3>Notes to Callers</h3>
      <para>Your container application can call <b>IOleLink.SetSourceDisplayName</b> when the end user changes the source of a link or breaks a link. Note that this requires the linked object to create a moniker out of the display name. If you'd rather parse the display name into a moniker yourself, your container can call <see cref="IOleLink.SetSourceMoniker" /> instead of <b>IOleLink.SetSourceDisplayName</b>.</para>
      <para>If you use the <see cref="OleUIEditLinks" /> function to display the <b>Links</b> dialog box, you must implement the <see cref="IOleUILinkContainer" /> interface. The dialog box calls your implementations of <see cref="IOleUILinkContainer.SetLinkSource" /> and <see cref="IOleUILinkContainer.CancelLink" />. Your implementation of these methods can call <b>IOleLink.SetSourceDisplayName</b>.</para>
      <para>If your container application is immediately going to bind to a newly specified link source, you should call <see cref="MkParseDisplayName" /> and <see cref="IOleLink.SetSourceMoniker" /> instead, and then call <see cref="IOleLink.BindToSource" /> using the bind context from the parsing operation. By reusing the bind context, you can avoid redundant loading of objects that might otherwise occur.</para>
      <h3>Notes to Implementers</h3>
      <para>The contract for <b>IOleLink.SetSourceDisplayName</b> does not specify when the linked object will parse the display name into a moniker. The parsing can occur before <b>IOleLink.SetSourceDisplayName</b> returns, or the linked object can store the display name and parse it only when it needs to bind to the link source. Note that parsing the display name is potentially an expensive operation because it might require binding to the link source. The provided implementation of <b>IOleLink.SetSourceDisplayName</b> parses the display name and then releases the bind context used in the parse operation. This can result in running and then stopping the link source server.</para>
      <para>If the linked object is bound to the current link source, the implementation of <b>IOleLink.SetSourceDisplayName</b> breaks the connection.</para>
      <para>For more information on how the linked object stores and uses the moniker to the link source, see <see cref="IOleLink.SetSourceMoniker" />.</para>
    </remarks>
    <seealso cref="IOleLink" />
    <seealso cref="IOleLink.SetSourceMoniker" />
    <seealso cref="IOleUILinkContainer" />
    <seealso cref="MkParseDisplayName" />
    <seealso cref="OleUIEditLinks" />
  </member>
  <member name="IOleLink.SetSourceMoniker">
    <summary>
      <para>Sets the moniker for the link source.</para>
    </summary>
    <param name="pmk">
      <para>A pointer to the <see cref="IMoniker" /> interface on a moniker that identifies the new link source of the linked object. A value of <b>NULL</b> breaks the link.</para>
    </param>
    <param name="rclsid">
      <para>The CLSID of the link source that the linked object should use to access information about the linked object when it is not bound.</para>
    </param>
    <returns>
      <para>This method returns S_OK on success.</para>
    </returns>
    <remarks>
      <h3>Notes to Callers</h3>
      <para>Your container application can call <b>IOleLink.SetSourceMoniker</b> when the end user changes the source of a link or breaks a link. Note that this requires your container to use the <see cref="MkParseDisplayName" /> function to create a moniker out of the display name that the end user enters. If you'd rather have the linked object perform the parsing, your container can call <see cref="IOleLink.SetSourceDisplayName" /> instead of <b>IOleLink.SetSourceMoniker</b>.</para>
      <para>The end user changes the source of a link or breaks a link using the <b>Links</b> dialog box. If you use the <see cref="OleUIEditLinks" /> function to display the <b>Links</b> dialog box, you must implement the <see cref="IOleUILinkContainer" /> interface. The dialog box calls your implementations of <see cref="IOleUILinkContainer.SetLinkSource" /> and <see cref="IOleUILinkContainer.CancelLink" />; your implementation of these methods can call <b>IOleLink.SetSourceMoniker</b>.</para>
      <para>If the linked object is currently bound to its link source, the linked object's implementation of <b>IOleLink.SetSourceMoniker</b> closes the link before changing the moniker.</para>
      <h3>Notes to Implementers</h3>
      <para>The <see cref="IOleLink" /> contract does not specify how the linked object stores or uses the link source moniker. The provided implementation stores the absolute moniker specified when the link is created or when the moniker is changed; it then computes and stores a relative moniker. Future implementations might manage monikers differently to provide better moniker tracking. The absolute moniker provides the complete path to the link source. The linked object uses this absolute moniker and the moniker of the compound document to compute a relative moniker that identifies the link source relative to the compound document that contains the link.</para>
      <para>pmkCompoundDoc-&gt;RelativePathTo(pmkAbsolute, ppmkRelative)</para>
      <para>When binding to the link source, the linked object first tries to bind using the relative moniker. If that fails, it tries to bind the absolute moniker.</para>
      <para>When the linked object successfully binds using either the relative or the absolute moniker, it automatically updates the other moniker. The linked object also updates both monikers when it is bound to the link source and it receives a rename notification through the <see cref="IAdviseSink.OnRename" /> method. A container application can also use the <see cref="IOleLink.SetSourceDisplayName" /> method to change a link's moniker.</para>
      <para>The linked object's implementation of <see cref="IPersistStorage.Save" /> saves both the relative and the absolute moniker.</para>
    </remarks>
    <seealso cref="IOleLink" />
    <seealso cref="IOleLink.GetSourceMoniker" />
    <seealso cref="IOleLink.SetSourceDisplayName" />
    <seealso cref="IOleUILinkContainer" />
    <seealso cref="OleUIEditLinks" />
  </member>
  <member name="IOleLink.SetUpdateOptions">
    <summary>
      <para>Specifies how often a linked object should update its cached data.</para>
    </summary>
    <param name="dwUpdateOpt">
      <para>Specifies how often a linked object should update its cached data. The possible values for <i>dwUpdateOpt</i> are taken from the enumeration <see cref="OLEUPDATE" />.</para>
    </param>
    <returns>
      <para>This method returns S_OK on success. Other possible return values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>The supplied value is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <h3>Notes to Callers</h3>
      <para>Your container application should call <b>IOleLink.SetUpdateOptions</b> when the end user changes the update option for a linked object.</para>
      <para>The end user selects the update option for a linked object using the <b>Links</b> dialog box. If you use the <see cref="OleUIEditLinks" /> function to display this dialog box, you must implement the <see cref="IOleUILinkContainer" /> interface. The dialog box calls your <see cref="IOleUILinkContainer.SetLinkUpdateOptions" /> method to specify the update option chosen by the end user. Your implementation of this method should call the <b>IOleLink.SetUpdateOptions</b> method to pass the selected option to the linked object.</para>
      <h3>Notes to Implementers</h3>
      <para>The default update option is OLEUDPATE_ALWAYS. The linked object's implementation of <see cref="IPersistStorage.Save" /> saves the current update option.</para>
      <para>If OLEUDPATE_ALWAYS is specified as the update option, the linked object updates the link's caches in the following situations:</para>
      <list type="bullet">
        <item>
          <description>When the update option is changed from manual to automatic, if the link source is running.</description>
        </item>
        <item>
          <description>Whenever the linked object binds to the link source.</description>
        </item>
        <item>
          <description>Whenever the link source is running and the linked object's <see cref="IOleObject.Close" />, <see cref="IPersistStorage.Save" />, or <see cref="IAdviseSink.OnSave" /> implementations are called.</description>
        </item>
      </list>
      <para>For both manual and automatic links, the linked object updates the cache whenever the container application calls <see cref="IOleObject.Update" /> or <see cref="IOleLink.Update" />.</para>
    </remarks>
    <seealso cref="IOleLink" />
    <seealso cref="IOleLink.GetUpdateOptions" />
    <seealso cref="IOleLink.Update" />
    <seealso cref="IOleObject.Update" />
    <seealso cref="IOleUILinkContainer" />
    <seealso cref="OleUIEditLinks" />
  </member>
  <member name="IOleLink.UnbindSource">
    <summary>
      <para>Breaks the connection between a linked object and its link source.</para>
    </summary>
    <returns>
      <para>This method returns S_OK on success.</para>
    </returns>
    <remarks>
      <para>You typically do not call <b>UnbindSource</b> directly. When it's necessary to deactivate the connection to the link source, your container typically calls <see cref="IOleObject.Close" /> or <see cref="IUnknown.Release" />; the linked object's implementation of these methods calls <b>UnbindSource</b>. The linked object's <see cref="IAdviseSink.OnClose" /> implementation also calls <b>UnbindSource</b>.</para>
      <h3>Notes to Implementers</h3>
      <para>The linked object's implementation of <b>UnbindSource</b> does nothing if the link source is not currently bound. If the link source is bound, <b>UnbindSource</b> calls the link source's <see cref="IOleObject.Unadvise" /> and <see cref="IDataObject.DUnadvise" /> implementations to delete the advisory connections to the link source. The <b>UnbindSource</b> method also calls the compound document's <see cref="IOleContainer.LockContainer" /> implementation to unlock the containing compound document. This undoes the lock on the container and the advisory connections that were established in <see cref="IOleLink.BindToSource" />. <b>UnbindSource</b> releases all the linked object's interface pointers to the link source.</para>
    </remarks>
    <seealso cref="IAdviseSink.OnClose" />
    <seealso cref="IDataObject.DUnadvise" />
    <seealso cref="IOleLink" />
    <seealso cref="IOleLink.BindToSource" />
    <seealso cref="IOleObject.Close" />
    <seealso cref="IOleObject.Unadvise" />
  </member>
  <member name="IOleLink.Update">
    <summary>
      <para>Updates the compound document's cached data for a linked object. This involves binding to the link source, if it is not already bound.</para>
    </summary>
    <param name="pbc">
      <para>A pointer to the <see cref="IBindCtx" /> interface on the bind context to be used in binding the link source. This parameter can be <b>NULL</b>. The bind context caches objects bound during the binding process, contains parameters that apply to all operations using the bind context, and provides the means by which the binding implementation should retrieve information about its environment. For more information, see <b>IBindCtx</b>.</para>
    </param>
    <returns>
      <para>This method returns S_OK on success. Other possible return values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>CACHE_E_NOCACHE_UPDATE</b>
            </para>
          </description>
          <description>
            <para>The bind operation worked but no caches were updated.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CACHE_S_SOMECACHES_NOTUPDATED</b>
            </para>
          </description>
          <description>
            <para>The bind operation worked but not all caches were updated.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>OLE_E_CANT_BINDTOSOURCE</b>
            </para>
          </description>
          <description>
            <para>Unable to bind to the link source.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <h3>Notes to Callers</h3>
      <para>Your container application should call <b>Update</b> if the end user updates the cached data for a linked object.</para>
      <para>The end user can update the cached data for a linked object by choosing the <b>Update Now</b> button in the <b>Links</b> dialog box. If you use the <see cref="OleUIEditLinks" /> function to display the <b>Links</b> dialog box, you must implement the <see cref="IOleUILinkContainer" /> interface. The dialog box calls your implementations of <see cref="IOleUILinkContainer.UpdateLink" /> when the end user chooses the <b>Update Now</b> button. Your implementation of that method can call <b>Update</b>.</para>
      <para>Your container application can also call <b>Update</b> to update a linked object, because that method calls <b>Update</b> when it is called on a linked object.</para>
      <para>This method updates both automatic links and manual links. For manual links, calling <b>Update</b> or <b>Update</b> is the only way to update the caches. For more information on automatic and manual links, see <see cref="IOleLink.SetUpdateOptions" />.</para>
      <h3>Notes on Implementation</h3>
      <para>If <i>pbc</i> is non-<b>NULL</b>, the linked object's implementation of <b>Update</b> calls <see cref="IBindCtx.RegisterObjectBound" /> to register the bound link source. This ensures that the link source remains running until the bind context is released.</para>
      <para>The current caches are left intact if the link source cannot be bound.</para>
    </remarks>
    <seealso cref="IBindCtx.RegisterObjectBound" />
    <seealso cref="IOleLink" />
    <seealso cref="IOleLink.SetUpdateOptions" />
    <seealso cref="IOleLink.Update" />
    <seealso cref="IOleUILinkContainer" />
    <seealso cref="OleUIEditLinks" />
  </member>
  <member name="IOleLink">
    <summary>
      <para>Enables a linked object to provide its container with functions pertaining to linking. The most important of these functions is binding to the link source, that is, activating the connection to the document that stores the linked object's native data. <b>IOleLink</b> also defines functions for managing information about the linked object, such as the location of the link source and the cached presentation data for the linked object.</para>
      <para>A container application can distinguish between embedded objects and linked objects by querying for <b>IOleLink</b>; only linked objects implement <b>IOleLink</b>.</para>
    </summary>
    <seealso cref="IOleObject" />
    <seealso cref="IOleUILinkContainer" />
    <seealso cref="OleUIEditLinks" />
  </member>
</doc>