<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AreFileApisANSI">
    <summary>Determines whether the file I/O functions are using the ANSI or OEM character set code page. This function is useful for 8-bit console input and output operations.</summary>
    <returns>
      <para>If the set of file I/O functions is using the ANSI code page, the return value is nonzero.</para>
      <para>If the set of file I/O functions is using the OEM code page, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.AreShortNamesEnabled">
    <summary>The <code>AreShortNamesEnabled</code> function determines whether short names are enabled for the specified volume. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</summary>
    <param name="Handle">The handle to the volume or the handle to a file or directory that resides on the volume to query.</param>
    <param name="Enabled">A pointer to a <code>BOOLEAN</code> value that receives the result of the query. If <code>TRUE</code>, short names are enabled for the volume, otherwise <code>FALSE</code> is returned.</param>
    <returns>A <code>BOOLEAN</code> value that indicates whether the function succeeded. If the function succeeds, the return value is <code>TRUE</code>. If the function fails, the return value is <code>FALSE</code>. To get extended error information, call the <see cref="GetLastError" /> function.</returns>
  </member>
  <member name="Windows.CompareFileTime">
    <summary>Compares two file times.</summary>
    <param name="lpFileTime1">A pointer to a <see cref="FILETIME" /> structure that specifies the first file time.</param>
    <param name="lpFileTime2">A pointer to a <see cref="FILETIME" /> structure that specifies the second file time.</param>
    <returns>
      <para>The return value is one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>-1</term>
              </listheader>
            </list>
          </description>
          <description>First file time is earlier than second file time.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>First file time is equal to second file time.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>First file time is later than second file time.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectory">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory. If <i>lpSecurityAttributes</i> is<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. (This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist; this function will only create the final directory in the path.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryA">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory. If <i>lpSecurityAttributes</i> is<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. (This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist; this function will only create the final directory in the path.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryW">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory. If <i>lpSecurityAttributes</i> is<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. (This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist; this function will only create the final directory in the path.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectory">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory. If <i>lpSecurityAttributes</i> is<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. (This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist; this function will only create the final directory in the path.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryA">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory. If <i>lpSecurityAttributes</i> is<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. (This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist; this function will only create the final directory in the path.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryW">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory. If <i>lpSecurityAttributes</i> is<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. (This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist; this function will only create the final directory in the path.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateFile2">
    <summary>
      <para>Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device for various types of I/O depending on the file or device and the flags and attributes specified.</para>
      <para>When called from a Windows Store app, <b>CreateFile2</b>is simplified. You can open only files or directories inside the<a href="https://docs.microsoft.com//uwp/api/windows.storage.applicationdata.localfolder">ApplicationData.LocalFolder</a> or<a href="https://docs.microsoft.com//uwp/api/windows.applicationmodel.package.installedlocation">Package.InstalledLocation</a>directories. You can't open named pipes or mailslots or create encrypted files (<b>FILE_ATTRIBUTE_ENCRYPTED</b>).</para>
      <div>
        <b>Note</b>  We refer here to the app's local folder and the package's installed location, not additional packages in the package graph, like resource packages. <b>CreateFile2</b> doesn't support opening files in additional packages in the package graph. For example, suppose an app has a dependency on <a href="https://docs.microsoft.com//previous-versions/windows/br212652(v=win.10)">WinJS</a>. The app can call <b>CreateFile2</b> to open a file in its package but not in the <b>WinJS</b> package.</div>To perform this operation as a transacted operation, which results in a handle that can be used for transacted I/O, use the <see cref="CreateFileTransacted" /> function.</summary>
    <param name="lpFileName">
      <para>The name of the file or device to be created or opened.</para>
      <para>For information on special device names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.</para>
      <para>To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/file-streams">File Streams</a>.</para>
      <div>
        <b>Tip</b>  Starting with Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
    </param>
    <param name="dwDesiredAccess">
      <para>The requested access to the file or device, which can be summarized as read, write, both or neither zero).</para>
      <para>The most commonly used values are <b>GENERIC_READ</b>,<b>GENERIC_WRITE</b>, or both (<code>GENERIC_READ | GENERIC_WRITE</code>). For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>,<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>,<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.</para>
      <para>If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would have been denied.</para>
      <para>You cannot request an access mode that conflicts with the sharing mode that is specified by the<i>dwShareMode</i> parameter in an open request that already has an open handle.</para>
      <para>For more information, see the Remarks section of this topic and<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
    </param>
    <param name="dwShareMode">
      <para>The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.</para>
      <para>If this parameter is zero and <b>CreateFile2</b> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.</para>
      <para>You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <b>CreateFile2</b> would fail and the <see cref="GetLastError" /> function would return<b>ERROR_SHARING_VIOLATION</b>.</para>
      <para>To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the following values. For more information about valid combinations of this parameter with the <i>dwDesiredAccess</i> parameter, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
      <div>
        <b>Note</b>  The sharing options for each open handle remain in effect until that handle is closed, regardless of process context.</div>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>0</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>Prevents other processes from opening a file or device if they request delete, read, or write access. Exclusive access to a file or directory is only granted if the application has write access to the file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_DELETE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request delete access.<para>Otherwise, other processes cannot open the file or device if they request delete access.</para><para>If this flag is not specified, but the file or device has been opened for delete access, the function fails.</para><div><b>Note</b>  Delete access allows both delete and rename operations.</div></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request read access.<para>Otherwise, other processes cannot open the file or device if they request read access.</para><para>If this flag is not specified, but the file or device has been opened for read access, the function fails.</para><para>If a file or directory is being opened and this flag is not specified, and the caller does not have write access to the file or directory, the function fails.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request write access.<para>Otherwise, other processes cannot open the file or device if they request write access.</para><para>If this flag is not specified, but the file or device has been opened for write access or has a file mapping with write access, the function fails.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwCreationDisposition">
      <para>An action to take on a file or device that exists or does not exist.</para>
      <para>For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.</para>
      <para>For more information, see the Remarks section.</para>
      <para>This parameter must be one of the following values, which cannot be combined:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_ALWAYS</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Creates a new file, always.<para>If the specified file exists and is writable, the function truncates the file, the function succeeds, and last-error code is set to <b>ERROR_ALREADY_EXISTS</b> (183).</para><para>If the specified file does not exist and is a valid path, a new file is created, the function succeeds, and the last-error code is set to zero.</para><para>For more information, see the Remarks section of this topic.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_NEW</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Creates a new file, only if it does not already exist.<para>If the specified file exists, the function fails and the last-error code is set to<b>ERROR_FILE_EXISTS</b> (80).</para><para>If the specified file does not exist and is a valid path to a writable location, a new file is created.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OPEN_ALWAYS</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file, always.<para>If the specified file exists, the function succeeds and the last-error code is set to<b>ERROR_ALREADY_EXISTS</b> (183).</para><para>If the specified file does not exist and is a valid path to a writable location, the function creates a file and the last-error code is set to zero.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OPEN_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file or device, only if it exists.<para>If the specified file or device does not exist, the function fails and the last-error code is set to<b>ERROR_FILE_NOT_FOUND</b> (2).</para><para>For more information about devices, see the Remarks section.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TRUNCATE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file and truncates it so that its size is zero bytes, only if it exists.<para>If the specified file does not exist, the function fails and the last-error code is set to<b>ERROR_FILE_NOT_FOUND</b> (2).</para><para>The calling process must open the file with the <b>GENERIC_WRITE</b> bit set as part of the <i>dwDesiredAccess</i> parameter.</para></description>
        </listheader>
      </list>
    </param>
    <param name="pCreateExParams">Pointer to an optional<see cref="CREATEFILE2_EXTENDED_PARAMETERS" />structure.</param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFile">
    <summary>
      <para>Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device for various types of I/O depending on the file or device and the flags and attributes specified.</para>
      <para>To perform this operation as a transacted operation, which results in a handle that can be used for transacted I/O, use the <see cref="CreateFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\) in this name.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>For information on special device names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.</para>
      <para>To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/file-streams">File Streams</a>.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The requested access to the file or device, which can be summarized as read, write, both or 0 to indicate neither).</para>
      <para>The most commonly used values are <b>GENERIC_READ</b>,<b>GENERIC_WRITE</b>, or both (<code>GENERIC_READ | GENERIC_WRITE</code>). For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>,<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>,<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.</para>
      <para>If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would have been denied.</para>
      <para>You cannot request an access mode that conflicts with the sharing mode that is specified by the<i>dwShareMode</i> parameter in an open request that already has an open handle.</para>
      <para>For more information, see the Remarks section of this topic and<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
    </param>
    <param name="dwShareMode">
      <para>The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.</para>
      <para>If this parameter is zero and <b>CreateFile</b> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.</para>
      <para>You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <b>CreateFile</b> would fail and the <see cref="GetLastError" /> function would return<b>ERROR_SHARING_VIOLATION</b>.</para>
      <para>To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the following values. For more information about valid combinations of this parameter with the <i>dwDesiredAccess</i> parameter, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
      <div>
        <b>Note</b>  The sharing options for each open handle remain in effect until that handle is closed, regardless of process context.</div>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>0</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>Prevents other processes from opening a file or device if they request delete, read, or write access.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_DELETE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request delete access.<para>Otherwise, other processes cannot open the file or device if they request delete access.</para><para>If this flag is not specified, but the file or device has been opened for delete access, the function fails.</para><div><b>Note</b>  Delete access allows both delete and rename operations.</div></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request read access.<para>Otherwise, other processes cannot open the file or device if they request read access.</para><para>If this flag is not specified, but the file or device has been opened for read access, the function fails.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request write access.<para>Otherwise, other processes cannot open the file or device if they request write access.</para><para>If this flag is not specified, but the file or device has been opened for write access or has a file mapping with write access, the function fails.</para></description>
        </listheader>
      </list>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If this parameter is <b>NULL</b>, the handle returned by<b>CreateFile</b> cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<see cref="SECURITY_DESCRIPTOR" /> for a file or device. If this member is <b>NULL</b>, the file or device associated with the returned handle is assigned a default security descriptor.</para>
      <para>
        <b>CreateFile</b> ignores the<b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues to use the <b>bInheritHandle</b> member.</para>
      <para>The <b>bInheritHandle</b> member of the structure specifies whether the returned handle can be inherited.</para>
      <para>For more information, see the Remarks section.</para>
    </param>
    <param name="dwCreationDisposition">
      <para>An action to take on a file or device that exists or does not exist.</para>
      <para>For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.</para>
      <para>For more information, see the Remarks section.</para>
      <para>This parameter must be one of the following values, which cannot be combined:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_ALWAYS</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Creates a new file, always.<para>If the specified file exists and is writable, the function truncates the file, the function succeeds, and last-error code is set to <b>ERROR_ALREADY_EXISTS</b> (183).</para><para>If the specified file does not exist and is a valid path, a new file is created, the function succeeds, and the last-error code is set to zero.</para><para>For more information, see the Remarks section of this topic.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_NEW</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Creates a new file, only if it does not already exist.<para>If the specified file exists, the function fails and the last-error code is set to<b>ERROR_FILE_EXISTS</b> (80).</para><para>If the specified file does not exist and is a valid path to a writable location, a new file is created.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OPEN_ALWAYS</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file, always.<para>If the specified file exists, the function succeeds and the last-error code is set to<b>ERROR_ALREADY_EXISTS</b> (183).</para><para>If the specified file does not exist and is a valid path to a writable location, the function creates a file and the last-error code is set to zero.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OPEN_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file or device, only if it exists.<para>If the specified file or device does not exist, the function fails and the last-error code is set to<b>ERROR_FILE_NOT_FOUND</b> (2).</para><para>For more information about devices, see the Remarks section.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TRUNCATE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file and truncates it so that its size is zero bytes, only if it exists.<para>If the specified file does not exist, the function fails and the last-error code is set to<b>ERROR_FILE_NOT_FOUND</b> (2).</para><para>The calling process must open the file with the <b>GENERIC_WRITE</b> bit set as part of the <i>dwDesiredAccess</i> parameter.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwFlagsAndAttributes">
      <para>The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value for files.</para>
      <para>This parameter can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override<b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any<b>FILE_ATTRIBUTE_*</b> values.</para>
      <para>This parameter can also contain Security Quality of Service (SQOS) information by specifying the<b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.</para>
      <div>
        <b>Note</b>  When <b>CreateFile</b> opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in <a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</div>Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that <b>CreateFile</b> can open. For additional information, see the Remarks section of this topic and <a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.<para>For more advanced access to file attributes, see<see cref="SetFileAttributes" />. For a complete list of all file attributes with their values and descriptions, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para><list type="table"><listheader><description>Attribute</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_ARCHIVE</b></term></listheader><listheader><term>32 (0x20)</term></listheader></list></description><description>The file should be archived. Applications use this attribute to mark files for backup or removal.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_ENCRYPTED</b></term></listheader><listheader><term>16384 (0x4000)</term></listheader></list></description><description>The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.<para>This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified.</para><para>This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_HIDDEN</b></term></listheader><listheader><term>2 (0x2)</term></listheader></list></description><description>The file is hidden. Do not include it in an ordinary directory listing.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_NORMAL</b></term></listheader><listheader><term>128 (0x80)</term></listheader></list></description><description>The file does not have other attributes set. This attribute is valid only if used alone.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_OFFLINE</b></term></listheader><listheader><term>4096 (0x1000)</term></listheader></list></description><description>The data of a file is not immediately available. This attribute indicates that file data is physically moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_READONLY</b></term></listheader><listheader><term>1 (0x1)</term></listheader></list></description><description>The file is read only. Applications can read the file, but cannot write to or delete it.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_SYSTEM</b></term></listheader><listheader><term>4 (0x4)</term></listheader></list></description><description>The file is part of or used exclusively by an operating system.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_TEMPORARY</b></term></listheader><listheader><term>256 (0x100)</term></listheader></list></description><description>The file is being used for temporary storage.<para>For more information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader></list> <list type="table"><listheader><description>Flag</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_BACKUP_SEMANTICS</b></term></listheader><listheader><term>0x02000000</term></listheader></list></description><description>The file is being opened or created for a backup or restore operation. The system ensures that the calling process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and <b>SE_RESTORE_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.<para>You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of a file handle. For more information, see the Remarks section.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_DELETE_ON_CLOSE</b></term></listheader><listheader><term>0x04000000</term></listheader></list></description><description>The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any other open or duplicated handles.<para>If there are existing open handles to a file, the call fails unless they were all opened with the<b>FILE_SHARE_DELETE</b> share mode.</para><para>Subsequent open requests for the file fail, unless the <b>FILE_SHARE_DELETE</b> share mode is specified.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_NO_BUFFERING</b></term></listheader><listheader><term>0x20000000</term></listheader></list></description><description>The file or device is being opened with no system caching for data reads and writes. This flag does not affect hard disk caching or memory mapped files.<para>There are strict requirements for successfully working with files opened with<b>CreateFile</b> using the<b>FILE_FLAG_NO_BUFFERING</b> flag, for details see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-buffering">File Buffering</a>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OPEN_NO_RECALL</b></term></listheader><listheader><term>0x00100000</term></listheader></list></description><description>The file data is requested, but it should continue to be located in remote storage. It should not be transported back to local storage. This flag is for use by remote storage systems.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OPEN_REPARSE_POINT</b></term></listheader><listheader><term>0x00200000</term></listheader></list></description><description>Normal <a href="https://docs.microsoft.com//windows/desktop/FileIO/reparse-points">reparse point</a> processing will not occur; <b>CreateFile</b> will attempt to open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.<para>This flag cannot be used with the <b>CREATE_ALWAYS</b> flag.</para><para>If the file is not a reparse point, then this flag is ignored.</para><para>For more information, see the Remarks section.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OVERLAPPED</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>The file or device is being opened or created for asynchronous I/O.<para>When subsequent I/O operations are completed on this handle, the event specified in the<see cref="OVERLAPPED" /> structure will be set to the signaled state.</para><para>If this flag is specified, the file can be used for simultaneous read and write operations.</para><para>If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions specify an <see cref="OVERLAPPED" /> structure.</para><para>For information about considerations when using a file handle created with this flag, see the<a href="https://docs.microsoft.com/#synchronous_and_asynchronous_i_o_handles">Synchronous and Asynchronous I/O Handles</a>section of this topic.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_POSIX_SEMANTICS</b></term></listheader><listheader><term>0x01000000</term></listheader></list></description><description>Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only in case, for file systems that support that naming. Use care when using this option, because files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit Windows.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_RANDOM_ACCESS</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Access is intended to be random. The system can use this as a hint to optimize file caching.<para>This flag has no effect if the file system does not support cached I/O and<b>FILE_FLAG_NO_BUFFERING</b>.</para><para>For more information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_SESSION_AWARE</b></term></listheader><listheader><term>0x00800000</term></listheader></list></description><description>The file or device is being opened with session awareness. If this flag is not specified, then per-session devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. This flag has no effect for callers not in session 0. This flag is supported only on server editions of Windows.<para><b>Windows Server 2008 R2 and Windows Server 2008:  </b>This flag is not supported before Windows Server 2012.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_SEQUENTIAL_SCAN</b></term></listheader><listheader><term>0x08000000</term></listheader></list></description><description>Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file caching.<para>This flag should not be used if read-behind (that is, reverse scans) will be used.</para><para>This flag has no effect if the file system does not support cached I/O and<b>FILE_FLAG_NO_BUFFERING</b>.</para><para>For more information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_WRITE_THROUGH</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Write operations will not go through any intermediate cache, they will go directly to disk.<para>For additional information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader></list> <para>The <i>dwFlagsAndAttributes</i> parameter can also specify SQOS information. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the calling application specifies the <b>SECURITY_SQOS_PRESENT</b> flag as part of<i>dwFlagsAndAttributes</i>, it can also contain one or more of the following values.</para><list type="table"><listheader><description>Security flag</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_ANONYMOUS</b></term></listheader></list></description><description>Impersonates a client at the Anonymous impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_CONTEXT_TRACKING</b></term></listheader></list></description><description>The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is static.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_DELEGATION</b></term></listheader></list></description><description>Impersonates a client at the Delegation impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_EFFECTIVE_ONLY</b></term></listheader></list></description><description>Only the enabled aspects of the client's security context are available to the server. If you do not specify this flag, all aspects of the client's security context are available.<para>This allows the client to limit the groups and privileges that a server can use while impersonating the client.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_IDENTIFICATION</b></term></listheader></list></description><description>Impersonates a client at the Identification impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_IMPERSONATION</b></term></listheader></list></description><description>Impersonate a client at the impersonation level. This is the default behavior if no other flags are specified along with the <b>SECURITY_SQOS_PRESENT</b> flag.</description></listheader></list></param>
    <param name="hTemplateFile">
      <para>A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file attributes and extended attributes for the file that is being created.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>When opening an existing file, <b>CreateFile</b> ignores this parameter.</para>
      <para>When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory. For additional information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileA">
    <summary>
      <para>Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device for various types of I/O depending on the file or device and the flags and attributes specified.</para>
      <para>To perform this operation as a transacted operation, which results in a handle that can be used for transacted I/O, use the <see cref="CreateFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\) in this name.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>For information on special device names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.</para>
      <para>To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/file-streams">File Streams</a>.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The requested access to the file or device, which can be summarized as read, write, both or 0 to indicate neither).</para>
      <para>The most commonly used values are <b>GENERIC_READ</b>,<b>GENERIC_WRITE</b>, or both (<code>GENERIC_READ | GENERIC_WRITE</code>). For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>,<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>,<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.</para>
      <para>If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would have been denied.</para>
      <para>You cannot request an access mode that conflicts with the sharing mode that is specified by the<i>dwShareMode</i> parameter in an open request that already has an open handle.</para>
      <para>For more information, see the Remarks section of this topic and<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
    </param>
    <param name="dwShareMode">
      <para>The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.</para>
      <para>If this parameter is zero and <b>CreateFile</b> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.</para>
      <para>You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <b>CreateFile</b> would fail and the <see cref="GetLastError" /> function would return<b>ERROR_SHARING_VIOLATION</b>.</para>
      <para>To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the following values. For more information about valid combinations of this parameter with the <i>dwDesiredAccess</i> parameter, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
      <div>
        <b>Note</b>  The sharing options for each open handle remain in effect until that handle is closed, regardless of process context.</div>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>0</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>Prevents other processes from opening a file or device if they request delete, read, or write access.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_DELETE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request delete access.<para>Otherwise, other processes cannot open the file or device if they request delete access.</para><para>If this flag is not specified, but the file or device has been opened for delete access, the function fails.</para><div><b>Note</b>  Delete access allows both delete and rename operations.</div></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request read access.<para>Otherwise, other processes cannot open the file or device if they request read access.</para><para>If this flag is not specified, but the file or device has been opened for read access, the function fails.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request write access.<para>Otherwise, other processes cannot open the file or device if they request write access.</para><para>If this flag is not specified, but the file or device has been opened for write access or has a file mapping with write access, the function fails.</para></description>
        </listheader>
      </list>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If this parameter is <b>NULL</b>, the handle returned by<b>CreateFile</b> cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<see cref="SECURITY_DESCRIPTOR" /> for a file or device. If this member is <b>NULL</b>, the file or device associated with the returned handle is assigned a default security descriptor.</para>
      <para>
        <b>CreateFile</b> ignores the<b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues to use the <b>bInheritHandle</b> member.</para>
      <para>The <b>bInheritHandle</b> member of the structure specifies whether the returned handle can be inherited.</para>
      <para>For more information, see the Remarks section.</para>
    </param>
    <param name="dwCreationDisposition">
      <para>An action to take on a file or device that exists or does not exist.</para>
      <para>For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.</para>
      <para>For more information, see the Remarks section.</para>
      <para>This parameter must be one of the following values, which cannot be combined:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_ALWAYS</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Creates a new file, always.<para>If the specified file exists and is writable, the function truncates the file, the function succeeds, and last-error code is set to <b>ERROR_ALREADY_EXISTS</b> (183).</para><para>If the specified file does not exist and is a valid path, a new file is created, the function succeeds, and the last-error code is set to zero.</para><para>For more information, see the Remarks section of this topic.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_NEW</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Creates a new file, only if it does not already exist.<para>If the specified file exists, the function fails and the last-error code is set to<b>ERROR_FILE_EXISTS</b> (80).</para><para>If the specified file does not exist and is a valid path to a writable location, a new file is created.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OPEN_ALWAYS</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file, always.<para>If the specified file exists, the function succeeds and the last-error code is set to<b>ERROR_ALREADY_EXISTS</b> (183).</para><para>If the specified file does not exist and is a valid path to a writable location, the function creates a file and the last-error code is set to zero.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OPEN_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file or device, only if it exists.<para>If the specified file or device does not exist, the function fails and the last-error code is set to<b>ERROR_FILE_NOT_FOUND</b> (2).</para><para>For more information about devices, see the Remarks section.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TRUNCATE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file and truncates it so that its size is zero bytes, only if it exists.<para>If the specified file does not exist, the function fails and the last-error code is set to<b>ERROR_FILE_NOT_FOUND</b> (2).</para><para>The calling process must open the file with the <b>GENERIC_WRITE</b> bit set as part of the <i>dwDesiredAccess</i> parameter.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwFlagsAndAttributes">
      <para>The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value for files.</para>
      <para>This parameter can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override<b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any<b>FILE_ATTRIBUTE_*</b> values.</para>
      <para>This parameter can also contain Security Quality of Service (SQOS) information by specifying the<b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.</para>
      <div>
        <b>Note</b>  When <b>CreateFile</b> opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in <a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</div>Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that <b>CreateFile</b> can open. For additional information, see the Remarks section of this topic and <a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.<para>For more advanced access to file attributes, see<see cref="SetFileAttributes" />. For a complete list of all file attributes with their values and descriptions, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para><list type="table"><listheader><description>Attribute</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_ARCHIVE</b></term></listheader><listheader><term>32 (0x20)</term></listheader></list></description><description>The file should be archived. Applications use this attribute to mark files for backup or removal.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_ENCRYPTED</b></term></listheader><listheader><term>16384 (0x4000)</term></listheader></list></description><description>The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.<para>This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified.</para><para>This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_HIDDEN</b></term></listheader><listheader><term>2 (0x2)</term></listheader></list></description><description>The file is hidden. Do not include it in an ordinary directory listing.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_NORMAL</b></term></listheader><listheader><term>128 (0x80)</term></listheader></list></description><description>The file does not have other attributes set. This attribute is valid only if used alone.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_OFFLINE</b></term></listheader><listheader><term>4096 (0x1000)</term></listheader></list></description><description>The data of a file is not immediately available. This attribute indicates that file data is physically moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_READONLY</b></term></listheader><listheader><term>1 (0x1)</term></listheader></list></description><description>The file is read only. Applications can read the file, but cannot write to or delete it.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_SYSTEM</b></term></listheader><listheader><term>4 (0x4)</term></listheader></list></description><description>The file is part of or used exclusively by an operating system.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_TEMPORARY</b></term></listheader><listheader><term>256 (0x100)</term></listheader></list></description><description>The file is being used for temporary storage.<para>For more information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader></list> <list type="table"><listheader><description>Flag</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_BACKUP_SEMANTICS</b></term></listheader><listheader><term>0x02000000</term></listheader></list></description><description>The file is being opened or created for a backup or restore operation. The system ensures that the calling process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and <b>SE_RESTORE_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.<para>You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of a file handle. For more information, see the Remarks section.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_DELETE_ON_CLOSE</b></term></listheader><listheader><term>0x04000000</term></listheader></list></description><description>The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any other open or duplicated handles.<para>If there are existing open handles to a file, the call fails unless they were all opened with the<b>FILE_SHARE_DELETE</b> share mode.</para><para>Subsequent open requests for the file fail, unless the <b>FILE_SHARE_DELETE</b> share mode is specified.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_NO_BUFFERING</b></term></listheader><listheader><term>0x20000000</term></listheader></list></description><description>The file or device is being opened with no system caching for data reads and writes. This flag does not affect hard disk caching or memory mapped files.<para>There are strict requirements for successfully working with files opened with<b>CreateFile</b> using the<b>FILE_FLAG_NO_BUFFERING</b> flag, for details see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-buffering">File Buffering</a>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OPEN_NO_RECALL</b></term></listheader><listheader><term>0x00100000</term></listheader></list></description><description>The file data is requested, but it should continue to be located in remote storage. It should not be transported back to local storage. This flag is for use by remote storage systems.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OPEN_REPARSE_POINT</b></term></listheader><listheader><term>0x00200000</term></listheader></list></description><description>Normal <a href="https://docs.microsoft.com//windows/desktop/FileIO/reparse-points">reparse point</a> processing will not occur; <b>CreateFile</b> will attempt to open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.<para>This flag cannot be used with the <b>CREATE_ALWAYS</b> flag.</para><para>If the file is not a reparse point, then this flag is ignored.</para><para>For more information, see the Remarks section.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OVERLAPPED</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>The file or device is being opened or created for asynchronous I/O.<para>When subsequent I/O operations are completed on this handle, the event specified in the<see cref="OVERLAPPED" /> structure will be set to the signaled state.</para><para>If this flag is specified, the file can be used for simultaneous read and write operations.</para><para>If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions specify an <see cref="OVERLAPPED" /> structure.</para><para>For information about considerations when using a file handle created with this flag, see the<a href="https://docs.microsoft.com/#synchronous_and_asynchronous_i_o_handles">Synchronous and Asynchronous I/O Handles</a>section of this topic.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_POSIX_SEMANTICS</b></term></listheader><listheader><term>0x01000000</term></listheader></list></description><description>Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only in case, for file systems that support that naming. Use care when using this option, because files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit Windows.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_RANDOM_ACCESS</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Access is intended to be random. The system can use this as a hint to optimize file caching.<para>This flag has no effect if the file system does not support cached I/O and<b>FILE_FLAG_NO_BUFFERING</b>.</para><para>For more information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_SESSION_AWARE</b></term></listheader><listheader><term>0x00800000</term></listheader></list></description><description>The file or device is being opened with session awareness. If this flag is not specified, then per-session devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. This flag has no effect for callers not in session 0. This flag is supported only on server editions of Windows.<para><b>Windows Server 2008 R2 and Windows Server 2008:  </b>This flag is not supported before Windows Server 2012.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_SEQUENTIAL_SCAN</b></term></listheader><listheader><term>0x08000000</term></listheader></list></description><description>Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file caching.<para>This flag should not be used if read-behind (that is, reverse scans) will be used.</para><para>This flag has no effect if the file system does not support cached I/O and<b>FILE_FLAG_NO_BUFFERING</b>.</para><para>For more information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_WRITE_THROUGH</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Write operations will not go through any intermediate cache, they will go directly to disk.<para>For additional information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader></list> <para>The <i>dwFlagsAndAttributes</i> parameter can also specify SQOS information. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the calling application specifies the <b>SECURITY_SQOS_PRESENT</b> flag as part of<i>dwFlagsAndAttributes</i>, it can also contain one or more of the following values.</para><list type="table"><listheader><description>Security flag</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_ANONYMOUS</b></term></listheader></list></description><description>Impersonates a client at the Anonymous impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_CONTEXT_TRACKING</b></term></listheader></list></description><description>The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is static.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_DELEGATION</b></term></listheader></list></description><description>Impersonates a client at the Delegation impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_EFFECTIVE_ONLY</b></term></listheader></list></description><description>Only the enabled aspects of the client's security context are available to the server. If you do not specify this flag, all aspects of the client's security context are available.<para>This allows the client to limit the groups and privileges that a server can use while impersonating the client.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_IDENTIFICATION</b></term></listheader></list></description><description>Impersonates a client at the Identification impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_IMPERSONATION</b></term></listheader></list></description><description>Impersonate a client at the impersonation level. This is the default behavior if no other flags are specified along with the <b>SECURITY_SQOS_PRESENT</b> flag.</description></listheader></list></param>
    <param name="hTemplateFile">
      <para>A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file attributes and extended attributes for the file that is being created.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>When opening an existing file, <b>CreateFile</b> ignores this parameter.</para>
      <para>When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory. For additional information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileW">
    <summary>
      <para>Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device for various types of I/O depending on the file or device and the flags and attributes specified.</para>
      <para>To perform this operation as a transacted operation, which results in a handle that can be used for transacted I/O, use the <see cref="CreateFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\) in this name.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>For information on special device names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.</para>
      <para>To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/file-streams">File Streams</a>.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The requested access to the file or device, which can be summarized as read, write, both or 0 to indicate neither).</para>
      <para>The most commonly used values are <b>GENERIC_READ</b>,<b>GENERIC_WRITE</b>, or both (<code>GENERIC_READ | GENERIC_WRITE</code>). For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>,<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>,<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.</para>
      <para>If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would have been denied.</para>
      <para>You cannot request an access mode that conflicts with the sharing mode that is specified by the<i>dwShareMode</i> parameter in an open request that already has an open handle.</para>
      <para>For more information, see the Remarks section of this topic and<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
    </param>
    <param name="dwShareMode">
      <para>The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.</para>
      <para>If this parameter is zero and <b>CreateFile</b> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.</para>
      <para>You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <b>CreateFile</b> would fail and the <see cref="GetLastError" /> function would return<b>ERROR_SHARING_VIOLATION</b>.</para>
      <para>To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the following values. For more information about valid combinations of this parameter with the <i>dwDesiredAccess</i> parameter, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
      <div>
        <b>Note</b>  The sharing options for each open handle remain in effect until that handle is closed, regardless of process context.</div>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>0</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>Prevents other processes from opening a file or device if they request delete, read, or write access.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_DELETE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request delete access.<para>Otherwise, other processes cannot open the file or device if they request delete access.</para><para>If this flag is not specified, but the file or device has been opened for delete access, the function fails.</para><div><b>Note</b>  Delete access allows both delete and rename operations.</div></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request read access.<para>Otherwise, other processes cannot open the file or device if they request read access.</para><para>If this flag is not specified, but the file or device has been opened for read access, the function fails.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on a file or device to request write access.<para>Otherwise, other processes cannot open the file or device if they request write access.</para><para>If this flag is not specified, but the file or device has been opened for write access or has a file mapping with write access, the function fails.</para></description>
        </listheader>
      </list>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If this parameter is <b>NULL</b>, the handle returned by<b>CreateFile</b> cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a<see cref="SECURITY_DESCRIPTOR" /> for a file or device. If this member is <b>NULL</b>, the file or device associated with the returned handle is assigned a default security descriptor.</para>
      <para>
        <b>CreateFile</b> ignores the<b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues to use the <b>bInheritHandle</b> member.</para>
      <para>The <b>bInheritHandle</b> member of the structure specifies whether the returned handle can be inherited.</para>
      <para>For more information, see the Remarks section.</para>
    </param>
    <param name="dwCreationDisposition">
      <para>An action to take on a file or device that exists or does not exist.</para>
      <para>For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.</para>
      <para>For more information, see the Remarks section.</para>
      <para>This parameter must be one of the following values, which cannot be combined:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_ALWAYS</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Creates a new file, always.<para>If the specified file exists and is writable, the function truncates the file, the function succeeds, and last-error code is set to <b>ERROR_ALREADY_EXISTS</b> (183).</para><para>If the specified file does not exist and is a valid path, a new file is created, the function succeeds, and the last-error code is set to zero.</para><para>For more information, see the Remarks section of this topic.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_NEW</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Creates a new file, only if it does not already exist.<para>If the specified file exists, the function fails and the last-error code is set to<b>ERROR_FILE_EXISTS</b> (80).</para><para>If the specified file does not exist and is a valid path to a writable location, a new file is created.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OPEN_ALWAYS</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file, always.<para>If the specified file exists, the function succeeds and the last-error code is set to<b>ERROR_ALREADY_EXISTS</b> (183).</para><para>If the specified file does not exist and is a valid path to a writable location, the function creates a file and the last-error code is set to zero.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OPEN_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file or device, only if it exists.<para>If the specified file or device does not exist, the function fails and the last-error code is set to<b>ERROR_FILE_NOT_FOUND</b> (2).</para><para>For more information about devices, see the Remarks section.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TRUNCATE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file and truncates it so that its size is zero bytes, only if it exists.<para>If the specified file does not exist, the function fails and the last-error code is set to<b>ERROR_FILE_NOT_FOUND</b> (2).</para><para>The calling process must open the file with the <b>GENERIC_WRITE</b> bit set as part of the <i>dwDesiredAccess</i> parameter.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwFlagsAndAttributes">
      <para>The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value for files.</para>
      <para>This parameter can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override<b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any<b>FILE_ATTRIBUTE_*</b> values.</para>
      <para>This parameter can also contain Security Quality of Service (SQOS) information by specifying the<b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.</para>
      <div>
        <b>Note</b>  When <b>CreateFile</b> opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in <a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</div>Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that <b>CreateFile</b> can open. For additional information, see the Remarks section of this topic and <a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.<para>For more advanced access to file attributes, see<see cref="SetFileAttributes" />. For a complete list of all file attributes with their values and descriptions, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para><list type="table"><listheader><description>Attribute</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_ARCHIVE</b></term></listheader><listheader><term>32 (0x20)</term></listheader></list></description><description>The file should be archived. Applications use this attribute to mark files for backup or removal.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_ENCRYPTED</b></term></listheader><listheader><term>16384 (0x4000)</term></listheader></list></description><description>The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.<para>This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified.</para><para>This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_HIDDEN</b></term></listheader><listheader><term>2 (0x2)</term></listheader></list></description><description>The file is hidden. Do not include it in an ordinary directory listing.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_NORMAL</b></term></listheader><listheader><term>128 (0x80)</term></listheader></list></description><description>The file does not have other attributes set. This attribute is valid only if used alone.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_OFFLINE</b></term></listheader><listheader><term>4096 (0x1000)</term></listheader></list></description><description>The data of a file is not immediately available. This attribute indicates that file data is physically moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_READONLY</b></term></listheader><listheader><term>1 (0x1)</term></listheader></list></description><description>The file is read only. Applications can read the file, but cannot write to or delete it.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_SYSTEM</b></term></listheader><listheader><term>4 (0x4)</term></listheader></list></description><description>The file is part of or used exclusively by an operating system.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_ATTRIBUTE_TEMPORARY</b></term></listheader><listheader><term>256 (0x100)</term></listheader></list></description><description>The file is being used for temporary storage.<para>For more information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader></list> <list type="table"><listheader><description>Flag</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_BACKUP_SEMANTICS</b></term></listheader><listheader><term>0x02000000</term></listheader></list></description><description>The file is being opened or created for a backup or restore operation. The system ensures that the calling process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and <b>SE_RESTORE_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.<para>You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of a file handle. For more information, see the Remarks section.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_DELETE_ON_CLOSE</b></term></listheader><listheader><term>0x04000000</term></listheader></list></description><description>The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any other open or duplicated handles.<para>If there are existing open handles to a file, the call fails unless they were all opened with the<b>FILE_SHARE_DELETE</b> share mode.</para><para>Subsequent open requests for the file fail, unless the <b>FILE_SHARE_DELETE</b> share mode is specified.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_NO_BUFFERING</b></term></listheader><listheader><term>0x20000000</term></listheader></list></description><description>The file or device is being opened with no system caching for data reads and writes. This flag does not affect hard disk caching or memory mapped files.<para>There are strict requirements for successfully working with files opened with<b>CreateFile</b> using the<b>FILE_FLAG_NO_BUFFERING</b> flag, for details see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-buffering">File Buffering</a>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OPEN_NO_RECALL</b></term></listheader><listheader><term>0x00100000</term></listheader></list></description><description>The file data is requested, but it should continue to be located in remote storage. It should not be transported back to local storage. This flag is for use by remote storage systems.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OPEN_REPARSE_POINT</b></term></listheader><listheader><term>0x00200000</term></listheader></list></description><description>Normal <a href="https://docs.microsoft.com//windows/desktop/FileIO/reparse-points">reparse point</a> processing will not occur; <b>CreateFile</b> will attempt to open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.<para>This flag cannot be used with the <b>CREATE_ALWAYS</b> flag.</para><para>If the file is not a reparse point, then this flag is ignored.</para><para>For more information, see the Remarks section.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OVERLAPPED</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>The file or device is being opened or created for asynchronous I/O.<para>When subsequent I/O operations are completed on this handle, the event specified in the<see cref="OVERLAPPED" /> structure will be set to the signaled state.</para><para>If this flag is specified, the file can be used for simultaneous read and write operations.</para><para>If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions specify an <see cref="OVERLAPPED" /> structure.</para><para>For information about considerations when using a file handle created with this flag, see the<a href="https://docs.microsoft.com/#synchronous_and_asynchronous_i_o_handles">Synchronous and Asynchronous I/O Handles</a>section of this topic.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_POSIX_SEMANTICS</b></term></listheader><listheader><term>0x01000000</term></listheader></list></description><description>Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only in case, for file systems that support that naming. Use care when using this option, because files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit Windows.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_RANDOM_ACCESS</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Access is intended to be random. The system can use this as a hint to optimize file caching.<para>This flag has no effect if the file system does not support cached I/O and<b>FILE_FLAG_NO_BUFFERING</b>.</para><para>For more information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_SESSION_AWARE</b></term></listheader><listheader><term>0x00800000</term></listheader></list></description><description>The file or device is being opened with session awareness. If this flag is not specified, then per-session devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. This flag has no effect for callers not in session 0. This flag is supported only on server editions of Windows.<para><b>Windows Server 2008 R2 and Windows Server 2008:  </b>This flag is not supported before Windows Server 2012.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_SEQUENTIAL_SCAN</b></term></listheader><listheader><term>0x08000000</term></listheader></list></description><description>Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file caching.<para>This flag should not be used if read-behind (that is, reverse scans) will be used.</para><para>This flag has no effect if the file system does not support cached I/O and<b>FILE_FLAG_NO_BUFFERING</b>.</para><para>For more information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_WRITE_THROUGH</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Write operations will not go through any intermediate cache, they will go directly to disk.<para>For additional information, see the <a href="https://docs.microsoft.com/#caching_behavior">Caching Behavior</a> section of this topic.</para></description></listheader></list> <para>The <i>dwFlagsAndAttributes</i> parameter can also specify SQOS information. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the calling application specifies the <b>SECURITY_SQOS_PRESENT</b> flag as part of<i>dwFlagsAndAttributes</i>, it can also contain one or more of the following values.</para><list type="table"><listheader><description>Security flag</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_ANONYMOUS</b></term></listheader></list></description><description>Impersonates a client at the Anonymous impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_CONTEXT_TRACKING</b></term></listheader></list></description><description>The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is static.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_DELEGATION</b></term></listheader></list></description><description>Impersonates a client at the Delegation impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_EFFECTIVE_ONLY</b></term></listheader></list></description><description>Only the enabled aspects of the client's security context are available to the server. If you do not specify this flag, all aspects of the client's security context are available.<para>This allows the client to limit the groups and privileges that a server can use while impersonating the client.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_IDENTIFICATION</b></term></listheader></list></description><description>Impersonates a client at the Identification impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_IMPERSONATION</b></term></listheader></list></description><description>Impersonate a client at the impersonation level. This is the default behavior if no other flags are specified along with the <b>SECURITY_SQOS_PRESENT</b> flag.</description></listheader></list></param>
    <param name="hTemplateFile">
      <para>A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file attributes and extended attributes for the file that is being created.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>When opening an existing file, <b>CreateFile</b> ignores this parameter.</para>
      <para>When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory. For additional information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DefineDosDevice">
    <summary>Defines, redefines, or deletes MS-DOS device names.</summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete something that you did not define.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message. By default, this message is broadcast to notify the shell and applications of the change.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_RAW_TARGET_PATH</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS path to a path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_REMOVE_DEFINITION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Removes the specified definition for the specified device. To determine which definition to remove, the function walks the list of mappings for the device, looking for a match of <i>lpTargetPath</i> against a prefix of each mapping associated with this device. The first mapping that matches is the one removed, and then the function returns.<para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a<b>NULL</b> string, the function will remove the first mapping associated with the device and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para><para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i>parameter will become the new mapping for this device.</para></description>
        </listheader>
      </list>
    </param>
    <param name="lpDeviceName">A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or deleting. The device name string must not have a colon as the last character, unless a drive letter is being defined, redefined, or deleted. For example, drive C would be the string "C:". In no case is a trailing backslash (\) allowed.</param>
    <param name="lpTargetPath">A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path string.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DefineDosDeviceA">
    <summary>Defines, redefines, or deletes MS-DOS device names.</summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete something that you did not define.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message. By default, this message is broadcast to notify the shell and applications of the change.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_RAW_TARGET_PATH</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS path to a path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_REMOVE_DEFINITION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Removes the specified definition for the specified device. To determine which definition to remove, the function walks the list of mappings for the device, looking for a match of <i>lpTargetPath</i> against a prefix of each mapping associated with this device. The first mapping that matches is the one removed, and then the function returns.<para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a<b>NULL</b> string, the function will remove the first mapping associated with the device and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para><para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i>parameter will become the new mapping for this device.</para></description>
        </listheader>
      </list>
    </param>
    <param name="lpDeviceName">A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or deleting. The device name string must not have a colon as the last character, unless a drive letter is being defined, redefined, or deleted. For example, drive C would be the string "C:". In no case is a trailing backslash (\) allowed.</param>
    <param name="lpTargetPath">A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path string.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DefineDosDeviceW">
    <summary>Defines, redefines, or deletes MS-DOS device names.</summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete something that you did not define.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message. By default, this message is broadcast to notify the shell and applications of the change.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_RAW_TARGET_PATH</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS path to a path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_REMOVE_DEFINITION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Removes the specified definition for the specified device. To determine which definition to remove, the function walks the list of mappings for the device, looking for a match of <i>lpTargetPath</i> against a prefix of each mapping associated with this device. The first mapping that matches is the one removed, and then the function returns.<para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a<b>NULL</b> string, the function will remove the first mapping associated with the device and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para><para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i>parameter will become the new mapping for this device.</para></description>
        </listheader>
      </list>
    </param>
    <param name="lpDeviceName">A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or deleting. The device name string must not have a colon as the last character, unless a drive letter is being defined, redefined, or deleted. For example, drive C would be the string "C:". In no case is a trailing backslash (\) allowed.</param>
    <param name="lpTargetPath">A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path string.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteFile">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteFileA">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteFileW">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteFile">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteFileA">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteFileW">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteVolumeMountPoint">
    <summary>Deletes a drive letter or mounted folder.</summary>
    <param name="lpszVolumeMountPoint">The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, "X:" or "Y:\MountX".</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteVolumeMountPointA">
    <summary>Deletes a drive letter or mounted folder.</summary>
    <param name="lpszVolumeMountPoint">The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, "X:" or "Y:\MountX".</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteVolumeMountPointW">
    <summary>Deletes a drive letter or mounted folder.</summary>
    <param name="lpszVolumeMountPoint">The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, "X:" or "Y:\MountX".</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FileTimeToLocalFileTime">
    <summary>Converts a file time to a local file time.</summary>
    <param name="lpFileTime">A pointer to a <see cref="FILETIME" /> structure containing the UTC-based file time to be converted into a local file time.</param>
    <param name="lpLocalFileTime">A pointer to a <see cref="FILETIME" /> structure to receive the converted local file time. This parameter cannot be the same as the <i>lpFileTime</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindClose">
    <summary>Closes a file search handle opened by the<see cref="FindFirstFile" />,<see cref="FindFirstFileEx" />,<see cref="FindFirstFileNameW" />,<see cref="FindFirstFileNameTransactedW" />,<see cref="FindFirstFileTransacted" />,<see cref="FindFirstStreamTransactedW" />, or<see cref="FindFirstStreamW" /> functions.</summary>
    <param name="hFindFile">The file search handle.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindCloseChangeNotification">
    <summary>Stops change notification handle monitoring.</summary>
    <param name="hChangeHandle">A handle to a change notification handle created by the<see cref="FindFirstChangeNotification" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstChangeNotification">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the<br /><see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bWatchSubtree">If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstChangeNotificationA">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the<br /><see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bWatchSubtree">If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstChangeNotificationW">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the<br /><see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bWatchSubtree">If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstChangeNotification">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the<br /><see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bWatchSubtree">If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstChangeNotificationA">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the<br /><see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bWatchSubtree">If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstChangeNotificationW">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the<br /><see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bWatchSubtree">If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFile">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to the root and all subdirectories on the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about a found file or directory.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFileA">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to the root and all subdirectories on the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about a found file or directory.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFileW">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to the root and all subdirectories on the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about a found file or directory.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFileEx">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those specified.</para>
      <para>For the most basic version of this function, see<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" />enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Searches are case-sensitive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Uses a larger buffer for directory queries, which can increase performance of the find operation.<para><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFileExA">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those specified.</para>
      <para>For the most basic version of this function, see<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" />enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Searches are case-sensitive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Uses a larger buffer for directory queries, which can increase performance of the find operation.<para><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFileExW">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those specified.</para>
      <para>For the most basic version of this function, see<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" />enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Searches are case-sensitive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Uses a larger buffer for directory queries, which can increase performance of the find operation.<para><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFileEx">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those specified.</para>
      <para>For the most basic version of this function, see<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.</para>
      <para>In the of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and prepend "\\?\" to the path. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <div>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" />enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Searches are case-sensitive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Uses a larger buffer for directory queries, which can increase performance of the find operation.<para><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFileExA">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those specified.</para>
      <para>For the most basic version of this function, see<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.</para>
      <para>In the of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and prepend "\\?\" to the path. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <div>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" />enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Searches are case-sensitive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Uses a larger buffer for directory queries, which can increase performance of the find operation.<para><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFileExW">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those specified.</para>
      <para>For the most basic version of this function, see<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.</para>
      <para>In the of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and prepend "\\?\" to the path. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <div>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" />enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Searches are case-sensitive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Uses a larger buffer for directory queries, which can increase performance of the find operation.<para><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFileNameW">
    <summary>
      <para>Creates an enumeration of all the hard links to the specified file. The<b>FindFirstFileNameW</b> function returns a handle to the enumeration that can be used on subsequent calls to the<see cref="FindNextFileNameW" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileNameTransactedW" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <div>
        <b>Tip</b>  Starting with Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
    </param>
    <param name="dwFlags">Reserved; specify zero (0).</param>
    <param name="StringLength">The size of the buffer pointed to by the <i>LinkName</i> parameter, in characters. If this call fails and the error returned from the<see cref="GetLastError" /> function is<b>ERROR_MORE_DATA</b> (234), the value that is returned by this parameter is the size that the buffer pointed to by <i>LinkName</i> must be to contain all the data.</param>
    <param name="LinkName">A pointer to a buffer to store the first link name found for <i>lpFileName</i>.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle that can be used with the<see cref="FindNextFileNameW" /> function or closed with the<see cref="FindClose" /> function.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b> (0xffffffff). To get extended error information, call the <see cref="GetLastError" />function.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFile">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to the root and all subdirectories on the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about a found file or directory.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFileA">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to the root and all subdirectories on the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about a found file or directory.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstFileW">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to the root and all subdirectories on the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about a found file or directory.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to<see cref="FindNextFile" /> or<see cref="FindClose" />, and the<i>lpFindFileData</i> parameter contains information about the first file or directory found.</para>
      <para>If the function fails or fails to locate files from the search string in the<i>lpFileName</i> parameter, the return value is<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstStreamW">
    <summary>
      <para>Enumerates the first stream with a .$DATA stream type in the specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="FindFirstStreamTransactedW" />function.</para>
    </summary>
    <param name="lpFileName">The fully qualified file name.</param>
    <param name="InfoLevel">
      <para>The information level of the returned data. This parameter is one of the values in the<see cref="STREAM_INFO_LEVELS" /> enumeration type.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FindStreamInfoStandard</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The data is returned in a <see cref="WIN32_FIND_STREAM_DATA" /> structure.</description>
        </listheader>
      </list>
    </param>
    <param name="lpFindStreamData">A pointer to a buffer that receives the file stream data. The format of this data depends on the value of the <i>InfoLevel</i> parameter.</param>
    <param name="dwFlags">Reserved for future use. This parameter must be zero.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle that can be used in subsequent calls to the<see cref="FindNextStreamW" /> function.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If no streams can be found, the function fails and<see cref="GetLastError" /> returns<b>ERROR_HANDLE_EOF</b> (38).</para>
      <para>If the filesystem does not support streams, the function fails and<see cref="GetLastError" /> returns<b>ERROR_INVALID_PARAMETER</b> (87).</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolume">
    <summary>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</summary>
    <param name="lpszVolumeName">A pointer to a buffer that receives a null-terminated string that specifies a volume<b>GUID</b> path for the first volume that is found.</param>
    <param name="cchBufferLength">The length of the buffer to receive the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolume" /> and<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolumeA">
    <summary>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</summary>
    <param name="lpszVolumeName">A pointer to a buffer that receives a null-terminated string that specifies a volume<b>GUID</b> path for the first volume that is found.</param>
    <param name="cchBufferLength">The length of the buffer to receive the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolume" /> and<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolumeW">
    <summary>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</summary>
    <param name="lpszVolumeName">A pointer to a buffer that receives a null-terminated string that specifies a volume<b>GUID</b> path for the first volume that is found.</param>
    <param name="cchBufferLength">The length of the buffer to receive the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolume" /> and<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindNextChangeNotification">
    <summary>Requests that the operating system signal a change notification handle the next time it detects an appropriate change.</summary>
    <param name="hChangeHandle">A handle to a change notification handle created by the<see cref="FindFirstChangeNotification" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindNextFile">
    <summary>Continues a file search from a previous call to the<see cref="FindFirstFile" />,<see cref="FindFirstFileEx" />, or<see cref="FindFirstFileTransacted" /> functions.</summary>
    <param name="hFindFile">The search handle returned by a previous call to the<see cref="FindFirstFile" /> or<see cref="FindFirstFileEx" /> function.</param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about the found file or subdirectory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and the <i>lpFindFileData</i>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i>are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindNextFileA">
    <summary>Continues a file search from a previous call to the<see cref="FindFirstFile" />,<see cref="FindFirstFileEx" />, or<see cref="FindFirstFileTransacted" /> functions.</summary>
    <param name="hFindFile">The search handle returned by a previous call to the<see cref="FindFirstFile" /> or<see cref="FindFirstFileEx" /> function.</param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about the found file or subdirectory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and the <i>lpFindFileData</i>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i>are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindNextFileW">
    <summary>Continues a file search from a previous call to the<see cref="FindFirstFile" />,<see cref="FindFirstFileEx" />, or<see cref="FindFirstFileTransacted" /> functions.</summary>
    <param name="hFindFile">The search handle returned by a previous call to the<see cref="FindFirstFile" /> or<see cref="FindFirstFileEx" /> function.</param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about the found file or subdirectory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and the <i>lpFindFileData</i>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i>are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindNextFileNameW">
    <summary>Continues enumerating the hard links to a file using the handle returned by a successful call to the<see cref="FindFirstFileNameW" /> function.</summary>
    <param name="hFindStream">A handle to the enumeration that is returned by a successful call to<see cref="FindFirstFileNameW" />.</param>
    <param name="StringLength">The size of the <i>LinkName</i> parameter, in characters. If this call fails and the error is <b>ERROR_MORE_DATA</b>, the value that is returned by this parameter is the size that <i>LinkName</i> must be to contain all the data.</param>
    <param name="LinkName">A pointer to a buffer to store the first link name found for <i>lpFileName</i>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If no matching files can be found, the <see cref="GetLastError" />function returns <b>ERROR_HANDLE_EOF</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindNextFile">
    <summary>Continues a file search from a previous call to the<see cref="FindFirstFile" />,<see cref="FindFirstFileEx" />, or<see cref="FindFirstFileTransacted" /> functions.</summary>
    <param name="hFindFile">The search handle returned by a previous call to the<see cref="FindFirstFile" /> or<see cref="FindFirstFileEx" /> function.</param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about the found file or subdirectory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and the <i>lpFindFileData</i>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i>are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindNextFileA">
    <summary>Continues a file search from a previous call to the<see cref="FindFirstFile" />,<see cref="FindFirstFileEx" />, or<see cref="FindFirstFileTransacted" /> functions.</summary>
    <param name="hFindFile">The search handle returned by a previous call to the<see cref="FindFirstFile" /> or<see cref="FindFirstFileEx" /> function.</param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about the found file or subdirectory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and the <i>lpFindFileData</i>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i>are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindNextFileW">
    <summary>Continues a file search from a previous call to the<see cref="FindFirstFile" />,<see cref="FindFirstFileEx" />, or<see cref="FindFirstFileTransacted" /> functions.</summary>
    <param name="hFindFile">The search handle returned by a previous call to the<see cref="FindFirstFile" /> or<see cref="FindFirstFileEx" /> function.</param>
    <param name="lpFindFileData">A pointer to the <see cref="WIN32_FIND_DATA" /> structure that receives information about the found file or subdirectory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and the <i>lpFindFileData</i>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i>are indeterminate. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the<see cref="GetLastError" /> function returns<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
  </member>
  <member name="Windows.FindNextStreamW">
    <summary>Continues a stream search started by a previous call to the<see cref="FindFirstStreamW" /> function.</summary>
    <param name="hFindStream">The search handle returned by a previous call to the<see cref="FindFirstStreamW" /> function.</param>
    <param name="lpFindStreamData">A pointer to the<see cref="WIN32_FIND_STREAM_DATA" /> structure that receives information about the stream.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no more streams can be found,<b>GetLastError</b> returns<b>ERROR_HANDLE_EOF</b> (38).</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolume">
    <summary>Continues a volume search started by a call to the<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</summary>
    <param name="hFindVolume">The volume search handle returned by a previous call to the<see cref="FindFirstVolume" /> function.</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no matching files can be found, the<b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolumeA">
    <summary>Continues a volume search started by a call to the<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</summary>
    <param name="hFindVolume">The volume search handle returned by a previous call to the<see cref="FindFirstVolume" /> function.</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no matching files can be found, the<b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolumeW">
    <summary>Continues a volume search started by a call to the<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</summary>
    <param name="hFindVolume">The volume search handle returned by a previous call to the<see cref="FindFirstVolume" /> function.</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no matching files can be found, the<b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindVolumeClose">
    <summary>Closes the specified volume search handle. The <see cref="FindFirstVolume" /> and<see cref="FindNextVolume" /> functions use this search handle to locate volumes.</summary>
    <param name="hFindVolume">The volume search handle to be closed. This handle must have been previously opened by the<see cref="FindFirstVolume" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FlushFileBuffers">
    <summary>Flushes the buffers of a specified file and causes all buffered data to be written to a file.</summary>
    <param name="hFile">
      <para>A handle to the open file.</para>
      <para>The file handle must have the <b>GENERIC_WRITE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is a handle to a communications device, the function only flushes the transmit buffer.</para>
      <para>If <i>hFile</i> is a handle to the server end of a named pipe, the function does not return until the client has read all buffered data from the pipe.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The function fails if <i>hFile</i> is a handle to the console output. That is because the console output is not buffered. The function returns <b>FALSE</b>, and <see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>.</para>
    </returns>
  </member>
  <member name="Windows.GetCompressedFileSize">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
  </member>
  <member name="Windows.GetCompressedFileSizeA">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
  </member>
  <member name="Windows.GetCompressedFileSizeW">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
  </member>
  <member name="Windows.GetCompressedFileSize">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
  </member>
  <member name="Windows.GetCompressedFileSizeA">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
  </member>
  <member name="Windows.GetCompressedFileSizeW">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpace">
    <summary>Retrieves information about the specified disk, including the amount of free space on the disk.</summary>
    <param name="lpRootPathName">The root directory of the disk for which information is to be returned. If this parameter is<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name, it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive specification must have a trailing backslash (for example, "C:\"). The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this directory.</param>
    <param name="lpSectorsPerCluster">A pointer to a variable that receives the number of sectors per cluster.</param>
    <param name="lpBytesPerSector">A pointer to a variable that receives the number of bytes per sector.</param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpaceA">
    <summary>Retrieves information about the specified disk, including the amount of free space on the disk.</summary>
    <param name="lpRootPathName">The root directory of the disk for which information is to be returned. If this parameter is<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name, it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive specification must have a trailing backslash (for example, "C:\"). The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this directory.</param>
    <param name="lpSectorsPerCluster">A pointer to a variable that receives the number of sectors per cluster.</param>
    <param name="lpBytesPerSector">A pointer to a variable that receives the number of bytes per sector.</param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpaceW">
    <summary>Retrieves information about the specified disk, including the amount of free space on the disk.</summary>
    <param name="lpRootPathName">The root directory of the disk for which information is to be returned. If this parameter is<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name, it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive specification must have a trailing backslash (for example, "C:\"). The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this directory.</param>
    <param name="lpSectorsPerCluster">A pointer to a variable that receives the number of sectors per cluster.</param>
    <param name="lpBytesPerSector">A pointer to a variable that receives the number of bytes per sector.</param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpaceEx">
    <summary>Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free space, and the total amount of free space available to the user that is associated with the calling thread.</summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example, "\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this<br />directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpaceExA">
    <summary>Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free space, and the total amount of free space available to the user that is associated with the calling thread.</summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example, "\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this<br />directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpaceExW">
    <summary>Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free space, and the total amount of free space available to the user that is associated with the calling thread.</summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example, "\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this<br />directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpaceEx">
    <summary>Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free space, and the total amount of free space available to the user that is associated with the calling thread.</summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example, "\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this<br />directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpaceExA">
    <summary>Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free space, and the total amount of free space available to the user that is associated with the calling thread.</summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example, "\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this<br />directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpaceExW">
    <summary>Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free space, and the total amount of free space available to the user that is associated with the calling thread.</summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example, "\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this<br />directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpace">
    <summary>Retrieves information about the specified disk, including the amount of free space on the disk.</summary>
    <param name="lpRootPathName">The root directory of the disk for which information is to be returned. If this parameter is<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name, it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive specification must have a trailing backslash (for example, "C:\"). The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this directory.</param>
    <param name="lpSectorsPerCluster">A pointer to a variable that receives the number of sectors per cluster.</param>
    <param name="lpBytesPerSector">A pointer to a variable that receives the number of bytes per sector.</param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpaceA">
    <summary>Retrieves information about the specified disk, including the amount of free space on the disk.</summary>
    <param name="lpRootPathName">The root directory of the disk for which information is to be returned. If this parameter is<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name, it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive specification must have a trailing backslash (for example, "C:\"). The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this directory.</param>
    <param name="lpSectorsPerCluster">A pointer to a variable that receives the number of sectors per cluster.</param>
    <param name="lpBytesPerSector">A pointer to a variable that receives the number of bytes per sector.</param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskFreeSpaceW">
    <summary>Retrieves information about the specified disk, including the amount of free space on the disk.</summary>
    <param name="lpRootPathName">The root directory of the disk for which information is to be returned. If this parameter is<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name, it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive specification must have a trailing backslash (for example, "C:\"). The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this directory.</param>
    <param name="lpSectorsPerCluster">A pointer to a variable that receives the number of sectors per cluster.</param>
    <param name="lpBytesPerSector">A pointer to a variable that receives the number of bytes per sector.</param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDiskSpaceInformation">
    <summary>Gets disk space information for a volume at a given root path.</summary>
    <param name="rootPath">
      <para>A pointer to a string that contains the root directory of the volume to be queried.</para>
      <para>If this parameter is <code>NULL</code>, the function uses the root of the current disk.</para>
    </param>
    <param name="diskSpaceInfo">A <see cref="DISK_SPACE_INFORMATION" /> structure containing information about the current disk space for the volume at the given root path.</param>
    <returns>Returns <code>TRUE</code> if the function succeeds, or <code>FALSE</code> if it fails. To get extended error information, call the <code>GetLastError</code> function.</returns>
  </member>
  <member name="Windows.GetDiskSpaceInformationA">
    <summary>Gets disk space information for a volume at a given root path.</summary>
    <param name="rootPath">
      <para>A pointer to a string that contains the root directory of the volume to be queried.</para>
      <para>If this parameter is <code>NULL</code>, the function uses the root of the current disk.</para>
    </param>
    <param name="diskSpaceInfo">A <see cref="DISK_SPACE_INFORMATION" /> structure containing information about the current disk space for the volume at the given root path.</param>
    <returns>Returns <code>TRUE</code> if the function succeeds, or <code>FALSE</code> if it fails. To get extended error information, call the <code>GetLastError</code> function.</returns>
  </member>
  <member name="Windows.GetDiskSpaceInformation">
    <summary>Gets disk space information for a volume at a given root path.</summary>
    <param name="rootPath">
      <para>A pointer to a string that contains the root directory of the volume to be queried.</para>
      <para>If this parameter is <code>NULL</code>, the function uses the root of the current disk.</para>
    </param>
    <param name="diskSpaceInfo">A <see cref="DISK_SPACE_INFORMATION" /> structure containing information about the current disk space for the volume at the given root path.</param>
    <returns>Returns <code>TRUE</code> if the function succeeds, or <code>FALSE</code> if it fails. To get extended error information, call the <code>GetLastError</code> function.</returns>
  </member>
  <member name="Windows.GetDiskSpaceInformationW">
    <summary>Gets disk space information for a volume at a given root path.</summary>
    <param name="rootPath">
      <para>A pointer to a string that contains the root directory of the volume to be queried.</para>
      <para>If this parameter is <code>NULL</code>, the function uses the root of the current disk.</para>
    </param>
    <param name="diskSpaceInfo">A <see cref="DISK_SPACE_INFORMATION" /> structure containing information about the current disk space for the volume at the given root path.</param>
    <returns>Returns <code>TRUE</code> if the function succeeds, or <code>FALSE</code> if it fails. To get extended error information, call the <code>GetLastError</code> function.</returns>
  </member>
  <member name="Windows.GetDriveType">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.</para>
      <para>To determine whether a drive is a USB-type drive, call<see cref="SetupDiGetDeviceRegistryProperty" />and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The drive type cannot be determined.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The root path is invalid; for example, there is no volume mounted at the specified path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOVABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_FIXED</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The drive has fixed media; for example, a hard disk drive or flash drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOTE</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a remote (network) drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_CDROM</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a CD-ROM drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_RAMDISK</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a RAM disk.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetDriveTypeA">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.</para>
      <para>To determine whether a drive is a USB-type drive, call<see cref="SetupDiGetDeviceRegistryProperty" />and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The drive type cannot be determined.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The root path is invalid; for example, there is no volume mounted at the specified path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOVABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_FIXED</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The drive has fixed media; for example, a hard disk drive or flash drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOTE</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a remote (network) drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_CDROM</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a CD-ROM drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_RAMDISK</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a RAM disk.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetDriveTypeW">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.</para>
      <para>To determine whether a drive is a USB-type drive, call<see cref="SetupDiGetDeviceRegistryProperty" />and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The drive type cannot be determined.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The root path is invalid; for example, there is no volume mounted at the specified path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOVABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_FIXED</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The drive has fixed media; for example, a hard disk drive or flash drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOTE</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a remote (network) drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_CDROM</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a CD-ROM drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_RAMDISK</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a RAM disk.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetDriveType">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.</para>
      <para>To determine whether a drive is a USB-type drive, call<see cref="SetupDiGetDeviceRegistryProperty" />and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The drive type cannot be determined.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The root path is invalid; for example, there is no volume mounted at the specified path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOVABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_FIXED</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The drive has fixed media; for example, a hard disk drive or flash drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOTE</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a remote (network) drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_CDROM</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a CD-ROM drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_RAMDISK</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a RAM disk.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetDriveTypeA">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.</para>
      <para>To determine whether a drive is a USB-type drive, call<see cref="SetupDiGetDeviceRegistryProperty" />and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The drive type cannot be determined.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The root path is invalid; for example, there is no volume mounted at the specified path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOVABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_FIXED</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The drive has fixed media; for example, a hard disk drive or flash drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOTE</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a remote (network) drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_CDROM</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a CD-ROM drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_RAMDISK</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a RAM disk.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetDriveTypeW">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.</para>
      <para>To determine whether a drive is a USB-type drive, call<see cref="SetupDiGetDeviceRegistryProperty" />and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The drive type cannot be determined.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The root path is invalid; for example, there is no volume mounted at the specified path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOVABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_FIXED</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The drive has fixed media; for example, a hard disk drive or flash drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_REMOTE</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a remote (network) drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_CDROM</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a CD-ROM drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DRIVE_RAMDISK</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The drive is a RAM disk.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetFileAttributes">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a list of attribute values and their descriptions, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileAttributesA">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a list of attribute values and their descriptions, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileAttributesW">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a list of attribute values and their descriptions, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileAttributesEx">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>GetFileExInfoStandard</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>lpFileInformation</i> parameter is a <see cref="WIN32_FILE_ATTRIBUTE_DATA" /> structure.</description>
        </listheader>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileAttributesExA">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>GetFileExInfoStandard</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>lpFileInformation</i> parameter is a <see cref="WIN32_FILE_ATTRIBUTE_DATA" /> structure.</description>
        </listheader>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileAttributesExW">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>GetFileExInfoStandard</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>lpFileInformation</i> parameter is a <see cref="WIN32_FILE_ATTRIBUTE_DATA" /> structure.</description>
        </listheader>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileAttributesEx">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>GetFileExInfoStandard</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>lpFileInformation</i> parameter is a <see cref="WIN32_FILE_ATTRIBUTE_DATA" /> structure.</description>
        </listheader>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileAttributesExA">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>GetFileExInfoStandard</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>lpFileInformation</i> parameter is a <see cref="WIN32_FILE_ATTRIBUTE_DATA" /> structure.</description>
        </listheader>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileAttributesExW">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>GetFileExInfoStandard</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>lpFileInformation</i> parameter is a <see cref="WIN32_FILE_ATTRIBUTE_DATA" /> structure.</description>
        </listheader>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileAttributes">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a list of attribute values and their descriptions, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileAttributesA">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a list of attribute values and their descriptions, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileAttributesW">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a list of attribute values and their descriptions, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileInformationByHandle">
    <summary>
      <para>Retrieves file information for the specified file.</para>
      <para>For a more advanced version of this function, see<see cref="GetFileInformationByHandleEx" />.</para>
      <para>To set file information using a file handle, see<see cref="SetFileInformationByHandle" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file that contains the information to be retrieved.</para>
      <para>This handle should not be a pipe handle.</para>
    </param>
    <param name="lpFileInformation">A pointer to a<see cref="BY_HANDLE_FILE_INFORMATION" /> structure that receives the file information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and file information data is contained in the buffer pointed to by the <i>lpFileInformation</i> parameter.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileSize">
    <summary>
      <para>Retrieves the size of the specified file, in bytes.</para>
      <para>It is recommended that you use <see cref="GetFileSizeEx" />.</para>
    </summary>
    <param name="hFile">A handle to the file.</param>
    <param name="lpFileSizeHigh">A pointer to the variable where the high-order doubleword of the file size is returned. This parameter can be <b>NULL</b> if the application does not require the high-order doubleword.</param>
    <returns>
      <para>If the function succeeds, the return value is the low-order doubleword of the file size, and, if<i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order doubleword of the file size into the variable pointed to by that parameter.</para>
      <para>If the function fails and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call<see cref="GetLastError" />. When<i>lpFileSizeHigh</i> is <b>NULL</b>, the results returned for large files are ambiguous, and you will not be able to determine the actual size of the file. It is recommended that you use <see cref="GetFileSizeEx" /> instead.</para>
      <para>If the function fails and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b> and<see cref="GetLastError" /> will return a value other than<b>NO_ERROR</b>.</para>
    </returns>
  </member>
  <member name="Windows.GetFileSizeEx">
    <summary>Retrieves the size of the specified file.</summary>
    <param name="hFile">A handle to the file. The handle must have been created with the<b>FILE_READ_ATTRIBUTES</b> access right or equivalent, or the caller must have sufficient permission on the directory that contains the file. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</param>
    <param name="lpFileSize">A pointer to a <see cref="LARGE_INTEGER" /> structure that receives the file size, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileTime">
    <summary>Retrieves the date and time that a file or directory was created, last accessed, and last modified.</summary>
    <param name="hFile">A handle to the file or directory for which dates and times are to be retrieved. The handle must have been created using the <see cref="CreateFile" /> function with the<b>GENERIC_READ</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</param>
    <param name="lpCreationTime">A pointer to a <see cref="FILETIME" /> structure to receive the date and time the file or directory was created. This parameter can be <b>NULL</b> if the application does not require this information.</param>
    <param name="lpLastAccessTime">A pointer to a <see cref="FILETIME" /> structure to receive the date and time the file or directory was last accessed. The last access time includes the last time the file or directory was written to, read from, or, in the case of executable files, run. This parameter can be<b>NULL</b> if the application does not require this information.</param>
    <param name="lpLastWriteTime">A pointer to a <see cref="FILETIME" /> structure to receive the date and time the file or directory was last written to, truncated, or overwritten (for example, with <see cref="WriteFile" /> or<see cref="SetEndOfFile" />). This date and time is not updated when file attributes or security descriptors are changed. This parameter can be <b>NULL</b> if the application does not require this information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileType">
    <summary>Retrieves the file type of the specified file.</summary>
    <param name="hFile">A handle to the file.</param>
    <returns>
      <para>The function returns one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_TYPE_CHAR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>The specified file is a character file, typically an LPT device or a console.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_TYPE_DISK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>The specified file is a disk file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_TYPE_PIPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0003</term>
              </listheader>
            </list>
          </description>
          <description>The specified file is a socket, a named pipe, or an anonymous pipe.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_TYPE_REMOTE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x8000</term>
              </listheader>
            </list>
          </description>
          <description>Unused.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_TYPE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0000</term>
              </listheader>
            </list>
          </description>
          <description>Either the type of the specified file is unknown, or the function failed.</description>
        </listheader>
      </list> <para>You can distinguish between a "valid" return of <b>FILE_TYPE_UNKNOWN</b> and its return due to a calling error (for example, passing an invalid handle to<b>GetFileType</b>) by calling<see cref="GetLastError" />.</para><para>If the function worked properly and <b>FILE_TYPE_UNKNOWN</b> was returned, a call to <b>GetLastError</b> will return <b>NO_ERROR</b>.</para><para>If the function returned <b>FILE_TYPE_UNKNOWN</b> due to an error in calling<b>GetFileType</b>,<see cref="GetLastError" /> will return the error code.</para></returns>
  </member>
  <member name="Windows.GetFinalPathNameByHandle">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">A handle to a file or directory.</param>
    <param name="lpszFilePath">A pointer to a buffer that receives the path of <i>hFile</i>.</param>
    <param name="cchFilePath">The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</param>
    <param name="dwFlags">
      <para>The type of result to return. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_NORMALIZED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>Return the normalized drive name. This is the default.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_OPENED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x8</term>
              </listheader>
            </list>
          </description>
          <description>Return the opened file name (not normalized).</description>
        </listheader>
      </list> <para>This parameter can also include one of the following values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_DOS</b></term></listheader><listheader><term>0x0</term></listheader></list></description><description>Return the path with the drive letter. This is the default.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_GUID</b></term></listheader><listheader><term>0x1</term></listheader></list></description><description>Return the path with a volume <b>GUID</b> path instead of the drive name.</description></listheader><listheader><description><list type="bullet"><listheader><term><b> VOLUME_NAME_NONE</b></term></listheader><listheader><term>0x4</term></listheader></list></description><description>Return the path with no drive information.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_NT</b></term></listheader><listheader><term>0x2</term></listheader></list></description><description>Return the path with the volume device path.</description></listheader></list></param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,<b>GetFinalPathNameByHandleA</b>, the return value includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the terminating null character, the return value is the required buffer size, in<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Can be returned if you are searching for a drive letter and one does not exist. For example, the handle was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to identify it.<para>This return value can also be returned if you are searching for a volume <b>GUID</b>path on a network share. Volume <b>GUID</b> paths are not created for network shares.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Invalid flags were specified for <i>dwFlags</i>.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetFinalPathNameByHandleA">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">A handle to a file or directory.</param>
    <param name="lpszFilePath">A pointer to a buffer that receives the path of <i>hFile</i>.</param>
    <param name="cchFilePath">The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</param>
    <param name="dwFlags">
      <para>The type of result to return. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_NORMALIZED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>Return the normalized drive name. This is the default.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_OPENED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x8</term>
              </listheader>
            </list>
          </description>
          <description>Return the opened file name (not normalized).</description>
        </listheader>
      </list> <para>This parameter can also include one of the following values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_DOS</b></term></listheader><listheader><term>0x0</term></listheader></list></description><description>Return the path with the drive letter. This is the default.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_GUID</b></term></listheader><listheader><term>0x1</term></listheader></list></description><description>Return the path with a volume <b>GUID</b> path instead of the drive name.</description></listheader><listheader><description><list type="bullet"><listheader><term><b> VOLUME_NAME_NONE</b></term></listheader><listheader><term>0x4</term></listheader></list></description><description>Return the path with no drive information.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_NT</b></term></listheader><listheader><term>0x2</term></listheader></list></description><description>Return the path with the volume device path.</description></listheader></list></param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,<b>GetFinalPathNameByHandleA</b>, the return value includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the terminating null character, the return value is the required buffer size, in<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Can be returned if you are searching for a drive letter and one does not exist. For example, the handle was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to identify it.<para>This return value can also be returned if you are searching for a volume <b>GUID</b>path on a network share. Volume <b>GUID</b> paths are not created for network shares.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Invalid flags were specified for <i>dwFlags</i>.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetFinalPathNameByHandleW">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">A handle to a file or directory.</param>
    <param name="lpszFilePath">A pointer to a buffer that receives the path of <i>hFile</i>.</param>
    <param name="cchFilePath">The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</param>
    <param name="dwFlags">
      <para>The type of result to return. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_NORMALIZED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>Return the normalized drive name. This is the default.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_OPENED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x8</term>
              </listheader>
            </list>
          </description>
          <description>Return the opened file name (not normalized).</description>
        </listheader>
      </list> <para>This parameter can also include one of the following values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_DOS</b></term></listheader><listheader><term>0x0</term></listheader></list></description><description>Return the path with the drive letter. This is the default.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_GUID</b></term></listheader><listheader><term>0x1</term></listheader></list></description><description>Return the path with a volume <b>GUID</b> path instead of the drive name.</description></listheader><listheader><description><list type="bullet"><listheader><term><b> VOLUME_NAME_NONE</b></term></listheader><listheader><term>0x4</term></listheader></list></description><description>Return the path with no drive information.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_NT</b></term></listheader><listheader><term>0x2</term></listheader></list></description><description>Return the path with the volume device path.</description></listheader></list></param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,<b>GetFinalPathNameByHandleA</b>, the return value includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the terminating null character, the return value is the required buffer size, in<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Can be returned if you are searching for a drive letter and one does not exist. For example, the handle was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to identify it.<para>This return value can also be returned if you are searching for a volume <b>GUID</b>path on a network share. Volume <b>GUID</b> paths are not created for network shares.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Invalid flags were specified for <i>dwFlags</i>.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetFinalPathNameByHandle">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">A handle to a file or directory.</param>
    <param name="lpszFilePath">A pointer to a buffer that receives the path of <i>hFile</i>.</param>
    <param name="cchFilePath">The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</param>
    <param name="dwFlags">
      <para>The type of result to return. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_NORMALIZED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>Return the normalized drive name. This is the default.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_OPENED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x8</term>
              </listheader>
            </list>
          </description>
          <description>Return the opened file name (not normalized).</description>
        </listheader>
      </list> <para>This parameter can also include one of the following values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_DOS</b></term></listheader><listheader><term>0x0</term></listheader></list></description><description>Return the path with the drive letter. This is the default.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_GUID</b></term></listheader><listheader><term>0x1</term></listheader></list></description><description>Return the path with a volume <b>GUID</b> path instead of the drive name.</description></listheader><listheader><description><list type="bullet"><listheader><term><b> VOLUME_NAME_NONE</b></term></listheader><listheader><term>0x4</term></listheader></list></description><description>Return the path with no drive information.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_NT</b></term></listheader><listheader><term>0x2</term></listheader></list></description><description>Return the NT device object path.</description></listheader></list></param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,<b>GetFinalPathNameByHandleA</b>, the return value includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the terminating null character, the return value is the required buffer size, in<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Can be returned if you are searching for a drive letter and one does not exist. For example, the handle was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to identify it.<para>This return value can also be returned if you are searching for a volume <b>GUID</b>path on a network share. Volume <b>GUID</b> paths are not created for network shares.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Invalid flags were specified for <i>dwFlags</i>.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetFinalPathNameByHandleA">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">A handle to a file or directory.</param>
    <param name="lpszFilePath">A pointer to a buffer that receives the path of <i>hFile</i>.</param>
    <param name="cchFilePath">The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</param>
    <param name="dwFlags">
      <para>The type of result to return. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_NORMALIZED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>Return the normalized drive name. This is the default.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_OPENED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x8</term>
              </listheader>
            </list>
          </description>
          <description>Return the opened file name (not normalized).</description>
        </listheader>
      </list> <para>This parameter can also include one of the following values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_DOS</b></term></listheader><listheader><term>0x0</term></listheader></list></description><description>Return the path with the drive letter. This is the default.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_GUID</b></term></listheader><listheader><term>0x1</term></listheader></list></description><description>Return the path with a volume <b>GUID</b> path instead of the drive name.</description></listheader><listheader><description><list type="bullet"><listheader><term><b> VOLUME_NAME_NONE</b></term></listheader><listheader><term>0x4</term></listheader></list></description><description>Return the path with no drive information.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_NT</b></term></listheader><listheader><term>0x2</term></listheader></list></description><description>Return the NT device object path.</description></listheader></list></param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,<b>GetFinalPathNameByHandleA</b>, the return value includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the terminating null character, the return value is the required buffer size, in<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Can be returned if you are searching for a drive letter and one does not exist. For example, the handle was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to identify it.<para>This return value can also be returned if you are searching for a volume <b>GUID</b>path on a network share. Volume <b>GUID</b> paths are not created for network shares.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Invalid flags were specified for <i>dwFlags</i>.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetFinalPathNameByHandleW">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">A handle to a file or directory.</param>
    <param name="lpszFilePath">A pointer to a buffer that receives the path of <i>hFile</i>.</param>
    <param name="cchFilePath">The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</param>
    <param name="dwFlags">
      <para>The type of result to return. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_NORMALIZED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>Return the normalized drive name. This is the default.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAME_OPENED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x8</term>
              </listheader>
            </list>
          </description>
          <description>Return the opened file name (not normalized).</description>
        </listheader>
      </list> <para>This parameter can also include one of the following values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_DOS</b></term></listheader><listheader><term>0x0</term></listheader></list></description><description>Return the path with the drive letter. This is the default.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_GUID</b></term></listheader><listheader><term>0x1</term></listheader></list></description><description>Return the path with a volume <b>GUID</b> path instead of the drive name.</description></listheader><listheader><description><list type="bullet"><listheader><term><b> VOLUME_NAME_NONE</b></term></listheader><listheader><term>0x4</term></listheader></list></description><description>Return the path with no drive information.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>VOLUME_NAME_NT</b></term></listheader><listheader><term>0x2</term></listheader></list></description><description>Return the NT device object path.</description></listheader></list></param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,<b>GetFinalPathNameByHandleA</b>, the return value includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the terminating null character, the return value is the required buffer size, in<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Can be returned if you are searching for a drive letter and one does not exist. For example, the handle was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to identify it.<para>This return value can also be returned if you are searching for a volume <b>GUID</b>path on a network share. Volume <b>GUID</b> paths are not created for network shares.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Invalid flags were specified for <i>dwFlags</i>.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetFullPathName">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <div>
        <b>Note</b> See the Remarks section for discussion of the use of relative paths with the <b>GetFullPathName</b> function in multithreaded applications or shared library code.</div>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume name.</para>
    </param>
    <param name="nBufferLength">The size of the buffer to receive the null-terminated string for the drive and path, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the null-terminated string for the drive and path.</param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final file name component in the path.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFullPathNameA">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <div>
        <b>Note</b> See the Remarks section for discussion of the use of relative paths with the <b>GetFullPathName</b> function in multithreaded applications or shared library code.</div>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume name.</para>
    </param>
    <param name="nBufferLength">The size of the buffer to receive the null-terminated string for the drive and path, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the null-terminated string for the drive and path.</param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final file name component in the path.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFullPathNameW">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <div>
        <b>Note</b> See the Remarks section for discussion of the use of relative paths with the <b>GetFullPathName</b> function in multithreaded applications or shared library code.</div>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume name.</para>
    </param>
    <param name="nBufferLength">The size of the buffer to receive the null-terminated string for the drive and path, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the null-terminated string for the drive and path.</param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final file name component in the path.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFullPathName">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <div>
        <b>Note</b> See the Remarks section for discussion of the use of relative paths with the <b>GetFullPathName</b> function in multithreaded applications or shared library code.</div>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume name.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="nBufferLength">The size of the buffer to receive the null-terminated string for the drive and path, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the null-terminated string for the drive and path.</param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final file name component in the path.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFullPathNameA">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <div>
        <b>Note</b> See the Remarks section for discussion of the use of relative paths with the <b>GetFullPathName</b> function in multithreaded applications or shared library code.</div>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume name.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="nBufferLength">The size of the buffer to receive the null-terminated string for the drive and path, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the null-terminated string for the drive and path.</param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final file name component in the path.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFullPathNameW">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <div>
        <b>Note</b> See the Remarks section for discussion of the use of relative paths with the <b>GetFullPathName</b> function in multithreaded applications or shared library code.</div>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume name.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="nBufferLength">The size of the buffer to receive the null-terminated string for the drive and path, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the null-terminated string for the drive and path.</param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final file name component in the path.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetLogicalDrives">
    <summary>Retrieves a bitmask representing the currently available disk drives.</summary>
    <returns>
      <para>If the function succeeds, the return value is a bitmask representing the currently available disk drives. Bit position 0 (the least-significant bit) is drive A, bit position 1 is drive B, bit position 2 is drive C, and so on.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetLogicalDriveStrings">
    <summary>Fills a buffer with strings that specify valid drives in the system.</summary>
    <param name="nBufferLength">The maximum size of the buffer pointed to by <i>lpBuffer</i>, in<b>TCHARs</b>. This size does not include the terminating null character. If this parameter is zero, <i>lpBuffer</i> is not used.</param>
    <param name="lpBuffer">A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the system, plus with an additional null character. Each string is a device name.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>. It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetLogicalDriveStringsA">
    <summary>Fills a buffer with strings that specify valid drives in the system.</summary>
    <param name="nBufferLength">The maximum size of the buffer pointed to by <i>lpBuffer</i>, in<b>TCHARs</b>. This size does not include the terminating null character. If this parameter is zero, <i>lpBuffer</i> is not used.</param>
    <param name="lpBuffer">A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the system, plus with an additional null character. Each string is a device name.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>. It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetLogicalDriveStringsW">
    <summary>Fills a buffer with strings that specify valid drives in the system.</summary>
    <param name="nBufferLength">The maximum size of the buffer pointed to by <i>lpBuffer</i>, in<b>TCHARs</b>. This size does not include the terminating null character. If this parameter is zero, <i>lpBuffer</i> is not used.</param>
    <param name="lpBuffer">A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the system, plus with an additional null character. Each string is a device name.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>. It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetLongPathName">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszShortPath">The path to be converted.</param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">The size of the buffer <i>lpszLongPath</i> points to, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not exist, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetLongPathNameA">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszShortPath">The path to be converted.</param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">The size of the buffer <i>lpszLongPath</i> points to, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not exist, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetLongPathNameW">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszShortPath">The path to be converted.</param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">The size of the buffer <i>lpszLongPath</i> points to, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not exist, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetLongPathName">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>
        <para>[!IMPORTANT]<br />To use this function, the caller must have the following permissions on the specified path and parent directories:</para>
        <list type="bullet">
          <item>
            <description>List Folder</description>
          </item>
          <item>
            <description>Read Data</description>
          </item>
          <item>
            <description>Read Attributes</description>
          </item>
        </list>
      </blockquote>
    </summary>
    <param name="lpszShortPath">
      <para>The path to be converted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">The size of the buffer <i>lpszLongPath</i> points to, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not exist, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetLongPathNameA">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>
        <para>[!IMPORTANT]<br />To use this function, the caller must have the following permissions on the specified path and parent directories:</para>
        <list type="bullet">
          <item>
            <description>List Folder</description>
          </item>
          <item>
            <description>Read Data</description>
          </item>
          <item>
            <description>Read Attributes</description>
          </item>
        </list>
      </blockquote>
    </summary>
    <param name="lpszShortPath">
      <para>The path to be converted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">The size of the buffer <i>lpszLongPath</i> points to, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not exist, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetLongPathNameW">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>
        <para>[!IMPORTANT]<br />To use this function, the caller must have the following permissions on the specified path and parent directories:</para>
        <list type="bullet">
          <item>
            <description>List Folder</description>
          </item>
          <item>
            <description>Read Data</description>
          </item>
          <item>
            <description>Read Attributes</description>
          </item>
        </list>
      </blockquote>
    </summary>
    <param name="lpszShortPath">
      <para>The path to be converted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">The size of the buffer <i>lpszLongPath</i> points to, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not exist, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetShortPathName">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer that <i>lpszShortPath</i> points to, in<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string that is copied to <i>lpszShortPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetShortPathNameA">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer that <i>lpszShortPath</i> points to, in<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string that is copied to <i>lpszShortPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetShortPathNameW">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer that <i>lpszShortPath</i> points to, in<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string that is copied to <i>lpszShortPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetTempFileName">
    <summary>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.</summary>
    <param name="lpPathName">The directory path for the file name. Applications typically specify a period (.) for the current directory or the result of the <see cref="GetTempPath" /> function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or<b>GetTempFileName</b> will fail. If this parameter is<b>NULL</b>, the function fails.</param>
    <param name="lpPrefixString">The null-terminated prefix string. The function uses up to the first three characters of this string as the prefix of the file name. This string must consist of characters in the OEM-defined character set.</param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the file already exists, the number is increased by one and the functions tests if this file already exists. This continues until a unique filename is found; the function creates a file by that name and closes it. Note that the function does not attempt to verify the uniqueness of the file name when<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">A pointer to the buffer that receives the temporary file name. This buffer should be<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUFFER_OVERFLOW</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The length of the string pointed to by the <i>lpPathName</i> parameter is more than <b>MAX_PATH</b>–14 characters.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetTempFileNameA">
    <summary>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.</summary>
    <param name="lpPathName">The directory path for the file name. Applications typically specify a period (.) for the current directory or the result of the <see cref="GetTempPath" /> function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or<b>GetTempFileName</b> will fail. If this parameter is<b>NULL</b>, the function fails.</param>
    <param name="lpPrefixString">The null-terminated prefix string. The function uses up to the first three characters of this string as the prefix of the file name. This string must consist of characters in the OEM-defined character set.</param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the file already exists, the number is increased by one and the functions tests if this file already exists. This continues until a unique filename is found; the function creates a file by that name and closes it. Note that the function does not attempt to verify the uniqueness of the file name when<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">A pointer to the buffer that receives the temporary file name. This buffer should be<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUFFER_OVERFLOW</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The length of the string pointed to by the <i>lpPathName</i> parameter is more than <b>MAX_PATH</b>–14 characters.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetTempFileNameW">
    <summary>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.</summary>
    <param name="lpPathName">The directory path for the file name. Applications typically specify a period (.) for the current directory or the result of the <see cref="GetTempPath" /> function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or<b>GetTempFileName</b> will fail. If this parameter is<b>NULL</b>, the function fails.</param>
    <param name="lpPrefixString">The null-terminated prefix string. The function uses up to the first three characters of this string as the prefix of the file name. This string must consist of characters in the OEM-defined character set.</param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the file already exists, the number is increased by one and the functions tests if this file already exists. This continues until a unique filename is found; the function creates a file by that name and closes it. Note that the function does not attempt to verify the uniqueness of the file name when<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">A pointer to the buffer that receives the temporary file name. This buffer should be<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUFFER_OVERFLOW</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The length of the string pointed to by the <i>lpPathName</i> parameter is more than <b>MAX_PATH</b>–14 characters.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetTempFileName">
    <summary>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.</summary>
    <param name="lpPathName">The directory path for the file name. Applications typically specify a period (.) for the current directory or the result of the <see cref="GetTempPath" /> function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or<b>GetTempFileName</b> will fail. If this parameter is<b>NULL</b>, the function fails.</param>
    <param name="lpPrefixString">The null-terminated prefix string. The function uses up to the first three characters of this string as the prefix of the file name. This string must consist of characters in the OEM-defined character set.</param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the file already exists, the number is increased by one and the function tests if this file already exists. This continues until a unique filename is found; the function creates a file by that name and closes it. Note that the function does not attempt to verify the uniqueness of the file name when<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">A pointer to the buffer that receives the temporary file name. This buffer should be<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUFFER_OVERFLOW</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The length of the string pointed to by the <i>lpPathName</i> parameter is more than <b>MAX_PATH</b>–14 characters.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetTempFileNameA">
    <summary>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.</summary>
    <param name="lpPathName">The directory path for the file name. Applications typically specify a period (.) for the current directory or the result of the <see cref="GetTempPath" /> function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or<b>GetTempFileName</b> will fail. If this parameter is<b>NULL</b>, the function fails.</param>
    <param name="lpPrefixString">The null-terminated prefix string. The function uses up to the first three characters of this string as the prefix of the file name. This string must consist of characters in the OEM-defined character set.</param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the file already exists, the number is increased by one and the function tests if this file already exists. This continues until a unique filename is found; the function creates a file by that name and closes it. Note that the function does not attempt to verify the uniqueness of the file name when<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">A pointer to the buffer that receives the temporary file name. This buffer should be<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUFFER_OVERFLOW</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The length of the string pointed to by the <i>lpPathName</i> parameter is more than <b>MAX_PATH</b>–14 characters.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetTempFileNameW">
    <summary>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.</summary>
    <param name="lpPathName">The directory path for the file name. Applications typically specify a period (.) for the current directory or the result of the <see cref="GetTempPath" /> function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or<b>GetTempFileName</b> will fail. If this parameter is<b>NULL</b>, the function fails.</param>
    <param name="lpPrefixString">The null-terminated prefix string. The function uses up to the first three characters of this string as the prefix of the file name. This string must consist of characters in the OEM-defined character set.</param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the file already exists, the number is increased by one and the function tests if this file already exists. This continues until a unique filename is found; the function creates a file by that name and closes it. Note that the function does not attempt to verify the uniqueness of the file name when<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">A pointer to the buffer that receives the temporary file name. This buffer should be<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUFFER_OVERFLOW</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The length of the string pointed to by the <i>lpPathName</i> parameter is more than <b>MAX_PATH</b>–14 characters.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetTempPath2A">
    <summary>Retrieves the path of the directory designated for temporary files, based on the privileges of the calling process.</summary>
    <param name="BufferLength">The size of the string buffer identified by <i>lpBuffer</i>, in<b>TCHARs</b>.</param>
    <param name="Buffer">A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. The returned string ends with a backslash, for example, "C:\TEMP\".</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, the return value is the length, in<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
  </member>
  <member name="Windows.GetTempPath2W">
    <summary>Retrieves the path of the directory designated for temporary files, based on the privileges of the calling process.</summary>
    <param name="BufferLength">The size of the string buffer identified by <i>lpBuffer</i>, in<b>TCHARs</b>.</param>
    <param name="Buffer">A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. The returned string ends with a backslash, for example, "C:\TEMP\".</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, the return value is the length, in<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
  </member>
  <member name="Windows.GetTempPath">
    <summary>Retrieves the path of the directory designated for temporary files.</summary>
    <param name="nBufferLength">The size of the string buffer identified by <i>lpBuffer</i>, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. The returned string ends with a backslash, for example, "C:\TEMP\".</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, the return value is the length, in<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
  </member>
  <member name="Windows.GetTempPathA">
    <summary>Retrieves the path of the directory designated for temporary files.</summary>
    <param name="nBufferLength">The size of the string buffer identified by <i>lpBuffer</i>, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. The returned string ends with a backslash, for example, "C:\TEMP\".</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, the return value is the length, in<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
  </member>
  <member name="Windows.GetTempPathW">
    <summary>Retrieves the path of the directory designated for temporary files.</summary>
    <param name="nBufferLength">The size of the string buffer identified by <i>lpBuffer</i>, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. The returned string ends with a backslash, for example, "C:\TEMP\".</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, the return value is the length, in<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
  </member>
  <member name="Windows.GetTempPath">
    <summary>Retrieves the path of the directory designated for temporary files.</summary>
    <param name="nBufferLength">The size of the string buffer identified by <i>lpBuffer</i>, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. The returned string ends with a backslash, for example, "C:\TEMP\".</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, the return value is the length, in<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
  </member>
  <member name="Windows.GetTempPathA">
    <summary>Retrieves the path of the directory designated for temporary files.</summary>
    <param name="nBufferLength">The size of the string buffer identified by <i>lpBuffer</i>, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. The returned string ends with a backslash, for example, "C:\TEMP\".</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, the return value is the length, in<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
  </member>
  <member name="Windows.GetTempPathW">
    <summary>Retrieves the path of the directory designated for temporary files.</summary>
    <param name="nBufferLength">The size of the string buffer identified by <i>lpBuffer</i>, in<b>TCHARs</b>.</param>
    <param name="lpBuffer">A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. The returned string ends with a backslash, for example, "C:\TEMP\".</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to <i>lpBuffer</i>, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, the return value is the length, in<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
  </member>
  <member name="Windows.GetVolumeInformation">
    <summary>
      <para>Retrieves information about the file system and volume associated with the specified root directory.</para>
      <para>To specify a handle when retrieving this information, use the <see cref="GetVolumeInformationByHandleW" /> function.</para>
      <para>To retrieve the current compression state of a file or directory, use <a href="https://docs.microsoft.com//windows/win32/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the root directory of the volume to be described.</para>
      <para>If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing backslash is required. For example, you specify \\MyServer\MyShare as "\\MyServer\MyShare\", or the C drive as "C:\".</para>
    </param>
    <param name="lpVolumeNameBuffer">A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the <i>nVolumeNameSize</i> parameter.</param>
    <param name="nVolumeNameSize">
      <para>The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>s+1.</para>
      <para>This parameter is ignored if the volume name buffer is not supplied.</para>
    </param>
    <param name="lpVolumeSerialNumber">
      <para>A pointer to a variable that receives the volume serial number.</para>
      <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
      <para>This function returns the volume serial number that the operating system assigns when a hard disk is formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the Windows Management Instrumentation (WMI) <a href="https://docs.microsoft.com//previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a> property <b>SerialNumber</b>.</para>
    </param>
    <param name="lpMaximumComponentLength">
      <para>A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file name component that a specified file system supports.</para>
      <para>A file name component is the portion of a file name between backslashes.</para>
      <para>The value that is stored in the variable that *<i>lpMaximumComponentLength</i> points to is used to indicate that a specified file system supports long names. For example, for a FAT file system that supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can also be supported on systems that use the NTFS file system.</para>
    </param>
    <param name="lpFileSystemFlags">
      <para>A pointer to a variable that receives flags associated with the specified file system.</para>
      <para>This parameter can be one or more of the following flags. However, <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually exclusive.</para>
      <para>| Value | Meaning | |--------|--------| | <b>FILE_CASE_SENSITIVE_SEARCH</b><br />0x00000001 | The specified volume supports case-sensitive file names. | | <b>FILE_CASE_PRESERVED_NAMES</b><br />0x00000002 | The specified volume supports preserved case of file names when it places a name on disk. | | <b>FILE_UNICODE_ON_DISK</b><br />0x00000004 | The specified volume supports Unicode in file names as they appear on disk. | | <b>FILE_PERSISTENT_ACLS</b><br />0x00000008 | The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system preserves and enforces ACLs, and the FAT file system does not. | | <b>FILE_FILE_COMPRESSION</b><br />0x00000010 | The specified volume supports file-based compression. | | <b>FILE_VOLUME_QUOTAS</b><br />0x00000020 | The specified volume supports disk quotas. | | <b>FILE_SUPPORTS_SPARSE_FILES</b><br />0x00000040 | The specified volume supports sparse files. | | <b>FILE_SUPPORTS_REPARSE_POINTS</b><br />0x00000080 | The specified volume supports reparse points.<br /><br /><b>ReFS:</b> ReFS supports reparse points but does not index them so <see cref="FindFirstVolumeMountPoint" /> and <see cref="FindNextVolumeMountPoint" /> will not function as expected. | | <b>FILE_SUPPORTS_REMOTE_STORAGE</b><br />0x00000100 | The file system supports remote storage. | | <b>FILE_RETURNS_CLEANUP_RESULT_INFO</b><br />0x00000200 | On a successful cleanup operation, the file system returns information that describes additional actions taken during cleanup, such as deleting the file. File system filters can examine this information in their post-cleanup callback. | | <b>FILE_SUPPORTS_POSIX_UNLINK_RENAME</b><br />0x00000400 | The file system supports POSIX-style delete and rename operations. | | <b>FILE_VOLUME_IS_COMPRESSED</b><br />0x00008000 | The specified volume is a compressed volume, for example, a DoubleSpace volume. | | <b>FILE_SUPPORTS_OBJECT_IDS</b><br />0x00010000 | The specified volume supports object identifiers. | | <b>FILE_SUPPORTS_ENCRYPTION</b><br />0x00020000 | The specified volume supports the Encrypted File System (EFS). For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/file-encryption">File Encryption</a>. | | <b>FILE_NAMED_STREAMS</b><br />0x00040000 | The specified volume supports named streams. | | <b>FILE_READ_ONLY_VOLUME</b><br />0x00080000 | The specified volume is read-only. | | <b>FILE_SEQUENTIAL_WRITE_ONCE</b><br />0x00100000 | The specified volume supports a single sequential write. | | <b>FILE_SUPPORTS_TRANSACTIONS</b><br />0x00200000 | The specified volume supports transactions. For more information, see <a href="https://docs.microsoft.com//windows/win32/Ktm/about-ktm">About KTM</a>. | | <b>FILE_SUPPORTS_HARD_LINKS</b><br />0x00400000 | The specified volume supports hard links. For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b><br />0x00800000 | The specified volume supports extended attributes. An extended attribute is a piece of application-specific metadata that an application can associate with a file and is not part of the file's data.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b><br />0x01000000 | The file system supports open by FileID. For more information, see <see cref="FILE_ID_BOTH_DIR_INFO" />.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_USN_JOURNAL</b><br />0x02000000 | The specified volume supports update sequence number (USN) journals. For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/change-journal-records">Change Journal Records</a>.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_INTEGRITY_STREAMS</b><br />0x04000000 | The file system supports <a href="https://docs.microsoft.com//windows-server/storage/refs/integrity-streams">integrity streams</a>. | | <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b><br />0x08000000 | The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that <b>FSCTL_DUPLICATE_EXTENTS_TO_FILE</b> is a supported operation. | | <b>FILE_SUPPORTS_SPARSE_VDL</b><br />0x10000000 | The file system tracks whether each cluster of a file contains valid data (either from explicit file writes or automatic zeros) or invalid data (has not yet been written to or zeroed). File systems that use sparse valid data length (VDL) do not store a valid data length and do not require that valid data be contiguous within a file. | | <b>FILE_DAX_VOLUME</b><br />0x20000000 | The specified volume is a direct access (DAX) volume.<br /><br /><b>Note:</b><br />This flag was introduced in Windows 10, version 1607. | | <b>FILE_SUPPORTS_GHOSTING</b><br />0x40000000 | The file system supports ghosting. |</para>
    </param>
    <param name="lpFileSystemNameBuffer">A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</param>
    <param name="nFileSystemNameSize">
      <para>The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the file system name buffer is not supplied.</para>
    </param>
    <returns>
      <para>If all the requested information is retrieved, the return value is nonzero.</para>
      <para>If not all the requested information is retrieved, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumeInformationA">
    <summary>
      <para>Retrieves information about the file system and volume associated with the specified root directory.</para>
      <para>To specify a handle when retrieving this information, use the <see cref="GetVolumeInformationByHandleW" /> function.</para>
      <para>To retrieve the current compression state of a file or directory, use <a href="https://docs.microsoft.com//windows/win32/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the root directory of the volume to be described.</para>
      <para>If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing backslash is required. For example, you specify \\MyServer\MyShare as "\\MyServer\MyShare\", or the C drive as "C:\".</para>
    </param>
    <param name="lpVolumeNameBuffer">A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the <i>nVolumeNameSize</i> parameter.</param>
    <param name="nVolumeNameSize">
      <para>The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>s+1.</para>
      <para>This parameter is ignored if the volume name buffer is not supplied.</para>
    </param>
    <param name="lpVolumeSerialNumber">
      <para>A pointer to a variable that receives the volume serial number.</para>
      <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
      <para>This function returns the volume serial number that the operating system assigns when a hard disk is formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the Windows Management Instrumentation (WMI) <a href="https://docs.microsoft.com//previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a> property <b>SerialNumber</b>.</para>
    </param>
    <param name="lpMaximumComponentLength">
      <para>A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file name component that a specified file system supports.</para>
      <para>A file name component is the portion of a file name between backslashes.</para>
      <para>The value that is stored in the variable that *<i>lpMaximumComponentLength</i> points to is used to indicate that a specified file system supports long names. For example, for a FAT file system that supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can also be supported on systems that use the NTFS file system.</para>
    </param>
    <param name="lpFileSystemFlags">
      <para>A pointer to a variable that receives flags associated with the specified file system.</para>
      <para>This parameter can be one or more of the following flags. However, <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually exclusive.</para>
      <para>| Value | Meaning | |--------|--------| | <b>FILE_CASE_SENSITIVE_SEARCH</b><br />0x00000001 | The specified volume supports case-sensitive file names. | | <b>FILE_CASE_PRESERVED_NAMES</b><br />0x00000002 | The specified volume supports preserved case of file names when it places a name on disk. | | <b>FILE_UNICODE_ON_DISK</b><br />0x00000004 | The specified volume supports Unicode in file names as they appear on disk. | | <b>FILE_PERSISTENT_ACLS</b><br />0x00000008 | The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system preserves and enforces ACLs, and the FAT file system does not. | | <b>FILE_FILE_COMPRESSION</b><br />0x00000010 | The specified volume supports file-based compression. | | <b>FILE_VOLUME_QUOTAS</b><br />0x00000020 | The specified volume supports disk quotas. | | <b>FILE_SUPPORTS_SPARSE_FILES</b><br />0x00000040 | The specified volume supports sparse files. | | <b>FILE_SUPPORTS_REPARSE_POINTS</b><br />0x00000080 | The specified volume supports reparse points.<br /><br /><b>ReFS:</b> ReFS supports reparse points but does not index them so <see cref="FindFirstVolumeMountPoint" /> and <see cref="FindNextVolumeMountPoint" /> will not function as expected. | | <b>FILE_SUPPORTS_REMOTE_STORAGE</b><br />0x00000100 | The file system supports remote storage. | | <b>FILE_RETURNS_CLEANUP_RESULT_INFO</b><br />0x00000200 | On a successful cleanup operation, the file system returns information that describes additional actions taken during cleanup, such as deleting the file. File system filters can examine this information in their post-cleanup callback. | | <b>FILE_SUPPORTS_POSIX_UNLINK_RENAME</b><br />0x00000400 | The file system supports POSIX-style delete and rename operations. | | <b>FILE_VOLUME_IS_COMPRESSED</b><br />0x00008000 | The specified volume is a compressed volume, for example, a DoubleSpace volume. | | <b>FILE_SUPPORTS_OBJECT_IDS</b><br />0x00010000 | The specified volume supports object identifiers. | | <b>FILE_SUPPORTS_ENCRYPTION</b><br />0x00020000 | The specified volume supports the Encrypted File System (EFS). For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/file-encryption">File Encryption</a>. | | <b>FILE_NAMED_STREAMS</b><br />0x00040000 | The specified volume supports named streams. | | <b>FILE_READ_ONLY_VOLUME</b><br />0x00080000 | The specified volume is read-only. | | <b>FILE_SEQUENTIAL_WRITE_ONCE</b><br />0x00100000 | The specified volume supports a single sequential write. | | <b>FILE_SUPPORTS_TRANSACTIONS</b><br />0x00200000 | The specified volume supports transactions. For more information, see <a href="https://docs.microsoft.com//windows/win32/Ktm/about-ktm">About KTM</a>. | | <b>FILE_SUPPORTS_HARD_LINKS</b><br />0x00400000 | The specified volume supports hard links. For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b><br />0x00800000 | The specified volume supports extended attributes. An extended attribute is a piece of application-specific metadata that an application can associate with a file and is not part of the file's data.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b><br />0x01000000 | The file system supports open by FileID. For more information, see <see cref="FILE_ID_BOTH_DIR_INFO" />.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_USN_JOURNAL</b><br />0x02000000 | The specified volume supports update sequence number (USN) journals. For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/change-journal-records">Change Journal Records</a>.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_INTEGRITY_STREAMS</b><br />0x04000000 | The file system supports <a href="https://docs.microsoft.com//windows-server/storage/refs/integrity-streams">integrity streams</a>. | | <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b><br />0x08000000 | The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that <b>FSCTL_DUPLICATE_EXTENTS_TO_FILE</b> is a supported operation. | | <b>FILE_SUPPORTS_SPARSE_VDL</b><br />0x10000000 | The file system tracks whether each cluster of a file contains valid data (either from explicit file writes or automatic zeros) or invalid data (has not yet been written to or zeroed). File systems that use sparse valid data length (VDL) do not store a valid data length and do not require that valid data be contiguous within a file. | | <b>FILE_DAX_VOLUME</b><br />0x20000000 | The specified volume is a direct access (DAX) volume.<br /><br /><b>Note:</b><br />This flag was introduced in Windows 10, version 1607. | | <b>FILE_SUPPORTS_GHOSTING</b><br />0x40000000 | The file system supports ghosting. |</para>
    </param>
    <param name="lpFileSystemNameBuffer">A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</param>
    <param name="nFileSystemNameSize">
      <para>The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the file system name buffer is not supplied.</para>
    </param>
    <returns>
      <para>If all the requested information is retrieved, the return value is nonzero.</para>
      <para>If not all the requested information is retrieved, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumeInformationW">
    <summary>
      <para>Retrieves information about the file system and volume associated with the specified root directory.</para>
      <para>To specify a handle when retrieving this information, use the <see cref="GetVolumeInformationByHandleW" /> function.</para>
      <para>To retrieve the current compression state of a file or directory, use <a href="https://docs.microsoft.com//windows/win32/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the root directory of the volume to be described.</para>
      <para>If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing backslash is required. For example, you specify \\MyServer\MyShare as "\\MyServer\MyShare\", or the C drive as "C:\".</para>
    </param>
    <param name="lpVolumeNameBuffer">A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the <i>nVolumeNameSize</i> parameter.</param>
    <param name="nVolumeNameSize">
      <para>The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>s+1.</para>
      <para>This parameter is ignored if the volume name buffer is not supplied.</para>
    </param>
    <param name="lpVolumeSerialNumber">
      <para>A pointer to a variable that receives the volume serial number.</para>
      <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
      <para>This function returns the volume serial number that the operating system assigns when a hard disk is formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the Windows Management Instrumentation (WMI) <a href="https://docs.microsoft.com//previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a> property <b>SerialNumber</b>.</para>
    </param>
    <param name="lpMaximumComponentLength">
      <para>A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file name component that a specified file system supports.</para>
      <para>A file name component is the portion of a file name between backslashes.</para>
      <para>The value that is stored in the variable that *<i>lpMaximumComponentLength</i> points to is used to indicate that a specified file system supports long names. For example, for a FAT file system that supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can also be supported on systems that use the NTFS file system.</para>
    </param>
    <param name="lpFileSystemFlags">
      <para>A pointer to a variable that receives flags associated with the specified file system.</para>
      <para>This parameter can be one or more of the following flags. However, <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually exclusive.</para>
      <para>| Value | Meaning | |--------|--------| | <b>FILE_CASE_SENSITIVE_SEARCH</b><br />0x00000001 | The specified volume supports case-sensitive file names. | | <b>FILE_CASE_PRESERVED_NAMES</b><br />0x00000002 | The specified volume supports preserved case of file names when it places a name on disk. | | <b>FILE_UNICODE_ON_DISK</b><br />0x00000004 | The specified volume supports Unicode in file names as they appear on disk. | | <b>FILE_PERSISTENT_ACLS</b><br />0x00000008 | The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system preserves and enforces ACLs, and the FAT file system does not. | | <b>FILE_FILE_COMPRESSION</b><br />0x00000010 | The specified volume supports file-based compression. | | <b>FILE_VOLUME_QUOTAS</b><br />0x00000020 | The specified volume supports disk quotas. | | <b>FILE_SUPPORTS_SPARSE_FILES</b><br />0x00000040 | The specified volume supports sparse files. | | <b>FILE_SUPPORTS_REPARSE_POINTS</b><br />0x00000080 | The specified volume supports reparse points.<br /><br /><b>ReFS:</b> ReFS supports reparse points but does not index them so <see cref="FindFirstVolumeMountPoint" /> and <see cref="FindNextVolumeMountPoint" /> will not function as expected. | | <b>FILE_SUPPORTS_REMOTE_STORAGE</b><br />0x00000100 | The file system supports remote storage. | | <b>FILE_RETURNS_CLEANUP_RESULT_INFO</b><br />0x00000200 | On a successful cleanup operation, the file system returns information that describes additional actions taken during cleanup, such as deleting the file. File system filters can examine this information in their post-cleanup callback. | | <b>FILE_SUPPORTS_POSIX_UNLINK_RENAME</b><br />0x00000400 | The file system supports POSIX-style delete and rename operations. | | <b>FILE_VOLUME_IS_COMPRESSED</b><br />0x00008000 | The specified volume is a compressed volume, for example, a DoubleSpace volume. | | <b>FILE_SUPPORTS_OBJECT_IDS</b><br />0x00010000 | The specified volume supports object identifiers. | | <b>FILE_SUPPORTS_ENCRYPTION</b><br />0x00020000 | The specified volume supports the Encrypted File System (EFS). For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/file-encryption">File Encryption</a>. | | <b>FILE_NAMED_STREAMS</b><br />0x00040000 | The specified volume supports named streams. | | <b>FILE_READ_ONLY_VOLUME</b><br />0x00080000 | The specified volume is read-only. | | <b>FILE_SEQUENTIAL_WRITE_ONCE</b><br />0x00100000 | The specified volume supports a single sequential write. | | <b>FILE_SUPPORTS_TRANSACTIONS</b><br />0x00200000 | The specified volume supports transactions. For more information, see <a href="https://docs.microsoft.com//windows/win32/Ktm/about-ktm">About KTM</a>. | | <b>FILE_SUPPORTS_HARD_LINKS</b><br />0x00400000 | The specified volume supports hard links. For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b><br />0x00800000 | The specified volume supports extended attributes. An extended attribute is a piece of application-specific metadata that an application can associate with a file and is not part of the file's data.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b><br />0x01000000 | The file system supports open by FileID. For more information, see <see cref="FILE_ID_BOTH_DIR_INFO" />.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_USN_JOURNAL</b><br />0x02000000 | The specified volume supports update sequence number (USN) journals. For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/change-journal-records">Change Journal Records</a>.<br /><br /><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</b> This value is not supported until Windows Server 2008 R2 and Windows 7. | | <b>FILE_SUPPORTS_INTEGRITY_STREAMS</b><br />0x04000000 | The file system supports <a href="https://docs.microsoft.com//windows-server/storage/refs/integrity-streams">integrity streams</a>. | | <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b><br />0x08000000 | The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that <b>FSCTL_DUPLICATE_EXTENTS_TO_FILE</b> is a supported operation. | | <b>FILE_SUPPORTS_SPARSE_VDL</b><br />0x10000000 | The file system tracks whether each cluster of a file contains valid data (either from explicit file writes or automatic zeros) or invalid data (has not yet been written to or zeroed). File systems that use sparse valid data length (VDL) do not store a valid data length and do not require that valid data be contiguous within a file. | | <b>FILE_DAX_VOLUME</b><br />0x20000000 | The specified volume is a direct access (DAX) volume.<br /><br /><b>Note:</b><br />This flag was introduced in Windows 10, version 1607. | | <b>FILE_SUPPORTS_GHOSTING</b><br />0x40000000 | The file system supports ghosting. |</para>
    </param>
    <param name="lpFileSystemNameBuffer">A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</param>
    <param name="nFileSystemNameSize">
      <para>The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the file system name buffer is not supplied.</para>
    </param>
    <returns>
      <para>If all the requested information is retrieved, the return value is nonzero.</para>
      <para>If not all the requested information is retrieved, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumeInformationByHandleW">
    <summary>
      <para>Retrieves information about the file system and volume associated with the specified file.</para>
      <para>To retrieve the current compression state of a file or directory, use <a href="https://docs.microsoft.com//windows/win32/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>.</para>
    </summary>
    <param name="hFile">A handle to the file.</param>
    <param name="lpVolumeNameBuffer">A pointer to a buffer that receives the name of a specified volume. The maximum buffer size is <code>MAX_PATH+1</code>.</param>
    <param name="nVolumeNameSize">
      <para>The length of a volume name buffer, in <b>WCHAR</b>s. The maximum buffer size is <code>MAX_PATH+1</code>.</para>
      <para>This parameter is ignored if the volume name buffer is not supplied.</para>
    </param>
    <param name="lpVolumeSerialNumber">
      <para>A pointer to a variable that receives the volume serial number.</para>
      <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
      <para>This function returns the volume serial number that the operating system assigns when a hard disk is formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the Windows Management Instrumentation (WMI) <a href="https://docs.microsoft.com//previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a> property <b>SerialNumber</b>.</para>
    </param>
    <param name="lpMaximumComponentLength">
      <para>A pointer to a variable that receives the maximum length, in <b>WCHAR</b>s, of a file name component that a specified file system supports.</para>
      <para>A file name component is the portion of a file name between backslashes.</para>
      <para>The value that is stored in the variable that *<i>lpMaximumComponentLength</i> points to is used to indicate that a specified file system supports long names. For example, for a FAT file system that supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can also be supported on systems that use the NTFS file system.</para>
    </param>
    <param name="lpFileSystemFlags">
      <para>A pointer to a variable that receives flags associated with the specified file system.</para>
      <para>This parameter can be one or more of the following flags. However, <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually exclusive.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_CASE_SENSITIVE_SEARCH</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports case-sensitive file names.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_CASE_PRESERVED_NAMES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports preserved case of file names when it places a name on disk.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_UNICODE_ON_DISK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports Unicode in file names as they appear on disk.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_PERSISTENT_ACLS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system preserves and enforces ACLs, and the FAT file system does not.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FILE_COMPRESSION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports file-based compression.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_VOLUME_QUOTAS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports disk quotas.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SUPPORTS_SPARSE_FILES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports sparse files.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SUPPORTS_REPARSE_POINTS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000080</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports re-parse points.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_VOLUME_IS_COMPRESSED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00008000</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume is a compressed volume, for example, a DoubleSpace volume.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SUPPORTS_OBJECT_IDS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00010000</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports object identifiers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SUPPORTS_ENCRYPTION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00020000</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports the Encrypted File System (EFS). For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/file-encryption">File Encryption</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NAMED_STREAMS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00040000</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports named streams.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_READ_ONLY_VOLUME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00080000</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume is read-only.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SEQUENTIAL_WRITE_ONCE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00100000</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports a single sequential write.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SUPPORTS_TRANSACTIONS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00200000</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports transactions. For more information, see <a href="https://docs.microsoft.com//windows/win32/Ktm/about-ktm">About KTM</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SUPPORTS_HARD_LINKS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00400000</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports hard links. For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.<para><b>Windows Vista and Windows Server 2008: </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00800000</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports extended attributes. An extended attribute is a piece of application-specific metadata that an application can associate with a file and is not part of the file's data.<para><b>Windows Vista and Windows Server 2008: </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b>
                </term>
              </listheader>
              <listheader>
                <term>0x01000000</term>
              </listheader>
            </list>
          </description>
          <description>The file system supports open by FileID. For more information, see <see cref="FILE_ID_BOTH_DIR_INFO" />.<para><b>Windows Vista and Windows Server 2008: </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SUPPORTS_USN_JOURNAL</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02000000</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports update sequence number (USN) journals. For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/change-journal-records">Change Journal Records</a>.<para><b>Windows Vista and Windows Server 2008:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08000000</term>
              </listheader>
            </list>
          </description>
          <description>The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.</description>
        </listheader>
      </list>
    </param>
    <param name="lpFileSystemNameBuffer">A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</param>
    <param name="nFileSystemNameSize">
      <para>The length of the file system name buffer, in <b>WCHAR</b>s. The maximum buffer size is <code>MAX_PATH+1</code>.</para>
      <para>This parameter is ignored if the file system name buffer is not supplied.</para>
    </param>
    <returns>
      <para>If all the requested information is retrieved, the return value is nonzero.</para>
      <para>If not all the requested information is retrieved, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPoint">
    <summary>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point ( drive letter, volume <b>GUID</b> path, or mounted folder).</summary>
    <param name="lpszVolumeMountPoint">A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\") or a drive letter (for example, "X:\"). The string must end with a trailing backslash ('\').</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</param>
    <param name="cchBufferLength">The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPointA">
    <summary>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point ( drive letter, volume <b>GUID</b> path, or mounted folder).</summary>
    <param name="lpszVolumeMountPoint">A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\") or a drive letter (for example, "X:\"). The string must end with a trailing backslash ('\').</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</param>
    <param name="cchBufferLength">The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPointW">
    <summary>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point ( drive letter, volume <b>GUID</b> path, or mounted folder).</summary>
    <param name="lpszVolumeMountPoint">A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\") or a drive letter (for example, "X:\"). The string must end with a trailing backslash ('\').</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</param>
    <param name="cchBufferLength">The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeName">
    <summary>Retrieves a list of drive letters and mounted folder paths for the specified volume.</summary>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. A volume <b>GUID</b>path is of the form "\\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\".</param>
    <param name="lpszVolumePathNames">A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an array of null-terminated strings terminated by an additional <b>NULL</b> character. If the buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</param>
    <param name="cchBufferLength">The length of the <i>lpszVolumePathNames</i> buffer, in<b>TCHARs</b>, including all <b>NULL</b> characters.</param>
    <param name="lpcchReturnLength">If the call is successful, this parameter is the number of <b>TCHARs</b> copied to the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer required to hold the complete list, in <b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If the buffer is not large enough to hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeNameA">
    <summary>Retrieves a list of drive letters and mounted folder paths for the specified volume.</summary>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. A volume <b>GUID</b>path is of the form "\\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\".</param>
    <param name="lpszVolumePathNames">A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an array of null-terminated strings terminated by an additional <b>NULL</b> character. If the buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</param>
    <param name="cchBufferLength">The length of the <i>lpszVolumePathNames</i> buffer, in<b>TCHARs</b>, including all <b>NULL</b> characters.</param>
    <param name="lpcchReturnLength">If the call is successful, this parameter is the number of <b>TCHARs</b> copied to the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer required to hold the complete list, in <b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If the buffer is not large enough to hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeNameW">
    <summary>Retrieves a list of drive letters and mounted folder paths for the specified volume.</summary>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. A volume <b>GUID</b>path is of the form "\\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\".</param>
    <param name="lpszVolumePathNames">A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an array of null-terminated strings terminated by an additional <b>NULL</b> character. If the buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</param>
    <param name="cchBufferLength">The length of the <i>lpszVolumePathNames</i> buffer, in<b>TCHARs</b>, including all <b>NULL</b> characters.</param>
    <param name="lpcchReturnLength">If the call is successful, this parameter is the number of <b>TCHARs</b> copied to the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer required to hold the complete list, in <b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If the buffer is not large enough to hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumePathName">
    <summary>Retrieves the volume mount point where the specified path is mounted.</summary>
    <param name="lpszFileName">
      <para>A pointer to the input path string. Both absolute and relative file and directory names, for example, "..", are acceptable in this path.</para>
      <para>If you specify a relative directory or file name without a volume qualifier, <b>GetVolumePathName</b> returns the drive letter of the boot volume.</para>
      <para>If this parameter is an empty string, "", the function fails but the last error is set to <b>ERROR_SUCCESS</b>.</para>
    </param>
    <param name="lpszVolumePathName">A pointer to a string that receives the volume mount point for the input path.</param>
    <param name="cchBufferLength">The length of the output buffer, in <b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumePathNameA">
    <summary>Retrieves the volume mount point where the specified path is mounted.</summary>
    <param name="lpszFileName">
      <para>A pointer to the input path string. Both absolute and relative file and directory names, for example, "..", are acceptable in this path.</para>
      <para>If you specify a relative directory or file name without a volume qualifier, <b>GetVolumePathName</b> returns the drive letter of the boot volume.</para>
      <para>If this parameter is an empty string, "", the function fails but the last error is set to <b>ERROR_SUCCESS</b>.</para>
    </param>
    <param name="lpszVolumePathName">A pointer to a string that receives the volume mount point for the input path.</param>
    <param name="cchBufferLength">The length of the output buffer, in <b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumePathNameW">
    <summary>Retrieves the volume mount point where the specified path is mounted.</summary>
    <param name="lpszFileName">
      <para>A pointer to the input path string. Both absolute and relative file and directory names, for example, "..", are acceptable in this path.</para>
      <para>If you specify a relative directory or file name without a volume qualifier, <b>GetVolumePathName</b> returns the drive letter of the boot volume.</para>
      <para>If this parameter is an empty string, "", the function fails but the last error is set to <b>ERROR_SUCCESS</b>.</para>
    </param>
    <param name="lpszVolumePathName">A pointer to a string that receives the volume mount point for the input path.</param>
    <param name="cchBufferLength">The length of the output buffer, in <b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LocalFileTimeToFileTime">
    <summary>Converts a local file time to a file time based on the Coordinated Universal Time (UTC).</summary>
    <param name="lpLocalFileTime">A pointer to a <see cref="FILETIME" /> structure that specifies the local file time to be converted into a UTC-based file time.</param>
    <param name="lpFileTime">A pointer to a <see cref="FILETIME" /> structure to receive the converted UTC-based file time. This parameter cannot be the same as the<i>lpLocalFileTime</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.LockFile">
    <summary>
      <para>Locks the specified file for exclusive access by the calling process.</para>
      <para>To specify additional options, for example creating a shared lock or for block-on-fail operation, use the<see cref="LockFileEx" /> function.</para>
    </summary>
    <param name="hFile">A handle to the file. The file handle must have been created with the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</param>
    <param name="dwFileOffsetLow">The low-order 32 bits of the starting byte offset in the file where the lock should begin.</param>
    <param name="dwFileOffsetHigh">The high-order 32 bits of the starting byte offset in the file where the lock should begin.</param>
    <param name="nNumberOfBytesToLockLow">The low-order 32 bits of the length of the byte range to be locked.</param>
    <param name="nNumberOfBytesToLockHigh">The high-order 32 bits of the length of the byte range to be locked.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero (<b>TRUE</b>).</para>
      <para>If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LockFileEx">
    <summary>Locks the specified file for exclusive access by the calling process. This function can operate either synchronously or asynchronously and can request either an exclusive or a shared lock.</summary>
    <param name="hFile">A handle to the file. The handle must have been created with either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</param>
    <param name="dwFlags">
      <para>This parameter may be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOCKFILE_EXCLUSIVE_LOCK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The function requests an exclusive lock. Otherwise, it requests a shared lock.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOCKFILE_FAIL_IMMEDIATELY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The function returns immediately if it is unable to acquire the requested lock. Otherwise, it waits.</description>
        </listheader>
      </list>
    </param>
    <param name="dwReserved">Reserved parameter; must be set to zero.</param>
    <param name="nNumberOfBytesToLockLow">The low-order 32 bits of the length of the byte range to lock.</param>
    <param name="nNumberOfBytesToLockHigh">The high-order 32 bits of the length of the byte range to lock.</param>
    <param name="lpOverlapped">A pointer to an<see cref="OVERLAPPED" /> structure that the function uses with the locking request. This structure, which is required, contains the file offset of the beginning of the lock range. You must initialize the <b>hEvent</b> member to a valid handle or zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero (<b>TRUE</b>).</para>
      <para>If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryDosDevice">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The<b>QueryDosDevice</b> function enables an application to query the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the<b>QueryDosDevice</b> function will store a list of all existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or more null-terminated strings. The final null-terminated string is followed by an additional<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by<i>lpTargetPath</i>.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
  </member>
  <member name="Windows.QueryDosDeviceA">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The<b>QueryDosDevice</b> function enables an application to query the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the<b>QueryDosDevice</b> function will store a list of all existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or more null-terminated strings. The final null-terminated string is followed by an additional<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by<i>lpTargetPath</i>.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
  </member>
  <member name="Windows.QueryDosDeviceW">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The<b>QueryDosDevice</b> function enables an application to query the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the<b>QueryDosDevice</b> function will store a list of all existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or more null-terminated strings. The final null-terminated string is followed by an additional<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by<i>lpTargetPath</i>.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
  </member>
  <member name="Windows.ReadFileEx">
    <summary>
      <para>Reads data from the specified file or input/output (I/O) device. It reports its completion status asynchronously, calling the specified completion routine when reading is completed or canceled and the calling thread is in an alertable wait state.</para>
      <para>To read data from a file or device synchronously, use the<see cref="ReadFile" /> function.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe).</para>
      <para>This parameter can be any handle opened with the <b>FILE_FLAG_OVERLAPPED</b> flag by the<see cref="CreateFile" /> function, or a socket handle returned by the<see cref="socket" /> or<see cref="accept" /> function.</para>
      <para>This handle also must have the <b>GENERIC_READ</b> access right. For more information on access rights, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the data read from the file or device.</para>
      <para>This buffer must remain valid for the duration of the read operation. The application should not use this buffer until the read operation is completed.</para>
    </param>
    <param name="nNumberOfBytesToRead">The number of bytes to be read.</param>
    <param name="lpOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> data structure that supplies data to be used during the asynchronous (overlapped) file read operation.</para>
      <para>For files that support byte offsets, you must specify a byte offset at which to start reading from the file. You specify this offset by setting the <b>Offset</b> and<b>OffsetHigh</b> members of the<see cref="OVERLAPPED" /> structure. For files or devices that do not support byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are ignored.</para>
      <para>The <b>ReadFileEx</b> function ignores the<see cref="OVERLAPPED" /> structure's<b>hEvent</b> member. An application is free to use that member for its own purposes in the context of a <b>ReadFileEx</b> call.<b>ReadFileEx</b> signals completion of its read operation by calling, or queuing a call to, the completion routine pointed to by<i>lpCompletionRoutine</i>, so it does not need an event handle.</para>
      <para>The <b>ReadFileEx</b> function does use the<see cref="OVERLAPPED" /> structure's<b>Internal</b> and <b>InternalHigh</b> members. An application should not set these members.</para>
      <para>The <see cref="OVERLAPPED" /> data structure must remain valid for the duration of the read operation. It should not be a variable that can go out of scope while the read operation is pending completion.</para>
    </param>
    <param name="lpCompletionRoutine">A pointer to the completion routine to be called when the read operation is complete and the calling thread is in an alertable wait state. For more information about the completion routine, see<a href="https://docs.microsoft.com//windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the function succeeds, the calling thread has an asynchronous I/O operation pending: the overlapped read operation from the file. When this I/O operation completes, and the calling thread is blocked in an alertable wait state, the system calls the function pointed to by <i>lpCompletionRoutine</i>, and the wait state completes with a return code of <b>WAIT_IO_COMPLETION</b>.</para>
      <para>If the function succeeds, and the file reading operation completes, but the calling thread is not in an alertable wait state, the system queues the completion routine call, holding the call until the calling thread enters an alertable wait state. For information about alertable waits and overlapped input/output operations, see <a href="https://docs.microsoft.com//windows/desktop/Sync/about-synchronization">About Synchronization</a>.</para>
      <para>If <b>ReadFileEx</b> attempts to read past the end-of-file (EOF), the call to<see cref="GetOverlappedResult" /> for that operation returns<b>FALSE</b> and <see cref="GetLastError" />returns <b>ERROR_HANDLE_EOF</b>.</para>
    </returns>
  </member>
  <member name="Windows.ReadFileScatter">
    <summary>
      <para>Reads data from a file and stores it in an array of buffers.</para>
      <para>The function starts reading data from the file at a position that is specified by an<see cref="OVERLAPPED" /> structure. The<b>ReadFileScatter</b> function operates asynchronously.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file to be read.</para>
      <para>The file handle must be created with the <b>GENERIC_READ</b> right, and the <b>FILE_FLAG_OVERLAPPED</b> and <b>FILE_FLAG_NO_BUFFERING</b> flags. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="aSegmentArray">
      <para>A pointer to an array of <see cref="FILE_SEGMENT_ELEMENT structure" /> buffers that receives the data. For a description of this union, see <a href="https://docs.microsoft.com/#remarks">Remarks</a>.</para>
      <para>Each element can receive one page of data.</para>
      <blockquote>[!NOTE] To determine the size of a system page, use <see cref="GetSystemInfo" />.</blockquote>
      <para>The array must contain enough elements to store <i>nNumberOfBytesToRead</i> bytes of data, plus one element for the terminating <b>NULL</b>. For example, if there are 40 KB to be read and the page size is 4 KB, the array must have 11 elements that includes 10 for the data and one for the <b>NULL</b>.</para>
      <para>Each buffer must be at least the size of a system memory page and must be aligned on a system memory page size boundary. The system reads one system memory page of data into each buffer.</para>
      <para>The function stores the data in the buffers in sequential order. For example, it stores data into the first buffer, then into the second buffer, and so on until each buffer is filled and all the data is stored, or there are no more buffers.</para>
    </param>
    <param name="nNumberOfBytesToRead">The total number of bytes to be read from the file. Each element of <i>aSegmentArray</i> contains a one-page chunk of this total. Because the file must be opened with <b>FILE_FLAG_NO_BUFFERING</b>, the number of bytes must be a multiple of the sector size of the file system where the file is located.</param>
    <param name="lpReserved">This parameter is reserved for future use and must be <b>NULL</b>.</param>
    <param name="lpOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> data structure.</para>
      <para>The <b>ReadFileScatter</b> function requires a valid<see cref="OVERLAPPED" /> structure. The <i>lpOverlapped</i> parameter cannot be <b>NULL</b>.</para>
      <para>The <b>ReadFileScatter</b> function starts reading data from the file at a position that is specified by the <b>Offset</b> and <b>OffsetHigh</b> members of the <see cref="OVERLAPPED" /> structure.</para>
      <para>The <b>ReadFileScatter</b> function may return before the read operation is complete. In that scenario, the <b>ReadFileScatter</b> function returns the value 0 (zero), and the <see cref="GetLastError" /> function returns the value <b>ERROR_IO_PENDING</b>. This asynchronous operation of <b>ReadFileScatter</b> lets the calling process continue while the read operation completes. You can call the <see cref="GetOverlappedResult" />, <see cref="HasOverlappedIoCompleted" />, or <see cref="GetQueuedCompletionStatus" /> functions to obtain information about the completion of the read operation. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call the <see cref="GetLastError" /> function.</para>
      <para>If <b>ReadFileScatter</b> attempts to read past the end-of-file (EOF), the call to <see cref="GetOverlappedResult" /> for that operation returns <b>FALSE</b> and <see cref="GetLastError" /> returns <b>ERROR_HANDLE_EOF</b>.</para>
      <para>If the function returns before the read operation is complete, the function returns zero (0), and <see cref="GetLastError" /> returns <b>ERROR_IO_PENDING</b>.</para>
    </returns>
  </member>
  <member name="Windows.RemoveDirectory">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process must have delete access to the directory.</para>
      <para>By default, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.RemoveDirectoryA">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process must have delete access to the directory.</para>
      <para>By default, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.RemoveDirectoryW">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process must have delete access to the directory.</para>
      <para>By default, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.RemoveDirectory">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process must have delete access to the directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.RemoveDirectoryA">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process must have delete access to the directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.RemoveDirectoryW">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process must have delete access to the directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetEndOfFile">
    <summary>
      <para>Sets the physical file size for the specified file to the current position of the file pointer.</para>
      <para>The physical file size is also referred to as the end of the file. The <b>SetEndOfFile</b> function can be used to truncate or extend a file. To set the logical end of a file, use the <see cref="SetFileValidData" /> function.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file to be extended or truncated.</para>
      <para>The file handle must be created with the <b>GENERIC_WRITE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileApisToANSI">
    <summary>Causes the file I/O functions to use the ANSI character set code page for the current process. This function is useful for 8-bit console input and output operations.</summary>
  </member>
  <member name="Windows.SetFileApisToOEM">
    <summary>Causes the file I/O functions for the process to use the OEM character set code page. This function is useful for 8-bit console input and output operations.</summary>
  </member>
  <member name="Windows.SetFileAttributes">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that is an archive file or directory. Applications typically use this attribute to mark files for backup or removal.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is hidden. It is not included in an ordinary directory listing.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>128 (0x80)</term>
              </listheader>
            </list>
          </description>
          <description>A file that does not have other attributes set. This attribute is valid only when used alone.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </term>
              </listheader>
              <listheader>
                <term>8192 (0x2000)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is not to be indexed by the content indexing service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </term>
              </listheader>
              <listheader>
                <term>4096 (0x1000)</term>
              </listheader>
            </list>
          </description>
          <description>The data of a file is not available immediately. This attribute indicates that the file data is physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management software. Applications should not arbitrarily change this attribute.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or the System attributes of folders in Windows Server 2003, in Windows XP, or in Windows Vista.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that the operating system uses a part of, or uses exclusively.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </term>
              </listheader>
              <listheader>
                <term>256 (0x100)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because typically, an application deletes a temporary file after the handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after the handle is closed.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileAttributesA">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that is an archive file or directory. Applications typically use this attribute to mark files for backup or removal.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is hidden. It is not included in an ordinary directory listing.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>128 (0x80)</term>
              </listheader>
            </list>
          </description>
          <description>A file that does not have other attributes set. This attribute is valid only when used alone.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </term>
              </listheader>
              <listheader>
                <term>8192 (0x2000)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is not to be indexed by the content indexing service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </term>
              </listheader>
              <listheader>
                <term>4096 (0x1000)</term>
              </listheader>
            </list>
          </description>
          <description>The data of a file is not available immediately. This attribute indicates that the file data is physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management software. Applications should not arbitrarily change this attribute.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or the System attributes of folders in Windows Server 2003, in Windows XP, or in Windows Vista.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that the operating system uses a part of, or uses exclusively.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </term>
              </listheader>
              <listheader>
                <term>256 (0x100)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because typically, an application deletes a temporary file after the handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after the handle is closed.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileAttributesW">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that is an archive file or directory. Applications typically use this attribute to mark files for backup or removal.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is hidden. It is not included in an ordinary directory listing.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>128 (0x80)</term>
              </listheader>
            </list>
          </description>
          <description>A file that does not have other attributes set. This attribute is valid only when used alone.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </term>
              </listheader>
              <listheader>
                <term>8192 (0x2000)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is not to be indexed by the content indexing service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </term>
              </listheader>
              <listheader>
                <term>4096 (0x1000)</term>
              </listheader>
            </list>
          </description>
          <description>The data of a file is not available immediately. This attribute indicates that the file data is physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management software. Applications should not arbitrarily change this attribute.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or the System attributes of folders in Windows Server 2003, in Windows XP, or in Windows Vista.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that the operating system uses a part of, or uses exclusively.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </term>
              </listheader>
              <listheader>
                <term>256 (0x100)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because typically, an application deletes a temporary file after the handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after the handle is closed.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileAttributes">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that is an archive file or directory. Applications typically use this attribute to mark files for backup or removal.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is hidden. It is not included in an ordinary directory listing.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>128 (0x80)</term>
              </listheader>
            </list>
          </description>
          <description>A file that does not have other attributes set. This attribute is valid only when used alone.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </term>
              </listheader>
              <listheader>
                <term>8192 (0x2000)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is not to be indexed by the content indexing service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </term>
              </listheader>
              <listheader>
                <term>4096 (0x1000)</term>
              </listheader>
            </list>
          </description>
          <description>The data of a file is not available immediately. This attribute indicates that the file data is physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management software. Applications should not arbitrarily change this attribute.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or the System attributes of folders in Windows Server 2003, in Windows XP, or in Windows Vista.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that the operating system uses a part of, or uses exclusively.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </term>
              </listheader>
              <listheader>
                <term>256 (0x100)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because typically, an application deletes a temporary file after the handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after the handle is closed.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileAttributesA">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that is an archive file or directory. Applications typically use this attribute to mark files for backup or removal.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is hidden. It is not included in an ordinary directory listing.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>128 (0x80)</term>
              </listheader>
            </list>
          </description>
          <description>A file that does not have other attributes set. This attribute is valid only when used alone.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </term>
              </listheader>
              <listheader>
                <term>8192 (0x2000)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is not to be indexed by the content indexing service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </term>
              </listheader>
              <listheader>
                <term>4096 (0x1000)</term>
              </listheader>
            </list>
          </description>
          <description>The data of a file is not available immediately. This attribute indicates that the file data is physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management software. Applications should not arbitrarily change this attribute.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or the System attributes of folders in Windows Server 2003, in Windows XP, or in Windows Vista.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that the operating system uses a part of, or uses exclusively.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </term>
              </listheader>
              <listheader>
                <term>256 (0x100)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because typically, an application deletes a temporary file after the handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after the handle is closed.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileAttributesW">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that is an archive file or directory. Applications typically use this attribute to mark files for backup or removal.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is hidden. It is not included in an ordinary directory listing.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>128 (0x80)</term>
              </listheader>
            </list>
          </description>
          <description>A file that does not have other attributes set. This attribute is valid only when used alone.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </term>
              </listheader>
              <listheader>
                <term>8192 (0x2000)</term>
              </listheader>
            </list>
          </description>
          <description>The file or directory is not to be indexed by the content indexing service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </term>
              </listheader>
              <listheader>
                <term>4096 (0x1000)</term>
              </listheader>
            </list>
          </description>
          <description>The data of a file is not available immediately. This attribute indicates that the file data is physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management software. Applications should not arbitrarily change this attribute.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or the System attributes of folders in Windows Server 2003, in Windows XP, or in Windows Vista.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>A file or directory that the operating system uses a part of, or uses exclusively.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </term>
              </listheader>
              <listheader>
                <term>256 (0x100)</term>
              </listheader>
            </list>
          </description>
          <description>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because typically, an application deletes a temporary file after the handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after the handle is closed.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileInformationByHandle">
    <summary>
      <para>Sets the file information for the specified file.</para>
      <para>To retrieve file information using a file handle, see<see cref="GetFileInformationByHandle" /> or<see cref="GetFileInformationByHandleEx" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file for which to change information.</para>
      <para>This handle must be opened with the appropriate permissions for the requested change. For more information, see the Remarks and Example Code sections.</para>
      <para>This handle should not be a pipe handle.</para>
    </param>
    <param name="FileInformationClass">
      <para>A <see cref="FILE_INFO_BY_HANDLE_CLASS" /> enumeration value that specifies the type of information to be changed.</para>
      <para>For a table of valid values, see the Remarks section.</para>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to the buffer that contains the information to change for the specified file information class. The structure that this parameter points to corresponds to the class that is specified by<i>FileInformationClass</i>.</para>
      <para>For a table of valid structure types, see the Remarks section.</para>
    </param>
    <param name="dwBufferSize">The size of <i>lpFileInformation</i>, in bytes.</param>
    <returns>
      <para>Returns nonzero if successful or zero otherwise.</para>
      <para>To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileIoOverlappedRange">
    <summary>Associates a virtual address range with the specified file handle. This indicates that the kernel should optimize any further asynchronous I/O requests with overlapped structures inside this range. The overlapped range is locked in memory, and then unlocked when the file is closed. After a range is associated with a file handle, it cannot be disassociated.</summary>
    <param name="FileHandle">
      <para>A handle to the file.</para>
      <para>This file handle must be opened with <b>FILE_READ_ATTRIBUTES</b> access rights.</para>
    </param>
    <param name="OverlappedRangeStart">The starting address for the range.</param>
    <param name="Length">The length of the range, in bytes.</param>
    <returns>
      <para>Returns nonzero if successful or zero otherwise.</para>
      <para>To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFilePointerEx">
    <summary>Moves the file pointer of the specified file.</summary>
    <param name="hFile">A handle to the file. The file handle must have been created with the<b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</param>
    <param name="liDistanceToMove">The number of bytes to move the file pointer. A positive value moves the pointer forward in the file and a negative value moves the file pointer backward.</param>
    <param name="lpNewFilePointer">A pointer to a variable to receive the new file pointer. If this parameter is<b>NULL</b>, the new file pointer is not returned.</param>
    <param name="dwMoveMethod">
      <para>The starting point for the file pointer move. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_BEGIN</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The starting point is zero or the beginning of the file. If this flag is specified, then the <i>liDistanceToMove</i> parameter is interpreted as an unsigned value.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_CURRENT</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The start point is the current value of the file pointer.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_END</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The starting point is the current end-of-file position.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileTime">
    <summary>Sets the date and time that the specified file or directory was created, last accessed, or last modified.</summary>
    <param name="hFile">A handle to the file or directory. The handle must have been created using the <see cref="CreateFile" /> function with the <b>FILE_WRITE_ATTRIBUTES</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</param>
    <param name="lpCreationTime">A pointer to a <see cref="FILETIME" /> structure that contains the new creation date and time for the file or directory. If the application does not need to change this information, set this parameter either to <code>NULL</code> or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to <code>0</code>.</param>
    <param name="lpLastAccessTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that contains the new last access date and time for the file or directory. The last access time includes the last time the file or directory was written to, read from, or (in the case of executable files) run. If the application does not need to change this information, set this parameter either to <code>NULL</code> or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to <code>0</code>.</para>
      <para>To prevent file operations using the given handle from modifying the last access time, call <b>SetFileTime</b> immediately after opening the file handle and pass a <see cref="FILETIME" /> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to <code>0xFFFFFFFF</code>.</para>
    </param>
    <param name="lpLastWriteTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that contains the new last modified date and time for the file or directory. If the application does not need to change this information, set this parameter either to <code>NULL</code> or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to <code>0</code>.</para>
      <para>To prevent file operations using the given handle from modifying the last write time, call <b>SetFileTime</b> immediately after opening the file handle and pass a <see cref="FILETIME" /> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to <code>0xFFFFFFFF</code>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.UnlockFile">
    <summary>
      <para>Unlocks a region in an open file. Unlocking a region enables other processes to access the region.</para>
      <para>For an alternate way to specify the region, use the<see cref="UnlockFileEx" /> function.</para>
    </summary>
    <param name="hFile">A handle to the file that contains a region locked with<see cref="LockFile" />. The file handle must have been created with either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</param>
    <param name="dwFileOffsetLow">The low-order word of the starting byte offset in the file where the locked region begins.</param>
    <param name="dwFileOffsetHigh">The high-order word of the starting byte offset in the file where the locked region begins.</param>
    <param name="nNumberOfBytesToUnlockLow">The low-order word of the length of the byte range to be unlocked.</param>
    <param name="nNumberOfBytesToUnlockHigh">The high-order word of the length of the byte range to be unlocked.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.UnlockFileEx">
    <summary>Unlocks a region in the specified file. This function can operate either synchronously or asynchronously.</summary>
    <param name="hFile">A handle to the file. The handle must have been created with either the<b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</param>
    <param name="dwReserved">Reserved parameter; must be zero.</param>
    <param name="nNumberOfBytesToUnlockLow">The low-order part of the length of the byte range to unlock.</param>
    <param name="nNumberOfBytesToUnlockHigh">The high-order part of the length of the byte range to unlock.</param>
    <param name="lpOverlapped">A pointer to an <see cref="OVERLAPPED" /> structure that the function uses with the unlocking request. This structure contains the file offset of the beginning of the unlock range. You must initialize the <b>hEvent</b> member to a valid handle or zero. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero or <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteFile">
    <summary>
      <para>Writes data to the specified file or input/output (I/O) device.</para>
      <para>This function is designed for both synchronous and asynchronous operation. For a similar function designed solely for asynchronous operation, see <see cref="WriteFileEx" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe).</para>
      <para>The <i>hFile</i> parameter must have been created with the write access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>For asynchronous write operations, <i>hFile</i> can be any handle opened with the<see cref="CreateFile" /> function using the<b>FILE_FLAG_OVERLAPPED</b> flag or a socket handle returned by the<see cref="socket" /> or<see cref="accept" /> function.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to the buffer containing the data to be written to the file or device.</para>
      <para>This buffer must remain valid for the duration of the write operation. The caller must not use this buffer until the write operation is completed.</para>
    </param>
    <param name="nNumberOfBytesToWrite">
      <para>The number of bytes to be written to the file or device.</para>
      <para>A value of zero specifies a null write operation. The behavior of a null write operation depends on the underlying file system or communications technology.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>Pipe write operations across a network are limited in size per write. The amount varies per platform. For x86 platforms it's 63.97 MB. For x64 platforms it's 31.97 MB. For Itanium it's 63.95 MB. For more information regarding pipes, see the Remarks section.</para>
    </param>
    <param name="lpNumberOfBytesWritten">
      <para>A pointer to the variable that receives the number of bytes written when using a synchronous<i>hFile</i> parameter. <b>WriteFile</b> sets this value to zero before doing any work or error checking. Use <b>NULL</b> for this parameter if this is an asynchronous operation to avoid potentially erroneous results.</para>
      <para>This parameter can be <b>NULL</b> only when the <i>lpOverlapped</i>parameter is not <b>NULL</b>.</para>
      <para>
        <b>Windows 7:  </b>This parameter can not be <b>NULL</b>.</para>
      <para>For more information, see the Remarks section.</para>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> structure is required if the <i>hFile</i> parameter was opened with<b>FILE_FLAG_OVERLAPPED</b>, otherwise this parameter can be<b>NULL</b>.</para>
      <para>For an <i>hFile</i> that supports byte offsets, if you use this parameter you must specify a byte offset at which to start writing to the file or device. This offset is specified by setting the<b>Offset</b> and <b>OffsetHigh</b> members of the<see cref="OVERLAPPED" /> structure. For an<i>hFile</i> that does not support byte offsets, <b>Offset</b> and<b>OffsetHigh</b> are ignored.</para>
      <para>To write to the end of file, specify both the <b>Offset</b> and<b>OffsetHigh</b> members of the<see cref="OVERLAPPED" /> structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the<see cref="CreateFile" /> function to open<i>hFile</i> using <b>FILE_APPEND_DATA</b> access.</para>
      <para>For more information about different combinations of <i>lpOverlapped</i> and<b>FILE_FLAG_OVERLAPPED</b>, see the Remarks section and the section.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero (<b>TRUE</b>).</para>
      <para>If the function fails, or is completing asynchronously, the return value is zero (<b>FALSE</b>). To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <div>
        <b>Note</b>  The <see cref="GetLastError" /> code <b>ERROR_IO_PENDING</b> is not a failure; it designates the write operation is pending completion asynchronously. For more information, see Remarks.</div>
    </returns>
  </member>
  <member name="Windows.WriteFileEx">
    <summary>
      <para>Writes data to the specified file or input/output (I/O) device. It reports its completion status asynchronously, calling the specified completion routine when writing is completed or canceled and the calling thread is in an alertable wait state.</para>
      <para>To write data to a file or device synchronously, use the <see cref="WriteFile" /> function.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape drive, socket, communications resource, mailslot, or pipe).</para>
      <para>This parameter can be any handle opened with the <b>FILE_FLAG_OVERLAPPED</b> flag by the <see cref="CreateFile" /> function, or a socket handle returned by the <see cref="socket" /> or <see cref="accept" /> function.</para>
      <para>Do not associate an I/O completion port with this handle. For more information, see the Remarks section.</para>
      <para>This handle also must have the <b>GENERIC_WRITE</b> access right. For more information on access rights, see <a href="https://docs.microsoft.com//windows/win32/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to the buffer containing the data to be written to the file or device.</para>
      <para>This buffer must remain valid for the duration of the write operation. The caller must not use this buffer until the write operation is completed.</para>
    </param>
    <param name="nNumberOfBytesToWrite">
      <para>The number of bytes to be written to the file or device.</para>
      <para>A value of zero specifies a null write operation. The behavior of a null write operation depends on the underlying file system.</para>
      <para>Pipe write operations across a network are limited to 65,535 bytes per write. For more information regarding pipes, see the Remarks section.</para>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> data structure that supplies data to be used during the overlapped (asynchronous) write operation.</para>
      <para>For files that support byte offsets, you must specify a byte offset at which to start writing to the file. You specify this offset by setting the <b>Offset</b> and <b>OffsetHigh</b> members of the <see cref="OVERLAPPED" /> structure. For files or devices that do not support byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are ignored.</para>
      <para>To write to the end of file, specify both the <b>Offset</b> and <b>OffsetHigh</b> members of the <see cref="OVERLAPPED" /> structure as <code>0xFFFFFFFF</code>. This is functionally equivalent to previously calling the <see cref="CreateFile" /> function to open <i>hFile</i> using <b>FILE_APPEND_DATA</b> access.</para>
      <para>The <b>WriteFileEx</b> function ignores the <see cref="OVERLAPPED" /> structure's <b>hEvent</b> member. An application is free to use that member for its own purposes in the context of a <b>WriteFileEx</b> call. <b>WriteFileEx</b> signals completion of its writing operation by calling, or queuing a call to, the completion routine pointed to by <i>lpCompletionRoutine</i>, so it does not need an event handle.</para>
      <para>The <b>WriteFileEx</b> function does use the <b>Internal</b> and <b>InternalHigh</b> members of the <see cref="OVERLAPPED" /> structure. You should not change the value of these members.</para>
      <para>The <see cref="OVERLAPPED" /> data structure must remain valid for the duration of the write operation. It should not be a variable that can go out of scope while the write operation is pending completion.</para>
    </param>
    <param name="lpCompletionRoutine">A pointer to a completion routine to be called when the write operation has been completed and the calling thread is in an alertable wait state. For more information about this completion routine, see <a href="https://docs.microsoft.com//windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>If the <b>WriteFileEx</b> function succeeds, the calling thread has an asynchronous I/O operation pending: the overlapped write operation to the file. When this I/O operation finishes, and the calling thread is blocked in an alertable wait state, the operating system calls the function pointed to by <i>lpCompletionRoutine</i>, and the wait completes with a return code of <code>WAIT_IO_COMPLETION</code>.</para>
      <para>If the function succeeds and the file-writing operation finishes, but the calling thread is not in an alertable wait state, the system queues the call to *<i>lpCompletionRoutine</i>, holding the call until the calling thread enters an alertable wait state. For more information about alertable wait states and overlapped input/output operations, see <a href="https://docs.microsoft.com//windows/win32/Sync/about-synchronization">About Synchronization</a>.</para>
    </returns>
  </member>
  <member name="Windows.WriteFileGather">
    <summary>
      <para>Retrieves data from an array of buffers and writes the data to a file.</para>
      <para>The function starts writing data to the file at a position that is specified by an <see cref="OVERLAPPED" /> structure. The <b>WriteFileGather</b> function operates asynchronously.</para>
    </summary>
    <param name="hFile">A handle to the file. The file handle must be created with the <b>GENERIC_WRITE</b> access right, and the <b>FILE_FLAG_OVERLAPPED</b> and <b>FILE_FLAG_NO_BUFFERING</b> flags. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</param>
    <param name="aSegmentArray">
      <para>A pointer to an array of <see cref="FILE_SEGMENT_ELEMENT structure" /> buffers that contain the data. For a description of this union, see Remarks.</para>
      <para>Each element contains the address of one page of data.</para>
      <blockquote>[!NOTE] To determine the size of a system page, use the <see cref="GetSystemInfo" /> function.</blockquote>
      <para>The array must contain enough elements to store <i>nNumberOfBytesToWrite</i> bytes of data, and one element for the terminating <b>NULL</b>. For example, if there are 40 KB to be read and the page size is 4 KB, the array must have 11 elements that includes 10 elements for the data and one element for the <b>NULL</b>.</para>
      <para>Each buffer must be at least the size of a system memory page and must be aligned on a system memory page size boundary. The system writes one system memory page of data from each buffer.</para>
      <para>The function gathers the data from the buffers in a sequential order. For example, it writes data to the file from the first buffer, then the second buffer, and so on until there is no more data.</para>
      <para>Due to the asynchronous operation of this function, precautions must be taken to ensure that this parameter always references valid memory for the lifetime of the asynchronous writes. For instance, a common programming error is to use local stack storage and then allow execution to run out of scope.</para>
    </param>
    <param name="nNumberOfBytesToWrite">
      <para>The total number of bytes to be written. Each element of <i>aSegmentArray</i> contains a one-page chunk of this total. Because the file must be opened with <b>FILE_FLAG_NO_BUFFERING</b>, the number of bytes must be a multiple of the sector size of the file system where the file is located.</para>
      <para>If <i>nNumberOfBytesToWrite</i> is zero (0), the function performs a null write operation. The behavior of a null write operation depends on the underlying file system. If <i>nNumberOfBytesToWrite</i> is not zero (0) and the offset and length of the write place data beyond the current end of the file, the <b>WriteFileGather</b> function extends the file.</para>
    </param>
    <param name="lpReserved">This parameter is reserved for future use and must be <b>NULL</b>.</param>
    <param name="lpOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> data structure.</para>
      <para>The <b>WriteFileGather</b> function requires a valid<see cref="OVERLAPPED" /> structure. The <i>lpOverlapped</i> parameter cannot be <b>NULL</b>.</para>
      <para>The <b>WriteFileGather</b> function starts writing data to the file at a position that is specified by the <b>Offset</b> and <b>OffsetHigh</b> members of the <see cref="OVERLAPPED" /> structure.</para>
      <para>The <b>WriteFileGather</b> function may return before the write operation is complete. In that scenario, the <b>WriteFileGather</b> function returns the value zero (0), and the <see cref="GetLastError" /> function returns the value <b>ERROR_IO_PENDING</b>. This asynchronous operation of the <b>WriteFileGather</b> function lets the calling process continue while the write operation completes.</para>
      <para>You can call the <see cref="GetOverlappedResult" />, <see cref="HasOverlappedIoCompleted" />, or <see cref="GetQueuedCompletionStatus" /> function to obtain information about the completion of the write operation. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call the <see cref="GetLastError" /> function.</para>
      <para>If the function returns before the write operation is complete, the function returns zero (0), and the <see cref="GetLastError" /> function returns <b>ERROR_IO_PENDING</b>.</para>
    </returns>
  </member>
</doc>