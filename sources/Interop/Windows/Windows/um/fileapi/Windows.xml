<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AreFileApisANSI">
    <summary>
      <para>Determines whether the file I/O functions are using the ANSI or OEM character set code
page. This function is useful for 8-bit console input and output operations.</para>
    </summary>
    <returns>
      <para>If the set of file I/O functions is using the ANSI code page, the return value is nonzero.</para>
      <para>If the set of file I/O functions is using the OEM code page, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <see cref="SetFileApisToOEM" /> function causes a set of file
I/O functions to use the OEM code page. The
<see cref="SetFileApisToANSI" /> function causes the same set of file
I/O functions to use the ANSI code page. Use the <b>AreFileApisANSI</b> function to
determine which code page the set of file I/O functions is currently using. For a discussion of these functions'
usage, please see the Remarks sections of
<b>SetFileApisToOEM</b> and
<b>SetFileApisToANSI</b>.</para>
      <para>The file I/O functions whose code page is ascertained by <b>AreFileApisANSI</b> are
those functions exported by KERNEL32.DLL that accept or return a file name.</para>
      <para>The functions <see cref="SetFileApisToOEM" /> and
<see cref="SetFileApisToANSI" /> set the code page for a process, so
<b>AreFileApisANSI</b> returns a value indicating the code page of an entire
process.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="SetFileApisToANSI" />
    <seealso cref="SetFileApisToOEM" />
  </member>
  <member name="Windows.CompareFileTime">
    <summary>
      <para>Compares two file times.</para>
    </summary>
    <param name="lpFileTime1">
      <para>A pointer to a <see cref="FILETIME" /> structure that specifies the
first file time.</para>
    </param>
    <param name="lpFileTime2">
      <para>A pointer to a <see cref="FILETIME" /> structure that specifies the
second file time.</para>
    </param>
    <returns>
      <para>The return value is one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>-1</para>
          </description>
          <description>
            <para>First file time is earlier than second file time.</para>
          </description>
        </item>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>First file time is equal to second file time.</para>
          </description>
        </item>
        <item>
          <description>
            <para>1</para>
          </description>
          <description>
            <para>First file time is later than second file time.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso cref="FILETIME" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/file-times">File Times</seealso>
    <seealso cref="GetFileTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.CreateDirectory">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and
directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the
<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this
operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory. If <i>lpSecurityAttributes</i> is
<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default
security descriptor for a  directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
(This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist; this function will only create the final directory in
the path.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>An application can obtain a handle to a directory by calling
<see cref="CreateFile" /> with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this object may heuristically determine
and report that inheritance is in effect. See
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a></para>
      <para>for more information.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines CreateDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectoryEx" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
  </member>
  <member name="Windows.CreateDirectoryA">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and
directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the
<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this
operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory. If <i>lpSecurityAttributes</i> is
<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default
security descriptor for a  directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
(This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist; this function will only create the final directory in
the path.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>An application can obtain a handle to a directory by calling
<see cref="CreateFile" /> with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this object may heuristically determine
and report that inheritance is in effect. See
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a></para>
      <para>for more information.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines CreateDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectoryEx" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
  </member>
  <member name="Windows.CreateDirectoryW">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and
directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the
<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this
operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory. If <i>lpSecurityAttributes</i> is
<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default
security descriptor for a  directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
(This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist; this function will only create the final directory in
the path.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>An application can obtain a handle to a directory by calling
<see cref="CreateFile" /> with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this object may heuristically determine
and report that inheritance is in effect. See
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a></para>
      <para>for more information.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines CreateDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectoryEx" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
  </member>
  <member name="Windows.CreateDirectory">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and
directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the
<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this
operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory. If <i>lpSecurityAttributes</i> is
<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default
security descriptor for a  directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
(This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist; this function will only create the final directory in
the path.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>An application can obtain a handle to a directory by calling
<see cref="CreateFile" /> with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this object may heuristically determine
and report that inheritance is in effect. See
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a></para>
      <para>for more information.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines CreateDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectoryEx" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
  </member>
  <member name="Windows.CreateDirectoryA">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and
directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the
<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this
operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory. If <i>lpSecurityAttributes</i> is
<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default
security descriptor for a  directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
(This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist; this function will only create the final directory in
the path.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>An application can obtain a handle to a directory by calling
<see cref="CreateFile" /> with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this object may heuristically determine
and report that inheritance is in effect. See
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a></para>
      <para>for more information.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines CreateDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectoryEx" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
  </member>
  <member name="Windows.CreateDirectoryW">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and
directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the
<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this
operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory. If <i>lpSecurityAttributes</i> is
<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default
security descriptor for a  directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
(This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist; this function will only create the final directory in
the path.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>An application can obtain a handle to a directory by calling
<see cref="CreateFile" /> with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this object may heuristically determine
and report that inheritance is in effect. See
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a></para>
      <para>for more information.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines CreateDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectoryEx" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
  </member>
  <member name="Windows.DefineDosDevice">
    <summary>
      <para>Defines, redefines, or deletes MS-DOS device names.</para>
    </summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter
can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will
use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete
something that you did not define.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message.
By default, this message is broadcast to notify the shell and applications of the change.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_RAW_TARGET_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS
path to a path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_REMOVE_DEFINITION</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Removes the specified definition for the specified device. To determine which definition to remove, the
function walks the list of mappings for the device, looking for a match of
<i>lpTargetPath</i> against a prefix of each mapping associated with this device. The
first mapping that matches is the one removed, and then the function returns.</para>
            <para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a
<b>NULL</b> string, the function will remove the first mapping associated with the device
and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para>
            <para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i></para>
            <para>parameter will become the new mapping for this device.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpDeviceName">
      <para>A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or
deleting. The device name string must not have a colon as the last character, unless a drive letter is being
defined, redefined, or deleted. For example, drive C  would be the string "C:". In no case is a
trailing backslash ("") allowed.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the
<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path
string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path
into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>DefineDosDevice</b> function enables an application to modify the junctions used to
implement the MS-DOS device namespace.</para>
      <para>To retrieve the current mapping for a particular MS-DOS device name or to obtain a list of all MS-DOS devices
known to the system, use the <see cref="QueryDosDevice" /></para>
      <para>function.</para>
      <para>To define a drive letter assignment that is persistent across boots and not a network share, use the
<see cref="SetVolumeMountPoint" /> function. If the volume to
be mounted already has a drive letter assigned to it, use the
<see cref="DeleteVolumeMountPoint" /> function to remove the
assignment.</para>
      <para>Drive letters and device names defined at system boot time are protected from redefinition and deletion unless
the user is an administrator.</para>
      <para>Starting with Windows XP, this function creates a device name for a caller that is not running in
the "LocalSystem" context in its own Local MS-DOS device namespace. If the caller  is running in
the "LocalSystem" context, the function creates the device name in the Global MS-DOS device
namespace. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a> and
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new name will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/editing-drive-letter-assignments">Editing Drive Letter Assignments</a>.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="QueryDosDevice" />
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.DefineDosDeviceA">
    <summary>
      <para>Defines, redefines, or deletes MS-DOS device names.</para>
    </summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter
can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will
use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete
something that you did not define.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message.
By default, this message is broadcast to notify the shell and applications of the change.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_RAW_TARGET_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS
path to a path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_REMOVE_DEFINITION</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Removes the specified definition for the specified device. To determine which definition to remove, the
function walks the list of mappings for the device, looking for a match of
<i>lpTargetPath</i> against a prefix of each mapping associated with this device. The
first mapping that matches is the one removed, and then the function returns.</para>
            <para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a
<b>NULL</b> string, the function will remove the first mapping associated with the device
and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para>
            <para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i></para>
            <para>parameter will become the new mapping for this device.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpDeviceName">
      <para>A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or
deleting. The device name string must not have a colon as the last character, unless a drive letter is being
defined, redefined, or deleted. For example, drive C  would be the string "C:". In no case is a
trailing backslash ("") allowed.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the
<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path
string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path
into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>DefineDosDevice</b> function enables an application to modify the junctions used to
implement the MS-DOS device namespace.</para>
      <para>To retrieve the current mapping for a particular MS-DOS device name or to obtain a list of all MS-DOS devices
known to the system, use the <see cref="QueryDosDevice" /></para>
      <para>function.</para>
      <para>To define a drive letter assignment that is persistent across boots and not a network share, use the
<see cref="SetVolumeMountPoint" /> function. If the volume to
be mounted already has a drive letter assigned to it, use the
<see cref="DeleteVolumeMountPoint" /> function to remove the
assignment.</para>
      <para>Drive letters and device names defined at system boot time are protected from redefinition and deletion unless
the user is an administrator.</para>
      <para>Starting with Windows XP, this function creates a device name for a caller that is not running in
the "LocalSystem" context in its own Local MS-DOS device namespace. If the caller  is running in
the "LocalSystem" context, the function creates the device name in the Global MS-DOS device
namespace. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a> and
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new name will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/editing-drive-letter-assignments">Editing Drive Letter Assignments</a>.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="QueryDosDevice" />
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.DefineDosDeviceW">
    <summary>
      <para>Defines, redefines, or deletes MS-DOS device names.</para>
    </summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter
can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will
use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete
something that you did not define.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message.
By default, this message is broadcast to notify the shell and applications of the change.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_RAW_TARGET_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS
path to a path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_REMOVE_DEFINITION</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Removes the specified definition for the specified device. To determine which definition to remove, the
function walks the list of mappings for the device, looking for a match of
<i>lpTargetPath</i> against a prefix of each mapping associated with this device. The
first mapping that matches is the one removed, and then the function returns.</para>
            <para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a
<b>NULL</b> string, the function will remove the first mapping associated with the device
and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para>
            <para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i></para>
            <para>parameter will become the new mapping for this device.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpDeviceName">
      <para>A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or
deleting. The device name string must not have a colon as the last character, unless a drive letter is being
defined, redefined, or deleted. For example, drive C  would be the string "C:". In no case is a
trailing backslash ("") allowed.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the
<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path
string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path
into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>DefineDosDevice</b> function enables an application to modify the junctions used to
implement the MS-DOS device namespace.</para>
      <para>To retrieve the current mapping for a particular MS-DOS device name or to obtain a list of all MS-DOS devices
known to the system, use the <see cref="QueryDosDevice" /></para>
      <para>function.</para>
      <para>To define a drive letter assignment that is persistent across boots and not a network share, use the
<see cref="SetVolumeMountPoint" /> function. If the volume to
be mounted already has a drive letter assigned to it, use the
<see cref="DeleteVolumeMountPoint" /> function to remove the
assignment.</para>
      <para>Drive letters and device names defined at system boot time are protected from redefinition and deletion unless
the user is an administrator.</para>
      <para>Starting with Windows XP, this function creates a device name for a caller that is not running in
the "LocalSystem" context in its own Local MS-DOS device namespace. If the caller  is running in
the "LocalSystem" context, the function creates the device name in the Global MS-DOS device
namespace. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a> and
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new name will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/editing-drive-letter-assignments">Editing Drive Letter Assignments</a>.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="QueryDosDevice" />
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.DeleteFile">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If an application attempts to delete a file that does not exist, the
<b>DeleteFile</b> function fails with
<b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>The following list identifies some tips for deleting, removing, or closing files:</para>
      <list type="bullet">
        <item>
          <description>To delete a read-only file, first you must remove the read-only attribute.</description>
        </item>
        <item>
          <description>To delete or rename a file, you must have either delete permission on the file, or delete child permission
in the parent directory.</description>
        </item>
        <item>
          <description>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</description>
        </item>
        <item>
          <description>To remove an empty directory, use the
<see cref="RemoveDirectory" /> function.</description>
        </item>
        <item>
          <description>To close an open file, use the
<see cref="CloseHandle" /> function.</description>
        </item>
      </list>
      <para>If you set up a directory with all access except delete and delete child, and the access control lists (ACL) of
new files are inherited, then you can create a file without being able to delete it. However, then you can create
a file, and then get all the access you request on the handle that is returned to you at the time you create the
file.</para>
      <para>If you request delete permission at the time you create a file, you can delete or rename the file with that
handle, but not with any other handle. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>The <b>DeleteFile</b> function fails if an application attempts
to delete a file that has other handles open for normal I/O or as a memory-mapped file
(<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).</para>
      <para>The <b>DeleteFile</b> function marks a file for deletion on
close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls
to <see cref="CreateFile" /> to open the file fail with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you
must call <see cref="CreateFile" /> and specify
<b>FILE_FLAG_DELETE_ON_CLOSE</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines DeleteFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.DeleteFileA">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If an application attempts to delete a file that does not exist, the
<b>DeleteFile</b> function fails with
<b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>The following list identifies some tips for deleting, removing, or closing files:</para>
      <list type="bullet">
        <item>
          <description>To delete a read-only file, first you must remove the read-only attribute.</description>
        </item>
        <item>
          <description>To delete or rename a file, you must have either delete permission on the file, or delete child permission
in the parent directory.</description>
        </item>
        <item>
          <description>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</description>
        </item>
        <item>
          <description>To remove an empty directory, use the
<see cref="RemoveDirectory" /> function.</description>
        </item>
        <item>
          <description>To close an open file, use the
<see cref="CloseHandle" /> function.</description>
        </item>
      </list>
      <para>If you set up a directory with all access except delete and delete child, and the access control lists (ACL) of
new files are inherited, then you can create a file without being able to delete it. However, then you can create
a file, and then get all the access you request on the handle that is returned to you at the time you create the
file.</para>
      <para>If you request delete permission at the time you create a file, you can delete or rename the file with that
handle, but not with any other handle. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>The <b>DeleteFile</b> function fails if an application attempts
to delete a file that has other handles open for normal I/O or as a memory-mapped file
(<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).</para>
      <para>The <b>DeleteFile</b> function marks a file for deletion on
close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls
to <see cref="CreateFile" /> to open the file fail with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you
must call <see cref="CreateFile" /> and specify
<b>FILE_FLAG_DELETE_ON_CLOSE</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines DeleteFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.DeleteFileW">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If an application attempts to delete a file that does not exist, the
<b>DeleteFile</b> function fails with
<b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>The following list identifies some tips for deleting, removing, or closing files:</para>
      <list type="bullet">
        <item>
          <description>To delete a read-only file, first you must remove the read-only attribute.</description>
        </item>
        <item>
          <description>To delete or rename a file, you must have either delete permission on the file, or delete child permission
in the parent directory.</description>
        </item>
        <item>
          <description>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</description>
        </item>
        <item>
          <description>To remove an empty directory, use the
<see cref="RemoveDirectory" /> function.</description>
        </item>
        <item>
          <description>To close an open file, use the
<see cref="CloseHandle" /> function.</description>
        </item>
      </list>
      <para>If you set up a directory with all access except delete and delete child, and the access control lists (ACL) of
new files are inherited, then you can create a file without being able to delete it. However, then you can create
a file, and then get all the access you request on the handle that is returned to you at the time you create the
file.</para>
      <para>If you request delete permission at the time you create a file, you can delete or rename the file with that
handle, but not with any other handle. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>The <b>DeleteFile</b> function fails if an application attempts
to delete a file that has other handles open for normal I/O or as a memory-mapped file
(<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).</para>
      <para>The <b>DeleteFile</b> function marks a file for deletion on
close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls
to <see cref="CreateFile" /> to open the file fail with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you
must call <see cref="CreateFile" /> and specify
<b>FILE_FLAG_DELETE_ON_CLOSE</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines DeleteFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.DeleteFile">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If an application attempts to delete a file that does not exist, the
<b>DeleteFile</b> function fails with
<b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>The following list identifies some tips for deleting, removing, or closing files:</para>
      <list type="bullet">
        <item>
          <description>To delete a read-only file, first you must remove the read-only attribute.</description>
        </item>
        <item>
          <description>To delete or rename a file, you must have either delete permission on the file, or delete child permission
in the parent directory.</description>
        </item>
        <item>
          <description>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</description>
        </item>
        <item>
          <description>To remove an empty directory, use the
<see cref="RemoveDirectory" /> function.</description>
        </item>
        <item>
          <description>To close an open file, use the
<see cref="CloseHandle" /> function.</description>
        </item>
      </list>
      <para>If you set up a directory with all access except delete and delete child, and the access control lists (ACL) of
new files are inherited, then you can create a file without being able to delete it. However, then you can create
a file, and then get all the access you request on the handle that is returned to you at the time you create the
file.</para>
      <para>If you request delete permission at the time you create a file, you can delete or rename the file with that
handle, but not with any other handle. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>The <b>DeleteFile</b> function fails if an application attempts
to delete a file that has other handles open for normal I/O or as a memory-mapped file
(<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).</para>
      <para>The <b>DeleteFile</b> function marks a file for deletion on
close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls
to <see cref="CreateFile" /> to open the file fail with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you
must call <see cref="CreateFile" /> and specify
<b>FILE_FLAG_DELETE_ON_CLOSE</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines DeleteFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.DeleteFileA">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If an application attempts to delete a file that does not exist, the
<b>DeleteFile</b> function fails with
<b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>The following list identifies some tips for deleting, removing, or closing files:</para>
      <list type="bullet">
        <item>
          <description>To delete a read-only file, first you must remove the read-only attribute.</description>
        </item>
        <item>
          <description>To delete or rename a file, you must have either delete permission on the file, or delete child permission
in the parent directory.</description>
        </item>
        <item>
          <description>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</description>
        </item>
        <item>
          <description>To remove an empty directory, use the
<see cref="RemoveDirectory" /> function.</description>
        </item>
        <item>
          <description>To close an open file, use the
<see cref="CloseHandle" /> function.</description>
        </item>
      </list>
      <para>If you set up a directory with all access except delete and delete child, and the access control lists (ACL) of
new files are inherited, then you can create a file without being able to delete it. However, then you can create
a file, and then get all the access you request on the handle that is returned to you at the time you create the
file.</para>
      <para>If you request delete permission at the time you create a file, you can delete or rename the file with that
handle, but not with any other handle. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>The <b>DeleteFile</b> function fails if an application attempts
to delete a file that has other handles open for normal I/O or as a memory-mapped file
(<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).</para>
      <para>The <b>DeleteFile</b> function marks a file for deletion on
close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls
to <see cref="CreateFile" /> to open the file fail with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you
must call <see cref="CreateFile" /> and specify
<b>FILE_FLAG_DELETE_ON_CLOSE</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines DeleteFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.DeleteFileW">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If an application attempts to delete a file that does not exist, the
<b>DeleteFile</b> function fails with
<b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>The following list identifies some tips for deleting, removing, or closing files:</para>
      <list type="bullet">
        <item>
          <description>To delete a read-only file, first you must remove the read-only attribute.</description>
        </item>
        <item>
          <description>To delete or rename a file, you must have either delete permission on the file, or delete child permission
in the parent directory.</description>
        </item>
        <item>
          <description>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</description>
        </item>
        <item>
          <description>To remove an empty directory, use the
<see cref="RemoveDirectory" /> function.</description>
        </item>
        <item>
          <description>To close an open file, use the
<see cref="CloseHandle" /> function.</description>
        </item>
      </list>
      <para>If you set up a directory with all access except delete and delete child, and the access control lists (ACL) of
new files are inherited, then you can create a file without being able to delete it. However, then you can create
a file, and then get all the access you request on the handle that is returned to you at the time you create the
file.</para>
      <para>If you request delete permission at the time you create a file, you can delete or rename the file with that
handle, but not with any other handle. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>The <b>DeleteFile</b> function fails if an application attempts
to delete a file that has other handles open for normal I/O or as a memory-mapped file
(<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).</para>
      <para>The <b>DeleteFile</b> function marks a file for deletion on
close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls
to <see cref="CreateFile" /> to open the file fail with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you
must call <see cref="CreateFile" /> and specify
<b>FILE_FLAG_DELETE_ON_CLOSE</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines DeleteFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.DeleteVolumeMountPoint">
    <summary>
      <para>Deletes a drive letter or mounted folder.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The drive letter or mounted folder to be deleted. A trailing backslash is required, for example,
"X:" or "Y:\MountX".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Deleting a mounted folder does not cause the underlying directory to be deleted.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter is a directory that is not a mounted folder,
the function does nothing. The directory is not deleted.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/unmounting-a-volume-at-a-mount-point">Unmounting a Volume at a Mount Point</a>.</para>
    </remarks>
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.DeleteVolumeMountPointA">
    <summary>
      <para>Deletes a drive letter or mounted folder.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The drive letter or mounted folder to be deleted. A trailing backslash is required, for example,
"X:" or "Y:\MountX".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Deleting a mounted folder does not cause the underlying directory to be deleted.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter is a directory that is not a mounted folder,
the function does nothing. The directory is not deleted.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/unmounting-a-volume-at-a-mount-point">Unmounting a Volume at a Mount Point</a>.</para>
    </remarks>
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.DeleteVolumeMountPointW">
    <summary>
      <para>Deletes a drive letter or mounted folder.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The drive letter or mounted folder to be deleted. A trailing backslash is required, for example,
"X:" or "Y:\MountX".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Deleting a mounted folder does not cause the underlying directory to be deleted.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter is a directory that is not a mounted folder,
the function does nothing. The directory is not deleted.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/unmounting-a-volume-at-a-mount-point">Unmounting a Volume at a Mount Point</a>.</para>
    </remarks>
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FileTimeToLocalFileTime">
    <summary>
      <para>Converts a file time to a local file time.</para>
    </summary>
    <param name="lpFileTime">
      <para>A pointer to a <see cref="FILETIME" /> structure containing the UTC-based file time to be converted into a local file time.</para>
    </param>
    <param name="lpLocalFileTime">
      <para>A pointer to a <see cref="FILETIME" /> structure to receive the converted local file time. This parameter cannot be the same as the <i>lpFileTime</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To account for daylight saving time when converting a file time to a local time, use the following sequence of functions in place of using <b>FileTimeToLocalFileTime</b>:</para>
      <list type="number">
        <item>
          <description>
            <see cref="FileTimeToSystemTime" />
          </description>
        </item>
        <item>
          <description>
            <see cref="SystemTimeToTzSpecificLocalTime" />
          </description>
        </item>
        <item>
          <description>
            <see cref="SystemTimeToFileTime" />
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="FILETIME" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/file-times">File Times</seealso>
    <seealso cref="LocalFileTimeToFileTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.FindClose">
    <summary>
      <para>Closes a file search handle opened by the
<see cref="FindFirstFile" />,
<see cref="FindFirstFileEx" />,
<see cref="FindFirstFileNameW" />,
<see cref="FindFirstFileNameTransactedW" />,
<see cref="FindFirstFileTransacted" />,
<see cref="FindFirstStreamTransactedW" />, or
<see cref="FindFirstStreamW" /> functions.</para>
    </summary>
    <param name="hFindFile">
      <para>The file search handle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After the <b>FindClose</b> function is called, the handle
specified by the <i>hFindFile</i> parameter cannot be used in subsequent calls to the
<see cref="FindNextFile" />,
<see cref="FindNextFileNameW" />,
<see cref="FindNextStreamW" />, or
<b>FindClose</b> functions.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="FindFirstFileNameTransactedW" />
    <seealso cref="FindFirstFileNameW" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindFirstStreamTransactedW" />
    <seealso cref="FindFirstStreamW" />
    <seealso cref="FindNextFile" />
    <seealso cref="FindNextFileNameW" />
    <seealso cref="FindNextStreamW" />
  </member>
  <member name="Windows.FindCloseChangeNotification">
    <summary>
      <para>Stops change notification handle monitoring.</para>
    </summary>
    <param name="hChangeHandle">
      <para>A handle to a change notification handle created by the
<see cref="FindFirstChangeNotification" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After the <b>FindCloseChangeNotification</b> function is called, the handle
specified by the <i>hChangeHandle</i> parameter cannot be used in subsequent calls to either the
<see cref="FindNextChangeNotification" /> or
<b>FindCloseChangeNotification</b> function.</para>
      <para>Change notifications can also be used in the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>See remark</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Application might experience false positives on CsvFs pause/resume.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="FindFirstChangeNotification" />
    <seealso cref="FindNextChangeNotification" />
  </member>
  <member name="Windows.FindFirstChangeNotification">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the
<see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="bWatchSubtree">
      <para>If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</para>
    </param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a> can monitor the specified directory or subtree by using the handle returned by the
<b>FindFirstChangeNotification</b> function. A wait is satisfied when one of the filter conditions occurs in the monitored directory or subtree.</para>
      <para>After the wait has been satisfied, the application can respond to this condition and continue monitoring the directory by calling the
<see cref="FindNextChangeNotification" /> function and the appropriate wait function. When the handle is no longer needed, it can be closed by using the
<see cref="FindCloseChangeNotification" /> function.</para>
      <para>Notifications may not be returned when calling <b>FindFirstChangeNotification</b> for a remote file system.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the notification handle is created for the target.</para>
      <para>If an application has registered to receive change notifications for a directory that contains symbolic links, the application is only notified when the symbolic links have been changed, not the target files.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>See remark</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Application might experience false positives on CsvFs pause/resume.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/obtaining-directory-change-notifications">Obtaining Directory Change_Notifications</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindFirstChangeNotification as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="FindCloseChangeNotification" />
    <seealso cref="FindNextChangeNotification" />
    <seealso cref="ReadDirectoryChangesW" />
  </member>
  <member name="Windows.FindFirstChangeNotificationA">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the
<see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="bWatchSubtree">
      <para>If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</para>
    </param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a> can monitor the specified directory or subtree by using the handle returned by the
<b>FindFirstChangeNotification</b> function. A wait is satisfied when one of the filter conditions occurs in the monitored directory or subtree.</para>
      <para>After the wait has been satisfied, the application can respond to this condition and continue monitoring the directory by calling the
<see cref="FindNextChangeNotification" /> function and the appropriate wait function. When the handle is no longer needed, it can be closed by using the
<see cref="FindCloseChangeNotification" /> function.</para>
      <para>Notifications may not be returned when calling <b>FindFirstChangeNotification</b> for a remote file system.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the notification handle is created for the target.</para>
      <para>If an application has registered to receive change notifications for a directory that contains symbolic links, the application is only notified when the symbolic links have been changed, not the target files.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>See remark</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Application might experience false positives on CsvFs pause/resume.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/obtaining-directory-change-notifications">Obtaining Directory Change_Notifications</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindFirstChangeNotification as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="FindCloseChangeNotification" />
    <seealso cref="FindNextChangeNotification" />
    <seealso cref="ReadDirectoryChangesW" />
  </member>
  <member name="Windows.FindFirstChangeNotificationW">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the
<see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="bWatchSubtree">
      <para>If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</para>
    </param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a> can monitor the specified directory or subtree by using the handle returned by the
<b>FindFirstChangeNotification</b> function. A wait is satisfied when one of the filter conditions occurs in the monitored directory or subtree.</para>
      <para>After the wait has been satisfied, the application can respond to this condition and continue monitoring the directory by calling the
<see cref="FindNextChangeNotification" /> function and the appropriate wait function. When the handle is no longer needed, it can be closed by using the
<see cref="FindCloseChangeNotification" /> function.</para>
      <para>Notifications may not be returned when calling <b>FindFirstChangeNotification</b> for a remote file system.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the notification handle is created for the target.</para>
      <para>If an application has registered to receive change notifications for a directory that contains symbolic links, the application is only notified when the symbolic links have been changed, not the target files.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>See remark</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Application might experience false positives on CsvFs pause/resume.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/obtaining-directory-change-notifications">Obtaining Directory Change_Notifications</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindFirstChangeNotification as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="FindCloseChangeNotification" />
    <seealso cref="FindNextChangeNotification" />
    <seealso cref="ReadDirectoryChangesW" />
  </member>
  <member name="Windows.FindFirstChangeNotification">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the
<see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="bWatchSubtree">
      <para>If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</para>
    </param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a> can monitor the specified directory or subtree by using the handle returned by the
<b>FindFirstChangeNotification</b> function. A wait is satisfied when one of the filter conditions occurs in the monitored directory or subtree.</para>
      <para>After the wait has been satisfied, the application can respond to this condition and continue monitoring the directory by calling the
<see cref="FindNextChangeNotification" /> function and the appropriate wait function. When the handle is no longer needed, it can be closed by using the
<see cref="FindCloseChangeNotification" /> function.</para>
      <para>Notifications may not be returned when calling <b>FindFirstChangeNotification</b> for a remote file system.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the notification handle is created for the target.</para>
      <para>If an application has registered to receive change notifications for a directory that contains symbolic links, the application is only notified when the symbolic links have been changed, not the target files.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>See remark</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Application might experience false positives on CsvFs pause/resume.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/obtaining-directory-change-notifications">Obtaining Directory Change_Notifications</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindFirstChangeNotification as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="FindCloseChangeNotification" />
    <seealso cref="FindNextChangeNotification" />
    <seealso cref="ReadDirectoryChangesW" />
  </member>
  <member name="Windows.FindFirstChangeNotificationA">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the
<see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="bWatchSubtree">
      <para>If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</para>
    </param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a> can monitor the specified directory or subtree by using the handle returned by the
<b>FindFirstChangeNotification</b> function. A wait is satisfied when one of the filter conditions occurs in the monitored directory or subtree.</para>
      <para>After the wait has been satisfied, the application can respond to this condition and continue monitoring the directory by calling the
<see cref="FindNextChangeNotification" /> function and the appropriate wait function. When the handle is no longer needed, it can be closed by using the
<see cref="FindCloseChangeNotification" /> function.</para>
      <para>Notifications may not be returned when calling <b>FindFirstChangeNotification</b> for a remote file system.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the notification handle is created for the target.</para>
      <para>If an application has registered to receive change notifications for a directory that contains symbolic links, the application is only notified when the symbolic links have been changed, not the target files.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>See remark</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Application might experience false positives on CsvFs pause/resume.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/obtaining-directory-change-notifications">Obtaining Directory Change_Notifications</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindFirstChangeNotification as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="FindCloseChangeNotification" />
    <seealso cref="FindNextChangeNotification" />
    <seealso cref="ReadDirectoryChangesW" />
  </member>
  <member name="Windows.FindFirstChangeNotificationW">
    <summary>
      <para>Creates a change notification handle and sets up initial change notification filter conditions. A wait on a notification handle succeeds when a change matching the filter conditions occurs in the specified directory or subtree. The function does not report changes to the specified directory itself.</para>
      <para>This function does not indicate the change that satisfied the wait condition. To retrieve information about the specific change as part of the notification, use the
<see cref="ReadDirectoryChangesW" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The full path of the directory to be watched.</para>
      <para>This cannot be a relative path or an empty string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="bWatchSubtree">
      <para>If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.</para>
    </param>
    <param name="dwNotifyFilter">
      <para>The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a find change notification object.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a> can monitor the specified directory or subtree by using the handle returned by the
<b>FindFirstChangeNotification</b> function. A wait is satisfied when one of the filter conditions occurs in the monitored directory or subtree.</para>
      <para>After the wait has been satisfied, the application can respond to this condition and continue monitoring the directory by calling the
<see cref="FindNextChangeNotification" /> function and the appropriate wait function. When the handle is no longer needed, it can be closed by using the
<see cref="FindCloseChangeNotification" /> function.</para>
      <para>Notifications may not be returned when calling <b>FindFirstChangeNotification</b> for a remote file system.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the notification handle is created for the target.</para>
      <para>If an application has registered to receive change notifications for a directory that contains symbolic links, the application is only notified when the symbolic links have been changed, not the target files.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>See remark</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Application might experience false positives on CsvFs pause/resume.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/obtaining-directory-change-notifications">Obtaining Directory Change_Notifications</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindFirstChangeNotification as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="FindCloseChangeNotification" />
    <seealso cref="FindNextChangeNotification" />
    <seealso cref="ReadDirectoryChangesW" />
  </member>
  <member name="Windows.FindFirstFile">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial
name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the
<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to
the root and all subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure that
receives information about a found file or directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFile</b> function opens a search handle and
returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFile</b> does no sorting of the search results. For
additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type (for other options, see <see cref="FindFirstFileEx" />).</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>After the search handle is established, you can use it to search for other files that match the same pattern
by using the <see cref="FindNextFile" /> function.</para><para>When the search handle is no longer needed, close it by using the
<see cref="FindClose" /> function, not
<see cref="CloseHandle" />.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFile</b>, therefore it may not be
obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the
directory by using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use the
<see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root
directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\Server\Share*". However, you cannot use an <i>lpFileName</i></para><para>that points to the share itself; for example, "\Server\Share" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be  run
on a 64-bit computer, you should call the
<see cref="Wow64DisableWow64FsRedirection" /> function
before calling <b>FindFirstFile</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows you a minimal use of <b>FindFirstFile</b>.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFile(argv[1], &amp;amp;amp;amp;amp;amp;FindFileData);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFile failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><para>For another example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstFileA">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial
name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the
<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to
the root and all subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure that
receives information about a found file or directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFile</b> function opens a search handle and
returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFile</b> does no sorting of the search results. For
additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type (for other options, see <see cref="FindFirstFileEx" />).</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>After the search handle is established, you can use it to search for other files that match the same pattern
by using the <see cref="FindNextFile" /> function.</para><para>When the search handle is no longer needed, close it by using the
<see cref="FindClose" /> function, not
<see cref="CloseHandle" />.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFile</b>, therefore it may not be
obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the
directory by using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use the
<see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root
directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\Server\Share*". However, you cannot use an <i>lpFileName</i></para><para>that points to the share itself; for example, "\Server\Share" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be  run
on a 64-bit computer, you should call the
<see cref="Wow64DisableWow64FsRedirection" /> function
before calling <b>FindFirstFile</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows you a minimal use of <b>FindFirstFile</b>.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFile(argv[1], &amp;amp;amp;amp;amp;amp;FindFileData);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFile failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><para>For another example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstFileW">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial
name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the
<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to
the root and all subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure that
receives information about a found file or directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFile</b> function opens a search handle and
returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFile</b> does no sorting of the search results. For
additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type (for other options, see <see cref="FindFirstFileEx" />).</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>After the search handle is established, you can use it to search for other files that match the same pattern
by using the <see cref="FindNextFile" /> function.</para><para>When the search handle is no longer needed, close it by using the
<see cref="FindClose" /> function, not
<see cref="CloseHandle" />.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFile</b>, therefore it may not be
obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the
directory by using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use the
<see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root
directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\Server\Share*". However, you cannot use an <i>lpFileName</i></para><para>that points to the share itself; for example, "\Server\Share" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be  run
on a 64-bit computer, you should call the
<see cref="Wow64DisableWow64FsRedirection" /> function
before calling <b>FindFirstFile</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows you a minimal use of <b>FindFirstFile</b>.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFile(argv[1], &amp;amp;amp;amp;amp;amp;FindFileData);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFile failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><para>For another example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstFileEx">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those
specified.</para>
      <para>For the most basic version of this function, see
<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all
subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and
prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the
<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the
<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" /></para>
      <para>enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured
search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search
information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches are case-sensitive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses a larger buffer for directory queries, which can increase performance of the find operation.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFileEx</b> function opens a search handle
and returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFileEx</b> does no sorting of the search results.
For additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type.</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>If the underlying file system does not support the specified type of filtering, other than directory
filtering, <b>FindFirstFileEx</b> fails with the error
<b>ERROR_NOT_SUPPORTED</b>. The application must use
<see cref="FINDEX_SEARCH_OPS" /> type
<b>FileExSearchNameMatch</b> and perform its own filtering.</para><para>After the search handle is established, use it in the
<see cref="FindNextFile" /> function to search for other
files that match the same pattern with the same filtering that is being performed. When the search handle is not
needed, it should be closed by using the
<see cref="FindClose" /> function.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFileEx</b>, therefore it may not
be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the directory by
using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use
the <see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\server\service*". However, you cannot use an <i>lpFileName</i> that points
to the share itself; for example, "\server\service" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>The following call:</para><code>FindFirstFileEx( lpFileName,
                 FindExInfoStandard,
                 lpFindData,
                 FindExSearchNameMatch,
                 NULL,
                 0 );
</code><para>Is equivalent to the following call:</para><code>FindFirstFile( lpFileName, lpFindData );
</code><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be run on
a 64-bit computer, you should call
<see cref="Wow64DisableWow64FsRedirection" /> before
calling <b>FindFirstFileEx</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following code shows a minimal use of
<b>FindFirstFileEx</b>. This program is equivalent to the
example in the <see cref="FindFirstFile" /> topic.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFileEx(argv[1], FindExInfoStandard, &amp;amp;amp;amp;amp;amp;FindFileData,
             FindExSearchNameMatch, NULL, 0);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFileEx failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso cref="FINDEX_INFO_LEVELS" />
    <seealso cref="FINDEX_SEARCH_OPS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstFileExA">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those
specified.</para>
      <para>For the most basic version of this function, see
<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all
subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and
prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the
<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the
<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" /></para>
      <para>enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured
search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search
information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches are case-sensitive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses a larger buffer for directory queries, which can increase performance of the find operation.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFileEx</b> function opens a search handle
and returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFileEx</b> does no sorting of the search results.
For additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type.</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>If the underlying file system does not support the specified type of filtering, other than directory
filtering, <b>FindFirstFileEx</b> fails with the error
<b>ERROR_NOT_SUPPORTED</b>. The application must use
<see cref="FINDEX_SEARCH_OPS" /> type
<b>FileExSearchNameMatch</b> and perform its own filtering.</para><para>After the search handle is established, use it in the
<see cref="FindNextFile" /> function to search for other
files that match the same pattern with the same filtering that is being performed. When the search handle is not
needed, it should be closed by using the
<see cref="FindClose" /> function.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFileEx</b>, therefore it may not
be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the directory by
using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use
the <see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\server\service*". However, you cannot use an <i>lpFileName</i> that points
to the share itself; for example, "\server\service" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>The following call:</para><code>FindFirstFileEx( lpFileName,
                 FindExInfoStandard,
                 lpFindData,
                 FindExSearchNameMatch,
                 NULL,
                 0 );
</code><para>Is equivalent to the following call:</para><code>FindFirstFile( lpFileName, lpFindData );
</code><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be run on
a 64-bit computer, you should call
<see cref="Wow64DisableWow64FsRedirection" /> before
calling <b>FindFirstFileEx</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following code shows a minimal use of
<b>FindFirstFileEx</b>. This program is equivalent to the
example in the <see cref="FindFirstFile" /> topic.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFileEx(argv[1], FindExInfoStandard, &amp;amp;amp;amp;amp;amp;FindFileData,
             FindExSearchNameMatch, NULL, 0);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFileEx failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso cref="FINDEX_INFO_LEVELS" />
    <seealso cref="FINDEX_SEARCH_OPS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstFileExW">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those
specified.</para>
      <para>For the most basic version of this function, see
<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all
subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and
prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the
<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the
<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" /></para>
      <para>enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured
search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search
information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches are case-sensitive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses a larger buffer for directory queries, which can increase performance of the find operation.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFileEx</b> function opens a search handle
and returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFileEx</b> does no sorting of the search results.
For additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type.</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>If the underlying file system does not support the specified type of filtering, other than directory
filtering, <b>FindFirstFileEx</b> fails with the error
<b>ERROR_NOT_SUPPORTED</b>. The application must use
<see cref="FINDEX_SEARCH_OPS" /> type
<b>FileExSearchNameMatch</b> and perform its own filtering.</para><para>After the search handle is established, use it in the
<see cref="FindNextFile" /> function to search for other
files that match the same pattern with the same filtering that is being performed. When the search handle is not
needed, it should be closed by using the
<see cref="FindClose" /> function.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFileEx</b>, therefore it may not
be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the directory by
using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use
the <see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\server\service*". However, you cannot use an <i>lpFileName</i> that points
to the share itself; for example, "\server\service" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>The following call:</para><code>FindFirstFileEx( lpFileName,
                 FindExInfoStandard,
                 lpFindData,
                 FindExSearchNameMatch,
                 NULL,
                 0 );
</code><para>Is equivalent to the following call:</para><code>FindFirstFile( lpFileName, lpFindData );
</code><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be run on
a 64-bit computer, you should call
<see cref="Wow64DisableWow64FsRedirection" /> before
calling <b>FindFirstFileEx</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following code shows a minimal use of
<b>FindFirstFileEx</b>. This program is equivalent to the
example in the <see cref="FindFirstFile" /> topic.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFileEx(argv[1], FindExInfoStandard, &amp;amp;amp;amp;amp;amp;FindFileData,
             FindExSearchNameMatch, NULL, 0);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFileEx failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso cref="FINDEX_INFO_LEVELS" />
    <seealso cref="FINDEX_SEARCH_OPS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstFileEx">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those
specified.</para>
      <para>For the most basic version of this function, see
<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all
subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and
prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the
<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the
<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" /></para>
      <para>enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured
search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search
information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches are case-sensitive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses a larger buffer for directory queries, which can increase performance of the find operation.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFileEx</b> function opens a search handle
and returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFileEx</b> does no sorting of the search results.
For additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type.</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>If the underlying file system does not support the specified type of filtering, other than directory
filtering, <b>FindFirstFileEx</b> fails with the error
<b>ERROR_NOT_SUPPORTED</b>. The application must use
<see cref="FINDEX_SEARCH_OPS" /> type
<b>FileExSearchNameMatch</b> and perform its own filtering.</para><para>After the search handle is established, use it in the
<see cref="FindNextFile" /> function to search for other
files that match the same pattern with the same filtering that is being performed. When the search handle is not
needed, it should be closed by using the
<see cref="FindClose" /> function.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFileEx</b>, therefore it may not
be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the directory by
using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use
the <see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\server\service*". However, you cannot use an <i>lpFileName</i> that points
to the share itself; for example, "\server\service" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>The following call:</para><code>FindFirstFileEx( lpFileName,
                 FindExInfoStandard,
                 lpFindData,
                 FindExSearchNameMatch,
                 NULL,
                 0 );
</code><para>Is equivalent to the following call:</para><code>FindFirstFile( lpFileName, lpFindData );
</code><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be run on
a 64-bit computer, you should call
<see cref="Wow64DisableWow64FsRedirection" /> before
calling <b>FindFirstFileEx</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following code shows a minimal use of
<b>FindFirstFileEx</b>. This program is equivalent to the
example in the <see cref="FindFirstFile" /> topic.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFileEx(argv[1], FindExInfoStandard, &amp;amp;amp;amp;amp;amp;FindFileData,
             FindExSearchNameMatch, NULL, 0);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFileEx failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso cref="FINDEX_INFO_LEVELS" />
    <seealso cref="FINDEX_SEARCH_OPS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstFileExA">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those
specified.</para>
      <para>For the most basic version of this function, see
<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all
subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and
prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the
<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the
<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" /></para>
      <para>enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured
search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search
information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches are case-sensitive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses a larger buffer for directory queries, which can increase performance of the find operation.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFileEx</b> function opens a search handle
and returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFileEx</b> does no sorting of the search results.
For additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type.</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>If the underlying file system does not support the specified type of filtering, other than directory
filtering, <b>FindFirstFileEx</b> fails with the error
<b>ERROR_NOT_SUPPORTED</b>. The application must use
<see cref="FINDEX_SEARCH_OPS" /> type
<b>FileExSearchNameMatch</b> and perform its own filtering.</para><para>After the search handle is established, use it in the
<see cref="FindNextFile" /> function to search for other
files that match the same pattern with the same filtering that is being performed. When the search handle is not
needed, it should be closed by using the
<see cref="FindClose" /> function.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFileEx</b>, therefore it may not
be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the directory by
using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use
the <see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\server\service*". However, you cannot use an <i>lpFileName</i> that points
to the share itself; for example, "\server\service" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>The following call:</para><code>FindFirstFileEx( lpFileName,
                 FindExInfoStandard,
                 lpFindData,
                 FindExSearchNameMatch,
                 NULL,
                 0 );
</code><para>Is equivalent to the following call:</para><code>FindFirstFile( lpFileName, lpFindData );
</code><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be run on
a 64-bit computer, you should call
<see cref="Wow64DisableWow64FsRedirection" /> before
calling <b>FindFirstFileEx</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following code shows a minimal use of
<b>FindFirstFileEx</b>. This program is equivalent to the
example in the <see cref="FindFirstFile" /> topic.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFileEx(argv[1], FindExInfoStandard, &amp;amp;amp;amp;amp;amp;FindFileData,
             FindExSearchNameMatch, NULL, 0);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFileEx failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso cref="FINDEX_INFO_LEVELS" />
    <seealso cref="FINDEX_SEARCH_OPS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstFileExW">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name and attributes that match those
specified.</para>
      <para>For the most basic version of this function, see
<see cref="FindFirstFile" />.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all
subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and
prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>The information level of the returned data.</para>
      <para>This parameter is one of the
<see cref="FINDEX_INFO_LEVELS" /> enumeration values.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the buffer that receives the file data.</para>
      <para>The pointer type is determined by the level of information that is specified in the
<i>fInfoLevelId</i> parameter.</para>
    </param>
    <param name="fSearchOp">
      <para>The type of filtering to perform that is different from wildcard matching.</para>
      <para>This parameter is one of the <see cref="FINDEX_SEARCH_OPS" /></para>
      <para>enumeration values.</para>
    </param>
    <param name="lpSearchFilter">
      <para>A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured
search information.</para>
      <para>At this time, none of the supported <i>fSearchOp</i> values require extended search
information. Therefore, this pointer must be <b>NULL</b>.</para>
    </param>
    <param name="dwAdditionalFlags">
      <para>Specifies additional flags that control the search.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_CASE_SENSITIVE</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches are case-sensitive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_LARGE_FETCH</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses a larger buffer for directory queries, which can increase performance of the find operation.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFileEx</b> function opens a search handle
and returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFileEx</b> does no sorting of the search results.
For additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type.</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>If the underlying file system does not support the specified type of filtering, other than directory
filtering, <b>FindFirstFileEx</b> fails with the error
<b>ERROR_NOT_SUPPORTED</b>. The application must use
<see cref="FINDEX_SEARCH_OPS" /> type
<b>FileExSearchNameMatch</b> and perform its own filtering.</para><para>After the search handle is established, use it in the
<see cref="FindNextFile" /> function to search for other
files that match the same pattern with the same filtering that is being performed. When the search handle is not
needed, it should be closed by using the
<see cref="FindClose" /> function.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFileEx</b>, therefore it may not
be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the directory by
using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use
the <see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\server\service*". However, you cannot use an <i>lpFileName</i> that points
to the share itself; for example, "\server\service" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>The following call:</para><code>FindFirstFileEx( lpFileName,
                 FindExInfoStandard,
                 lpFindData,
                 FindExSearchNameMatch,
                 NULL,
                 0 );
</code><para>Is equivalent to the following call:</para><code>FindFirstFile( lpFileName, lpFindData );
</code><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be run on
a 64-bit computer, you should call
<see cref="Wow64DisableWow64FsRedirection" /> before
calling <b>FindFirstFileEx</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following code shows a minimal use of
<b>FindFirstFileEx</b>. This program is equivalent to the
example in the <see cref="FindFirstFile" /> topic.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFileEx(argv[1], FindExInfoStandard, &amp;amp;amp;amp;amp;amp;FindFileData,
             FindExSearchNameMatch, NULL, 0);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFileEx failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso cref="FINDEX_INFO_LEVELS" />
    <seealso cref="FINDEX_SEARCH_OPS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstFileNameW">
    <summary>
      <para>Creates an enumeration of all the hard links to the specified file. The
<b>FindFirstFileNameW</b> function returns a handle to the
enumeration that can be used on subsequent calls to the
<see cref="FindNextFileNameW" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileNameTransactedW" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>Reserved; specify zero (0).</para>
    </param>
    <param name="StringLength">
      <para>The size of the buffer pointed to by the <i>LinkName</i> parameter, in characters. If
this call fails and the error returned from the
<see cref="GetLastError" /> function is
<b>ERROR_MORE_DATA</b> (234), the value that is returned by this parameter is the size that
the buffer pointed to by <i>LinkName</i>  must be to contain all the data.</para>
    </param>
    <param name="LinkName">
      <para>A pointer to a buffer to store the first link name found for <i>lpFileName</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle that can be used with the
<see cref="FindNextFileNameW" /> function or closed with the
<see cref="FindClose" /> function.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b> (0xffffffff). To
get extended error information, call the <see cref="GetLastError" /></para>
      <para>function.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFileNameTransactedW" />
    <seealso cref="FindNextFileNameW" />
  </member>
  <member name="Windows.FindFirstFile">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial
name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the
<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to
the root and all subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure that
receives information about a found file or directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFile</b> function opens a search handle and
returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFile</b> does no sorting of the search results. For
additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type (for other options, see <see cref="FindFirstFileEx" />).</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>After the search handle is established, you can use it to search for other files that match the same pattern
by using the <see cref="FindNextFile" /> function.</para><para>When the search handle is no longer needed, close it by using the
<see cref="FindClose" /> function, not
<see cref="CloseHandle" />.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFile</b>, therefore it may not be
obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the
directory by using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use the
<see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root
directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\Server\Share*". However, you cannot use an <i>lpFileName</i></para><para>that points to the share itself; for example, "\Server\Share" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be  run
on a 64-bit computer, you should call the
<see cref="Wow64DisableWow64FsRedirection" /> function
before calling <b>FindFirstFile</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows you a minimal use of <b>FindFirstFile</b>.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFile(argv[1], &amp;amp;amp;amp;amp;amp;FindFileData);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFile failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><para>For another example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstFileA">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial
name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the
<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to
the root and all subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure that
receives information about a found file or directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFile</b> function opens a search handle and
returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFile</b> does no sorting of the search results. For
additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type (for other options, see <see cref="FindFirstFileEx" />).</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>After the search handle is established, you can use it to search for other files that match the same pattern
by using the <see cref="FindNextFile" /> function.</para><para>When the search handle is no longer needed, close it by using the
<see cref="FindClose" /> function, not
<see cref="CloseHandle" />.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFile</b>, therefore it may not be
obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the
directory by using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use the
<see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root
directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\Server\Share*". However, you cannot use an <i>lpFileName</i></para><para>that points to the share itself; for example, "\Server\Share" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be  run
on a 64-bit computer, you should call the
<see cref="Wow64DisableWow64FsRedirection" /> function
before calling <b>FindFirstFile</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows you a minimal use of <b>FindFirstFile</b>.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFile(argv[1], &amp;amp;amp;amp;amp;amp;FindFileData);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFile failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><para>For another example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstFileW">
    <summary>
      <para>Searches a directory for a file or subdirectory with a name that matches a specific name (or partial
name if wildcards are used).</para>
      <para>To specify additional attributes to use in a search, use the
<see cref="FindFirstFileEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk
(*) or a question mark (?).</para>
      <para>This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string
or a string that is missing the terminating null character), or end in a trailing backslash (\).</para>
      <para>If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to
the root and all subdirectories on the path.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure that
receives information about a found file or directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to
<see cref="FindNextFile" /> or
<see cref="FindClose" />, and  the
<i>lpFindFileData</i> parameter contains information about the first file or directory
found.</para>
      <para>If the function fails or fails to locate files from the search string in the
<i>lpFileName</i> parameter, the return value is
<b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are
indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstFile</b> function opens a search handle and
returns information about the first file that the file system finds with a name that matches the specified
pattern. This may or may not be the first file or directory that appears in a directory-listing application (such
as the dir command) when given the same file name string pattern. This is because
<b>FindFirstFile</b> does no sorting of the search results. For
additional information, see <see cref="FindNextFile" />.</para>
      <para>The following list identifies some other search characteristics:</para>
      <list type="bullet">
        <item>
          <description>The search is performed strictly on the name of the file, not on any attributes such as a date or a file
type (for other options, see <see cref="FindFirstFileEx" />).</description>
        </item>
        <item>
          <description>The search includes the long and short file names.</description>
        </item>
        <item>
          <description>An attempt to open a search with a trailing backslash always fails.</description>
        </item>
        <item>
          <description>Passing an invalid string, <b>NULL</b>, or empty string for the
<i>lpFileName</i> parameter is not a valid use of this function. Results in this case are
undefined.</description>
        </item>
      </list>
      <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.
<para>After the search handle is established, you can use it to search for other files that match the same pattern
by using the <see cref="FindNextFile" /> function.</para><para>When the search handle is no longer needed, close it by using the
<see cref="FindClose" /> function, not
<see cref="CloseHandle" />.</para><para>As stated previously, you cannot use a trailing backslash (\) in the <i>lpFileName</i></para><para>input string for <b>FindFirstFile</b>, therefore it may not be
obvious how to search root directories. If you want to see files or get the attributes of a root directory, the
following options would apply:</para><list type="bullet"><item><description>To examine files in a root directory, you can use "C:\*" and step through the
directory by using <see cref="FindNextFile" />.</description></item><item><description>To get the attributes of a root directory, use the
<see cref="GetFileAttributes" /> function.</description></item></list><b>Note</b>  Prepending the string "\\?\" does not allow access to the root
directory.
<para>On network shares, you can use an <i>lpFileName</i> in the form of the following:
"\Server\Share*". However, you cannot use an <i>lpFileName</i></para><para>that points to the share itself; for example, "\Server\Share" is not valid.</para><para>To examine a directory that is not a root directory, use the path to that directory, without a trailing
backslash. For example, an argument of "C:\Windows" returns information about the
directory "C:\Windows", not about a directory or file in
"C:\Windows". To examine the files and directories in
"C:\Windows", use an <i>lpFileName</i> of
"C:\Windows*".</para><para>Be aware that some other thread or process could create or delete a file with this name between the time you
query for the result and the time you act on the information. If this is a potential concern for your application,
one possible solution is to use the <see cref="CreateFile" /> function with
<b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b></para><para>(which fails if the file does not exist).</para><para>If you are writing a 32-bit application to list all the files in a directory and the application may be  run
on a 64-bit computer, you should call the
<see cref="Wow64DisableWow64FsRedirection" /> function
before calling <b>FindFirstFile</b> and call
<see cref="Wow64RevertWow64FsRedirection" /> after the
last call to <see cref="FindNextFile" />. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.</para><para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about
the symbolic link, not the target.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows you a minimal use of <b>FindFirstFile</b>.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

void _tmain(int argc, TCHAR *argv[])
{
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [target_file]\n"), argv[0]);
      return;
   }

   _tprintf (TEXT("Target file is %s\n"), argv[1]);
   hFind = FindFirstFile(argv[1], &amp;amp;amp;amp;amp;amp;FindFileData);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      printf ("FindFirstFile failed (%d)\n", GetLastError());
      return;
   }
   else
   {
      _tprintf (TEXT("The first file found is %s\n"),
                FindFileData.cFileName);
      FindClose(hFind);
   }
}

</code><para>For another example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para><blockquote><para>[!NOTE]
The fileapi.h header defines FindFirstFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="FindFirstFileTransacted" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindFirstStreamW">
    <summary>
      <para>Enumerates the first stream with a .$DATA stream type in the specified file or
directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="FindFirstStreamTransactedW" /></para>
      <para>function.</para>
    </summary>
    <param name="lpFileName">
      <para>The fully qualified file name.</para>
    </param>
    <param name="InfoLevel">
      <para>The information level of the returned data. This parameter is one of the values in the
<see cref="STREAM_INFO_LEVELS" /> enumeration type.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FindStreamInfoStandard</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The data is returned in a
<see cref="WIN32_FIND_STREAM_DATA" /> structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFindStreamData">
      <para>A pointer to a buffer that receives the file stream data. The format of this data depends on the value of
the <i>InfoLevel</i> parameter.</para>
    </param>
    <param name="dwFlags">
      <para>Reserved for future use. This parameter must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle that can be used in subsequent calls to the
<see cref="FindNextStreamW" /> function.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended
error information, call <see cref="GetLastError" />.</para>
      <para>If no  streams can be found, the function fails and
<see cref="GetLastError" /> returns
<b>ERROR_HANDLE_EOF</b> (38).</para>
      <para>If the filesystem does not support streams, the function fails and
<see cref="GetLastError" /> returns
<b>ERROR_INVALID_PARAMETER</b> (87).</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstStreamW</b> function opens a search handle and returns information about the first
$DATA stream in the specified file or directory.
For files, this is always the default, unnamed data stream, ".$DATA". Directories do not have $DATA streams by default
and cannot have an unnamed data stream, but may have named data streams set after they have been created.
After the search handle has been established, use it in calls to the
<see cref="FindNextStreamW" /> function to
search for other streams in the specified file or directory. When the search handle is no longer needed, it should
be closed using the <see cref="FindClose" /> function.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 supports list of streams less than or equal to 64K.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstStreamTransactedW" />
    <seealso cref="FindNextStreamW" />
    <seealso cref="STREAM_INFO_LEVELS" />
    <seealso cref="WIN32_FIND_STREAM_DATA" />
  </member>
  <member name="Windows.FindFirstVolume">
    <summary>
      <para>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies a volume
<b>GUID</b> path for the first volume that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer to receive the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolume" /> and
<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolume</b> function opens a volume search handle and returns
information about the first volume found on a computer. After the search handle is established, you can use the
<see cref="FindNextVolume" /> function to search for other volumes. When
the search handle is no longer needed, close it by using the
<see cref="FindVolumeClose" /> function.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindNextVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindFirstVolumeA">
    <summary>
      <para>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies a volume
<b>GUID</b> path for the first volume that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer to receive the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolume" /> and
<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolume</b> function opens a volume search handle and returns
information about the first volume found on a computer. After the search handle is established, you can use the
<see cref="FindNextVolume" /> function to search for other volumes. When
the search handle is no longer needed, close it by using the
<see cref="FindVolumeClose" /> function.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindNextVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindFirstVolumeW">
    <summary>
      <para>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies a volume
<b>GUID</b> path for the first volume that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer to receive the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolume" /> and
<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolume</b> function opens a volume search handle and returns
information about the first volume found on a computer. After the search handle is established, you can use the
<see cref="FindNextVolume" /> function to search for other volumes. When
the search handle is no longer needed, close it by using the
<see cref="FindVolumeClose" /> function.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindNextVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextChangeNotification">
    <summary>
      <para>Requests that the operating system signal a change notification handle the next time it detects an appropriate change.</para>
    </summary>
    <param name="hChangeHandle">
      <para>A handle to a change notification handle created by the
<see cref="FindFirstChangeNotification" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After the
<b>FindNextChangeNotification</b> function returns successfully, the application can wait for notification that a change has occurred by using the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>.</para>
      <para>If a change occurs after a call to
<see cref="FindFirstChangeNotification" /> but before a call to
<b>FindNextChangeNotification</b>, the operating system records the change. When
<b>FindNextChangeNotification</b> is executed, the recorded change immediately satisfies a wait for the change notification.</para>
      <para>Each successful call to <b>FindNextChangeNotification</b> must be followed by a call to one of the wait functions. If the wait function returns for any reason other than the change notification handle being signaled (for example, if the wait times out), the application must retry the wait. Failing to follow this rule can cause the system to eventually run out of resources. It can also cause the application to miss some change notifications.</para>
      <para>When <i>hChangeHandle</i> is no longer needed, close it by using the
<see cref="FindCloseChangeNotification" /> function.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>See remark</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Application might experience false positives on CsvFs pause/resume.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/obtaining-directory-change-notifications">Obtaining Directory Change Notifications</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="FindCloseChangeNotification" />
    <seealso cref="FindFirstChangeNotification" />
  </member>
  <member name="Windows.FindNextFile">
    <summary>
      <para>Continues a file search from a previous call to the
<see cref="FindFirstFile" />,
<see cref="FindFirstFileEx" />, or
<see cref="FindFirstFileTransacted" /> functions.</para>
    </summary>
    <param name="hFindFile">
      <para>The search handle returned by a previous call to the
<see cref="FindFirstFile" /> or
<see cref="FindFirstFileEx" /> function.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure
that receives information about the found file or subdirectory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and  the <i>lpFindFileData</i></para>
      <para>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i></para>
      <para>are indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
    <remarks>
      <para>This function uses the same search filters that were used to create the search handle passed in the
<i>hFindFile</i> parameter. For additional information, see
<see cref="FindFirstFile" /> and
<see cref="FindFirstFileEx" />.</para>
      <para>The order in which the search returns the files, such as alphabetical order, is not guaranteed, and is
dependent on the file system. If the data  must be sorted,
the application must do the ordering after obtaining all the results.</para>
      <para>
        <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.</para>
      <para>The order in which this function returns the file names is dependent on the file system type. With the NTFS
file system and CDFS file systems, the names are usually returned in alphabetical order. With FAT file systems,
the names are usually returned in the order the files were written to the disk, which may or may not be in
alphabetical order. However, as stated previously, these behaviors are not guaranteed.</para>
      <para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about the
symbolic link, not the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the file enumeration handle, then the files that are returned are subject
to transaction isolation rules.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindNextFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindNextFileA">
    <summary>
      <para>Continues a file search from a previous call to the
<see cref="FindFirstFile" />,
<see cref="FindFirstFileEx" />, or
<see cref="FindFirstFileTransacted" /> functions.</para>
    </summary>
    <param name="hFindFile">
      <para>The search handle returned by a previous call to the
<see cref="FindFirstFile" /> or
<see cref="FindFirstFileEx" /> function.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure
that receives information about the found file or subdirectory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and  the <i>lpFindFileData</i></para>
      <para>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i></para>
      <para>are indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
    <remarks>
      <para>This function uses the same search filters that were used to create the search handle passed in the
<i>hFindFile</i> parameter. For additional information, see
<see cref="FindFirstFile" /> and
<see cref="FindFirstFileEx" />.</para>
      <para>The order in which the search returns the files, such as alphabetical order, is not guaranteed, and is
dependent on the file system. If the data  must be sorted,
the application must do the ordering after obtaining all the results.</para>
      <para>
        <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.</para>
      <para>The order in which this function returns the file names is dependent on the file system type. With the NTFS
file system and CDFS file systems, the names are usually returned in alphabetical order. With FAT file systems,
the names are usually returned in the order the files were written to the disk, which may or may not be in
alphabetical order. However, as stated previously, these behaviors are not guaranteed.</para>
      <para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about the
symbolic link, not the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the file enumeration handle, then the files that are returned are subject
to transaction isolation rules.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindNextFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindNextFileW">
    <summary>
      <para>Continues a file search from a previous call to the
<see cref="FindFirstFile" />,
<see cref="FindFirstFileEx" />, or
<see cref="FindFirstFileTransacted" /> functions.</para>
    </summary>
    <param name="hFindFile">
      <para>The search handle returned by a previous call to the
<see cref="FindFirstFile" /> or
<see cref="FindFirstFileEx" /> function.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure
that receives information about the found file or subdirectory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and  the <i>lpFindFileData</i></para>
      <para>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i></para>
      <para>are indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
    <remarks>
      <para>This function uses the same search filters that were used to create the search handle passed in the
<i>hFindFile</i> parameter. For additional information, see
<see cref="FindFirstFile" /> and
<see cref="FindFirstFileEx" />.</para>
      <para>The order in which the search returns the files, such as alphabetical order, is not guaranteed, and is
dependent on the file system. If the data  must be sorted,
the application must do the ordering after obtaining all the results.</para>
      <para>
        <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.</para>
      <para>The order in which this function returns the file names is dependent on the file system type. With the NTFS
file system and CDFS file systems, the names are usually returned in alphabetical order. With FAT file systems,
the names are usually returned in the order the files were written to the disk, which may or may not be in
alphabetical order. However, as stated previously, these behaviors are not guaranteed.</para>
      <para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about the
symbolic link, not the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the file enumeration handle, then the files that are returned are subject
to transaction isolation rules.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindNextFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindNextFileNameW">
    <summary>
      <para>Continues enumerating the hard links to a file using the handle returned by a successful call to the
<see cref="FindFirstFileNameW" /> function.</para>
    </summary>
    <param name="hFindStream">
      <para>A handle to the enumeration that is returned by a successful call to
<see cref="FindFirstFileNameW" />.</para>
    </param>
    <param name="StringLength">
      <para>The size of the <i>LinkName</i> parameter, in characters. If this call fails and the
error is <b>ERROR_MORE_DATA</b>, the value that is returned by this parameter is the size
that <i>LinkName</i>  must be to contain all the data.</para>
    </param>
    <param name="LinkName">
      <para>A pointer to a buffer to store the first link name found for <i>lpFileName</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If no matching files can be found, the <see cref="GetLastError" /></para>
      <para>function returns <b>ERROR_HANDLE_EOF</b>.</para>
    </returns>
    <remarks>
      <para>If the function returns <b>TRUE</b>, there are more hard links to enumerate.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFileNameW" />
  </member>
  <member name="Windows.FindNextFile">
    <summary>
      <para>Continues a file search from a previous call to the
<see cref="FindFirstFile" />,
<see cref="FindFirstFileEx" />, or
<see cref="FindFirstFileTransacted" /> functions.</para>
    </summary>
    <param name="hFindFile">
      <para>The search handle returned by a previous call to the
<see cref="FindFirstFile" /> or
<see cref="FindFirstFileEx" /> function.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure
that receives information about the found file or subdirectory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and  the <i>lpFindFileData</i></para>
      <para>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i></para>
      <para>are indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
    <remarks>
      <para>This function uses the same search filters that were used to create the search handle passed in the
<i>hFindFile</i> parameter. For additional information, see
<see cref="FindFirstFile" /> and
<see cref="FindFirstFileEx" />.</para>
      <para>The order in which the search returns the files, such as alphabetical order, is not guaranteed, and is
dependent on the file system. If the data  must be sorted,
the application must do the ordering after obtaining all the results.</para>
      <para>
        <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.</para>
      <para>The order in which this function returns the file names is dependent on the file system type. With the NTFS
file system and CDFS file systems, the names are usually returned in alphabetical order. With FAT file systems,
the names are usually returned in the order the files were written to the disk, which may or may not be in
alphabetical order. However, as stated previously, these behaviors are not guaranteed.</para>
      <para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about the
symbolic link, not the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the file enumeration handle, then the files that are returned are subject
to transaction isolation rules.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindNextFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindNextFileA">
    <summary>
      <para>Continues a file search from a previous call to the
<see cref="FindFirstFile" />,
<see cref="FindFirstFileEx" />, or
<see cref="FindFirstFileTransacted" /> functions.</para>
    </summary>
    <param name="hFindFile">
      <para>The search handle returned by a previous call to the
<see cref="FindFirstFile" /> or
<see cref="FindFirstFileEx" /> function.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure
that receives information about the found file or subdirectory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and  the <i>lpFindFileData</i></para>
      <para>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i></para>
      <para>are indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
    <remarks>
      <para>This function uses the same search filters that were used to create the search handle passed in the
<i>hFindFile</i> parameter. For additional information, see
<see cref="FindFirstFile" /> and
<see cref="FindFirstFileEx" />.</para>
      <para>The order in which the search returns the files, such as alphabetical order, is not guaranteed, and is
dependent on the file system. If the data  must be sorted,
the application must do the ordering after obtaining all the results.</para>
      <para>
        <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.</para>
      <para>The order in which this function returns the file names is dependent on the file system type. With the NTFS
file system and CDFS file systems, the names are usually returned in alphabetical order. With FAT file systems,
the names are usually returned in the order the files were written to the disk, which may or may not be in
alphabetical order. However, as stated previously, these behaviors are not guaranteed.</para>
      <para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about the
symbolic link, not the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the file enumeration handle, then the files that are returned are subject
to transaction isolation rules.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindNextFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindNextFileW">
    <summary>
      <para>Continues a file search from a previous call to the
<see cref="FindFirstFile" />,
<see cref="FindFirstFileEx" />, or
<see cref="FindFirstFileTransacted" /> functions.</para>
    </summary>
    <param name="hFindFile">
      <para>The search handle returned by a previous call to the
<see cref="FindFirstFile" /> or
<see cref="FindFirstFileEx" /> function.</para>
    </param>
    <param name="lpFindFileData">
      <para>A pointer to the <see cref="WIN32_FIND_DATA" /> structure
that receives information about the found file or subdirectory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and  the <i>lpFindFileData</i></para>
      <para>parameter contains information about the next file or directory found.</para>
      <para>If the function fails, the return value is zero and the contents of <i>lpFindFileData</i></para>
      <para>are indeterminate. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function fails because no more matching files can be found, the
<see cref="GetLastError" /> function returns
<b>ERROR_NO_MORE_FILES</b>.</para>
    </returns>
    <remarks>
      <para>This function uses the same search filters that were used to create the search handle passed in the
<i>hFindFile</i> parameter. For additional information, see
<see cref="FindFirstFile" /> and
<see cref="FindFirstFileEx" />.</para>
      <para>The order in which the search returns the files, such as alphabetical order, is not guaranteed, and is
dependent on the file system. If the data  must be sorted,
the application must do the ordering after obtaining all the results.</para>
      <para>
        <b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be
current at the time this function is called. To be assured of getting the current NTFS file system file
attributes, call the
<see cref="GetFileInformationByHandle" /> function.</para>
      <para>The order in which this function returns the file names is dependent on the file system type. With the NTFS
file system and CDFS file systems, the names are usually returned in alphabetical order. With FAT file systems,
the names are usually returned in the order the files were written to the disk, which may or may not be in
alphabetical order. However, as stated previously, these behaviors are not guaranteed.</para>
      <para>If the path points to a symbolic link, the
<see cref="WIN32_FIND_DATA" /> buffer contains information about the
symbolic link, not the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the file enumeration handle, then the files that are returned are subject
to transaction isolation rules.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/listing-the-files-in-a-directory">Listing the Files in a Directory</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines FindNextFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindClose" />
    <seealso cref="FindFirstFile" />
    <seealso cref="FindFirstFileEx" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="WIN32_FIND_DATA" />
  </member>
  <member name="Windows.FindNextStreamW">
    <summary>
      <para>Continues a stream search started by a previous call to the
<see cref="FindFirstStreamW" /> function.</para>
    </summary>
    <param name="hFindStream">
      <para>The search handle returned by a previous call to the
<see cref="FindFirstStreamW" /> function.</para>
    </param>
    <param name="lpFindStreamData">
      <para>A pointer to the
<see cref="WIN32_FIND_STREAM_DATA" /> structure that
receives information about the stream.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no  more streams can be found,
<b>GetLastError</b> returns
<b>ERROR_HANDLE_EOF</b> (38).</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstStreamW" />
    <seealso cref="WIN32_FIND_STREAM_DATA" />
  </member>
  <member name="Windows.FindNextVolume">
    <summary>
      <para>Continues a volume search started by a call to the
<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</para>
    </summary>
    <param name="hFindVolume">
      <para>The volume search handle returned by a previous call to the
<see cref="FindFirstVolume" /> function.</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no matching files can be found, the
<b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolume" />, you can use the
<b>FindNextVolume</b> function to search for other volumes.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindFirstVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextVolumeA">
    <summary>
      <para>Continues a volume search started by a call to the
<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</para>
    </summary>
    <param name="hFindVolume">
      <para>The volume search handle returned by a previous call to the
<see cref="FindFirstVolume" /> function.</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no matching files can be found, the
<b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolume" />, you can use the
<b>FindNextVolume</b> function to search for other volumes.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindFirstVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextVolumeW">
    <summary>
      <para>Continues a volume search started by a call to the
<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</para>
    </summary>
    <param name="hFindVolume">
      <para>The volume search handle returned by a previous call to the
<see cref="FindFirstVolume" /> function.</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no matching files can be found, the
<b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolume" />, you can use the
<b>FindNextVolume</b> function to search for other volumes.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindFirstVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindVolumeClose">
    <summary>
      <para>Closes the specified volume search handle. The <see cref="FindFirstVolume" /> and
<see cref="FindNextVolume" /> functions use this search handle to locate volumes.</para>
    </summary>
    <param name="hFindVolume">
      <para>The volume search handle to be closed. This handle must have been previously opened by the
<see cref="FindFirstVolume" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After the
<b>FindVolumeClose</b> function is called, the handle <i>hFindVolume</i> cannot be used in subsequent calls to either
<see cref="FindNextVolume" /> or
<b>FindVolumeClose</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindFirstVolume" />
    <seealso cref="FindNextVolume" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FlushFileBuffers">
    <summary>
      <para>Flushes the buffers of a specified file and causes all buffered data to be written to a file.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the open file.</para>
      <para>The file handle must have the <b>GENERIC_WRITE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is a handle to a communications device, the function only flushes the transmit buffer.</para>
      <para>If <i>hFile</i> is a handle to the server end of a named pipe, the function does not return until the client has read all buffered data from the pipe.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The function fails if <i>hFile</i> is a handle to the console output. That is because the console output is not buffered. The function returns <b>FALSE</b>, and <see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>.</para>
    </returns>
    <remarks>
      <para>Typically the
<see cref="WriteFile" /> and
<see cref="WriteFileEx" /> functions write data to an internal buffer that the operating system writes to a disk or communication pipe on a regular basis. The
<b>FlushFileBuffers</b> function writes all the buffered information for a specified file to the device or pipe.</para>
      <para>Due to disk caching interactions within the system, the
<b>FlushFileBuffers</b> function can be inefficient when used after every write to a disk drive device when many writes are being performed separately. If an application is  performing multiple writes to disk and also needs to ensure critical data is
written to persistent media, the application should use unbuffered I/O  instead of frequently calling <b>FlushFileBuffers</b>. To open a file for unbuffered I/O, call the <see cref="CreateFile" /> function with the <b>FILE_FLAG_NO_BUFFERING</b> and <b>FILE_FLAG_WRITE_THROUGH</b> flags. This prevents the file contents from being cached and flushes the metadata to disk with each write. For more information, see <see cref="CreateFile" />.</para>
      <para>To flush all open files on a volume, call <b>FlushFileBuffers</b> with a handle to the volume. The caller must have administrative privileges. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>When opening a volume with <see cref="CreateFile" />, the <i>lpFileName</i> string should be the following form: \.\<i>x</i>: or \?\Volume{<i>GUID</i>}. Do not use a trailing backslash in the volume name, because that indicates the root directory of a drive.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/multithreaded-pipe-server">Multithreaded Pipe Server</a>.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="WriteFile" />
    <seealso cref="WriteFileEx" />
  </member>
  <member name="Windows.GetCompressedFileSize">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
    <remarks>
      <para>An application can determine whether a volume is compressed by calling
<see cref="GetVolumeInformation" />, then checking the status of the <b>FS_VOL_IS_COMPRESSED</b> flag in the <b>DWORD</b> value pointed to by that function's <i>lpFileSystemFlags</i> parameter.</para>
      <para>If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to
<see cref="GetFileSize" />.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns the file size of the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetCompressedFileSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetCompressedFileSizeTransacted" />
    <seealso cref="GetFileSize" />
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetCompressedFileSizeA">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
    <remarks>
      <para>An application can determine whether a volume is compressed by calling
<see cref="GetVolumeInformation" />, then checking the status of the <b>FS_VOL_IS_COMPRESSED</b> flag in the <b>DWORD</b> value pointed to by that function's <i>lpFileSystemFlags</i> parameter.</para>
      <para>If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to
<see cref="GetFileSize" />.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns the file size of the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetCompressedFileSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetCompressedFileSizeTransacted" />
    <seealso cref="GetFileSize" />
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetCompressedFileSizeW">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
    <remarks>
      <para>An application can determine whether a volume is compressed by calling
<see cref="GetVolumeInformation" />, then checking the status of the <b>FS_VOL_IS_COMPRESSED</b> flag in the <b>DWORD</b> value pointed to by that function's <i>lpFileSystemFlags</i> parameter.</para>
      <para>If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to
<see cref="GetFileSize" />.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns the file size of the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetCompressedFileSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetCompressedFileSizeTransacted" />
    <seealso cref="GetFileSize" />
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetCompressedFileSize">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
    <remarks>
      <para>An application can determine whether a volume is compressed by calling
<see cref="GetVolumeInformation" />, then checking the status of the <b>FS_VOL_IS_COMPRESSED</b> flag in the <b>DWORD</b> value pointed to by that function's <i>lpFileSystemFlags</i> parameter.</para>
      <para>If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to
<see cref="GetFileSize" />.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns the file size of the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetCompressedFileSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetCompressedFileSizeTransacted" />
    <seealso cref="GetFileSize" />
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetCompressedFileSizeA">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
    <remarks>
      <para>An application can determine whether a volume is compressed by calling
<see cref="GetVolumeInformation" />, then checking the status of the <b>FS_VOL_IS_COMPRESSED</b> flag in the <b>DWORD</b> value pointed to by that function's <i>lpFileSystemFlags</i> parameter.</para>
      <para>If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to
<see cref="GetFileSize" />.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns the file size of the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetCompressedFileSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetCompressedFileSizeTransacted" />
    <seealso cref="GetFileSize" />
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetCompressedFileSizeW">
    <summary>
      <para>Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a volume that supports compression and the file is compressed, the value obtained is the compressed size of the specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the value obtained is the sparse size of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the <see cref="GetCompressedFileSizeTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpFileSizeHigh">
      <para>The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size.</para>
      <para>This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.</para>
      <para>If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <see cref="GetLastError" /> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).</para>
    </returns>
    <remarks>
      <para>An application can determine whether a volume is compressed by calling
<see cref="GetVolumeInformation" />, then checking the status of the <b>FS_VOL_IS_COMPRESSED</b> flag in the <b>DWORD</b> value pointed to by that function's <i>lpFileSystemFlags</i> parameter.</para>
      <para>If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to
<see cref="GetFileSize" />.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns the file size of the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetCompressedFileSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetCompressedFileSizeTransacted" />
    <seealso cref="GetFileSize" />
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetDiskFreeSpace">
    <summary>
      <para>Retrieves information about the specified disk, including the amount of free space on the
disk.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory of the disk for which information is to be returned. If this parameter is
<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name,
it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive
specification must have a trailing backslash (for example, "C:\"). The calling application must
have <b>FILE_LIST_DIRECTORY</b> access rights for this  directory.</para>
    </param>
    <param name="lpSectorsPerCluster">
      <para>A pointer to a variable that receives the number of sectors per cluster.</para>
    </param>
    <param name="lpBytesPerSector">
      <para>A pointer to a variable that receives the number of bytes per sector.</para>
    </param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the
user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the
disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user
who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetDiskFreeSpaceEx" /> function lets
you avoid some of the arithmetic that is required by the
<b>GetDiskFreeSpace</b> function.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso cref="GetDriveType" />
  </member>
  <member name="Windows.GetDiskFreeSpaceA">
    <summary>
      <para>Retrieves information about the specified disk, including the amount of free space on the
disk.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory of the disk for which information is to be returned. If this parameter is
<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name,
it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive
specification must have a trailing backslash (for example, "C:\"). The calling application must
have <b>FILE_LIST_DIRECTORY</b> access rights for this  directory.</para>
    </param>
    <param name="lpSectorsPerCluster">
      <para>A pointer to a variable that receives the number of sectors per cluster.</para>
    </param>
    <param name="lpBytesPerSector">
      <para>A pointer to a variable that receives the number of bytes per sector.</para>
    </param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the
user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the
disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user
who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetDiskFreeSpaceEx" /> function lets
you avoid some of the arithmetic that is required by the
<b>GetDiskFreeSpace</b> function.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso cref="GetDriveType" />
  </member>
  <member name="Windows.GetDiskFreeSpaceW">
    <summary>
      <para>Retrieves information about the specified disk, including the amount of free space on the
disk.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory of the disk for which information is to be returned. If this parameter is
<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name,
it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive
specification must have a trailing backslash (for example, "C:\"). The calling application must
have <b>FILE_LIST_DIRECTORY</b> access rights for this  directory.</para>
    </param>
    <param name="lpSectorsPerCluster">
      <para>A pointer to a variable that receives the number of sectors per cluster.</para>
    </param>
    <param name="lpBytesPerSector">
      <para>A pointer to a variable that receives the number of bytes per sector.</para>
    </param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the
user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the
disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user
who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetDiskFreeSpaceEx" /> function lets
you avoid some of the arithmetic that is required by the
<b>GetDiskFreeSpace</b> function.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso cref="GetDriveType" />
  </member>
  <member name="Windows.GetDiskFreeSpaceEx">
    <summary>
      <para>Retrieves information about the amount of space that is available on a disk volume, which is the total
amount of space, the total amount of free space, and the total amount of free space available to the user that is
associated with the calling thread.</para>
    </summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example,
"\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a
disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this
directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user
who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who
is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The values obtained by this function are of the type
<see cref="ULARGE_INTEGER" />. Do not truncate these values to 32
bits.</para>
      <para>The <b>GetDiskFreeSpaceEx</b> function returns zero (0)
for <i>lpTotalNumberOfFreeBytes</i> and <i>lpFreeBytesAvailable</i> for all
CD requests unless the disk is an unwritten CD in a CD-RW drive.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetModuleHandle" />
  </member>
  <member name="Windows.GetDiskFreeSpaceExA">
    <summary>
      <para>Retrieves information about the amount of space that is available on a disk volume, which is the total
amount of space, the total amount of free space, and the total amount of free space available to the user that is
associated with the calling thread.</para>
    </summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example,
"\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a
disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this
directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user
who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who
is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The values obtained by this function are of the type
<see cref="ULARGE_INTEGER" />. Do not truncate these values to 32
bits.</para>
      <para>The <b>GetDiskFreeSpaceEx</b> function returns zero (0)
for <i>lpTotalNumberOfFreeBytes</i> and <i>lpFreeBytesAvailable</i> for all
CD requests unless the disk is an unwritten CD in a CD-RW drive.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetModuleHandle" />
  </member>
  <member name="Windows.GetDiskFreeSpaceExW">
    <summary>
      <para>Retrieves information about the amount of space that is available on a disk volume, which is the total
amount of space, the total amount of free space, and the total amount of free space available to the user that is
associated with the calling thread.</para>
    </summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example,
"\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a
disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this
directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user
who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who
is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The values obtained by this function are of the type
<see cref="ULARGE_INTEGER" />. Do not truncate these values to 32
bits.</para>
      <para>The <b>GetDiskFreeSpaceEx</b> function returns zero (0)
for <i>lpTotalNumberOfFreeBytes</i> and <i>lpFreeBytesAvailable</i> for all
CD requests unless the disk is an unwritten CD in a CD-RW drive.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetModuleHandle" />
  </member>
  <member name="Windows.GetDiskFreeSpaceEx">
    <summary>
      <para>Retrieves information about the amount of space that is available on a disk volume, which is the total
amount of space, the total amount of free space, and the total amount of free space available to the user that is
associated with the calling thread.</para>
    </summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example,
"\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a
disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this
directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user
who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who
is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The values obtained by this function are of the type
<see cref="ULARGE_INTEGER" />. Do not truncate these values to 32
bits.</para>
      <para>The <b>GetDiskFreeSpaceEx</b> function returns zero (0)
for <i>lpTotalNumberOfFreeBytes</i> and <i>lpFreeBytesAvailable</i> for all
CD requests unless the disk is an unwritten CD in a CD-RW drive.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetModuleHandle" />
  </member>
  <member name="Windows.GetDiskFreeSpaceExA">
    <summary>
      <para>Retrieves information about the amount of space that is available on a disk volume, which is the total
amount of space, the total amount of free space, and the total amount of free space available to the user that is
associated with the calling thread.</para>
    </summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example,
"\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a
disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this
directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user
who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who
is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The values obtained by this function are of the type
<see cref="ULARGE_INTEGER" />. Do not truncate these values to 32
bits.</para>
      <para>The <b>GetDiskFreeSpaceEx</b> function returns zero (0)
for <i>lpTotalNumberOfFreeBytes</i> and <i>lpFreeBytesAvailable</i> for all
CD requests unless the disk is an unwritten CD in a CD-RW drive.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetModuleHandle" />
  </member>
  <member name="Windows.GetDiskFreeSpaceExW">
    <summary>
      <para>Retrieves information about the amount of space that is available on a disk volume, which is the total
amount of space, the total amount of free space, and the total amount of free space available to the user that is
associated with the calling thread.</para>
    </summary>
    <param name="lpDirectoryName">
      <para>A directory on the disk.</para>
      <para>If this parameter is <b>NULL</b>, the function uses the root of the current disk.</para>
      <para>If this parameter is a UNC name, it must include a trailing backslash, for example,
"\\MyServer\MyShare\".</para>
      <para>This parameter does not have to specify the root directory on a disk. The function accepts any directory on a
disk.</para>
      <para>The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this
directory.</para>
    </param>
    <param name="lpFreeBytesAvailableToCaller">
      <para>A pointer to a variable that receives the total number of free bytes on a disk that are available to the user
who is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.</para>
    </param>
    <param name="lpTotalNumberOfBytes">
      <para>A pointer to a variable that receives the total number of bytes on a disk that are available to the user who
is associated with the calling thread.</para>
      <para>This parameter can be <b>NULL</b>.</para>
      <para>If per-user quotas are being used, this value may be less than the total number of bytes on a disk.</para>
      <para>To determine the total number of bytes on a disk or volume, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.</para>
    </param>
    <param name="lpTotalNumberOfFreeBytes">
      <para>A pointer to a variable that receives the total number of free bytes on a disk.</para>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The values obtained by this function are of the type
<see cref="ULARGE_INTEGER" />. Do not truncate these values to 32
bits.</para>
      <para>The <b>GetDiskFreeSpaceEx</b> function returns zero (0)
for <i>lpTotalNumberOfFreeBytes</i> and <i>lpFreeBytesAvailable</i> for all
CD requests unless the disk is an unwritten CD in a CD-RW drive.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetModuleHandle" />
  </member>
  <member name="Windows.GetDiskFreeSpace">
    <summary>
      <para>Retrieves information about the specified disk, including the amount of free space on the
disk.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory of the disk for which information is to be returned. If this parameter is
<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name,
it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive
specification must have a trailing backslash (for example, "C:\"). The calling application must
have <b>FILE_LIST_DIRECTORY</b> access rights for this  directory.</para>
    </param>
    <param name="lpSectorsPerCluster">
      <para>A pointer to a variable that receives the number of sectors per cluster.</para>
    </param>
    <param name="lpBytesPerSector">
      <para>A pointer to a variable that receives the number of bytes per sector.</para>
    </param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the
user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the
disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user
who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetDiskFreeSpaceEx" /> function lets
you avoid some of the arithmetic that is required by the
<b>GetDiskFreeSpace</b> function.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso cref="GetDriveType" />
  </member>
  <member name="Windows.GetDiskFreeSpaceA">
    <summary>
      <para>Retrieves information about the specified disk, including the amount of free space on the
disk.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory of the disk for which information is to be returned. If this parameter is
<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name,
it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive
specification must have a trailing backslash (for example, "C:\"). The calling application must
have <b>FILE_LIST_DIRECTORY</b> access rights for this  directory.</para>
    </param>
    <param name="lpSectorsPerCluster">
      <para>A pointer to a variable that receives the number of sectors per cluster.</para>
    </param>
    <param name="lpBytesPerSector">
      <para>A pointer to a variable that receives the number of bytes per sector.</para>
    </param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the
user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the
disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user
who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetDiskFreeSpaceEx" /> function lets
you avoid some of the arithmetic that is required by the
<b>GetDiskFreeSpace</b> function.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso cref="GetDriveType" />
  </member>
  <member name="Windows.GetDiskFreeSpaceW">
    <summary>
      <para>Retrieves information about the specified disk, including the amount of free space on the
disk.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory of the disk for which information is to be returned. If this parameter is
<b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name,
it must include a trailing backslash (for example, "\\MyServer\MyShare\"). Furthermore, a drive
specification must have a trailing backslash (for example, "C:\"). The calling application must
have <b>FILE_LIST_DIRECTORY</b> access rights for this  directory.</para>
    </param>
    <param name="lpSectorsPerCluster">
      <para>A pointer to a variable that receives the number of sectors per cluster.</para>
    </param>
    <param name="lpBytesPerSector">
      <para>A pointer to a variable that receives the number of bytes per sector.</para>
    </param>
    <param name="lpNumberOfFreeClusters">
      <para>A pointer to a variable that receives the total number of free clusters on the disk that are available to the
user who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of free clusters on the
disk.</para>
    </param>
    <param name="lpTotalNumberOfClusters">
      <para>A pointer to a variable that receives the total number of clusters on the disk that are available to the user
who is associated with the calling thread.</para>
      <para>If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetDiskFreeSpaceEx" /> function lets
you avoid some of the arithmetic that is required by the
<b>GetDiskFreeSpace</b> function.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the operation is performed
on the target.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDiskFreeSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-functions">Disk Management Functions</seealso>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso cref="GetDriveType" />
  </member>
  <member name="Windows.GetDriveType">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network
drive.</para>
      <para>To determine whether a drive is a USB-type drive, call
<see cref="SetupDiGetDeviceRegistryProperty" /></para>
      <para>and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the
root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive type cannot be determined.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The root path is invalid; for example, there is no volume mounted at the specified path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOVABLE</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_FIXED</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has fixed media; for example, a hard disk drive or flash drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOTE</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a remote (network) drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_CDROM</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a CD-ROM drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_RAMDISK</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a RAM disk.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDriveType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetDriveTypeA">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network
drive.</para>
      <para>To determine whether a drive is a USB-type drive, call
<see cref="SetupDiGetDeviceRegistryProperty" /></para>
      <para>and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the
root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive type cannot be determined.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The root path is invalid; for example, there is no volume mounted at the specified path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOVABLE</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_FIXED</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has fixed media; for example, a hard disk drive or flash drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOTE</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a remote (network) drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_CDROM</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a CD-ROM drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_RAMDISK</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a RAM disk.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDriveType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetDriveTypeW">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network
drive.</para>
      <para>To determine whether a drive is a USB-type drive, call
<see cref="SetupDiGetDeviceRegistryProperty" /></para>
      <para>and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the
root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive type cannot be determined.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The root path is invalid; for example, there is no volume mounted at the specified path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOVABLE</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_FIXED</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has fixed media; for example, a hard disk drive or flash drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOTE</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a remote (network) drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_CDROM</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a CD-ROM drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_RAMDISK</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a RAM disk.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDriveType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetDriveType">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network
drive.</para>
      <para>To determine whether a drive is a USB-type drive, call
<see cref="SetupDiGetDeviceRegistryProperty" /></para>
      <para>and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the
root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive type cannot be determined.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The root path is invalid; for example, there is no volume mounted at the specified path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOVABLE</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_FIXED</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has fixed media; for example, a hard disk drive or flash drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOTE</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a remote (network) drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_CDROM</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a CD-ROM drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_RAMDISK</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a RAM disk.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDriveType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetDriveTypeA">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network
drive.</para>
      <para>To determine whether a drive is a USB-type drive, call
<see cref="SetupDiGetDeviceRegistryProperty" /></para>
      <para>and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the
root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive type cannot be determined.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The root path is invalid; for example, there is no volume mounted at the specified path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOVABLE</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_FIXED</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has fixed media; for example, a hard disk drive or flash drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOTE</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a remote (network) drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_CDROM</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a CD-ROM drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_RAMDISK</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a RAM disk.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDriveType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetDriveTypeW">
    <summary>
      <para>Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network
drive.</para>
      <para>To determine whether a drive is a USB-type drive, call
<see cref="SetupDiGetDeviceRegistryProperty" /></para>
      <para>and specify the <b>SPDRP_REMOVAL_POLICY</b> property.</para>
    </summary>
    <param name="lpRootPathName">
      <para>The root directory for the drive.</para>
      <para>A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the
root of the current directory.</para>
    </param>
    <returns>
      <para>The return value specifies the type of drive, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive type cannot be determined.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_NO_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The root path is invalid; for example, there is no volume mounted at the specified path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOVABLE</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_FIXED</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive has fixed media; for example, a hard disk drive or flash drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_REMOTE</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a remote (network) drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_CDROM</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a CD-ROM drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DRIVE_RAMDISK</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The drive is a RAM disk.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetDriveType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetFileAttributes">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the
<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a
list of attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended
error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When <b>GetFileAttributes</b> is called on a directory
that is a mounted folder, it returns the file system attributes of the directory, not those of the root directory
in the volume that the mounted folder associates with the directory. To obtain the file attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributes</b>. The results are the attributes of
the root directory on the associated volume.</para>
      <para>If you call <b>GetFileAttributes</b> for a network share,
the function fails, and <see cref="GetLastError" /> returns
<b>ERROR_BAD_NETPATH</b>. You must specify a path to a subfolder on that share.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeviceIoControl" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributesEx" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileAttributesA">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the
<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a
list of attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended
error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When <b>GetFileAttributes</b> is called on a directory
that is a mounted folder, it returns the file system attributes of the directory, not those of the root directory
in the volume that the mounted folder associates with the directory. To obtain the file attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributes</b>. The results are the attributes of
the root directory on the associated volume.</para>
      <para>If you call <b>GetFileAttributes</b> for a network share,
the function fails, and <see cref="GetLastError" /> returns
<b>ERROR_BAD_NETPATH</b>. You must specify a path to a subfolder on that share.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeviceIoControl" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributesEx" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileAttributesW">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the
<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a
list of attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended
error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When <b>GetFileAttributes</b> is called on a directory
that is a mounted folder, it returns the file system attributes of the directory, not those of the root directory
in the volume that the mounted folder associates with the directory. To obtain the file attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributes</b>. The results are the attributes of
the root directory on the associated volume.</para>
      <para>If you call <b>GetFileAttributes</b> for a network share,
the function fails, and <see cref="GetLastError" /> returns
<b>ERROR_BAD_NETPATH</b>. You must specify a path to a subfolder on that share.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeviceIoControl" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributesEx" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileAttributesEx">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesExW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the
<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GetFileExInfoStandard</b>
          </description>
          <description>
            <para>The <i>lpFileInformation</i> parameter is a
<see cref="WIN32_FILE_ATTRIBUTE_DATA" /></para>
            <para>structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of
<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetFileAttributes" /> function retrieves file
system attribute information. <b>GetFileAttributesEx</b></para>
      <para>can obtain other sets of file or directory attribute information. Currently,
<b>GetFileAttributesEx</b> retrieves a set of standard
attributes that is a superset of the file system attribute information.</para>
      <para>When the <b>GetFileAttributesEx</b> function is
called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root
directory in the volume that the mounted folder associates with the directory. To obtain the attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributesEx</b>. The results are the attributes
of the root directory on the associated volume.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed.  So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation.  If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileAttributesExA">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesExW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the
<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GetFileExInfoStandard</b>
          </description>
          <description>
            <para>The <i>lpFileInformation</i> parameter is a
<see cref="WIN32_FILE_ATTRIBUTE_DATA" /></para>
            <para>structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of
<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetFileAttributes" /> function retrieves file
system attribute information. <b>GetFileAttributesEx</b></para>
      <para>can obtain other sets of file or directory attribute information. Currently,
<b>GetFileAttributesEx</b> retrieves a set of standard
attributes that is a superset of the file system attribute information.</para>
      <para>When the <b>GetFileAttributesEx</b> function is
called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root
directory in the volume that the mounted folder associates with the directory. To obtain the attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributesEx</b>. The results are the attributes
of the root directory on the associated volume.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed.  So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation.  If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileAttributesExW">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesExW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the
<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GetFileExInfoStandard</b>
          </description>
          <description>
            <para>The <i>lpFileInformation</i> parameter is a
<see cref="WIN32_FILE_ATTRIBUTE_DATA" /></para>
            <para>structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of
<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetFileAttributes" /> function retrieves file
system attribute information. <b>GetFileAttributesEx</b></para>
      <para>can obtain other sets of file or directory attribute information. Currently,
<b>GetFileAttributesEx</b> retrieves a set of standard
attributes that is a superset of the file system attribute information.</para>
      <para>When the <b>GetFileAttributesEx</b> function is
called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root
directory in the volume that the mounted folder associates with the directory. To obtain the attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributesEx</b>. The results are the attributes
of the root directory on the associated volume.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed.  So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation.  If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileAttributesEx">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesExW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the
<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GetFileExInfoStandard</b>
          </description>
          <description>
            <para>The <i>lpFileInformation</i> parameter is a
<see cref="WIN32_FILE_ATTRIBUTE_DATA" /></para>
            <para>structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of
<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetFileAttributes" /> function retrieves file
system attribute information. <b>GetFileAttributesEx</b></para>
      <para>can obtain other sets of file or directory attribute information. Currently,
<b>GetFileAttributesEx</b> retrieves a set of standard
attributes that is a superset of the file system attribute information.</para>
      <para>When the <b>GetFileAttributesEx</b> function is
called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root
directory in the volume that the mounted folder associates with the directory. To obtain the attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributesEx</b>. The results are the attributes
of the root directory on the associated volume.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed.  So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation.  If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileAttributesExA">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesExW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the
<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GetFileExInfoStandard</b>
          </description>
          <description>
            <para>The <i>lpFileInformation</i> parameter is a
<see cref="WIN32_FILE_ATTRIBUTE_DATA" /></para>
            <para>structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of
<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetFileAttributes" /> function retrieves file
system attribute information. <b>GetFileAttributesEx</b></para>
      <para>can obtain other sets of file or directory attribute information. Currently,
<b>GetFileAttributesEx</b> retrieves a set of standard
attributes that is a superset of the file system attribute information.</para>
      <para>When the <b>GetFileAttributesEx</b> function is
called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root
directory in the volume that the mounted folder associates with the directory. To obtain the attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributesEx</b>. The results are the attributes
of the root directory on the associated volume.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed.  So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation.  If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileAttributesExW">
    <summary>
      <para>Retrieves attributes for a specified file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesExW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="fInfoLevelId">
      <para>A class of attribute information to retrieve.</para>
      <para>This parameter can be the following value from the
<see cref="GET_FILEEX_INFO_LEVELS" /> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GetFileExInfoStandard</b>
          </description>
          <description>
            <para>The <i>lpFileInformation</i> parameter is a
<see cref="WIN32_FILE_ATTRIBUTE_DATA" /></para>
            <para>structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a buffer that receives the attribute information.</para>
      <para>The type of attribute information that is stored into this buffer is determined by the value of
<i>fInfoLevelId</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <see cref="GetFileAttributes" /> function retrieves file
system attribute information. <b>GetFileAttributesEx</b></para>
      <para>can obtain other sets of file or directory attribute information. Currently,
<b>GetFileAttributesEx</b> retrieves a set of standard
attributes that is a superset of the file system attribute information.</para>
      <para>When the <b>GetFileAttributesEx</b> function is
called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root
directory in the volume that the mounted folder associates with the directory. To obtain the attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributesEx</b>. The results are the attributes
of the root directory on the associated volume.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed.  So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation.  If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileAttributes">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the
<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a
list of attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended
error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When <b>GetFileAttributes</b> is called on a directory
that is a mounted folder, it returns the file system attributes of the directory, not those of the root directory
in the volume that the mounted folder associates with the directory. To obtain the file attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributes</b>. The results are the attributes of
the root directory on the associated volume.</para>
      <para>If you call <b>GetFileAttributes</b> for a network share,
the function fails, and <see cref="GetLastError" /> returns
<b>ERROR_BAD_NETPATH</b>. You must specify a path to a subfolder on that share.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeviceIoControl" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributesEx" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileAttributesA">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the
<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a
list of attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended
error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When <b>GetFileAttributes</b> is called on a directory
that is a mounted folder, it returns the file system attributes of the directory, not those of the root directory
in the volume that the mounted folder associates with the directory. To obtain the file attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributes</b>. The results are the attributes of
the root directory on the associated volume.</para>
      <para>If you call <b>GetFileAttributes</b> for a network share,
the function fails, and <see cref="GetLastError" /> returns
<b>ERROR_BAD_NETPATH</b>. You must specify a path to a subfolder on that share.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeviceIoControl" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributesEx" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileAttributesW">
    <summary>
      <para>Retrieves file system attributes for a specified file or directory.</para>
      <para>To get more attribute information, use the
<see cref="GetFileAttributesEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value contains the attributes of the specified file or directory. For a
list of attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <para>If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended
error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When <b>GetFileAttributes</b> is called on a directory
that is a mounted folder, it returns the file system attributes of the directory, not those of the root directory
in the volume that the mounted folder associates with the directory. To obtain the file attributes of the
associated volume, call
<see cref="GetVolumeNameForVolumeMountPoint" /> to
obtain the name of the associated volume. Then use the resulting name in a call to
<b>GetFileAttributes</b>. The results are the attributes of
the root directory on the associated volume.</para>
      <para>If you call <b>GetFileAttributes</b> for a network share,
the function fails, and <see cref="GetLastError" /> returns
<b>ERROR_BAD_NETPATH</b>. You must specify a path to a subfolder on that share.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.</para>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeviceIoControl" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="FindNextFile" />
    <seealso cref="GetFileAttributesEx" />
    <seealso cref="GetFileAttributesTransacted" />
    <seealso cref="SetFileAttributes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetFileInformationByHandle">
    <summary>
      <para>Retrieves file information for the specified file.</para>
      <para>For a more advanced version of this function, see
<see cref="GetFileInformationByHandleEx" />.</para>
      <para>To set file information using a file handle, see
<see cref="SetFileInformationByHandle" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file that contains the information to be retrieved.</para>
      <para>This handle should not be a pipe handle.</para>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to a
<see cref="BY_HANDLE_FILE_INFORMATION" /> structure that
receives the file information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and file information data is contained in the buffer
pointed to by the <i>lpFileInformation</i> parameter.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Depending on the underlying network features of the operating system and the type of server connected to, the
<b>GetFileInformationByHandle</b> function may fail,
return partial information, or full information for the given file.</para>
      <para>You can compare the <b>VolumeSerialNumber</b> and <b>FileIndex</b></para>
      <para>members returned in the
<see cref="BY_HANDLE_FILE_INFORMATION" /> structure to
determine if two paths map to the same target; for example, you can compare two file paths and determine if they
map to the same directory.</para>
      <para>IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the thread at the time of the call, then the function returns the
compressed file size of the isolated file view. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/about-transactional-ntfs">About Transactional NTFS</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileInformationByHandleEx" />
    <seealso cref="SetFileInformationByHandle" />
  </member>
  <member name="Windows.GetFileSize">
    <summary>
      <para>Retrieves the size of the specified file, in bytes.</para>
      <para>It is recommended that you use <see cref="GetFileSizeEx" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file.</para>
    </param>
    <param name="lpFileSizeHigh">
      <para>A pointer to the variable where the high-order doubleword of the file size is returned. This parameter can
be <b>NULL</b> if the application does not require the high-order doubleword.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the low-order doubleword of the file size, and, if
<i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the
high-order doubleword of the file size into the variable pointed to by that parameter.</para>
      <para>If the function fails and <i>lpFileSizeHigh</i> is <b>NULL</b>, the
return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call
<see cref="GetLastError" />. When
<i>lpFileSizeHigh</i> is <b>NULL</b>, the results returned for large
files are ambiguous, and you will not be able to determine the actual size of the file. It is recommended that
you use <see cref="GetFileSizeEx" /> instead.</para>
      <para>If the function fails and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the
return value is <b>INVALID_FILE_SIZE</b> and
<see cref="GetLastError" /> will return a value other than
<b>NO_ERROR</b>.</para>
    </returns>
    <remarks>
      <para>You cannot use the <b>GetFileSize</b> function with a handle of
a nonseeking device such as a pipe or a communications device. To determine the file type for
<i>hFile</i>, use the <see cref="GetFileType" /></para>
      <para>function.</para>
      <para>The <b>GetFileSize</b> function retrieves the uncompressed size
of a file. Use the <see cref="GetCompressedFileSize" /></para>
      <para>function to obtain the compressed size of a file.</para>
      <para>Note that if the return value is <b>INVALID_FILE_SIZE</b> (0xffffffff), an application must
call <see cref="GetLastError" /> to determine whether the function has
succeeded or failed. The reason the function may appear to fail when it has not is that
<i>lpFileSizeHigh</i> could be non-<b>NULL</b> or the file size could be
0xffffffff. In this case, <b>GetLastError</b> will return
<b>NO_ERROR</b> (0) upon success. Because of this behavior, it is recommended that you use
<see cref="GetFileSizeEx" /> instead.</para>
      <para>
        <b>Transacted Operations:  </b>If there is a transaction bound to the file handle, then the function returns information for the isolated
file view.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-view-within-a-file">Creating a View Within a File</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetCompressedFileSize" />
    <seealso cref="GetFileSizeEx" />
    <seealso cref="GetFileType" />
  </member>
  <member name="Windows.GetFileSizeEx">
    <summary>
      <para>Retrieves the size of the specified file.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The handle must have been created with the
<b>FILE_READ_ATTRIBUTES</b> access right or equivalent, or the caller must have sufficient permission on the directory that contains the file.
For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="lpFileSize">
      <para>A pointer to a <see cref="LARGE_INTEGER" /> structure that
receives the file size, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>Transacted Operations:  </b>If there is a transaction bound to the file handle, then the function returns information for the isolated
file view.</para>
      <para>
        <b>Windows Store apps:  </b>
        <b>GetFileSizeEx</b> is not supported. Use
<see cref="GetFileInformationByHandleEx" />.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="LARGE_INTEGER" />
  </member>
  <member name="Windows.GetFileTime">
    <summary>
      <para>Retrieves the date and time that a file or directory was created, last accessed, and last
modified.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file or directory for which dates and times are to be retrieved. The handle must have been
created using the <see cref="CreateFile" /> function with the
<b>GENERIC_READ</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="lpCreationTime">
      <para>A pointer to a <see cref="FILETIME" /> structure to receive the
date and time the file or directory was created. This parameter can be <b>NULL</b> if the
application does not require this information.</para>
    </param>
    <param name="lpLastAccessTime">
      <para>A pointer to a <see cref="FILETIME" /> structure to
receive the date and time the file or directory was last accessed. The last access time includes the last time
the file or directory was written to, read from, or, in the case of executable files, run. This parameter can be
<b>NULL</b> if the application does not require this information.</para>
    </param>
    <param name="lpLastWriteTime">
      <para>A pointer to a <see cref="FILETIME" /> structure to
receive the date and time the file or directory was last written to, truncated, or overwritten (for example,
with <see cref="WriteFile" /> or
<see cref="SetEndOfFile" />). This date and time is not updated when
file attributes or security descriptors are changed. This parameter can be <b>NULL</b> if the
application does not require this information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Not all file systems can record creation and last access times and not all file systems record them in the
same manner. For example, on  FAT, create time has a resolution of 10 milliseconds, write time has a resolution of
2 seconds, and access time has a resolution of 1 day (really, the access date). Therefore, the
<b>GetFileTime</b> function may not return the same file time
information set using the <see cref="SetFileTime" /> function.</para>
      <para>NTFS delays updates to the last access time for a file by up to one hour after the last access. NTFS also
permits last access time updates to be disabled. Last access time is not updated on NTFS volumes by default.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>Last access time is updated on NTFS volumes by default.</para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/file-times">File Times</a>.</para>
      <para>If you rename or delete a file, then restore it shortly thereafter, Windows searches the cache for file
information to restore. Cached information includes its short/long name pair and creation time.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/retrieving-the-last-write-time">Retrieving the Last-Write Time</a>.</para>
    </remarks>
    <seealso cref="FILETIME" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/file-times">File Times</seealso>
    <seealso cref="GetFileSize" />
    <seealso cref="GetFileType" />
    <seealso cref="SetFileTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.GetFileType">
    <summary>
      <para>Retrieves the file type of the specified file.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file.</para>
    </param>
    <returns>
      <para>The function returns one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_TYPE_CHAR</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file is a character file, typically an LPT device or a console.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_TYPE_DISK</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file is a disk file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_TYPE_PIPE</b>
                </description>
              </item>
              <item>
                <description>0x0003</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file is a socket, a named pipe, or an anonymous pipe.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_TYPE_REMOTE</b>
                </description>
              </item>
              <item>
                <description>0x8000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Unused.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_TYPE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>0x0000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Either the type of the specified file is unknown, or the function failed.</para>
          </description>
        </item>
      </list>
      <para>You can distinguish between a "valid" return of <b>FILE_TYPE_UNKNOWN</b> and its return due to a calling error (for example, passing an invalid handle to
<b>GetFileType</b>) by calling
<see cref="GetLastError" />.</para>
      <para>If the function worked properly and <b>FILE_TYPE_UNKNOWN</b> was returned, a call to <b>GetLastError</b> will return <b>NO_ERROR</b>.</para>
      <para>If the function returned <b>FILE_TYPE_UNKNOWN</b> due to an error in calling
<b>GetFileType</b>,
<see cref="GetLastError" /> will return the error code.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileSize" />
    <seealso cref="GetFileTime" />
  </member>
  <member name="Windows.GetFinalPathNameByHandle">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">
      <para>A handle to a file or directory.</para>
    </param>
    <param name="lpszFilePath">
      <para>A pointer to a buffer that receives the path of <i>hFile</i>.</para>
    </param>
    <param name="cchFilePath">
      <para>The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</para>
    </param>
    <param name="dwFlags">
      <para>The type of result to return.  This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_NORMALIZED</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the normalized drive name. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_OPENED</b>
                </description>
              </item>
              <item>
                <description>0x8</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the opened file name (not normalized).</para>
          </description>
        </item>
      </list>
      <para>This parameter can also include one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_DOS</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the drive letter. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_GUID</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with a volume <b>GUID</b> path instead of the drive name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b> VOLUME_NAME_NONE</b>
                </description>
              </item>
              <item>
                <description>0x4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with no drive information.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_NT</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the volume device path.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by
<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the
size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,
<b>GetFinalPathNameByHandleA</b>, the return value
includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the
terminating null character, the return value is the required buffer size, in
<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>Can be returned if you are searching for a drive letter and one does not exist.  For example, the handle
was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive
letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to
identify it.</para>
            <para>This return value can also be returned if you are searching for a volume <b>GUID</b></para>
            <para>path on a network share. Volume <b>GUID</b> paths are not created for network
shares.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Invalid flags were specified for <i>dwFlags</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The Server Message Block (SMB) Protocol does not support queries for normalized paths. Consequently, when you call this function passing the handle of a file opened using SMB, and with the FILE_NAME_NORMALIZED flag, the function splits the path into its components and tries to query for the normalized name of each of those components in turn. If the user lacks access permission to any one of those components, then the function call fails with ERROR_ACCESS_DENIED.</para>
      <para>A final path is the path that is returned when a path is fully resolved. For example, for a symbolic link
named "C:\tmp\mydir" that points to "D:\yourdir", the final path would be
"D:\yourdir".</para>
      <para>The string that is returned by this function uses the "\\?\"
syntax. For more information, see <see cref="CreateFile" />.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following example demonstrates the use of the
<b>GetFinalPathNameByHandle</b> function.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE MAX_PATH

void __cdecl _tmain(int argc, TCHAR *argv[])
{
    TCHAR Path[BUFSIZE];
    HANDLE hFile;
    DWORD dwRet;

    printf("\n");
    if( argc != 2 )
    {
        printf("ERROR:\tIncorrect number of arguments\n\n");
        printf("%s &lt;file_name&gt;\n", argv[0]);
        return;
    }

    hFile = CreateFile(argv[1],               // file to open
                       GENERIC_READ,          // open for reading
                       FILE_SHARE_READ,       // share for reading
                       NULL,                  // default security
                       OPEN_EXISTING,         // existing file only
                       FILE_ATTRIBUTE_NORMAL, // normal file
                       NULL);                 // no attr. template

    if( hFile == INVALID_HANDLE_VALUE)
    {
        printf("Could not open file (error %d\n)", GetLastError());
        return;
    }

    dwRet = GetFinalPathNameByHandle( hFile, Path, BUFSIZE, VOLUME_NAME_NT );
    if(dwRet &lt; BUFSIZE)
    {
        _tprintf(TEXT("\nThe final path is: %s\n"), Path);
    }
    else printf("\nThe required buffer size is %d.\n", dwRet);

    CloseHandle(hFile);
}

</code>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFinalPathNameByHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.GetFinalPathNameByHandleA">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">
      <para>A handle to a file or directory.</para>
    </param>
    <param name="lpszFilePath">
      <para>A pointer to a buffer that receives the path of <i>hFile</i>.</para>
    </param>
    <param name="cchFilePath">
      <para>The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</para>
    </param>
    <param name="dwFlags">
      <para>The type of result to return.  This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_NORMALIZED</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the normalized drive name. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_OPENED</b>
                </description>
              </item>
              <item>
                <description>0x8</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the opened file name (not normalized).</para>
          </description>
        </item>
      </list>
      <para>This parameter can also include one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_DOS</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the drive letter. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_GUID</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with a volume <b>GUID</b> path instead of the drive name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b> VOLUME_NAME_NONE</b>
                </description>
              </item>
              <item>
                <description>0x4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with no drive information.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_NT</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the volume device path.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by
<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the
size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,
<b>GetFinalPathNameByHandleA</b>, the return value
includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the
terminating null character, the return value is the required buffer size, in
<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>Can be returned if you are searching for a drive letter and one does not exist.  For example, the handle
was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive
letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to
identify it.</para>
            <para>This return value can also be returned if you are searching for a volume <b>GUID</b></para>
            <para>path on a network share. Volume <b>GUID</b> paths are not created for network
shares.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Invalid flags were specified for <i>dwFlags</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The Server Message Block (SMB) Protocol does not support queries for normalized paths. Consequently, when you call this function passing the handle of a file opened using SMB, and with the FILE_NAME_NORMALIZED flag, the function splits the path into its components and tries to query for the normalized name of each of those components in turn. If the user lacks access permission to any one of those components, then the function call fails with ERROR_ACCESS_DENIED.</para>
      <para>A final path is the path that is returned when a path is fully resolved. For example, for a symbolic link
named "C:\tmp\mydir" that points to "D:\yourdir", the final path would be
"D:\yourdir".</para>
      <para>The string that is returned by this function uses the "\\?\"
syntax. For more information, see <see cref="CreateFile" />.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following example demonstrates the use of the
<b>GetFinalPathNameByHandle</b> function.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE MAX_PATH

void __cdecl _tmain(int argc, TCHAR *argv[])
{
    TCHAR Path[BUFSIZE];
    HANDLE hFile;
    DWORD dwRet;

    printf("\n");
    if( argc != 2 )
    {
        printf("ERROR:\tIncorrect number of arguments\n\n");
        printf("%s &lt;file_name&gt;\n", argv[0]);
        return;
    }

    hFile = CreateFile(argv[1],               // file to open
                       GENERIC_READ,          // open for reading
                       FILE_SHARE_READ,       // share for reading
                       NULL,                  // default security
                       OPEN_EXISTING,         // existing file only
                       FILE_ATTRIBUTE_NORMAL, // normal file
                       NULL);                 // no attr. template

    if( hFile == INVALID_HANDLE_VALUE)
    {
        printf("Could not open file (error %d\n)", GetLastError());
        return;
    }

    dwRet = GetFinalPathNameByHandle( hFile, Path, BUFSIZE, VOLUME_NAME_NT );
    if(dwRet &lt; BUFSIZE)
    {
        _tprintf(TEXT("\nThe final path is: %s\n"), Path);
    }
    else printf("\nThe required buffer size is %d.\n", dwRet);

    CloseHandle(hFile);
}

</code>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFinalPathNameByHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.GetFinalPathNameByHandleW">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">
      <para>A handle to a file or directory.</para>
    </param>
    <param name="lpszFilePath">
      <para>A pointer to a buffer that receives the path of <i>hFile</i>.</para>
    </param>
    <param name="cchFilePath">
      <para>The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</para>
    </param>
    <param name="dwFlags">
      <para>The type of result to return.  This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_NORMALIZED</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the normalized drive name. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_OPENED</b>
                </description>
              </item>
              <item>
                <description>0x8</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the opened file name (not normalized).</para>
          </description>
        </item>
      </list>
      <para>This parameter can also include one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_DOS</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the drive letter. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_GUID</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with a volume <b>GUID</b> path instead of the drive name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b> VOLUME_NAME_NONE</b>
                </description>
              </item>
              <item>
                <description>0x4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with no drive information.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_NT</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the volume device path.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by
<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the
size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,
<b>GetFinalPathNameByHandleA</b>, the return value
includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the
terminating null character, the return value is the required buffer size, in
<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>Can be returned if you are searching for a drive letter and one does not exist.  For example, the handle
was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive
letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to
identify it.</para>
            <para>This return value can also be returned if you are searching for a volume <b>GUID</b></para>
            <para>path on a network share. Volume <b>GUID</b> paths are not created for network
shares.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Invalid flags were specified for <i>dwFlags</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The Server Message Block (SMB) Protocol does not support queries for normalized paths. Consequently, when you call this function passing the handle of a file opened using SMB, and with the FILE_NAME_NORMALIZED flag, the function splits the path into its components and tries to query for the normalized name of each of those components in turn. If the user lacks access permission to any one of those components, then the function call fails with ERROR_ACCESS_DENIED.</para>
      <para>A final path is the path that is returned when a path is fully resolved. For example, for a symbolic link
named "C:\tmp\mydir" that points to "D:\yourdir", the final path would be
"D:\yourdir".</para>
      <para>The string that is returned by this function uses the "\\?\"
syntax. For more information, see <see cref="CreateFile" />.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following example demonstrates the use of the
<b>GetFinalPathNameByHandle</b> function.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE MAX_PATH

void __cdecl _tmain(int argc, TCHAR *argv[])
{
    TCHAR Path[BUFSIZE];
    HANDLE hFile;
    DWORD dwRet;

    printf("\n");
    if( argc != 2 )
    {
        printf("ERROR:\tIncorrect number of arguments\n\n");
        printf("%s &lt;file_name&gt;\n", argv[0]);
        return;
    }

    hFile = CreateFile(argv[1],               // file to open
                       GENERIC_READ,          // open for reading
                       FILE_SHARE_READ,       // share for reading
                       NULL,                  // default security
                       OPEN_EXISTING,         // existing file only
                       FILE_ATTRIBUTE_NORMAL, // normal file
                       NULL);                 // no attr. template

    if( hFile == INVALID_HANDLE_VALUE)
    {
        printf("Could not open file (error %d\n)", GetLastError());
        return;
    }

    dwRet = GetFinalPathNameByHandle( hFile, Path, BUFSIZE, VOLUME_NAME_NT );
    if(dwRet &lt; BUFSIZE)
    {
        _tprintf(TEXT("\nThe final path is: %s\n"), Path);
    }
    else printf("\nThe required buffer size is %d.\n", dwRet);

    CloseHandle(hFile);
}

</code>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFinalPathNameByHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.GetFinalPathNameByHandle">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">
      <para>A handle to a file or directory.</para>
    </param>
    <param name="lpszFilePath">
      <para>A pointer to a buffer that receives the path of <i>hFile</i>.</para>
    </param>
    <param name="cchFilePath">
      <para>The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</para>
    </param>
    <param name="dwFlags">
      <para>The type of result to return.  This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_NORMALIZED</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the normalized drive name. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_OPENED</b>
                </description>
              </item>
              <item>
                <description>0x8</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the opened file name (not normalized).</para>
          </description>
        </item>
      </list>
      <para>This parameter can also include one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_DOS</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the drive letter. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_GUID</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with a volume <b>GUID</b> path instead of the drive name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b> VOLUME_NAME_NONE</b>
                </description>
              </item>
              <item>
                <description>0x4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with no drive information.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_NT</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the volume device path.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by
<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the
size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,
<b>GetFinalPathNameByHandleA</b>, the return value
includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the
terminating null character, the return value is the required buffer size, in
<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>Can be returned if you are searching for a drive letter and one does not exist.  For example, the handle
was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive
letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to
identify it.</para>
            <para>This return value can also be returned if you are searching for a volume <b>GUID</b></para>
            <para>path on a network share. Volume <b>GUID</b> paths are not created for network
shares.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Invalid flags were specified for <i>dwFlags</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The Server Message Block (SMB) Protocol does not support queries for normalized paths. Consequently, when you call this function passing the handle of a file opened using SMB, and with the FILE_NAME_NORMALIZED flag, the function splits the path into its components and tries to query for the normalized name of each of those components in turn. If the user lacks access permission to any one of those components, then the function call fails with ERROR_ACCESS_DENIED.</para>
      <para>A final path is the path that is returned when a path is fully resolved. For example, for a symbolic link
named "C:\tmp\mydir" that points to "D:\yourdir", the final path would be
"D:\yourdir".</para>
      <para>The string that is returned by this function uses the "\\?\"
syntax. For more information, see <see cref="CreateFile" />.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following example demonstrates the use of the
<b>GetFinalPathNameByHandle</b> function.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE MAX_PATH

void __cdecl _tmain(int argc, TCHAR *argv[])
{
    TCHAR Path[BUFSIZE];
    HANDLE hFile;
    DWORD dwRet;

    printf("\n");
    if( argc != 2 )
    {
        printf("ERROR:\tIncorrect number of arguments\n\n");
        printf("%s &lt;file_name&gt;\n", argv[0]);
        return;
    }

    hFile = CreateFile(argv[1],               // file to open
                       GENERIC_READ,          // open for reading
                       FILE_SHARE_READ,       // share for reading
                       NULL,                  // default security
                       OPEN_EXISTING,         // existing file only
                       FILE_ATTRIBUTE_NORMAL, // normal file
                       NULL);                 // no attr. template

    if( hFile == INVALID_HANDLE_VALUE)
    {
        printf("Could not open file (error %d\n)", GetLastError());
        return;
    }

    dwRet = GetFinalPathNameByHandle( hFile, Path, BUFSIZE, VOLUME_NAME_NT );
    if(dwRet &lt; BUFSIZE)
    {
        _tprintf(TEXT("\nThe final path is: %s\n"), Path);
    }
    else printf("\nThe required buffer size is %d.\n", dwRet);

    CloseHandle(hFile);
}

</code>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFinalPathNameByHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.GetFinalPathNameByHandleA">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">
      <para>A handle to a file or directory.</para>
    </param>
    <param name="lpszFilePath">
      <para>A pointer to a buffer that receives the path of <i>hFile</i>.</para>
    </param>
    <param name="cchFilePath">
      <para>The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</para>
    </param>
    <param name="dwFlags">
      <para>The type of result to return.  This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_NORMALIZED</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the normalized drive name. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_OPENED</b>
                </description>
              </item>
              <item>
                <description>0x8</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the opened file name (not normalized).</para>
          </description>
        </item>
      </list>
      <para>This parameter can also include one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_DOS</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the drive letter. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_GUID</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with a volume <b>GUID</b> path instead of the drive name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b> VOLUME_NAME_NONE</b>
                </description>
              </item>
              <item>
                <description>0x4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with no drive information.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_NT</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the volume device path.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by
<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the
size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,
<b>GetFinalPathNameByHandleA</b>, the return value
includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the
terminating null character, the return value is the required buffer size, in
<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>Can be returned if you are searching for a drive letter and one does not exist.  For example, the handle
was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive
letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to
identify it.</para>
            <para>This return value can also be returned if you are searching for a volume <b>GUID</b></para>
            <para>path on a network share. Volume <b>GUID</b> paths are not created for network
shares.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Invalid flags were specified for <i>dwFlags</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The Server Message Block (SMB) Protocol does not support queries for normalized paths. Consequently, when you call this function passing the handle of a file opened using SMB, and with the FILE_NAME_NORMALIZED flag, the function splits the path into its components and tries to query for the normalized name of each of those components in turn. If the user lacks access permission to any one of those components, then the function call fails with ERROR_ACCESS_DENIED.</para>
      <para>A final path is the path that is returned when a path is fully resolved. For example, for a symbolic link
named "C:\tmp\mydir" that points to "D:\yourdir", the final path would be
"D:\yourdir".</para>
      <para>The string that is returned by this function uses the "\\?\"
syntax. For more information, see <see cref="CreateFile" />.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following example demonstrates the use of the
<b>GetFinalPathNameByHandle</b> function.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE MAX_PATH

void __cdecl _tmain(int argc, TCHAR *argv[])
{
    TCHAR Path[BUFSIZE];
    HANDLE hFile;
    DWORD dwRet;

    printf("\n");
    if( argc != 2 )
    {
        printf("ERROR:\tIncorrect number of arguments\n\n");
        printf("%s &lt;file_name&gt;\n", argv[0]);
        return;
    }

    hFile = CreateFile(argv[1],               // file to open
                       GENERIC_READ,          // open for reading
                       FILE_SHARE_READ,       // share for reading
                       NULL,                  // default security
                       OPEN_EXISTING,         // existing file only
                       FILE_ATTRIBUTE_NORMAL, // normal file
                       NULL);                 // no attr. template

    if( hFile == INVALID_HANDLE_VALUE)
    {
        printf("Could not open file (error %d\n)", GetLastError());
        return;
    }

    dwRet = GetFinalPathNameByHandle( hFile, Path, BUFSIZE, VOLUME_NAME_NT );
    if(dwRet &lt; BUFSIZE)
    {
        _tprintf(TEXT("\nThe final path is: %s\n"), Path);
    }
    else printf("\nThe required buffer size is %d.\n", dwRet);

    CloseHandle(hFile);
}

</code>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFinalPathNameByHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.GetFinalPathNameByHandleW">
    <summary>
      <para>Retrieves the final path for the specified file.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </summary>
    <param name="hFile">
      <para>A handle to a file or directory.</para>
    </param>
    <param name="lpszFilePath">
      <para>A pointer to a buffer that receives the path of <i>hFile</i>.</para>
    </param>
    <param name="cchFilePath">
      <para>The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</para>
    </param>
    <param name="dwFlags">
      <para>The type of result to return.  This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_NORMALIZED</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the normalized drive name. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAME_OPENED</b>
                </description>
              </item>
              <item>
                <description>0x8</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the opened file name (not normalized).</para>
          </description>
        </item>
      </list>
      <para>This parameter can also include one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_DOS</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the drive letter. This is the default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_GUID</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with a volume <b>GUID</b> path instead of the drive name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b> VOLUME_NAME_NONE</b>
                </description>
              </item>
              <item>
                <description>0x4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with no drive information.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VOLUME_NAME_NT</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the path with the volume device path.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string received by
<i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the
size of the terminating null character.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function,
<b>GetFinalPathNameByHandleA</b>, the return value
includes the size of the terminating null character.</para>
      <para>If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the
terminating null character, the return value is the required buffer size, in
<b>TCHAR</b>s. This value includes the size of the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>Can be returned if you are searching for a drive letter and one does not exist.  For example, the handle
was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive
letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to
identify it.</para>
            <para>This return value can also be returned if you are searching for a volume <b>GUID</b></para>
            <para>path on a network share. Volume <b>GUID</b> paths are not created for network
shares.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Invalid flags were specified for <i>dwFlags</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The Server Message Block (SMB) Protocol does not support queries for normalized paths. Consequently, when you call this function passing the handle of a file opened using SMB, and with the FILE_NAME_NORMALIZED flag, the function splits the path into its components and tries to query for the normalized name of each of those components in turn. If the user lacks access permission to any one of those components, then the function call fails with ERROR_ACCESS_DENIED.</para>
      <para>A final path is the path that is returned when a path is fully resolved. For example, for a symbolic link
named "C:\tmp\mydir" that points to "D:\yourdir", the final path would be
"D:\yourdir".</para>
      <para>The string that is returned by this function uses the "\\?\"
syntax. For more information, see <see cref="CreateFile" />.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following example demonstrates the use of the
<b>GetFinalPathNameByHandle</b> function.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE MAX_PATH

void __cdecl _tmain(int argc, TCHAR *argv[])
{
    TCHAR Path[BUFSIZE];
    HANDLE hFile;
    DWORD dwRet;

    printf("\n");
    if( argc != 2 )
    {
        printf("ERROR:\tIncorrect number of arguments\n\n");
        printf("%s &lt;file_name&gt;\n", argv[0]);
        return;
    }

    hFile = CreateFile(argv[1],               // file to open
                       GENERIC_READ,          // open for reading
                       FILE_SHARE_READ,       // share for reading
                       NULL,                  // default security
                       OPEN_EXISTING,         // existing file only
                       FILE_ATTRIBUTE_NORMAL, // normal file
                       NULL);                 // no attr. template

    if( hFile == INVALID_HANDLE_VALUE)
    {
        printf("Could not open file (error %d\n)", GetLastError());
        return;
    }

    dwRet = GetFinalPathNameByHandle( hFile, Path, BUFSIZE, VOLUME_NAME_NT );
    if(dwRet &lt; BUFSIZE)
    {
        _tprintf(TEXT("\nThe final path is: %s\n"), Path);
    }
    else printf("\nThe required buffer size is %d.\n", dwRet);

    CloseHandle(hFile);
}

</code>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetFinalPathNameByHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.GetFullPathName">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
<b>Note</b> See the Remarks section for discussion of
the use of relative paths with the <b>GetFullPathName</b> function
in multithreaded applications or shared library code.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the  file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume
name.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFullPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="nBufferLength">
      <para>The size of the buffer to receive the null-terminated string for the drive and path, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the null-terminated string for the  drive and path.</para>
    </param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final
file name component in the path.</para>
      <para>This parameter can be  <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i></para>
      <para>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>GetFullPathName</b> merges the name of the current drive
and directory with a specified file name to determine the full path and file name of a specified file. It also
calculates the address of the file name portion of the full path and file name.</para>
      <para>This function does not verify that the resulting path and file name are valid, or that they see an existing
file on the associated volume.</para>
      <para>Note that the <i>lpFilePart</i> parameter does not
require string buffer space, but only enough for a single address. This is because it simply returns an address
within the buffer that already exists for <i>lpBuffer</i>.</para>
      <para>Share and volume names are
valid input for <i>lpFileName</i>. For example, the following list identities the returned path
and file names if test-2 is a remote computer and U: is a network mapped drive whose current directory is the root of the volume:</para>
      <list type="bullet">
        <item>
          <description>If you specify "\\test-2\q$\lh" the path returned is
"\\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "\\?\UNC\test-2\q$\lh" the path returned is
"\\?\UNC\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "U:" the path returned is the current directory on the
"U:\" drive</description>
        </item>
      </list>
      <b>GetFullPathName</b> does not convert the specified file
name, <i>lpFileName</i>. If the specified file name exists, you can use
<see cref="GetLongPathName" /> or
<see cref="GetShortPathName" /> to convert to long or short path
names, respectively.
<para>If the return value is greater than or equal to the value specified in
<i>nBufferLength</i>, you can call the function again with a buffer that is large enough to
hold the path. For an example of this case in addition to using zero-length buffer for dynamic allocation, see the
Example Code section.</para><para><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para><para>Relative paths passed to the <b>GetFullPathName</b> function are
interpreted as relative to the process's current directory.
The current directory state written by the
<see cref="SetCurrentDirectory" /></para><para>function is global to the process and can be changed by any thread at any time.
Applications should be aware that
consecutive calls to the <b>GetFullPathName</b> function with a relative path
may produce different results if the current directory changes between the two calls.</para><para>To avoid problems caused by inconsistent results,
multithreaded applications and shared library code should avoid using relative paths.
If a relative path is received, it should be consumed exactly once,
either by passing the relative path directly to a function like <b>CreateFile</b>,
or by converting it to an absolute path and using the absolute path
from that point forward.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows a basic use of
<b>GetFullPathName</b>,
<see cref="GetLongPathName" />, and
<see cref="GetShortPathName" />. For another example using dynamic
allocation, see <see cref="GetShortPathName" />.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE 4096
#define LONG_DIR_NAME TEXT("c:\\longdirectoryname")

void _tmain(int argc, TCHAR *argv[])
{
    DWORD  retval=0;
    BOOL   success;
    TCHAR  buffer[BUFSIZE]=TEXT("");
    TCHAR  buf[BUFSIZE]=TEXT("");
    TCHAR** lppPart={NULL};

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [file]\n"), argv[0]);
      return;
   }

// Retrieve the full path name for a file.
// The file does not need to exist.

    retval = GetFullPathName(argv[1],
                 BUFSIZE,
                 buffer,
                 lppPart);

    if (retval == 0)
    {
        // Handle an error condition.
        printf ("GetFullPathName failed (%d)\n", GetLastError());
        return;
    }
    else
    {
        _tprintf(TEXT("The full path name is:  %s\n"), buffer);
        if (lppPart != NULL &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; *lppPart != 0)
        {
            _tprintf(TEXT("The final component in the path name is:  %s\n"), *lppPart);
        }
    }


// Create a long directory name for use with the next two examples.

    success = CreateDirectory(LONG_DIR_NAME,
                              NULL);

    if (!success)
    {
        // Handle an error condition.
        printf ("CreateDirectory failed (%d)\n", GetLastError());
        return;
    }


// Retrieve the short path name.

    retval = GetShortPathName(LONG_DIR_NAME,
                  buf,
                  BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetShortPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The short name for %s is %s\n"),
                  LONG_DIR_NAME, buf);


// Retrieve the long path name.

    retval = GetLongPathName(buf,
              buffer,
              BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetLongPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The long name for %s is %s\n"), buf, buffer);

// Clean up the directory.

    success = RemoveDirectory(LONG_DIR_NAME);
    if (!success)
    {
        // Handle an error condition.
        printf ("RemoveDirectory failed (%d)\n", GetLastError());
        return;
    }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines GetFullPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathNameTransacted" />
    <seealso cref="GetLongPathName" />
    <seealso cref="GetShortPathName" />
    <seealso cref="GetTempPath" />
    <seealso cref="SearchPath" />
  </member>
  <member name="Windows.GetFullPathNameA">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
<b>Note</b> See the Remarks section for discussion of
the use of relative paths with the <b>GetFullPathName</b> function
in multithreaded applications or shared library code.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the  file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume
name.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFullPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="nBufferLength">
      <para>The size of the buffer to receive the null-terminated string for the drive and path, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the null-terminated string for the  drive and path.</para>
    </param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final
file name component in the path.</para>
      <para>This parameter can be  <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i></para>
      <para>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>GetFullPathName</b> merges the name of the current drive
and directory with a specified file name to determine the full path and file name of a specified file. It also
calculates the address of the file name portion of the full path and file name.</para>
      <para>This function does not verify that the resulting path and file name are valid, or that they see an existing
file on the associated volume.</para>
      <para>Note that the <i>lpFilePart</i> parameter does not
require string buffer space, but only enough for a single address. This is because it simply returns an address
within the buffer that already exists for <i>lpBuffer</i>.</para>
      <para>Share and volume names are
valid input for <i>lpFileName</i>. For example, the following list identities the returned path
and file names if test-2 is a remote computer and U: is a network mapped drive whose current directory is the root of the volume:</para>
      <list type="bullet">
        <item>
          <description>If you specify "\\test-2\q$\lh" the path returned is
"\\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "\\?\UNC\test-2\q$\lh" the path returned is
"\\?\UNC\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "U:" the path returned is the current directory on the
"U:\" drive</description>
        </item>
      </list>
      <b>GetFullPathName</b> does not convert the specified file
name, <i>lpFileName</i>. If the specified file name exists, you can use
<see cref="GetLongPathName" /> or
<see cref="GetShortPathName" /> to convert to long or short path
names, respectively.
<para>If the return value is greater than or equal to the value specified in
<i>nBufferLength</i>, you can call the function again with a buffer that is large enough to
hold the path. For an example of this case in addition to using zero-length buffer for dynamic allocation, see the
Example Code section.</para><para><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para><para>Relative paths passed to the <b>GetFullPathName</b> function are
interpreted as relative to the process's current directory.
The current directory state written by the
<see cref="SetCurrentDirectory" /></para><para>function is global to the process and can be changed by any thread at any time.
Applications should be aware that
consecutive calls to the <b>GetFullPathName</b> function with a relative path
may produce different results if the current directory changes between the two calls.</para><para>To avoid problems caused by inconsistent results,
multithreaded applications and shared library code should avoid using relative paths.
If a relative path is received, it should be consumed exactly once,
either by passing the relative path directly to a function like <b>CreateFile</b>,
or by converting it to an absolute path and using the absolute path
from that point forward.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows a basic use of
<b>GetFullPathName</b>,
<see cref="GetLongPathName" />, and
<see cref="GetShortPathName" />. For another example using dynamic
allocation, see <see cref="GetShortPathName" />.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE 4096
#define LONG_DIR_NAME TEXT("c:\\longdirectoryname")

void _tmain(int argc, TCHAR *argv[])
{
    DWORD  retval=0;
    BOOL   success;
    TCHAR  buffer[BUFSIZE]=TEXT("");
    TCHAR  buf[BUFSIZE]=TEXT("");
    TCHAR** lppPart={NULL};

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [file]\n"), argv[0]);
      return;
   }

// Retrieve the full path name for a file.
// The file does not need to exist.

    retval = GetFullPathName(argv[1],
                 BUFSIZE,
                 buffer,
                 lppPart);

    if (retval == 0)
    {
        // Handle an error condition.
        printf ("GetFullPathName failed (%d)\n", GetLastError());
        return;
    }
    else
    {
        _tprintf(TEXT("The full path name is:  %s\n"), buffer);
        if (lppPart != NULL &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; *lppPart != 0)
        {
            _tprintf(TEXT("The final component in the path name is:  %s\n"), *lppPart);
        }
    }


// Create a long directory name for use with the next two examples.

    success = CreateDirectory(LONG_DIR_NAME,
                              NULL);

    if (!success)
    {
        // Handle an error condition.
        printf ("CreateDirectory failed (%d)\n", GetLastError());
        return;
    }


// Retrieve the short path name.

    retval = GetShortPathName(LONG_DIR_NAME,
                  buf,
                  BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetShortPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The short name for %s is %s\n"),
                  LONG_DIR_NAME, buf);


// Retrieve the long path name.

    retval = GetLongPathName(buf,
              buffer,
              BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetLongPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The long name for %s is %s\n"), buf, buffer);

// Clean up the directory.

    success = RemoveDirectory(LONG_DIR_NAME);
    if (!success)
    {
        // Handle an error condition.
        printf ("RemoveDirectory failed (%d)\n", GetLastError());
        return;
    }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines GetFullPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathNameTransacted" />
    <seealso cref="GetLongPathName" />
    <seealso cref="GetShortPathName" />
    <seealso cref="GetTempPath" />
    <seealso cref="SearchPath" />
  </member>
  <member name="Windows.GetFullPathNameW">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
<b>Note</b> See the Remarks section for discussion of
the use of relative paths with the <b>GetFullPathName</b> function
in multithreaded applications or shared library code.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the  file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume
name.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFullPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="nBufferLength">
      <para>The size of the buffer to receive the null-terminated string for the drive and path, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the null-terminated string for the  drive and path.</para>
    </param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final
file name component in the path.</para>
      <para>This parameter can be  <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i></para>
      <para>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>GetFullPathName</b> merges the name of the current drive
and directory with a specified file name to determine the full path and file name of a specified file. It also
calculates the address of the file name portion of the full path and file name.</para>
      <para>This function does not verify that the resulting path and file name are valid, or that they see an existing
file on the associated volume.</para>
      <para>Note that the <i>lpFilePart</i> parameter does not
require string buffer space, but only enough for a single address. This is because it simply returns an address
within the buffer that already exists for <i>lpBuffer</i>.</para>
      <para>Share and volume names are
valid input for <i>lpFileName</i>. For example, the following list identities the returned path
and file names if test-2 is a remote computer and U: is a network mapped drive whose current directory is the root of the volume:</para>
      <list type="bullet">
        <item>
          <description>If you specify "\\test-2\q$\lh" the path returned is
"\\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "\\?\UNC\test-2\q$\lh" the path returned is
"\\?\UNC\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "U:" the path returned is the current directory on the
"U:\" drive</description>
        </item>
      </list>
      <b>GetFullPathName</b> does not convert the specified file
name, <i>lpFileName</i>. If the specified file name exists, you can use
<see cref="GetLongPathName" /> or
<see cref="GetShortPathName" /> to convert to long or short path
names, respectively.
<para>If the return value is greater than or equal to the value specified in
<i>nBufferLength</i>, you can call the function again with a buffer that is large enough to
hold the path. For an example of this case in addition to using zero-length buffer for dynamic allocation, see the
Example Code section.</para><para><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para><para>Relative paths passed to the <b>GetFullPathName</b> function are
interpreted as relative to the process's current directory.
The current directory state written by the
<see cref="SetCurrentDirectory" /></para><para>function is global to the process and can be changed by any thread at any time.
Applications should be aware that
consecutive calls to the <b>GetFullPathName</b> function with a relative path
may produce different results if the current directory changes between the two calls.</para><para>To avoid problems caused by inconsistent results,
multithreaded applications and shared library code should avoid using relative paths.
If a relative path is received, it should be consumed exactly once,
either by passing the relative path directly to a function like <b>CreateFile</b>,
or by converting it to an absolute path and using the absolute path
from that point forward.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows a basic use of
<b>GetFullPathName</b>,
<see cref="GetLongPathName" />, and
<see cref="GetShortPathName" />. For another example using dynamic
allocation, see <see cref="GetShortPathName" />.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE 4096
#define LONG_DIR_NAME TEXT("c:\\longdirectoryname")

void _tmain(int argc, TCHAR *argv[])
{
    DWORD  retval=0;
    BOOL   success;
    TCHAR  buffer[BUFSIZE]=TEXT("");
    TCHAR  buf[BUFSIZE]=TEXT("");
    TCHAR** lppPart={NULL};

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [file]\n"), argv[0]);
      return;
   }

// Retrieve the full path name for a file.
// The file does not need to exist.

    retval = GetFullPathName(argv[1],
                 BUFSIZE,
                 buffer,
                 lppPart);

    if (retval == 0)
    {
        // Handle an error condition.
        printf ("GetFullPathName failed (%d)\n", GetLastError());
        return;
    }
    else
    {
        _tprintf(TEXT("The full path name is:  %s\n"), buffer);
        if (lppPart != NULL &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; *lppPart != 0)
        {
            _tprintf(TEXT("The final component in the path name is:  %s\n"), *lppPart);
        }
    }


// Create a long directory name for use with the next two examples.

    success = CreateDirectory(LONG_DIR_NAME,
                              NULL);

    if (!success)
    {
        // Handle an error condition.
        printf ("CreateDirectory failed (%d)\n", GetLastError());
        return;
    }


// Retrieve the short path name.

    retval = GetShortPathName(LONG_DIR_NAME,
                  buf,
                  BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetShortPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The short name for %s is %s\n"),
                  LONG_DIR_NAME, buf);


// Retrieve the long path name.

    retval = GetLongPathName(buf,
              buffer,
              BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetLongPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The long name for %s is %s\n"), buf, buffer);

// Clean up the directory.

    success = RemoveDirectory(LONG_DIR_NAME);
    if (!success)
    {
        // Handle an error condition.
        printf ("RemoveDirectory failed (%d)\n", GetLastError());
        return;
    }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines GetFullPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathNameTransacted" />
    <seealso cref="GetLongPathName" />
    <seealso cref="GetShortPathName" />
    <seealso cref="GetTempPath" />
    <seealso cref="SearchPath" />
  </member>
  <member name="Windows.GetFullPathName">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
<b>Note</b> See the Remarks section for discussion of
the use of relative paths with the <b>GetFullPathName</b> function
in multithreaded applications or shared library code.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the  file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume
name.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFullPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="nBufferLength">
      <para>The size of the buffer to receive the null-terminated string for the drive and path, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the null-terminated string for the  drive and path.</para>
    </param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final
file name component in the path.</para>
      <para>This parameter can be  <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i></para>
      <para>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>GetFullPathName</b> merges the name of the current drive
and directory with a specified file name to determine the full path and file name of a specified file. It also
calculates the address of the file name portion of the full path and file name.</para>
      <para>This function does not verify that the resulting path and file name are valid, or that they see an existing
file on the associated volume.</para>
      <para>Note that the <i>lpFilePart</i> parameter does not
require string buffer space, but only enough for a single address. This is because it simply returns an address
within the buffer that already exists for <i>lpBuffer</i>.</para>
      <para>Share and volume names are
valid input for <i>lpFileName</i>. For example, the following list identities the returned path
and file names if test-2 is a remote computer and U: is a network mapped drive whose current directory is the root of the volume:</para>
      <list type="bullet">
        <item>
          <description>If you specify "\\test-2\q$\lh" the path returned is
"\\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "\\?\UNC\test-2\q$\lh" the path returned is
"\\?\UNC\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "U:" the path returned is the current directory on the
"U:\" drive</description>
        </item>
      </list>
      <b>GetFullPathName</b> does not convert the specified file
name, <i>lpFileName</i>. If the specified file name exists, you can use
<see cref="GetLongPathName" /> or
<see cref="GetShortPathName" /> to convert to long or short path
names, respectively.
<para>If the return value is greater than or equal to the value specified in
<i>nBufferLength</i>, you can call the function again with a buffer that is large enough to
hold the path. For an example of this case in addition to using zero-length buffer for dynamic allocation, see the
Example Code section.</para><para><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para><para>Relative paths passed to the <b>GetFullPathName</b> function are
interpreted as relative to the process's current directory.
The current directory state written by the
<see cref="SetCurrentDirectory" /></para><para>function is global to the process and can be changed by any thread at any time.
Applications should be aware that
consecutive calls to the <b>GetFullPathName</b> function with a relative path
may produce different results if the current directory changes between the two calls.</para><para>To avoid problems caused by inconsistent results,
multithreaded applications and shared library code should avoid using relative paths.
If a relative path is received, it should be consumed exactly once,
either by passing the relative path directly to a function like <b>CreateFile</b>,
or by converting it to an absolute path and using the absolute path
from that point forward.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows a basic use of
<b>GetFullPathName</b>,
<see cref="GetLongPathName" />, and
<see cref="GetShortPathName" />. For another example using dynamic
allocation, see <see cref="GetShortPathName" />.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE 4096
#define LONG_DIR_NAME TEXT("c:\\longdirectoryname")

void _tmain(int argc, TCHAR *argv[])
{
    DWORD  retval=0;
    BOOL   success;
    TCHAR  buffer[BUFSIZE]=TEXT("");
    TCHAR  buf[BUFSIZE]=TEXT("");
    TCHAR** lppPart={NULL};

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [file]\n"), argv[0]);
      return;
   }

// Retrieve the full path name for a file.
// The file does not need to exist.

    retval = GetFullPathName(argv[1],
                 BUFSIZE,
                 buffer,
                 lppPart);

    if (retval == 0)
    {
        // Handle an error condition.
        printf ("GetFullPathName failed (%d)\n", GetLastError());
        return;
    }
    else
    {
        _tprintf(TEXT("The full path name is:  %s\n"), buffer);
        if (lppPart != NULL &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; *lppPart != 0)
        {
            _tprintf(TEXT("The final component in the path name is:  %s\n"), *lppPart);
        }
    }


// Create a long directory name for use with the next two examples.

    success = CreateDirectory(LONG_DIR_NAME,
                              NULL);

    if (!success)
    {
        // Handle an error condition.
        printf ("CreateDirectory failed (%d)\n", GetLastError());
        return;
    }


// Retrieve the short path name.

    retval = GetShortPathName(LONG_DIR_NAME,
                  buf,
                  BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetShortPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The short name for %s is %s\n"),
                  LONG_DIR_NAME, buf);


// Retrieve the long path name.

    retval = GetLongPathName(buf,
              buffer,
              BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetLongPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The long name for %s is %s\n"), buf, buffer);

// Clean up the directory.

    success = RemoveDirectory(LONG_DIR_NAME);
    if (!success)
    {
        // Handle an error condition.
        printf ("RemoveDirectory failed (%d)\n", GetLastError());
        return;
    }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines GetFullPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathNameTransacted" />
    <seealso cref="GetLongPathName" />
    <seealso cref="GetShortPathName" />
    <seealso cref="GetTempPath" />
    <seealso cref="SearchPath" />
  </member>
  <member name="Windows.GetFullPathNameA">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
<b>Note</b> See the Remarks section for discussion of
the use of relative paths with the <b>GetFullPathName</b> function
in multithreaded applications or shared library code.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the  file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume
name.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFullPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="nBufferLength">
      <para>The size of the buffer to receive the null-terminated string for the drive and path, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the null-terminated string for the  drive and path.</para>
    </param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final
file name component in the path.</para>
      <para>This parameter can be  <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i></para>
      <para>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>GetFullPathName</b> merges the name of the current drive
and directory with a specified file name to determine the full path and file name of a specified file. It also
calculates the address of the file name portion of the full path and file name.</para>
      <para>This function does not verify that the resulting path and file name are valid, or that they see an existing
file on the associated volume.</para>
      <para>Note that the <i>lpFilePart</i> parameter does not
require string buffer space, but only enough for a single address. This is because it simply returns an address
within the buffer that already exists for <i>lpBuffer</i>.</para>
      <para>Share and volume names are
valid input for <i>lpFileName</i>. For example, the following list identities the returned path
and file names if test-2 is a remote computer and U: is a network mapped drive whose current directory is the root of the volume:</para>
      <list type="bullet">
        <item>
          <description>If you specify "\\test-2\q$\lh" the path returned is
"\\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "\\?\UNC\test-2\q$\lh" the path returned is
"\\?\UNC\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "U:" the path returned is the current directory on the
"U:\" drive</description>
        </item>
      </list>
      <b>GetFullPathName</b> does not convert the specified file
name, <i>lpFileName</i>. If the specified file name exists, you can use
<see cref="GetLongPathName" /> or
<see cref="GetShortPathName" /> to convert to long or short path
names, respectively.
<para>If the return value is greater than or equal to the value specified in
<i>nBufferLength</i>, you can call the function again with a buffer that is large enough to
hold the path. For an example of this case in addition to using zero-length buffer for dynamic allocation, see the
Example Code section.</para><para><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para><para>Relative paths passed to the <b>GetFullPathName</b> function are
interpreted as relative to the process's current directory.
The current directory state written by the
<see cref="SetCurrentDirectory" /></para><para>function is global to the process and can be changed by any thread at any time.
Applications should be aware that
consecutive calls to the <b>GetFullPathName</b> function with a relative path
may produce different results if the current directory changes between the two calls.</para><para>To avoid problems caused by inconsistent results,
multithreaded applications and shared library code should avoid using relative paths.
If a relative path is received, it should be consumed exactly once,
either by passing the relative path directly to a function like <b>CreateFile</b>,
or by converting it to an absolute path and using the absolute path
from that point forward.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows a basic use of
<b>GetFullPathName</b>,
<see cref="GetLongPathName" />, and
<see cref="GetShortPathName" />. For another example using dynamic
allocation, see <see cref="GetShortPathName" />.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE 4096
#define LONG_DIR_NAME TEXT("c:\\longdirectoryname")

void _tmain(int argc, TCHAR *argv[])
{
    DWORD  retval=0;
    BOOL   success;
    TCHAR  buffer[BUFSIZE]=TEXT("");
    TCHAR  buf[BUFSIZE]=TEXT("");
    TCHAR** lppPart={NULL};

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [file]\n"), argv[0]);
      return;
   }

// Retrieve the full path name for a file.
// The file does not need to exist.

    retval = GetFullPathName(argv[1],
                 BUFSIZE,
                 buffer,
                 lppPart);

    if (retval == 0)
    {
        // Handle an error condition.
        printf ("GetFullPathName failed (%d)\n", GetLastError());
        return;
    }
    else
    {
        _tprintf(TEXT("The full path name is:  %s\n"), buffer);
        if (lppPart != NULL &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; *lppPart != 0)
        {
            _tprintf(TEXT("The final component in the path name is:  %s\n"), *lppPart);
        }
    }


// Create a long directory name for use with the next two examples.

    success = CreateDirectory(LONG_DIR_NAME,
                              NULL);

    if (!success)
    {
        // Handle an error condition.
        printf ("CreateDirectory failed (%d)\n", GetLastError());
        return;
    }


// Retrieve the short path name.

    retval = GetShortPathName(LONG_DIR_NAME,
                  buf,
                  BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetShortPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The short name for %s is %s\n"),
                  LONG_DIR_NAME, buf);


// Retrieve the long path name.

    retval = GetLongPathName(buf,
              buffer,
              BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetLongPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The long name for %s is %s\n"), buf, buffer);

// Clean up the directory.

    success = RemoveDirectory(LONG_DIR_NAME);
    if (!success)
    {
        // Handle an error condition.
        printf ("RemoveDirectory failed (%d)\n", GetLastError());
        return;
    }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines GetFullPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathNameTransacted" />
    <seealso cref="GetLongPathName" />
    <seealso cref="GetShortPathName" />
    <seealso cref="GetTempPath" />
    <seealso cref="SearchPath" />
  </member>
  <member name="Windows.GetFullPathNameW">
    <summary>
      <para>Retrieves the full path and file name of the specified file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetFullPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
<b>Note</b> See the Remarks section for discussion of
the use of relative paths with the <b>GetFullPathName</b> function
in multithreaded applications or shared library code.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the  file.</para>
      <para>This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume
name.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>), and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFullPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="nBufferLength">
      <para>The size of the buffer to receive the null-terminated string for the drive and path, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the null-terminated string for the  drive and path.</para>
    </param>
    <param name="lpFilePart">
      <para>A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final
file name component in the path.</para>
      <para>This parameter can be  <b>NULL</b>.</para>
      <para>If <i>lpBuffer</i></para>
      <para>refers to a directory and not a file, <i>lpFilePart</i> receives zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>GetFullPathName</b> merges the name of the current drive
and directory with a specified file name to determine the full path and file name of a specified file. It also
calculates the address of the file name portion of the full path and file name.</para>
      <para>This function does not verify that the resulting path and file name are valid, or that they see an existing
file on the associated volume.</para>
      <para>Note that the <i>lpFilePart</i> parameter does not
require string buffer space, but only enough for a single address. This is because it simply returns an address
within the buffer that already exists for <i>lpBuffer</i>.</para>
      <para>Share and volume names are
valid input for <i>lpFileName</i>. For example, the following list identities the returned path
and file names if test-2 is a remote computer and U: is a network mapped drive whose current directory is the root of the volume:</para>
      <list type="bullet">
        <item>
          <description>If you specify "\\test-2\q$\lh" the path returned is
"\\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "\\?\UNC\test-2\q$\lh" the path returned is
"\\?\UNC\test-2\q$\lh"</description>
        </item>
        <item>
          <description>If you specify "U:" the path returned is the current directory on the
"U:\" drive</description>
        </item>
      </list>
      <b>GetFullPathName</b> does not convert the specified file
name, <i>lpFileName</i>. If the specified file name exists, you can use
<see cref="GetLongPathName" /> or
<see cref="GetShortPathName" /> to convert to long or short path
names, respectively.
<para>If the return value is greater than or equal to the value specified in
<i>nBufferLength</i>, you can call the function again with a buffer that is large enough to
hold the path. For an example of this case in addition to using zero-length buffer for dynamic allocation, see the
Example Code section.</para><para><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para><para>Relative paths passed to the <b>GetFullPathName</b> function are
interpreted as relative to the process's current directory.
The current directory state written by the
<see cref="SetCurrentDirectory" /></para><para>function is global to the process and can be changed by any thread at any time.
Applications should be aware that
consecutive calls to the <b>GetFullPathName</b> function with a relative path
may produce different results if the current directory changes between the two calls.</para><para>To avoid problems caused by inconsistent results,
multithreaded applications and shared library code should avoid using relative paths.
If a relative path is received, it should be consumed exactly once,
either by passing the relative path directly to a function like <b>CreateFile</b>,
or by converting it to an absolute path and using the absolute path
from that point forward.</para><para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para><list type="table"><listheader><description>Technology</description><description>Supported</description></listheader><item><description><para>Server Message Block (SMB) 3.0 protocol</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 Transparent Failover (TFO)</para></description><description><para>Yes</para></description></item><item><description><para>SMB 3.0 with Scale-out File Shares (SO)</para></description><description><para>Yes</para></description></item><item><description><para>Cluster Shared Volume File System (CsvFS)</para></description><description><para>Yes</para></description></item><item><description><para>Resilient File System (ReFS)</para></description><description><para>Yes</para></description></item></list><h4>Examples</h4><para>The following C++ example shows a basic use of
<b>GetFullPathName</b>,
<see cref="GetLongPathName" />, and
<see cref="GetShortPathName" />. For another example using dynamic
allocation, see <see cref="GetShortPathName" />.</para><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;

#define BUFSIZE 4096
#define LONG_DIR_NAME TEXT("c:\\longdirectoryname")

void _tmain(int argc, TCHAR *argv[])
{
    DWORD  retval=0;
    BOOL   success;
    TCHAR  buffer[BUFSIZE]=TEXT("");
    TCHAR  buf[BUFSIZE]=TEXT("");
    TCHAR** lppPart={NULL};

   if( argc != 2 )
   {
      _tprintf(TEXT("Usage: %s [file]\n"), argv[0]);
      return;
   }

// Retrieve the full path name for a file.
// The file does not need to exist.

    retval = GetFullPathName(argv[1],
                 BUFSIZE,
                 buffer,
                 lppPart);

    if (retval == 0)
    {
        // Handle an error condition.
        printf ("GetFullPathName failed (%d)\n", GetLastError());
        return;
    }
    else
    {
        _tprintf(TEXT("The full path name is:  %s\n"), buffer);
        if (lppPart != NULL &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; *lppPart != 0)
        {
            _tprintf(TEXT("The final component in the path name is:  %s\n"), *lppPart);
        }
    }


// Create a long directory name for use with the next two examples.

    success = CreateDirectory(LONG_DIR_NAME,
                              NULL);

    if (!success)
    {
        // Handle an error condition.
        printf ("CreateDirectory failed (%d)\n", GetLastError());
        return;
    }


// Retrieve the short path name.

    retval = GetShortPathName(LONG_DIR_NAME,
                  buf,
                  BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetShortPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The short name for %s is %s\n"),
                  LONG_DIR_NAME, buf);


// Retrieve the long path name.

    retval = GetLongPathName(buf,
              buffer,
              BUFSIZE);

    if (retval == 0)
    {
        // Handle an error condition.
         printf ("GetLongPathName failed (%d)\n", GetLastError());
         return;
    }
    else _tprintf(TEXT("The long name for %s is %s\n"), buf, buffer);

// Clean up the directory.

    success = RemoveDirectory(LONG_DIR_NAME);
    if (!success)
    {
        // Handle an error condition.
        printf ("RemoveDirectory failed (%d)\n", GetLastError());
        return;
    }
}

</code><blockquote><para>[!NOTE]
The fileapi.h header defines GetFullPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathNameTransacted" />
    <seealso cref="GetLongPathName" />
    <seealso cref="GetShortPathName" />
    <seealso cref="GetTempPath" />
    <seealso cref="SearchPath" />
  </member>
  <member name="Windows.GetLogicalDrives">
    <summary>
      <para>Retrieves a bitmask representing the currently available disk drives.</para>
    </summary>
    <returns>
      <para>If the function succeeds, the return value is a bitmask representing the currently available disk drives. Bit position 0 (the least-significant bit) is drive A, bit position 1 is drive B, bit position 2 is drive C, and so on.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
    </remarks>
    <seealso cref="GetLogicalDriveStrings" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetLogicalDriveStrings">
    <summary>
      <para>Fills a buffer with strings that specify valid drives in the system.</para>
    </summary>
    <param name="nBufferLength">
      <para>The maximum size of the buffer pointed to by <i>lpBuffer</i>, in
<b>TCHARs</b>. This size does not include the terminating null character. If this
parameter is zero, <i>lpBuffer</i> is not used.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the
system, plus with an additional null character. Each string is a device name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer,
not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a
Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>.
It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>Each string in the buffer may be used wherever a root directory is required, such as for the
<see cref="GetDriveType" /> and
<see cref="GetDiskFreeSpace" /> functions.</para>
      <para>This function returns a concatenation of the drives in the Global and Local MS-DOS Device namespaces. If a
drive exists in both namespaces, this function will return the entry in the Local MS-DOS Device namespace. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetDriveType" />
    <seealso cref="GetLogicalDrives" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetLogicalDriveStringsA">
    <summary>
      <para>Fills a buffer with strings that specify valid drives in the system.</para>
    </summary>
    <param name="nBufferLength">
      <para>The maximum size of the buffer pointed to by <i>lpBuffer</i>, in
<b>TCHARs</b>. This size does not include the terminating null character. If this
parameter is zero, <i>lpBuffer</i> is not used.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the
system, plus with an additional null character. Each string is a device name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer,
not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a
Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>.
It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>Each string in the buffer may be used wherever a root directory is required, such as for the
<see cref="GetDriveType" /> and
<see cref="GetDiskFreeSpace" /> functions.</para>
      <para>This function returns a concatenation of the drives in the Global and Local MS-DOS Device namespaces. If a
drive exists in both namespaces, this function will return the entry in the Local MS-DOS Device namespace. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetDriveType" />
    <seealso cref="GetLogicalDrives" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetLogicalDriveStringsW">
    <summary>
      <para>Fills a buffer with strings that specify valid drives in the system.</para>
    </summary>
    <param name="nBufferLength">
      <para>The maximum size of the buffer pointed to by <i>lpBuffer</i>, in
<b>TCHARs</b>. This size does not include the terminating null character. If this
parameter is zero, <i>lpBuffer</i> is not used.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the
system, plus with an additional null character. Each string is a device name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer,
not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a
Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>.
It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>Each string in the buffer may be used wherever a root directory is required, such as for the
<see cref="GetDriveType" /> and
<see cref="GetDiskFreeSpace" /> functions.</para>
      <para>This function returns a concatenation of the drives in the Global and Local MS-DOS Device namespaces. If a
drive exists in both namespaces, this function will return the entry in the Local MS-DOS Device namespace. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetDriveType" />
    <seealso cref="GetLogicalDrives" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetLongPathName">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszShortPath">
      <para>The path to be converted.</para>
      <para>In the ANSI version of this function,
<b>GetLongPathNameA</b>, the name is limited to
<b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the
Unicode version of the function, <b>GetLongPathNameW</b>,
and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer <i>lpszLongPath</i> points to, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not
exist, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow
this convention. Therefore, do not assume that you can skip calling
<b>GetLongPathName</b> if the path does not contain a tilde (~)
character.</para>
      <para>If the file or directory exists but a long path is not found,
<b>GetLongPathName</b> succeeds, having copied the string
referred to by the <i>lpszShortPath</i> parameter to the buffer referred to by the
<i>lpszLongPath</i> parameter.</para>
      <para>If the return value is greater than the value specified in <i>cchBuffer</i>, you can call
the function again with a buffer that is large enough to hold the path. For an example of this case, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetLongPathName</b> may
fail when it is unable to query the parent directory of a path component to determine the long name for that
component. This check can be skipped for directory components that have file extensions longer than 3 characters,
or total lengths longer than 12 characters. For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetLongPathName</b>, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetLongPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathNameTransacted" />
    <seealso cref="GetShortPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetLongPathNameA">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszShortPath">
      <para>The path to be converted.</para>
      <para>In the ANSI version of this function,
<b>GetLongPathNameA</b>, the name is limited to
<b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the
Unicode version of the function, <b>GetLongPathNameW</b>,
and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer <i>lpszLongPath</i> points to, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not
exist, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow
this convention. Therefore, do not assume that you can skip calling
<b>GetLongPathName</b> if the path does not contain a tilde (~)
character.</para>
      <para>If the file or directory exists but a long path is not found,
<b>GetLongPathName</b> succeeds, having copied the string
referred to by the <i>lpszShortPath</i> parameter to the buffer referred to by the
<i>lpszLongPath</i> parameter.</para>
      <para>If the return value is greater than the value specified in <i>cchBuffer</i>, you can call
the function again with a buffer that is large enough to hold the path. For an example of this case, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetLongPathName</b> may
fail when it is unable to query the parent directory of a path component to determine the long name for that
component. This check can be skipped for directory components that have file extensions longer than 3 characters,
or total lengths longer than 12 characters. For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetLongPathName</b>, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetLongPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathNameTransacted" />
    <seealso cref="GetShortPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetLongPathNameW">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszShortPath">
      <para>The path to be converted.</para>
      <para>In the ANSI version of this function,
<b>GetLongPathNameA</b>, the name is limited to
<b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the
Unicode version of the function, <b>GetLongPathNameW</b>,
and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer <i>lpszLongPath</i> points to, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not
exist, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow
this convention. Therefore, do not assume that you can skip calling
<b>GetLongPathName</b> if the path does not contain a tilde (~)
character.</para>
      <para>If the file or directory exists but a long path is not found,
<b>GetLongPathName</b> succeeds, having copied the string
referred to by the <i>lpszShortPath</i> parameter to the buffer referred to by the
<i>lpszLongPath</i> parameter.</para>
      <para>If the return value is greater than the value specified in <i>cchBuffer</i>, you can call
the function again with a buffer that is large enough to hold the path. For an example of this case, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetLongPathName</b> may
fail when it is unable to query the parent directory of a path component to determine the long name for that
component. This check can be skipped for directory components that have file extensions longer than 3 characters,
or total lengths longer than 12 characters. For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetLongPathName</b>, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetLongPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathNameTransacted" />
    <seealso cref="GetShortPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetLongPathName">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>
        <para>[!IMPORTANT]
To use this function, the caller must have the following permissions on the specified path and parent directories:</para>
        <list type="bullet">
          <item>
            <description>List Folder</description>
          </item>
          <item>
            <description>Read Data</description>
          </item>
          <item>
            <description>Read Attributes</description>
          </item>
        </list>
      </blockquote>
    </summary>
    <param name="lpszShortPath">
      <para>The path to be converted.</para>
      <para>In the ANSI version of this function,
<b>GetLongPathNameA</b>, the name is limited to
<b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the
Unicode version of the function, <b>GetLongPathNameW</b>,
and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer <i>lpszLongPath</i> points to, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not
exist, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow
this convention. Therefore, do not assume that you can skip calling
<b>GetLongPathName</b> if the path does not contain a tilde (~)
character.</para>
      <para>If the file or directory exists but a long path is not found,
<b>GetLongPathName</b> succeeds, having copied the string
referred to by the <i>lpszShortPath</i> parameter to the buffer referred to by the
<i>lpszLongPath</i> parameter.</para>
      <para>If the return value is greater than the value specified in <i>cchBuffer</i>, you can call
the function again with a buffer that is large enough to hold the path. For an example of this case, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetLongPathName</b> may
fail when it is unable to query the parent directory of a path component to determine the long name for that
component. This check can be skipped for directory components that have file extensions longer than 3 characters,
or total lengths longer than 12 characters. For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetLongPathName</b>, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetLongPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathNameTransacted" />
    <seealso cref="GetShortPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetLongPathNameA">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>
        <para>[!IMPORTANT]
To use this function, the caller must have the following permissions on the specified path and parent directories:</para>
        <list type="bullet">
          <item>
            <description>List Folder</description>
          </item>
          <item>
            <description>Read Data</description>
          </item>
          <item>
            <description>Read Attributes</description>
          </item>
        </list>
      </blockquote>
    </summary>
    <param name="lpszShortPath">
      <para>The path to be converted.</para>
      <para>In the ANSI version of this function,
<b>GetLongPathNameA</b>, the name is limited to
<b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the
Unicode version of the function, <b>GetLongPathNameW</b>,
and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer <i>lpszLongPath</i> points to, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not
exist, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow
this convention. Therefore, do not assume that you can skip calling
<b>GetLongPathName</b> if the path does not contain a tilde (~)
character.</para>
      <para>If the file or directory exists but a long path is not found,
<b>GetLongPathName</b> succeeds, having copied the string
referred to by the <i>lpszShortPath</i> parameter to the buffer referred to by the
<i>lpszLongPath</i> parameter.</para>
      <para>If the return value is greater than the value specified in <i>cchBuffer</i>, you can call
the function again with a buffer that is large enough to hold the path. For an example of this case, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetLongPathName</b> may
fail when it is unable to query the parent directory of a path component to determine the long name for that
component. This check can be skipped for directory components that have file extensions longer than 3 characters,
or total lengths longer than 12 characters. For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetLongPathName</b>, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetLongPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathNameTransacted" />
    <seealso cref="GetShortPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetLongPathNameW">
    <summary>
      <para>Converts the specified path to its long form.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="GetLongPathNameTransacted" /> function.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>
        <para>[!IMPORTANT]
To use this function, the caller must have the following permissions on the specified path and parent directories:</para>
        <list type="bullet">
          <item>
            <description>List Folder</description>
          </item>
          <item>
            <description>Read Data</description>
          </item>
          <item>
            <description>Read Attributes</description>
          </item>
        </list>
      </blockquote>
    </summary>
    <param name="lpszShortPath">
      <para>The path to be converted.</para>
      <para>In the ANSI version of this function,
<b>GetLongPathNameA</b>, the name is limited to
<b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the
Unicode version of the function, <b>GetLongPathNameW</b>,
and prepend "\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpszLongPath">
      <para>A pointer to the buffer to receive the long path.</para>
      <para>You can use the same buffer you used for the <i>lpszShortPath</i> parameter.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer <i>lpszLongPath</i> points to, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpszLongPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the
size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, such as if the file does not
exist, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow
this convention. Therefore, do not assume that you can skip calling
<b>GetLongPathName</b> if the path does not contain a tilde (~)
character.</para>
      <para>If the file or directory exists but a long path is not found,
<b>GetLongPathName</b> succeeds, having copied the string
referred to by the <i>lpszShortPath</i> parameter to the buffer referred to by the
<i>lpszLongPath</i> parameter.</para>
      <para>If the return value is greater than the value specified in <i>cchBuffer</i>, you can call
the function again with a buffer that is large enough to hold the path. For an example of this case, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetLongPathName</b> may
fail when it is unable to query the parent directory of a path component to determine the long name for that
component. This check can be skipped for directory components that have file extensions longer than 3 characters,
or total lengths longer than 12 characters. For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetLongPathName</b>, see the
Example Code section for <see cref="GetFullPathName" />.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetLongPathName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathNameTransacted" />
    <seealso cref="GetShortPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetShortPathName">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that
<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i></para>
      <para>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer  that <i>lpszShortPath</i> points to, in
<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string that is copied to <i>lpszShortPath</i>, not including the terminating null
character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is
the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The path that the <i>lpszLongPath</i> parameter specifies does not have to be a full or
long path. The short form can be longer than the specified path.</para>
      <para>If the return value is greater than the value specified in the <i>cchBuffer</i> parameter,
you can call the function again with a buffer that is large enough to hold the path. For an example of this case
in addition to using zero-length buffer for dynamic allocation, see the Example Code section.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>If the specified path is already in its short form  and conversion is not needed, the function simply copies
the specified path to the buffer specified by the <i>lpszShortPath</i> parameter.</para>
      <para>You can set the <i>lpszShortPath</i> parameter to the same value as the
<i>lpszLongPath</i> parameter; in other words, you can set the output buffer for the short path
to the address of the input path string. Always ensure that the <i>cchBuffer</i> parameter
accurately represents the total size, in <b>TCHARs</b>, of this buffer.</para>
      <para>You can obtain the long name of a file from the short name by calling the
<see cref="GetLongPathName" /> function. Alternatively, where
<b>GetLongPathName</b> is not available, you can call
<see cref="FindFirstFile" /> on each component of the path to get the
corresponding long name.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetShortPathName</b></para>
      <para>may fail when it is unable to query the parent directory of a path component  to determine the short name for that
component. This check can be skipped for directory components that already meet the requirements of a short name.
For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability.</para>
      <para>Resilient File System (ReFS) doesn't support short names. If you call <b>GetShortPathName</b> on a path that doesn't have any short names on-disk, the call will succeed, but will return the long-name path instead. This outcome is also possible with NTFS volumes because there's no guarantee that a short name will exist for a given long name.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetShortPathName</b>, see
the Example Code section for <see cref="GetFullPathName" />.</para>
      <para>The following C++ example shows how to use a dynamically allocated output buffer.</para>
      <code>//...
    long     length = 0;
    TCHAR*   buffer = NULL;

// First obtain the size needed by passing NULL and 0.

    length = GetShortPathName(lpszPath, NULL, 0);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

// Dynamically allocate the correct size
// (terminating null char was included in length)

    buffer = new TCHAR[length];

// Now simply call again using same long path.

    length = GetShortPathName(lpszPath, buffer, length);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

    _tprintf(TEXT("long name = %s shortname = %s"), lpszPath, buffer);

    delete [] buffer;
///...

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
    <seealso cref="SetFileShortName" />
  </member>
  <member name="Windows.GetShortPathNameA">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that
<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i></para>
      <para>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer  that <i>lpszShortPath</i> points to, in
<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string that is copied to <i>lpszShortPath</i>, not including the terminating null
character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is
the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The path that the <i>lpszLongPath</i> parameter specifies does not have to be a full or
long path. The short form can be longer than the specified path.</para>
      <para>If the return value is greater than the value specified in the <i>cchBuffer</i> parameter,
you can call the function again with a buffer that is large enough to hold the path. For an example of this case
in addition to using zero-length buffer for dynamic allocation, see the Example Code section.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>If the specified path is already in its short form  and conversion is not needed, the function simply copies
the specified path to the buffer specified by the <i>lpszShortPath</i> parameter.</para>
      <para>You can set the <i>lpszShortPath</i> parameter to the same value as the
<i>lpszLongPath</i> parameter; in other words, you can set the output buffer for the short path
to the address of the input path string. Always ensure that the <i>cchBuffer</i> parameter
accurately represents the total size, in <b>TCHARs</b>, of this buffer.</para>
      <para>You can obtain the long name of a file from the short name by calling the
<see cref="GetLongPathName" /> function. Alternatively, where
<b>GetLongPathName</b> is not available, you can call
<see cref="FindFirstFile" /> on each component of the path to get the
corresponding long name.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetShortPathName</b></para>
      <para>may fail when it is unable to query the parent directory of a path component  to determine the short name for that
component. This check can be skipped for directory components that already meet the requirements of a short name.
For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability.</para>
      <para>Resilient File System (ReFS) doesn't support short names. If you call <b>GetShortPathName</b> on a path that doesn't have any short names on-disk, the call will succeed, but will return the long-name path instead. This outcome is also possible with NTFS volumes because there's no guarantee that a short name will exist for a given long name.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetShortPathName</b>, see
the Example Code section for <see cref="GetFullPathName" />.</para>
      <para>The following C++ example shows how to use a dynamically allocated output buffer.</para>
      <code>//...
    long     length = 0;
    TCHAR*   buffer = NULL;

// First obtain the size needed by passing NULL and 0.

    length = GetShortPathName(lpszPath, NULL, 0);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

// Dynamically allocate the correct size
// (terminating null char was included in length)

    buffer = new TCHAR[length];

// Now simply call again using same long path.

    length = GetShortPathName(lpszPath, buffer, length);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

    _tprintf(TEXT("long name = %s shortname = %s"), lpszPath, buffer);

    delete [] buffer;
///...

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
    <seealso cref="SetFileShortName" />
  </member>
  <member name="Windows.GetShortPathNameW">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that
<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i></para>
      <para>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer  that <i>lpszShortPath</i> points to, in
<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string that is copied to <i>lpszShortPath</i>, not including the terminating null
character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is
the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The path that the <i>lpszLongPath</i> parameter specifies does not have to be a full or
long path. The short form can be longer than the specified path.</para>
      <para>If the return value is greater than the value specified in the <i>cchBuffer</i> parameter,
you can call the function again with a buffer that is large enough to hold the path. For an example of this case
in addition to using zero-length buffer for dynamic allocation, see the Example Code section.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>If the specified path is already in its short form  and conversion is not needed, the function simply copies
the specified path to the buffer specified by the <i>lpszShortPath</i> parameter.</para>
      <para>You can set the <i>lpszShortPath</i> parameter to the same value as the
<i>lpszLongPath</i> parameter; in other words, you can set the output buffer for the short path
to the address of the input path string. Always ensure that the <i>cchBuffer</i> parameter
accurately represents the total size, in <b>TCHARs</b>, of this buffer.</para>
      <para>You can obtain the long name of a file from the short name by calling the
<see cref="GetLongPathName" /> function. Alternatively, where
<b>GetLongPathName</b> is not available, you can call
<see cref="FindFirstFile" /> on each component of the path to get the
corresponding long name.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetShortPathName</b></para>
      <para>may fail when it is unable to query the parent directory of a path component  to determine the short name for that
component. This check can be skipped for directory components that already meet the requirements of a short name.
For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability.</para>
      <para>Resilient File System (ReFS) doesn't support short names. If you call <b>GetShortPathName</b> on a path that doesn't have any short names on-disk, the call will succeed, but will return the long-name path instead. This outcome is also possible with NTFS volumes because there's no guarantee that a short name will exist for a given long name.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetShortPathName</b>, see
the Example Code section for <see cref="GetFullPathName" />.</para>
      <para>The following C++ example shows how to use a dynamically allocated output buffer.</para>
      <code>//...
    long     length = 0;
    TCHAR*   buffer = NULL;

// First obtain the size needed by passing NULL and 0.

    length = GetShortPathName(lpszPath, NULL, 0);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

// Dynamically allocate the correct size
// (terminating null char was included in length)

    buffer = new TCHAR[length];

// Now simply call again using same long path.

    length = GetShortPathName(lpszPath, buffer, length);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

    _tprintf(TEXT("long name = %s shortname = %s"), lpszPath, buffer);

    delete [] buffer;
///...

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
    <seealso cref="SetFileShortName" />
  </member>
  <member name="Windows.GetTempFileName">
    <summary>
      <para>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and
the handle to it is released; otherwise, only a file name is generated.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory path for the file name. Applications typically specify a period (.) for the current directory
or the result of the <see cref="GetTempPath" /> function. The string
cannot be longer than <b>MAX_PATH</b>–14 characters or
<b>GetTempFileName</b> will fail. If this parameter is
<b>NULL</b>, the function fails.</para>
    </param>
    <param name="lpPrefixString">
      <para>The null-terminated prefix string. The function uses up to the first three characters of this string as the
prefix of the file name. This string must consist of characters in the OEM-defined character set.</para>
    </param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the
current system time. If the file already exists, the number is increased by one and the functions tests if this
file already exists. This continues until a unique filename is found; the function creates a file by that name
and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when
<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">
      <para>A pointer to the buffer that receives the temporary file name. This buffer should be
<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file
name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same
number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The length of the string pointed to by the <i>lpPathName</i> parameter is more than
<b>MAX_PATH</b>–14 characters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTempFileName</b> function creates a temporary
file name of the following form:</para>
      <para>
        <i>&lt;path&gt;</i>\<i>&lt;pre&gt;</i><i>&lt;uuuu&gt;</i>.TMP</para>
      <para>The following table describes the file name syntax.</para>
      <list type="table">
        <listheader>
          <description>Component</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>&lt;path&gt;</i>
          </description>
          <description>Path specified by the <i>lpPathName</i> parameter</description>
        </item>
        <item>
          <description>
            <i>&lt;pre&gt;</i>
          </description>
          <description>First three letters of the <i>lpPrefixString</i> string</description>
        </item>
        <item>
          <description>
            <i>&lt;uuuu&gt;</i>
          </description>
          <description>Hexadecimal value of <i>uUnique</i></description>
        </item>
      </list>
      <para>If <i>uUnique</i> is zero,
<b>GetTempFileName</b> creates an empty file and closes it. If
<i>uUnique</i> is not zero, you must create the file yourself. Only a file name is created,
because <b>GetTempFileName</b> is not able to guarantee that
the file name is unique.</para>
      <para>Only the lower 16 bits of the <i>uUnique</i> parameter are used. This limits
<b>GetTempFileName</b> to a maximum of 65,535 unique file names
if the <i>lpPathName</i> and <i>lpPrefixString</i> parameters remain the
same.</para>
      <para>Due to the algorithm used to generate file names,
<b>GetTempFileName</b> can perform poorly when creating a large
number of files with the same prefix. In such cases, it is recommended that you construct unique file names based
on <b>GUID</b>s.</para>
      <para>Temporary files whose names have been created by this function are not automatically deleted. To delete these
files call <see cref="DeleteFile" />.</para>
      <para>To avoid problems resulting when converting an ANSI string, an application should call the
<see cref="CreateFile" /> function to create a temporary file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetTempFileNameA">
    <summary>
      <para>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and
the handle to it is released; otherwise, only a file name is generated.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory path for the file name. Applications typically specify a period (.) for the current directory
or the result of the <see cref="GetTempPath" /> function. The string
cannot be longer than <b>MAX_PATH</b>–14 characters or
<b>GetTempFileName</b> will fail. If this parameter is
<b>NULL</b>, the function fails.</para>
    </param>
    <param name="lpPrefixString">
      <para>The null-terminated prefix string. The function uses up to the first three characters of this string as the
prefix of the file name. This string must consist of characters in the OEM-defined character set.</para>
    </param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the
current system time. If the file already exists, the number is increased by one and the functions tests if this
file already exists. This continues until a unique filename is found; the function creates a file by that name
and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when
<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">
      <para>A pointer to the buffer that receives the temporary file name. This buffer should be
<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file
name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same
number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The length of the string pointed to by the <i>lpPathName</i> parameter is more than
<b>MAX_PATH</b>–14 characters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTempFileName</b> function creates a temporary
file name of the following form:</para>
      <para>
        <i>&lt;path&gt;</i>\<i>&lt;pre&gt;</i><i>&lt;uuuu&gt;</i>.TMP</para>
      <para>The following table describes the file name syntax.</para>
      <list type="table">
        <listheader>
          <description>Component</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>&lt;path&gt;</i>
          </description>
          <description>Path specified by the <i>lpPathName</i> parameter</description>
        </item>
        <item>
          <description>
            <i>&lt;pre&gt;</i>
          </description>
          <description>First three letters of the <i>lpPrefixString</i> string</description>
        </item>
        <item>
          <description>
            <i>&lt;uuuu&gt;</i>
          </description>
          <description>Hexadecimal value of <i>uUnique</i></description>
        </item>
      </list>
      <para>If <i>uUnique</i> is zero,
<b>GetTempFileName</b> creates an empty file and closes it. If
<i>uUnique</i> is not zero, you must create the file yourself. Only a file name is created,
because <b>GetTempFileName</b> is not able to guarantee that
the file name is unique.</para>
      <para>Only the lower 16 bits of the <i>uUnique</i> parameter are used. This limits
<b>GetTempFileName</b> to a maximum of 65,535 unique file names
if the <i>lpPathName</i> and <i>lpPrefixString</i> parameters remain the
same.</para>
      <para>Due to the algorithm used to generate file names,
<b>GetTempFileName</b> can perform poorly when creating a large
number of files with the same prefix. In such cases, it is recommended that you construct unique file names based
on <b>GUID</b>s.</para>
      <para>Temporary files whose names have been created by this function are not automatically deleted. To delete these
files call <see cref="DeleteFile" />.</para>
      <para>To avoid problems resulting when converting an ANSI string, an application should call the
<see cref="CreateFile" /> function to create a temporary file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetTempFileNameW">
    <summary>
      <para>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and
the handle to it is released; otherwise, only a file name is generated.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory path for the file name. Applications typically specify a period (.) for the current directory
or the result of the <see cref="GetTempPath" /> function. The string
cannot be longer than <b>MAX_PATH</b>–14 characters or
<b>GetTempFileName</b> will fail. If this parameter is
<b>NULL</b>, the function fails.</para>
    </param>
    <param name="lpPrefixString">
      <para>The null-terminated prefix string. The function uses up to the first three characters of this string as the
prefix of the file name. This string must consist of characters in the OEM-defined character set.</para>
    </param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the
current system time. If the file already exists, the number is increased by one and the functions tests if this
file already exists. This continues until a unique filename is found; the function creates a file by that name
and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when
<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">
      <para>A pointer to the buffer that receives the temporary file name. This buffer should be
<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file
name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same
number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The length of the string pointed to by the <i>lpPathName</i> parameter is more than
<b>MAX_PATH</b>–14 characters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTempFileName</b> function creates a temporary
file name of the following form:</para>
      <para>
        <i>&lt;path&gt;</i>\<i>&lt;pre&gt;</i><i>&lt;uuuu&gt;</i>.TMP</para>
      <para>The following table describes the file name syntax.</para>
      <list type="table">
        <listheader>
          <description>Component</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>&lt;path&gt;</i>
          </description>
          <description>Path specified by the <i>lpPathName</i> parameter</description>
        </item>
        <item>
          <description>
            <i>&lt;pre&gt;</i>
          </description>
          <description>First three letters of the <i>lpPrefixString</i> string</description>
        </item>
        <item>
          <description>
            <i>&lt;uuuu&gt;</i>
          </description>
          <description>Hexadecimal value of <i>uUnique</i></description>
        </item>
      </list>
      <para>If <i>uUnique</i> is zero,
<b>GetTempFileName</b> creates an empty file and closes it. If
<i>uUnique</i> is not zero, you must create the file yourself. Only a file name is created,
because <b>GetTempFileName</b> is not able to guarantee that
the file name is unique.</para>
      <para>Only the lower 16 bits of the <i>uUnique</i> parameter are used. This limits
<b>GetTempFileName</b> to a maximum of 65,535 unique file names
if the <i>lpPathName</i> and <i>lpPrefixString</i> parameters remain the
same.</para>
      <para>Due to the algorithm used to generate file names,
<b>GetTempFileName</b> can perform poorly when creating a large
number of files with the same prefix. In such cases, it is recommended that you construct unique file names based
on <b>GUID</b>s.</para>
      <para>Temporary files whose names have been created by this function are not automatically deleted. To delete these
files call <see cref="DeleteFile" />.</para>
      <para>To avoid problems resulting when converting an ANSI string, an application should call the
<see cref="CreateFile" /> function to create a temporary file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetTempFileName">
    <summary>
      <para>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and
the handle to it is released; otherwise, only a file name is generated.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory path for the file name. Applications typically specify a period (.) for the current directory
or the result of the <see cref="GetTempPath" /> function. The string
cannot be longer than <b>MAX_PATH</b>–14 characters or
<b>GetTempFileName</b> will fail. If this parameter is
<b>NULL</b>, the function fails.</para>
    </param>
    <param name="lpPrefixString">
      <para>The null-terminated prefix string. The function uses up to the first three characters of this string as the
prefix of the file name. This string must consist of characters in the OEM-defined character set.</para>
    </param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the
current system time. If the file already exists, the number is increased by one and the functions tests if this
file already exists. This continues until a unique filename is found; the function creates a file by that name
and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when
<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">
      <para>A pointer to the buffer that receives the temporary file name. This buffer should be
<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file
name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same
number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The length of the string pointed to by the <i>lpPathName</i> parameter is more than
<b>MAX_PATH</b>–14 characters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTempFileName</b> function creates a temporary
file name of the following form:</para>
      <para>
        <i>&lt;path&gt;</i>\<i>&lt;pre&gt;</i><i>&lt;uuuu&gt;</i>.TMP</para>
      <para>The following table describes the file name syntax.</para>
      <list type="table">
        <listheader>
          <description>Component</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>&lt;path&gt;</i>
          </description>
          <description>Path specified by the <i>lpPathName</i> parameter</description>
        </item>
        <item>
          <description>
            <i>&lt;pre&gt;</i>
          </description>
          <description>First three letters of the <i>lpPrefixString</i> string</description>
        </item>
        <item>
          <description>
            <i>&lt;uuuu&gt;</i>
          </description>
          <description>Hexadecimal value of <i>uUnique</i></description>
        </item>
      </list>
      <para>If <i>uUnique</i> is zero,
<b>GetTempFileName</b> creates an empty file and closes it. If
<i>uUnique</i> is not zero, you must create the file yourself. Only a file name is created,
because <b>GetTempFileName</b> is not able to guarantee that
the file name is unique.</para>
      <para>Only the lower 16 bits of the <i>uUnique</i> parameter are used. This limits
<b>GetTempFileName</b> to a maximum of 65,535 unique file names
if the <i>lpPathName</i> and <i>lpPrefixString</i> parameters remain the
same.</para>
      <para>Due to the algorithm used to generate file names,
<b>GetTempFileName</b> can perform poorly when creating a large
number of files with the same prefix. In such cases, it is recommended that you construct unique file names based
on <b>GUID</b>s.</para>
      <para>Temporary files whose names have been created by this function are not automatically deleted. To delete these
files call <see cref="DeleteFile" />.</para>
      <para>To avoid problems resulting when converting an ANSI string, an application should call the
<see cref="CreateFile" /> function to create a temporary file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetTempFileNameA">
    <summary>
      <para>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and
the handle to it is released; otherwise, only a file name is generated.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory path for the file name. Applications typically specify a period (.) for the current directory
or the result of the <see cref="GetTempPath" /> function. The string
cannot be longer than <b>MAX_PATH</b>–14 characters or
<b>GetTempFileName</b> will fail. If this parameter is
<b>NULL</b>, the function fails.</para>
    </param>
    <param name="lpPrefixString">
      <para>The null-terminated prefix string. The function uses up to the first three characters of this string as the
prefix of the file name. This string must consist of characters in the OEM-defined character set.</para>
    </param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the
current system time. If the file already exists, the number is increased by one and the functions tests if this
file already exists. This continues until a unique filename is found; the function creates a file by that name
and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when
<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">
      <para>A pointer to the buffer that receives the temporary file name. This buffer should be
<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file
name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same
number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The length of the string pointed to by the <i>lpPathName</i> parameter is more than
<b>MAX_PATH</b>–14 characters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTempFileName</b> function creates a temporary
file name of the following form:</para>
      <para>
        <i>&lt;path&gt;</i>\<i>&lt;pre&gt;</i><i>&lt;uuuu&gt;</i>.TMP</para>
      <para>The following table describes the file name syntax.</para>
      <list type="table">
        <listheader>
          <description>Component</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>&lt;path&gt;</i>
          </description>
          <description>Path specified by the <i>lpPathName</i> parameter</description>
        </item>
        <item>
          <description>
            <i>&lt;pre&gt;</i>
          </description>
          <description>First three letters of the <i>lpPrefixString</i> string</description>
        </item>
        <item>
          <description>
            <i>&lt;uuuu&gt;</i>
          </description>
          <description>Hexadecimal value of <i>uUnique</i></description>
        </item>
      </list>
      <para>If <i>uUnique</i> is zero,
<b>GetTempFileName</b> creates an empty file and closes it. If
<i>uUnique</i> is not zero, you must create the file yourself. Only a file name is created,
because <b>GetTempFileName</b> is not able to guarantee that
the file name is unique.</para>
      <para>Only the lower 16 bits of the <i>uUnique</i> parameter are used. This limits
<b>GetTempFileName</b> to a maximum of 65,535 unique file names
if the <i>lpPathName</i> and <i>lpPrefixString</i> parameters remain the
same.</para>
      <para>Due to the algorithm used to generate file names,
<b>GetTempFileName</b> can perform poorly when creating a large
number of files with the same prefix. In such cases, it is recommended that you construct unique file names based
on <b>GUID</b>s.</para>
      <para>Temporary files whose names have been created by this function are not automatically deleted. To delete these
files call <see cref="DeleteFile" />.</para>
      <para>To avoid problems resulting when converting an ANSI string, an application should call the
<see cref="CreateFile" /> function to create a temporary file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetTempFileNameW">
    <summary>
      <para>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and
the handle to it is released; otherwise, only a file name is generated.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory path for the file name. Applications typically specify a period (.) for the current directory
or the result of the <see cref="GetTempPath" /> function. The string
cannot be longer than <b>MAX_PATH</b>–14 characters or
<b>GetTempFileName</b> will fail. If this parameter is
<b>NULL</b>, the function fails.</para>
    </param>
    <param name="lpPrefixString">
      <para>The null-terminated prefix string. The function uses up to the first three characters of this string as the
prefix of the file name. This string must consist of characters in the OEM-defined character set.</para>
    </param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the
current system time. If the file already exists, the number is increased by one and the functions tests if this
file already exists. This continues until a unique filename is found; the function creates a file by that name
and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when
<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">
      <para>A pointer to the buffer that receives the temporary file name. This buffer should be
<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file
name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same
number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The length of the string pointed to by the <i>lpPathName</i> parameter is more than
<b>MAX_PATH</b>–14 characters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTempFileName</b> function creates a temporary
file name of the following form:</para>
      <para>
        <i>&lt;path&gt;</i>\<i>&lt;pre&gt;</i><i>&lt;uuuu&gt;</i>.TMP</para>
      <para>The following table describes the file name syntax.</para>
      <list type="table">
        <listheader>
          <description>Component</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>&lt;path&gt;</i>
          </description>
          <description>Path specified by the <i>lpPathName</i> parameter</description>
        </item>
        <item>
          <description>
            <i>&lt;pre&gt;</i>
          </description>
          <description>First three letters of the <i>lpPrefixString</i> string</description>
        </item>
        <item>
          <description>
            <i>&lt;uuuu&gt;</i>
          </description>
          <description>Hexadecimal value of <i>uUnique</i></description>
        </item>
      </list>
      <para>If <i>uUnique</i> is zero,
<b>GetTempFileName</b> creates an empty file and closes it. If
<i>uUnique</i> is not zero, you must create the file yourself. Only a file name is created,
because <b>GetTempFileName</b> is not able to guarantee that
the file name is unique.</para>
      <para>Only the lower 16 bits of the <i>uUnique</i> parameter are used. This limits
<b>GetTempFileName</b> to a maximum of 65,535 unique file names
if the <i>lpPathName</i> and <i>lpPrefixString</i> parameters remain the
same.</para>
      <para>Due to the algorithm used to generate file names,
<b>GetTempFileName</b> can perform poorly when creating a large
number of files with the same prefix. In such cases, it is recommended that you construct unique file names based
on <b>GUID</b>s.</para>
      <para>Temporary files whose names have been created by this function are not automatically deleted. To delete these
files call <see cref="DeleteFile" />.</para>
      <para>To avoid problems resulting when converting an ANSI string, an application should call the
<see cref="CreateFile" /> function to create a temporary file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetTempPath2A">
    <summary>
      <para>Retrieves the path of the directory designated for temporary files, based on the privileges of the calling process.</para>
    </summary>
    <param name="BufferLength">
      <para>The size of the string buffer identified by <i>lpBuffer</i>, in
<b>TCHARs</b>.</para>
    </param>
    <param name="Buffer">
      <para>A pointer to a string buffer that receives the null-terminated string specifying the temporary file path.
The returned string ends with a backslash, for example, "C:\TEMP\".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character. If the
return value is greater than <i>nBufferLength</i>, the return value is the length, in
<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
    <remarks>
      <para>When calling this function from a process running as SYSTEM it will return the path C:\Windows\SystemTemp, which is inaccessible to non-SYSTEM processes. For non-SYSTEM processes, <b>GetTempPath2</b> will behave the same as <see cref="GetTempPath" />.</para>
      <para>The <b>GetTempPath2</b> function checks for the existence of
environment variables in the following order and uses the first path found:</para>
      <list type="number">
        <item>
          <description>The path specified by the TMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the TEMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the USERPROFILE environment variable.</description>
        </item>
        <item>
          <description>The Windows directory.</description>
        </item>
      </list>
      <para>Note that the function does not verify that the path exists, nor does it test to see if the current process has
any kind of access rights to the path. The <b>GetTempPath2</b></para>
      <para>function returns the properly formatted string that specifies the fully qualified path based on the environment
variable search order as previously specified. The application should verify the existence of the path and
adequate access rights to the path prior to any use for file I/O operations.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the temp path name
maintains any symbolic links.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempPath2 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.GetTempPath2W">
    <summary>
      <para>Retrieves the path of the directory designated for temporary files, based on the privileges of the calling process.</para>
    </summary>
    <param name="BufferLength">
      <para>The size of the string buffer identified by <i>lpBuffer</i>, in
<b>TCHARs</b>.</para>
    </param>
    <param name="Buffer">
      <para>A pointer to a string buffer that receives the null-terminated string specifying the temporary file path.
The returned string ends with a backslash, for example, "C:\TEMP\".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character. If the
return value is greater than <i>nBufferLength</i>, the return value is the length, in
<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
    <remarks>
      <para>When calling this function from a process running as SYSTEM it will return the path C:\Windows\SystemTemp, which is inaccessible to non-SYSTEM processes. For non-SYSTEM processes, <b>GetTempPath2</b> will behave the same as <see cref="GetTempPath" />.</para>
      <para>The <b>GetTempPath2</b> function checks for the existence of
environment variables in the following order and uses the first path found:</para>
      <list type="number">
        <item>
          <description>The path specified by the TMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the TEMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the USERPROFILE environment variable.</description>
        </item>
        <item>
          <description>The Windows directory.</description>
        </item>
      </list>
      <para>Note that the function does not verify that the path exists, nor does it test to see if the current process has
any kind of access rights to the path. The <b>GetTempPath2</b></para>
      <para>function returns the properly formatted string that specifies the fully qualified path based on the environment
variable search order as previously specified. The application should verify the existence of the path and
adequate access rights to the path prior to any use for file I/O operations.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the temp path name
maintains any symbolic links.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempPath2 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetTempPath">
    <summary>
      <para>Retrieves the path of the directory designated for temporary files.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the string buffer identified by <i>lpBuffer</i>, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a string buffer that receives the null-terminated string specifying the temporary file path.
The returned string ends with a backslash, for example, "C:\TEMP\".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character. If the
return value is greater than <i>nBufferLength</i>, the return value is the length, in
<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
Apps should call <see cref="GetTempPath2" /> instead of <b>GetTempPath</b>.</para>
      </blockquote>
      <para>The <b>GetTempPath</b> function checks for the existence of
environment variables in the following order and uses the first path found:</para>
      <list type="number">
        <item>
          <description>The path specified by the TMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the TEMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the USERPROFILE environment variable.</description>
        </item>
        <item>
          <description>The Windows directory.</description>
        </item>
      </list>
      <para>Note that the function does not verify that the path exists, nor does it test to see if the current process has
any kind of access rights to the path. The <b>GetTempPath</b></para>
      <para>function returns the properly formatted string that specifies the fully qualified path based on the environment
variable search order as previously specified. The application should verify the existence of the path and
adequate access rights to the path prior to any use for file I/O operations.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the temp path name
maintains any symbolic links.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetTempPathA">
    <summary>
      <para>Retrieves the path of the directory designated for temporary files.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the string buffer identified by <i>lpBuffer</i>, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a string buffer that receives the null-terminated string specifying the temporary file path.
The returned string ends with a backslash, for example, "C:\TEMP\".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character. If the
return value is greater than <i>nBufferLength</i>, the return value is the length, in
<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
Apps should call <see cref="GetTempPath2" /> instead of <b>GetTempPath</b>.</para>
      </blockquote>
      <para>The <b>GetTempPath</b> function checks for the existence of
environment variables in the following order and uses the first path found:</para>
      <list type="number">
        <item>
          <description>The path specified by the TMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the TEMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the USERPROFILE environment variable.</description>
        </item>
        <item>
          <description>The Windows directory.</description>
        </item>
      </list>
      <para>Note that the function does not verify that the path exists, nor does it test to see if the current process has
any kind of access rights to the path. The <b>GetTempPath</b></para>
      <para>function returns the properly formatted string that specifies the fully qualified path based on the environment
variable search order as previously specified. The application should verify the existence of the path and
adequate access rights to the path prior to any use for file I/O operations.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the temp path name
maintains any symbolic links.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetTempPathW">
    <summary>
      <para>Retrieves the path of the directory designated for temporary files.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the string buffer identified by <i>lpBuffer</i>, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a string buffer that receives the null-terminated string specifying the temporary file path.
The returned string ends with a backslash, for example, "C:\TEMP\".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character. If the
return value is greater than <i>nBufferLength</i>, the return value is the length, in
<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
Apps should call <see cref="GetTempPath2" /> instead of <b>GetTempPath</b>.</para>
      </blockquote>
      <para>The <b>GetTempPath</b> function checks for the existence of
environment variables in the following order and uses the first path found:</para>
      <list type="number">
        <item>
          <description>The path specified by the TMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the TEMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the USERPROFILE environment variable.</description>
        </item>
        <item>
          <description>The Windows directory.</description>
        </item>
      </list>
      <para>Note that the function does not verify that the path exists, nor does it test to see if the current process has
any kind of access rights to the path. The <b>GetTempPath</b></para>
      <para>function returns the properly formatted string that specifies the fully qualified path based on the environment
variable search order as previously specified. The application should verify the existence of the path and
adequate access rights to the path prior to any use for file I/O operations.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the temp path name
maintains any symbolic links.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetTempPath">
    <summary>
      <para>Retrieves the path of the directory designated for temporary files.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the string buffer identified by <i>lpBuffer</i>, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a string buffer that receives the null-terminated string specifying the temporary file path.
The returned string ends with a backslash, for example, "C:\TEMP\".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character. If the
return value is greater than <i>nBufferLength</i>, the return value is the length, in
<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
Apps should call <see cref="GetTempPath2" /> instead of <b>GetTempPath</b>.</para>
      </blockquote>
      <para>The <b>GetTempPath</b> function checks for the existence of
environment variables in the following order and uses the first path found:</para>
      <list type="number">
        <item>
          <description>The path specified by the TMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the TEMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the USERPROFILE environment variable.</description>
        </item>
        <item>
          <description>The Windows directory.</description>
        </item>
      </list>
      <para>Note that the function does not verify that the path exists, nor does it test to see if the current process has
any kind of access rights to the path. The <b>GetTempPath</b></para>
      <para>function returns the properly formatted string that specifies the fully qualified path based on the environment
variable search order as previously specified. The application should verify the existence of the path and
adequate access rights to the path prior to any use for file I/O operations.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the temp path name
maintains any symbolic links.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetTempPathA">
    <summary>
      <para>Retrieves the path of the directory designated for temporary files.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the string buffer identified by <i>lpBuffer</i>, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a string buffer that receives the null-terminated string specifying the temporary file path.
The returned string ends with a backslash, for example, "C:\TEMP\".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character. If the
return value is greater than <i>nBufferLength</i>, the return value is the length, in
<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
Apps should call <see cref="GetTempPath2" /> instead of <b>GetTempPath</b>.</para>
      </blockquote>
      <para>The <b>GetTempPath</b> function checks for the existence of
environment variables in the following order and uses the first path found:</para>
      <list type="number">
        <item>
          <description>The path specified by the TMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the TEMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the USERPROFILE environment variable.</description>
        </item>
        <item>
          <description>The Windows directory.</description>
        </item>
      </list>
      <para>Note that the function does not verify that the path exists, nor does it test to see if the current process has
any kind of access rights to the path. The <b>GetTempPath</b></para>
      <para>function returns the properly formatted string that specifies the fully qualified path based on the environment
variable search order as previously specified. The application should verify the existence of the path and
adequate access rights to the path prior to any use for file I/O operations.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the temp path name
maintains any symbolic links.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetTempPathW">
    <summary>
      <para>Retrieves the path of the directory designated for temporary files.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the string buffer identified by <i>lpBuffer</i>, in
<b>TCHARs</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a string buffer that receives the null-terminated string specifying the temporary file path.
The returned string ends with a backslash, for example, "C:\TEMP\".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string copied to <i>lpBuffer</i>, not including the terminating null character. If the
return value is greater than <i>nBufferLength</i>, the return value is the length, in
<b>TCHARs</b>, of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The maximum possible return value is <b>MAX_PATH</b>+1 (261).</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
Apps should call <see cref="GetTempPath2" /> instead of <b>GetTempPath</b>.</para>
      </blockquote>
      <para>The <b>GetTempPath</b> function checks for the existence of
environment variables in the following order and uses the first path found:</para>
      <list type="number">
        <item>
          <description>The path specified by the TMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the TEMP environment variable.</description>
        </item>
        <item>
          <description>The path specified by the USERPROFILE environment variable.</description>
        </item>
        <item>
          <description>The Windows directory.</description>
        </item>
      </list>
      <para>Note that the function does not verify that the path exists, nor does it test to see if the current process has
any kind of access rights to the path. The <b>GetTempPath</b></para>
      <para>function returns the properly formatted string that specifies the fully qualified path based on the environment
variable search order as previously specified. The application should verify the existence of the path and
adequate access rights to the path prior to any use for file I/O operations.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the temp path name
maintains any symbolic links.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetTempPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetVolumeInformation">
    <summary>
      <para>Retrieves information about the file system and volume associated with the specified root
directory.</para>
      <para>To specify a handle when retrieving this information, use the
<see cref="GetVolumeInformationByHandleW" /> function.</para>
      <para>To retrieve the current compression state of a file or directory, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the root directory of the volume to be described.</para>
      <para>If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing
backslash is required. For example, you  specify \\MyServer\MyShare as
"\\MyServer\MyShare\", or the C drive as
"C:\".</para>
    </param>
    <param name="lpVolumeNameBuffer">
      <para>A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the
<i>nVolumeNameSize</i> parameter.</para>
    </param>
    <param name="nVolumeNameSize">
      <para>The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the volume name buffer is not supplied.</para>
    </param>
    <param name="lpVolumeSerialNumber">
      <para>A pointer to a variable that receives the volume serial number.</para>
      <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
      <para>This function returns the volume serial number that the operating system assigns when a hard disk is
formatted.  To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the
Windows Management Instrumentation (WMI)
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a>  property
<b>SerialNumber</b>.</para>
    </param>
    <param name="lpMaximumComponentLength">
      <para>A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file
name component  that a specified file system supports.</para>
      <para>A file name component is the portion of a file name between backslashes.</para>
      <para>The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to
is used to indicate that a specified file system supports long names. For example, for a FAT file system that
supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can
also be supported on systems that use the NTFS file system.</para>
    </param>
    <param name="lpFileSystemFlags">
      <para>A pointer to a variable that receives flags associated with the specified file system.</para>
      <para>This parameter can be one or more of the following flags. However,
<b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually
exclusive.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_PRESERVED_NAMES</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports preserved case of file names when it places a name on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_SENSITIVE_SEARCH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports case-sensitive file names.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_DAX_VOLUME        </b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a direct access (DAX) volume.</para>
            <para>
              <b>Note</b>  This flag was introduced in Windows 10, version 1607.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FILE_COMPRESSION</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports file-based compression.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAMED_STREAMS</b>
                </description>
              </item>
              <item>
                <description>0x00040000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports named streams.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_PERSISTENT_ACLS</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system
preserves and enforces ACLs, and the FAT file system does not.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY_VOLUME</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is read-only.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SEQUENTIAL_WRITE_ONCE</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports a single sequential write.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_ENCRYPTION</b>
                </description>
              </item>
              <item>
                <description>0x00020000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports the Encrypted File System (EFS). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00800000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports extended attributes. An extended attribute is a piece of
application-specific metadata that an application can associate with a file and is not part of the file's data.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_HARD_LINKS</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports hard links. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OBJECT_IDS</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports object identifiers.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b>
                </description>
              </item>
              <item>
                <description>0x01000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system supports open by FileID. For more information, see
<see cref="FILE_ID_BOTH_DIR_INFO" />.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_REPARSE_POINTS</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports reparse points.</para>
            <para>
              <b>ReFS:  </b>ReFS supports reparse points but does not index them so
<see cref="FindFirstVolumeMountPoint" /> and
<see cref="FindNextVolumeMountPoint" /> will not
function as expected.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_SPARSE_FILES</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sparse files.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_TRANSACTIONS</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports transactions. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_USN_JOURNAL</b>
                </description>
              </item>
              <item>
                <description>0x02000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports update sequence number (USN) journals. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNICODE_ON_DISK</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports Unicode in file names as they appear on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_IS_COMPRESSED</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a compressed volume, for example, a DoubleSpace volume.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_QUOTAS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports disk quotas.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b>
                </description>
              </item>
              <item>
                <description>0x08000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileSystemNameBuffer">
      <para>A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS
file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</para>
    </param>
    <param name="nFileSystemNameSize">
      <para>The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the file system name buffer is not supplied.</para>
    </param>
    <returns>
      <para>If all the requested information is retrieved, the return value is nonzero.</para>
      <para>If not all the requested information is retrieved, the return value is zero. To get extended error
information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a user attempts to get information about a floppy drive that does not have a floppy disk, or a CD-ROM
drive that does not have a compact disc, the system displays a message box for the user to insert a floppy disk
or a compact disc, respectively. To prevent the system from displaying this message box, call the
<see cref="SetErrorMode" /> function with
<b>SEM_FAILCRITICALERRORS</b>.</para>
      <para>The <b>FILE_VOL_IS_COMPRESSED</b> flag is the only indicator of volume-based compression. The
file system name is not altered to indicate compression, for example, this flag is returned set on a DoubleSpace
volume. When compression is volume-based, an entire volume is  compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> flag indicates whether a file system supports file-based
compression. When compression is file-based, individual files can be compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> flags are
mutually exclusive. Both bits cannot be returned set.</para>
      <para>The maximum component length value that is stored in <i>lpMaximumComponentLength</i> is the
only indicator that a volume supports longer-than-normal FAT file system (or other file system) file names. The
file system name is not altered to indicate support for long file names.</para>
      <para>The <see cref="GetCompressedFileSize" /> function obtains the
compressed size of a file. The <see cref="GetFileAttributes" /></para>
      <para>function can determine whether an individual file is compressed.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the function returns volume information for the target.</para>
      <para>Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h3>Transacted Operations</h3>
      <para>If the volume supports file system transactions, the function returns
<b>FILE_SUPPORTS_TRANSACTIONS</b> in <i>lpFileSystemFlags</i>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetVolumeInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso cref="GetCompressedFileSize" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetVolumeInformationByHandleW" />
    <seealso cref="SetErrorMode" />
    <seealso cref="SetVolumeLabel" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumeInformationA">
    <summary>
      <para>Retrieves information about the file system and volume associated with the specified root
directory.</para>
      <para>To specify a handle when retrieving this information, use the
<see cref="GetVolumeInformationByHandleW" /> function.</para>
      <para>To retrieve the current compression state of a file or directory, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the root directory of the volume to be described.</para>
      <para>If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing
backslash is required. For example, you  specify \\MyServer\MyShare as
"\\MyServer\MyShare\", or the C drive as
"C:\".</para>
    </param>
    <param name="lpVolumeNameBuffer">
      <para>A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the
<i>nVolumeNameSize</i> parameter.</para>
    </param>
    <param name="nVolumeNameSize">
      <para>The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the volume name buffer is not supplied.</para>
    </param>
    <param name="lpVolumeSerialNumber">
      <para>A pointer to a variable that receives the volume serial number.</para>
      <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
      <para>This function returns the volume serial number that the operating system assigns when a hard disk is
formatted.  To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the
Windows Management Instrumentation (WMI)
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a>  property
<b>SerialNumber</b>.</para>
    </param>
    <param name="lpMaximumComponentLength">
      <para>A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file
name component  that a specified file system supports.</para>
      <para>A file name component is the portion of a file name between backslashes.</para>
      <para>The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to
is used to indicate that a specified file system supports long names. For example, for a FAT file system that
supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can
also be supported on systems that use the NTFS file system.</para>
    </param>
    <param name="lpFileSystemFlags">
      <para>A pointer to a variable that receives flags associated with the specified file system.</para>
      <para>This parameter can be one or more of the following flags. However,
<b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually
exclusive.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_PRESERVED_NAMES</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports preserved case of file names when it places a name on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_SENSITIVE_SEARCH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports case-sensitive file names.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_DAX_VOLUME        </b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a direct access (DAX) volume.</para>
            <para>
              <b>Note</b>  This flag was introduced in Windows 10, version 1607.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FILE_COMPRESSION</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports file-based compression.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAMED_STREAMS</b>
                </description>
              </item>
              <item>
                <description>0x00040000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports named streams.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_PERSISTENT_ACLS</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system
preserves and enforces ACLs, and the FAT file system does not.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY_VOLUME</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is read-only.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SEQUENTIAL_WRITE_ONCE</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports a single sequential write.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_ENCRYPTION</b>
                </description>
              </item>
              <item>
                <description>0x00020000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports the Encrypted File System (EFS). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00800000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports extended attributes. An extended attribute is a piece of
application-specific metadata that an application can associate with a file and is not part of the file's data.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_HARD_LINKS</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports hard links. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OBJECT_IDS</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports object identifiers.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b>
                </description>
              </item>
              <item>
                <description>0x01000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system supports open by FileID. For more information, see
<see cref="FILE_ID_BOTH_DIR_INFO" />.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_REPARSE_POINTS</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports reparse points.</para>
            <para>
              <b>ReFS:  </b>ReFS supports reparse points but does not index them so
<see cref="FindFirstVolumeMountPoint" /> and
<see cref="FindNextVolumeMountPoint" /> will not
function as expected.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_SPARSE_FILES</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sparse files.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_TRANSACTIONS</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports transactions. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_USN_JOURNAL</b>
                </description>
              </item>
              <item>
                <description>0x02000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports update sequence number (USN) journals. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNICODE_ON_DISK</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports Unicode in file names as they appear on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_IS_COMPRESSED</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a compressed volume, for example, a DoubleSpace volume.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_QUOTAS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports disk quotas.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b>
                </description>
              </item>
              <item>
                <description>0x08000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileSystemNameBuffer">
      <para>A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS
file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</para>
    </param>
    <param name="nFileSystemNameSize">
      <para>The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the file system name buffer is not supplied.</para>
    </param>
    <returns>
      <para>If all the requested information is retrieved, the return value is nonzero.</para>
      <para>If not all the requested information is retrieved, the return value is zero. To get extended error
information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a user attempts to get information about a floppy drive that does not have a floppy disk, or a CD-ROM
drive that does not have a compact disc, the system displays a message box for the user to insert a floppy disk
or a compact disc, respectively. To prevent the system from displaying this message box, call the
<see cref="SetErrorMode" /> function with
<b>SEM_FAILCRITICALERRORS</b>.</para>
      <para>The <b>FILE_VOL_IS_COMPRESSED</b> flag is the only indicator of volume-based compression. The
file system name is not altered to indicate compression, for example, this flag is returned set on a DoubleSpace
volume. When compression is volume-based, an entire volume is  compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> flag indicates whether a file system supports file-based
compression. When compression is file-based, individual files can be compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> flags are
mutually exclusive. Both bits cannot be returned set.</para>
      <para>The maximum component length value that is stored in <i>lpMaximumComponentLength</i> is the
only indicator that a volume supports longer-than-normal FAT file system (or other file system) file names. The
file system name is not altered to indicate support for long file names.</para>
      <para>The <see cref="GetCompressedFileSize" /> function obtains the
compressed size of a file. The <see cref="GetFileAttributes" /></para>
      <para>function can determine whether an individual file is compressed.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the function returns volume information for the target.</para>
      <para>Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h3>Transacted Operations</h3>
      <para>If the volume supports file system transactions, the function returns
<b>FILE_SUPPORTS_TRANSACTIONS</b> in <i>lpFileSystemFlags</i>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetVolumeInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso cref="GetCompressedFileSize" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetVolumeInformationByHandleW" />
    <seealso cref="SetErrorMode" />
    <seealso cref="SetVolumeLabel" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumeInformationW">
    <summary>
      <para>Retrieves information about the file system and volume associated with the specified root
directory.</para>
      <para>To specify a handle when retrieving this information, use the
<see cref="GetVolumeInformationByHandleW" /> function.</para>
      <para>To retrieve the current compression state of a file or directory, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the root directory of the volume to be described.</para>
      <para>If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing
backslash is required. For example, you  specify \\MyServer\MyShare as
"\\MyServer\MyShare\", or the C drive as
"C:\".</para>
    </param>
    <param name="lpVolumeNameBuffer">
      <para>A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the
<i>nVolumeNameSize</i> parameter.</para>
    </param>
    <param name="nVolumeNameSize">
      <para>The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the volume name buffer is not supplied.</para>
    </param>
    <param name="lpVolumeSerialNumber">
      <para>A pointer to a variable that receives the volume serial number.</para>
      <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
      <para>This function returns the volume serial number that the operating system assigns when a hard disk is
formatted.  To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the
Windows Management Instrumentation (WMI)
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a>  property
<b>SerialNumber</b>.</para>
    </param>
    <param name="lpMaximumComponentLength">
      <para>A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file
name component  that a specified file system supports.</para>
      <para>A file name component is the portion of a file name between backslashes.</para>
      <para>The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to
is used to indicate that a specified file system supports long names. For example, for a FAT file system that
supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can
also be supported on systems that use the NTFS file system.</para>
    </param>
    <param name="lpFileSystemFlags">
      <para>A pointer to a variable that receives flags associated with the specified file system.</para>
      <para>This parameter can be one or more of the following flags. However,
<b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually
exclusive.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_PRESERVED_NAMES</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports preserved case of file names when it places a name on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_SENSITIVE_SEARCH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports case-sensitive file names.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_DAX_VOLUME        </b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a direct access (DAX) volume.</para>
            <para>
              <b>Note</b>  This flag was introduced in Windows 10, version 1607.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FILE_COMPRESSION</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports file-based compression.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAMED_STREAMS</b>
                </description>
              </item>
              <item>
                <description>0x00040000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports named streams.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_PERSISTENT_ACLS</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system
preserves and enforces ACLs, and the FAT file system does not.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY_VOLUME</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is read-only.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SEQUENTIAL_WRITE_ONCE</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports a single sequential write.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_ENCRYPTION</b>
                </description>
              </item>
              <item>
                <description>0x00020000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports the Encrypted File System (EFS). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00800000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports extended attributes. An extended attribute is a piece of
application-specific metadata that an application can associate with a file and is not part of the file's data.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_HARD_LINKS</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports hard links. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OBJECT_IDS</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports object identifiers.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b>
                </description>
              </item>
              <item>
                <description>0x01000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system supports open by FileID. For more information, see
<see cref="FILE_ID_BOTH_DIR_INFO" />.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_REPARSE_POINTS</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports reparse points.</para>
            <para>
              <b>ReFS:  </b>ReFS supports reparse points but does not index them so
<see cref="FindFirstVolumeMountPoint" /> and
<see cref="FindNextVolumeMountPoint" /> will not
function as expected.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_SPARSE_FILES</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sparse files.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_TRANSACTIONS</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports transactions. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_USN_JOURNAL</b>
                </description>
              </item>
              <item>
                <description>0x02000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports update sequence number (USN) journals. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNICODE_ON_DISK</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports Unicode in file names as they appear on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_IS_COMPRESSED</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a compressed volume, for example, a DoubleSpace volume.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_QUOTAS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports disk quotas.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b>
                </description>
              </item>
              <item>
                <description>0x08000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileSystemNameBuffer">
      <para>A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS
file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</para>
    </param>
    <param name="nFileSystemNameSize">
      <para>The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the file system name buffer is not supplied.</para>
    </param>
    <returns>
      <para>If all the requested information is retrieved, the return value is nonzero.</para>
      <para>If not all the requested information is retrieved, the return value is zero. To get extended error
information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a user attempts to get information about a floppy drive that does not have a floppy disk, or a CD-ROM
drive that does not have a compact disc, the system displays a message box for the user to insert a floppy disk
or a compact disc, respectively. To prevent the system from displaying this message box, call the
<see cref="SetErrorMode" /> function with
<b>SEM_FAILCRITICALERRORS</b>.</para>
      <para>The <b>FILE_VOL_IS_COMPRESSED</b> flag is the only indicator of volume-based compression. The
file system name is not altered to indicate compression, for example, this flag is returned set on a DoubleSpace
volume. When compression is volume-based, an entire volume is  compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> flag indicates whether a file system supports file-based
compression. When compression is file-based, individual files can be compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> flags are
mutually exclusive. Both bits cannot be returned set.</para>
      <para>The maximum component length value that is stored in <i>lpMaximumComponentLength</i> is the
only indicator that a volume supports longer-than-normal FAT file system (or other file system) file names. The
file system name is not altered to indicate support for long file names.</para>
      <para>The <see cref="GetCompressedFileSize" /> function obtains the
compressed size of a file. The <see cref="GetFileAttributes" /></para>
      <para>function can determine whether an individual file is compressed.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the function returns volume information for the target.</para>
      <para>Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h3>Transacted Operations</h3>
      <para>If the volume supports file system transactions, the function returns
<b>FILE_SUPPORTS_TRANSACTIONS</b> in <i>lpFileSystemFlags</i>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetVolumeInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso cref="GetCompressedFileSize" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetVolumeInformationByHandleW" />
    <seealso cref="SetErrorMode" />
    <seealso cref="SetVolumeLabel" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumeInformationByHandleW">
    <summary>
      <para>Retrieves information about the file system and volume associated with the specified
file.</para>
      <para>To retrieve the current compression state of a file or directory, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file.</para>
    </param>
    <param name="lpVolumeNameBuffer">
      <para>A pointer to a buffer that receives the name of a specified volume. The maximum buffer size is
<code>MAX_PATH+1</code>.</para>
    </param>
    <param name="nVolumeNameSize">
      <para>The length of a volume name buffer, in <b>WCHAR</b>s. The maximum buffer size is
<code>MAX_PATH+1</code>.</para>
      <para>This parameter is ignored if the volume name buffer is not supplied.</para>
    </param>
    <param name="lpVolumeSerialNumber">
      <para>A pointer to a variable that receives the volume serial number.</para>
      <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
      <para>This function returns the volume serial number that the operating system assigns when a hard disk is
formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the
Windows Management Instrumentation (WMI)
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a> property
<b>SerialNumber</b>.</para>
    </param>
    <param name="lpMaximumComponentLength">
      <para>A pointer to a variable that receives the maximum length, in <b>WCHAR</b>s, of a file
name component  that a specified file system supports.</para>
      <para>A file name component is the portion of a file name between backslashes.</para>
      <para>The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to
is used to indicate that a specified file system supports long names. For example, for a FAT file system that
supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can
also be supported on systems that use the NTFS file system.</para>
    </param>
    <param name="lpFileSystemFlags">
      <para>A pointer to a variable that receives flags associated with the specified file system.</para>
      <para>This parameter can be one or more of the following flags. However,
<b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually
exclusive.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_PRESERVED_NAMES</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports preserved case of file names when it places a name on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_SENSITIVE_SEARCH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports case-sensitive file names.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FILE_COMPRESSION</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports file-based compression.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAMED_STREAMS</b>
                </description>
              </item>
              <item>
                <description>0x00040000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports named streams.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_PERSISTENT_ACLS</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system
preserves and enforces ACLs, and the FAT file system does not.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY_VOLUME</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is read-only.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SEQUENTIAL_WRITE_ONCE</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports a single sequential write.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_ENCRYPTION</b>
                </description>
              </item>
              <item>
                <description>0x00020000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports the Encrypted File System (EFS). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00800000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports extended attributes. An extended attribute is a piece of
application-specific metadata that an application can associate with a file and is not part of the file's data.</para>
            <para>
              <b>Windows Vista and Windows Server 2008:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_HARD_LINKS</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports hard links. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
            <para>
              <b>Windows Vista and Windows Server 2008:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OBJECT_IDS</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports object identifiers.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b>
                </description>
              </item>
              <item>
                <description>0x01000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system supports open by FileID. For more information, see
<see cref="FILE_ID_BOTH_DIR_INFO" />.</para>
            <para>
              <b>Windows Vista and Windows Server 2008:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_REPARSE_POINTS</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports re-parse points.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_SPARSE_FILES</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sparse files.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_TRANSACTIONS</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports transactions. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_USN_JOURNAL</b>
                </description>
              </item>
              <item>
                <description>0x02000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports update sequence number (USN) journals. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.</para>
            <para>
              <b>Windows Vista and Windows Server 2008:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNICODE_ON_DISK</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports Unicode in file names as they appear on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_IS_COMPRESSED</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a compressed volume.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_QUOTAS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports disk quotas.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b>
                </description>
              </item>
              <item>
                <description>0x08000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileSystemNameBuffer">
      <para>A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the
NTFS file system. The buffer size is specified by the <i>nFileSystemNameSize</i></para>
      <para>parameter.</para>
    </param>
    <param name="nFileSystemNameSize">
      <para>The length of the file system name buffer, in <b>WCHAR</b>s. The maximum buffer size
is <code>MAX_PATH+1</code>.</para>
      <para>This parameter is ignored if the file system name buffer is not supplied.</para>
    </param>
    <returns>
      <para>If all the requested information is retrieved, the return value is nonzero.</para>
      <para>If not all the requested information is retrieved, the return value is zero. To get extended error
information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso cref="GetCompressedFileSize" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetVolumeInformation" />
    <seealso cref="SetErrorMode" />
    <seealso cref="SetVolumeLabel" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumeInformation">
    <summary>
      <para>Retrieves information about the file system and volume associated with the specified root
directory.</para>
      <para>To specify a handle when retrieving this information, use the
<see cref="GetVolumeInformationByHandleW" /> function.</para>
      <para>To retrieve the current compression state of a file or directory, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the root directory of the volume to be described.</para>
      <para>If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing
backslash is required. For example, you  specify \MyServer\MyShare as
"\MyServer\MyShare", or the C drive as
"C:".</para>
    </param>
    <param name="lpVolumeNameBuffer">
      <para>A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the
<i>nVolumeNameSize</i> parameter.</para>
    </param>
    <param name="nVolumeNameSize">
      <para>The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the volume name buffer is not supplied.</para>
    </param>
    <param name="lpVolumeSerialNumber">
      <para>A pointer to a variable that receives the volume serial number.</para>
      <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
      <para>This function returns the volume serial number that the operating system assigns when a hard disk is
formatted.  To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the
Windows Management Instrumentation (WMI)
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a>  property
<b>SerialNumber</b>.</para>
    </param>
    <param name="lpMaximumComponentLength">
      <para>A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file
name component  that a specified file system supports.</para>
      <para>A file name component is the portion of a file name between backslashes.</para>
      <para>The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to
is used to indicate that a specified file system supports long names. For example, for a FAT file system that
supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can
also be supported on systems that use the NTFS file system.</para>
    </param>
    <param name="lpFileSystemFlags">
      <para>A pointer to a variable that receives flags associated with the specified file system.</para>
      <para>This parameter can be one or more of the following flags. However,
<b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually
exclusive.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_PRESERVED_NAMES</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports preserved case of file names when it places a name on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_SENSITIVE_SEARCH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports case-sensitive file names.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_DAX_VOLUME        </b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a direct access (DAX) volume.</para>
            <para>
              <b>Note</b>  This flag was introduced in Windows 10, version 1607.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FILE_COMPRESSION</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports file-based compression.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAMED_STREAMS</b>
                </description>
              </item>
              <item>
                <description>0x00040000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports named streams.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_PERSISTENT_ACLS</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system
preserves and enforces ACLs, and the FAT file system does not.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY_VOLUME</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is read-only.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SEQUENTIAL_WRITE_ONCE</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports a single sequential write.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_ENCRYPTION</b>
                </description>
              </item>
              <item>
                <description>0x00020000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports the Encrypted File System (EFS). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00800000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports extended attributes. An extended attribute is a piece of
application-specific metadata that an application can associate with a file and is not part of the file's data.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_HARD_LINKS</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports hard links. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OBJECT_IDS</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports object identifiers.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b>
                </description>
              </item>
              <item>
                <description>0x01000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system supports open by FileID. For more information, see
<see cref="FILE_ID_BOTH_DIR_INFO" />.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_REPARSE_POINTS</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports reparse points.</para>
            <para>
              <b>ReFS:  </b>ReFS supports reparse points but does not index them so
<see cref="FindFirstVolumeMountPoint" /> and
<see cref="FindNextVolumeMountPoint" /> will not
function as expected.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_SPARSE_FILES</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sparse files.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_TRANSACTIONS</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports transactions. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_USN_JOURNAL</b>
                </description>
              </item>
              <item>
                <description>0x02000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports update sequence number (USN) journals. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNICODE_ON_DISK</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports Unicode in file names as they appear on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_IS_COMPRESSED</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a compressed volume, for example, a DoubleSpace volume.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_QUOTAS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports disk quotas.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b>
                </description>
              </item>
              <item>
                <description>0x08000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileSystemNameBuffer">
      <para>A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS
file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</para>
    </param>
    <param name="nFileSystemNameSize">
      <para>The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the file system name buffer is not supplied.</para>
    </param>
    <returns>
      <para>If all the requested information is retrieved, the return value is nonzero.</para>
      <para>If not all the requested information is retrieved, the return value is zero. To get extended error
information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a user attempts to get information about a floppy drive that does not have a floppy disk, or a CD-ROM
drive that does not have a compact disc, the system displays a message box for the user to insert a floppy disk
or a compact disc, respectively. To prevent the system from displaying this message box, call the
<see cref="SetErrorMode" /> function with
<b>SEM_FAILCRITICALERRORS</b>.</para>
      <para>The <b>FILE_VOL_IS_COMPRESSED</b> flag is the only indicator of volume-based compression. The
file system name is not altered to indicate compression, for example, this flag is returned set on a DoubleSpace
volume. When compression is volume-based, an entire volume is  compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> flag indicates whether a file system supports file-based
compression. When compression is file-based, individual files can be compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> flags are
mutually exclusive. Both bits cannot be returned set.</para>
      <para>The maximum component length value that is stored in <i>lpMaximumComponentLength</i> is the
only indicator that a volume supports longer-than-normal FAT file system (or other file system) file names. The
file system name is not altered to indicate support for long file names.</para>
      <para>The <see cref="GetCompressedFileSize" /> function obtains the
compressed size of a file. The <see cref="GetFileAttributes" /></para>
      <para>function can determine whether an individual file is compressed.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the function returns volume information for the target.</para>
      <para>Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h3>Transacted Operations</h3>
      <para>If the volume supports file system transactions, the function returns
<b>FILE_SUPPORTS_TRANSACTIONS</b> in <i>lpFileSystemFlags</i>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetVolumeInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso cref="GetCompressedFileSize" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetVolumeInformationByHandleW" />
    <seealso cref="SetErrorMode" />
    <seealso cref="SetVolumeLabel" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumeInformationA">
    <summary>
      <para>Retrieves information about the file system and volume associated with the specified root
directory.</para>
      <para>To specify a handle when retrieving this information, use the
<see cref="GetVolumeInformationByHandleW" /> function.</para>
      <para>To retrieve the current compression state of a file or directory, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the root directory of the volume to be described.</para>
      <para>If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing
backslash is required. For example, you  specify \MyServer\MyShare as
"\MyServer\MyShare", or the C drive as
"C:".</para>
    </param>
    <param name="lpVolumeNameBuffer">
      <para>A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the
<i>nVolumeNameSize</i> parameter.</para>
    </param>
    <param name="nVolumeNameSize">
      <para>The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the volume name buffer is not supplied.</para>
    </param>
    <param name="lpVolumeSerialNumber">
      <para>A pointer to a variable that receives the volume serial number.</para>
      <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
      <para>This function returns the volume serial number that the operating system assigns when a hard disk is
formatted.  To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the
Windows Management Instrumentation (WMI)
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a>  property
<b>SerialNumber</b>.</para>
    </param>
    <param name="lpMaximumComponentLength">
      <para>A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file
name component  that a specified file system supports.</para>
      <para>A file name component is the portion of a file name between backslashes.</para>
      <para>The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to
is used to indicate that a specified file system supports long names. For example, for a FAT file system that
supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can
also be supported on systems that use the NTFS file system.</para>
    </param>
    <param name="lpFileSystemFlags">
      <para>A pointer to a variable that receives flags associated with the specified file system.</para>
      <para>This parameter can be one or more of the following flags. However,
<b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually
exclusive.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_PRESERVED_NAMES</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports preserved case of file names when it places a name on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_SENSITIVE_SEARCH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports case-sensitive file names.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_DAX_VOLUME        </b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a direct access (DAX) volume.</para>
            <para>
              <b>Note</b>  This flag was introduced in Windows 10, version 1607.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FILE_COMPRESSION</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports file-based compression.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAMED_STREAMS</b>
                </description>
              </item>
              <item>
                <description>0x00040000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports named streams.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_PERSISTENT_ACLS</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system
preserves and enforces ACLs, and the FAT file system does not.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY_VOLUME</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is read-only.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SEQUENTIAL_WRITE_ONCE</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports a single sequential write.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_ENCRYPTION</b>
                </description>
              </item>
              <item>
                <description>0x00020000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports the Encrypted File System (EFS). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00800000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports extended attributes. An extended attribute is a piece of
application-specific metadata that an application can associate with a file and is not part of the file's data.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_HARD_LINKS</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports hard links. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OBJECT_IDS</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports object identifiers.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b>
                </description>
              </item>
              <item>
                <description>0x01000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system supports open by FileID. For more information, see
<see cref="FILE_ID_BOTH_DIR_INFO" />.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_REPARSE_POINTS</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports reparse points.</para>
            <para>
              <b>ReFS:  </b>ReFS supports reparse points but does not index them so
<see cref="FindFirstVolumeMountPoint" /> and
<see cref="FindNextVolumeMountPoint" /> will not
function as expected.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_SPARSE_FILES</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sparse files.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_TRANSACTIONS</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports transactions. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_USN_JOURNAL</b>
                </description>
              </item>
              <item>
                <description>0x02000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports update sequence number (USN) journals. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNICODE_ON_DISK</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports Unicode in file names as they appear on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_IS_COMPRESSED</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a compressed volume, for example, a DoubleSpace volume.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_QUOTAS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports disk quotas.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b>
                </description>
              </item>
              <item>
                <description>0x08000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileSystemNameBuffer">
      <para>A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS
file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</para>
    </param>
    <param name="nFileSystemNameSize">
      <para>The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the file system name buffer is not supplied.</para>
    </param>
    <returns>
      <para>If all the requested information is retrieved, the return value is nonzero.</para>
      <para>If not all the requested information is retrieved, the return value is zero. To get extended error
information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a user attempts to get information about a floppy drive that does not have a floppy disk, or a CD-ROM
drive that does not have a compact disc, the system displays a message box for the user to insert a floppy disk
or a compact disc, respectively. To prevent the system from displaying this message box, call the
<see cref="SetErrorMode" /> function with
<b>SEM_FAILCRITICALERRORS</b>.</para>
      <para>The <b>FILE_VOL_IS_COMPRESSED</b> flag is the only indicator of volume-based compression. The
file system name is not altered to indicate compression, for example, this flag is returned set on a DoubleSpace
volume. When compression is volume-based, an entire volume is  compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> flag indicates whether a file system supports file-based
compression. When compression is file-based, individual files can be compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> flags are
mutually exclusive. Both bits cannot be returned set.</para>
      <para>The maximum component length value that is stored in <i>lpMaximumComponentLength</i> is the
only indicator that a volume supports longer-than-normal FAT file system (or other file system) file names. The
file system name is not altered to indicate support for long file names.</para>
      <para>The <see cref="GetCompressedFileSize" /> function obtains the
compressed size of a file. The <see cref="GetFileAttributes" /></para>
      <para>function can determine whether an individual file is compressed.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the function returns volume information for the target.</para>
      <para>Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h3>Transacted Operations</h3>
      <para>If the volume supports file system transactions, the function returns
<b>FILE_SUPPORTS_TRANSACTIONS</b> in <i>lpFileSystemFlags</i>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetVolumeInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso cref="GetCompressedFileSize" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetVolumeInformationByHandleW" />
    <seealso cref="SetErrorMode" />
    <seealso cref="SetVolumeLabel" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumeInformationW">
    <summary>
      <para>Retrieves information about the file system and volume associated with the specified root
directory.</para>
      <para>To specify a handle when retrieving this information, use the
<see cref="GetVolumeInformationByHandleW" /> function.</para>
      <para>To retrieve the current compression state of a file or directory, use
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the root directory of the volume to be described.</para>
      <para>If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing
backslash is required. For example, you  specify \MyServer\MyShare as
"\MyServer\MyShare", or the C drive as
"C:".</para>
    </param>
    <param name="lpVolumeNameBuffer">
      <para>A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the
<i>nVolumeNameSize</i> parameter.</para>
    </param>
    <param name="nVolumeNameSize">
      <para>The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the volume name buffer is not supplied.</para>
    </param>
    <param name="lpVolumeSerialNumber">
      <para>A pointer to a variable that receives the volume serial number.</para>
      <para>This parameter can be <b>NULL</b> if the serial number is not required.</para>
      <para>This function returns the volume serial number that the operating system assigns when a hard disk is
formatted.  To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the
Windows Management Instrumentation (WMI)
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a>  property
<b>SerialNumber</b>.</para>
    </param>
    <param name="lpMaximumComponentLength">
      <para>A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file
name component  that a specified file system supports.</para>
      <para>A file name component is the portion of a file name between backslashes.</para>
      <para>The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to
is used to indicate that a specified file system supports long names. For example, for a FAT file system that
supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can
also be supported on systems that use the NTFS file system.</para>
    </param>
    <param name="lpFileSystemFlags">
      <para>A pointer to a variable that receives flags associated with the specified file system.</para>
      <para>This parameter can be one or more of the following flags. However,
<b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually
exclusive.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_PRESERVED_NAMES</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports preserved case of file names when it places a name on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CASE_SENSITIVE_SEARCH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports case-sensitive file names.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_DAX_VOLUME        </b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a direct access (DAX) volume.</para>
            <para>
              <b>Note</b>  This flag was introduced in Windows 10, version 1607.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FILE_COMPRESSION</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports file-based compression.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_NAMED_STREAMS</b>
                </description>
              </item>
              <item>
                <description>0x00040000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports named streams.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_PERSISTENT_ACLS</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system
preserves and enforces ACLs, and the FAT file system does not.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY_VOLUME</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is read-only.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SEQUENTIAL_WRITE_ONCE</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports a single sequential write.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_ENCRYPTION</b>
                </description>
              </item>
              <item>
                <description>0x00020000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports the Encrypted File System (EFS). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b>
                </description>
              </item>
              <item>
                <description>0x00800000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports extended attributes. An extended attribute is a piece of
application-specific metadata that an application can associate with a file and is not part of the file's data.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_HARD_LINKS</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports hard links. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OBJECT_IDS</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports object identifiers.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b>
                </description>
              </item>
              <item>
                <description>0x01000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system supports open by FileID. For more information, see
<see cref="FILE_ID_BOTH_DIR_INFO" />.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_REPARSE_POINTS</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports reparse points.</para>
            <para>
              <b>ReFS:  </b>ReFS supports reparse points but does not index them so
<see cref="FindFirstVolumeMountPoint" /> and
<see cref="FindNextVolumeMountPoint" /> will not
function as expected.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_SPARSE_FILES</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sparse files.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_TRANSACTIONS</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports transactions. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_USN_JOURNAL</b>
                </description>
              </item>
              <item>
                <description>0x02000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports update sequence number (USN) journals. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNICODE_ON_DISK</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports Unicode in file names as they appear on disk.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_IS_COMPRESSED</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume is a compressed volume, for example, a DoubleSpace volume.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_VOLUME_QUOTAS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports disk quotas.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b>
                </description>
              </item>
              <item>
                <description>0x08000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpFileSystemNameBuffer">
      <para>A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS
file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.</para>
    </param>
    <param name="nFileSystemNameSize">
      <para>The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is
<b>MAX_PATH</b>+1.</para>
      <para>This parameter is ignored if the file system name buffer is not supplied.</para>
    </param>
    <returns>
      <para>If all the requested information is retrieved, the return value is nonzero.</para>
      <para>If not all the requested information is retrieved, the return value is zero. To get extended error
information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a user attempts to get information about a floppy drive that does not have a floppy disk, or a CD-ROM
drive that does not have a compact disc, the system displays a message box for the user to insert a floppy disk
or a compact disc, respectively. To prevent the system from displaying this message box, call the
<see cref="SetErrorMode" /> function with
<b>SEM_FAILCRITICALERRORS</b>.</para>
      <para>The <b>FILE_VOL_IS_COMPRESSED</b> flag is the only indicator of volume-based compression. The
file system name is not altered to indicate compression, for example, this flag is returned set on a DoubleSpace
volume. When compression is volume-based, an entire volume is  compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> flag indicates whether a file system supports file-based
compression. When compression is file-based, individual files can be compressed or not compressed.</para>
      <para>The <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> flags are
mutually exclusive. Both bits cannot be returned set.</para>
      <para>The maximum component length value that is stored in <i>lpMaximumComponentLength</i> is the
only indicator that a volume supports longer-than-normal FAT file system (or other file system) file names. The
file system name is not altered to indicate support for long file names.</para>
      <para>The <see cref="GetCompressedFileSize" /> function obtains the
compressed size of a file. The <see cref="GetFileAttributes" /></para>
      <para>function can determine whether an individual file is compressed.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the function returns volume information for the target.</para>
      <para>Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h3>Transacted Operations</h3>
      <para>If the volume supports file system transactions, the function returns
<b>FILE_SUPPORTS_TRANSACTIONS</b> in <i>lpFileSystemFlags</i>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines GetVolumeInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Ktm/about-ktm">About KTM</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso cref="GetCompressedFileSize" />
    <seealso cref="GetFileAttributes" />
    <seealso cref="GetVolumeInformationByHandleW" />
    <seealso cref="SetErrorMode" />
    <seealso cref="SetVolumeLabel" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPoint">
    <summary>
      <para>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point (
drive letter, volume <b>GUID</b> path, or mounted folder).</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\") or a drive letter (for example, "X:\"). The string must end with a trailing backslash ('\').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Use
<b>GetVolumeNameForVolumeMountPoint</b> to obtain a volume <b>GUID</b> path for use with functions such as <see cref="SetVolumeMountPoint" /> and <see cref="FindFirstVolumeMountPoint" /> that require a volume <b>GUID</b> path as an input parameter. For more information about volume <b>GUID</b> paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming A Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <para>Mount points aren't supported by ReFS volumes.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPointA">
    <summary>
      <para>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point (
drive letter, volume <b>GUID</b> path, or mounted folder).</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\") or a drive letter (for example, "X:\"). The string must end with a trailing backslash ('\').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Use
<b>GetVolumeNameForVolumeMountPoint</b> to obtain a volume <b>GUID</b> path for use with functions such as <see cref="SetVolumeMountPoint" /> and <see cref="FindFirstVolumeMountPoint" /> that require a volume <b>GUID</b> path as an input parameter. For more information about volume <b>GUID</b> paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming A Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <para>Mount points aren't supported by ReFS volumes.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPointW">
    <summary>
      <para>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point (
drive letter, volume <b>GUID</b> path, or mounted folder).</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\") or a drive letter (for example, "X:\"). The string must end with a trailing backslash ('\').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Use
<b>GetVolumeNameForVolumeMountPoint</b> to obtain a volume <b>GUID</b> path for use with functions such as <see cref="SetVolumeMountPoint" /> and <see cref="FindFirstVolumeMountPoint" /> that require a volume <b>GUID</b> path as an input parameter. For more information about volume <b>GUID</b> paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming A Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <para>Mount points aren't supported by ReFS volumes.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeName">
    <summary>
      <para>Retrieves a list of drive letters and mounted folder paths for the specified volume.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. A volume <b>GUID</b></para>
      <para>path is of the form
"\\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\".</para>
    </param>
    <param name="lpszVolumePathNames">
      <para>A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an
array of null-terminated strings terminated by an additional <b>NULL</b> character. If the
buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the <i>lpszVolumePathNames</i> buffer, in
<b>TCHARs</b>, including all <b>NULL</b> characters.</para>
    </param>
    <param name="lpcchReturnLength">
      <para>If the call is successful, this parameter is the number of <b>TCHARs</b> copied to
the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer
required to hold the complete list, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If the buffer is not large enough to
hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the
<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeNameA">
    <summary>
      <para>Retrieves a list of drive letters and mounted folder paths for the specified volume.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. A volume <b>GUID</b></para>
      <para>path is of the form
"\\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\".</para>
    </param>
    <param name="lpszVolumePathNames">
      <para>A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an
array of null-terminated strings terminated by an additional <b>NULL</b> character. If the
buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the <i>lpszVolumePathNames</i> buffer, in
<b>TCHARs</b>, including all <b>NULL</b> characters.</para>
    </param>
    <param name="lpcchReturnLength">
      <para>If the call is successful, this parameter is the number of <b>TCHARs</b> copied to
the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer
required to hold the complete list, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If the buffer is not large enough to
hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the
<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeNameW">
    <summary>
      <para>Retrieves a list of drive letters and mounted folder paths for the specified volume.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. A volume <b>GUID</b></para>
      <para>path is of the form
"\\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\".</para>
    </param>
    <param name="lpszVolumePathNames">
      <para>A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an
array of null-terminated strings terminated by an additional <b>NULL</b> character. If the
buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the <i>lpszVolumePathNames</i> buffer, in
<b>TCHARs</b>, including all <b>NULL</b> characters.</para>
    </param>
    <param name="lpcchReturnLength">
      <para>If the call is successful, this parameter is the number of <b>TCHARs</b> copied to
the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer
required to hold the complete list, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If the buffer is not large enough to
hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the
<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumePathName">
    <summary>
      <para>Retrieves the volume mount point where the specified path is mounted.</para>
    </summary>
    <param name="lpszFileName">
      <para>A pointer to the input path string. Both absolute and relative file and directory names, for example, "..", are acceptable in this path.</para>
      <para>If you specify a relative directory or file name without a volume qualifier, <b>GetVolumePathName</b> returns the drive letter of the boot volume.</para>
      <para>If this parameter is an empty string, "", the function fails but the last error is set to <b>ERROR_SUCCESS</b>.</para>
    </param>
    <param name="lpszVolumePathName">
      <para>A pointer to a string that receives the volume mount point for the input path.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the output buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a specified path is passed, <b>GetVolumePathName</b> returns the path to the volume mount point, which means that it returns the root of the volume where the end point of the specified path is located.</para>
      <para>For example, assume that you have volume D mounted at <code>C:\Mnt\Ddrive</code> and volume E mounted at <code>C:\Mnt\Ddrive\Mnt\Edrive</code>. Also assume that you have a file with the path <code>E:\Dir\Subdir\MyFile</code>. If you pass <code>C:\Mnt\Ddrive\Mnt\Edrive\Dir\Subdir\MyFile</code> to <b>GetVolumePathName</b>, it returns the path <code>C:\Mnt\Ddrive\Mnt\Edrive\</code>.</para>
      <para>If either a relative directory or a file is passed without a volume qualifier, the function returns the drive letter of the boot volume. The drive letter of the boot volume is also returned if an invalid file or directory name is specified without a valid volume qualifier. If a valid volume specifier is given, and the volume exists, but an invalid file or directory name is specified, the function will succeed and that volume name will be returned. For examples, see the Examples section of this topic.</para>
      <para>You must specify a valid Win32 namespace path. If you specify an NT namespace path, for example, <code>\DosDevices\H:</code> or <code>\Device\HardDiskVolume6</code>, the function returns the drive letter of the boot volume, not the drive letter of that NT namespace path.</para>
      <para>For more information about path names and namespaces, see <a href="https://docs.microsoft.com//windows/win32/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>You can specify both local and remote paths. If you specify a local path, <b>GetVolumePathName</b> returns a full path whose prefix is the longest prefix that represents a volume.</para>
      <para>If a network share is specified, <b>GetVolumePathName</b> returns the shortest path for which <see cref="GetDriveType" /> returns <b>DRIVE_REMOTE</b>, which means that the path is validated as a remote drive that exists, which the current user can access.</para>
      <para>There are certain special cases that do not return a trailing backslash. These occur when the output buffer length is one character too short. For example, if <i>lpszFileName</i> is <code>C:</code> and <i>lpszVolumePathName</i> is 4 characters long, the value returned is <code>C:\</code>; however, if <i>lpszVolumePathName</i> is 3 characters long, the value returned is <code>C:</code>. A safer but slower way to set the size of the return buffer is to call the <see cref="GetFullPathName" /> function, and then make sure that the buffer size is at least the same size as the full path that <b>GetFullPathName</b> returns. If the output buffer is more than one character too short, the function will fail and return an error.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <para>Technology | Supported
-----------|----------
Server Message Block (SMB) 3.0 protocol|No
SMB 3.0 Transparent Failover (TFO)|No
SMB 3.0 with Scale-out File Shares (SO)|No
Cluster Shared Volume File System (CsvFS)|Yes
Resilient File System (ReFS)|Yes</para>
      <para>SMB does not support volume management functions.</para>
      <h3>Trailing Path Elements</h3>
      <para>Trailing path elements that are invalid are ignored. For remote paths, the entire path (not just trailing elements) is considered invalid if one of the following conditions is true:</para>
      <list type="bullet">
        <item>
          <description>The path is not formed correctly.</description>
        </item>
        <item>
          <description>The path does not exist.</description>
        </item>
        <item>
          <description>The current user does not have access to the path.</description>
        </item>
      </list>
      <h3>Junction Points and Mounted Folders</h3>
      <para>If the specified path traverses a junction point, <b>GetVolumePathName</b> returns the volume to which the   junction point refers. For example, if <code>W:\Adir</code> is a junction point that points to <code>C:\Adir</code>, then <b>GetVolumePathName</b> invoked on <code>W:\Adir\Afile</code> returns <code>C:\</code>. If the specified path traverses multiple junction points, the entire chain is followed, and <b>GetVolumePathName</b> returns the volume to which the   last junction point in the chain refers.</para>
      <para>If a remote path to a mounted folder or junction point is specified, the path is parsed as a remote path, and   the mounted folder or junction point are ignored. For example if <code>C:\Dir_C</code> is linked to <code>D:\Dir_D</code> and <code>C:</code> is mapped to <code>X:</code> on a remote computer, calling  <b>GetVolumePathName</b> and specifying <code>X:\Dir_C</code> on the remote computer returns <code>X:\</code>.</para>
      <h4>Examples</h4>
      <para>For the following set of examples, U: is mapped to the remote computer  <code>\\_YourComputer_\C$</code>, and Q is a local drive.</para>
      <para>Specified path                     | Function returns
-----------------------------------|-----------------
<code>\\_YourComputer_\C$\Windows</code>      | <code>\\_YourComputer_\C$\</code><code>\\?\UNC\_YourComputer_\C$\Windows</code>| <code>\\?\UNC\_YourComputer_\C$\</code><code>Q:\Windows</code>                       | <code>Q:\</code><code>\\?\Q:\Windows</code>                   | <code>\\?\Q:\</code><code>\\.\Q:\Windows</code>                   | <code>\\.\Q:\</code><code>\\?\UNC\W:\Windows</code>               | <b>FALSE</b> with error 123 because a specified remote path was not valid; W$ share does not exist or no user access granted.
<code>C:\COM2</code> (which exists)           | <code>\\.\COM2\</code><code>C:\COM3</code> (non-existent)           | <b>FALSE</b> with error 123 because a non-existent COM device was specified.</para>
      <para>For the following set of examples, the paths contain invalid trailing path elements.</para>
      <para>Specified path                                                | Function returns
--------------------------------------------------------------|-----------------
<code>G:\invalid</code> (invalid path)                                   | <code>G:\</code><code>\\.\I:\aaa\invalid</code> (invalid path)                           | <code>\\.\I:\</code><code>\\_YourComputer_\C$\invalid</code> (invalid trailing path element) | <code>\\_YourComputer_\C$\</code></para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/win32/FileIO/volume-management-functions">Volume Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/FileIO/volume-mount-points">Volume Mount Points</seealso>
  </member>
  <member name="Windows.GetVolumePathNameA">
    <summary>
      <para>Retrieves the volume mount point where the specified path is mounted.</para>
    </summary>
    <param name="lpszFileName">
      <para>A pointer to the input path string. Both absolute and relative file and directory names, for example, "..", are acceptable in this path.</para>
      <para>If you specify a relative directory or file name without a volume qualifier, <b>GetVolumePathName</b> returns the drive letter of the boot volume.</para>
      <para>If this parameter is an empty string, "", the function fails but the last error is set to <b>ERROR_SUCCESS</b>.</para>
    </param>
    <param name="lpszVolumePathName">
      <para>A pointer to a string that receives the volume mount point for the input path.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the output buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a specified path is passed, <b>GetVolumePathName</b> returns the path to the volume mount point, which means that it returns the root of the volume where the end point of the specified path is located.</para>
      <para>For example, assume that you have volume D mounted at <code>C:\Mnt\Ddrive</code> and volume E mounted at <code>C:\Mnt\Ddrive\Mnt\Edrive</code>. Also assume that you have a file with the path <code>E:\Dir\Subdir\MyFile</code>. If you pass <code>C:\Mnt\Ddrive\Mnt\Edrive\Dir\Subdir\MyFile</code> to <b>GetVolumePathName</b>, it returns the path <code>C:\Mnt\Ddrive\Mnt\Edrive\</code>.</para>
      <para>If either a relative directory or a file is passed without a volume qualifier, the function returns the drive letter of the boot volume. The drive letter of the boot volume is also returned if an invalid file or directory name is specified without a valid volume qualifier. If a valid volume specifier is given, and the volume exists, but an invalid file or directory name is specified, the function will succeed and that volume name will be returned. For examples, see the Examples section of this topic.</para>
      <para>You must specify a valid Win32 namespace path. If you specify an NT namespace path, for example, <code>\DosDevices\H:</code> or <code>\Device\HardDiskVolume6</code>, the function returns the drive letter of the boot volume, not the drive letter of that NT namespace path.</para>
      <para>For more information about path names and namespaces, see <a href="https://docs.microsoft.com//windows/win32/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>You can specify both local and remote paths. If you specify a local path, <b>GetVolumePathName</b> returns a full path whose prefix is the longest prefix that represents a volume.</para>
      <para>If a network share is specified, <b>GetVolumePathName</b> returns the shortest path for which <see cref="GetDriveType" /> returns <b>DRIVE_REMOTE</b>, which means that the path is validated as a remote drive that exists, which the current user can access.</para>
      <para>There are certain special cases that do not return a trailing backslash. These occur when the output buffer length is one character too short. For example, if <i>lpszFileName</i> is <code>C:</code> and <i>lpszVolumePathName</i> is 4 characters long, the value returned is <code>C:\</code>; however, if <i>lpszVolumePathName</i> is 3 characters long, the value returned is <code>C:</code>. A safer but slower way to set the size of the return buffer is to call the <see cref="GetFullPathName" /> function, and then make sure that the buffer size is at least the same size as the full path that <b>GetFullPathName</b> returns. If the output buffer is more than one character too short, the function will fail and return an error.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <para>Technology | Supported
-----------|----------
Server Message Block (SMB) 3.0 protocol|No
SMB 3.0 Transparent Failover (TFO)|No
SMB 3.0 with Scale-out File Shares (SO)|No
Cluster Shared Volume File System (CsvFS)|Yes
Resilient File System (ReFS)|Yes</para>
      <para>SMB does not support volume management functions.</para>
      <h3>Trailing Path Elements</h3>
      <para>Trailing path elements that are invalid are ignored. For remote paths, the entire path (not just trailing elements) is considered invalid if one of the following conditions is true:</para>
      <list type="bullet">
        <item>
          <description>The path is not formed correctly.</description>
        </item>
        <item>
          <description>The path does not exist.</description>
        </item>
        <item>
          <description>The current user does not have access to the path.</description>
        </item>
      </list>
      <h3>Junction Points and Mounted Folders</h3>
      <para>If the specified path traverses a junction point, <b>GetVolumePathName</b> returns the volume to which the   junction point refers. For example, if <code>W:\Adir</code> is a junction point that points to <code>C:\Adir</code>, then <b>GetVolumePathName</b> invoked on <code>W:\Adir\Afile</code> returns <code>C:\</code>. If the specified path traverses multiple junction points, the entire chain is followed, and <b>GetVolumePathName</b> returns the volume to which the   last junction point in the chain refers.</para>
      <para>If a remote path to a mounted folder or junction point is specified, the path is parsed as a remote path, and   the mounted folder or junction point are ignored. For example if <code>C:\Dir_C</code> is linked to <code>D:\Dir_D</code> and <code>C:</code> is mapped to <code>X:</code> on a remote computer, calling  <b>GetVolumePathName</b> and specifying <code>X:\Dir_C</code> on the remote computer returns <code>X:\</code>.</para>
      <h4>Examples</h4>
      <para>For the following set of examples, U: is mapped to the remote computer  <code>\\_YourComputer_\C$</code>, and Q is a local drive.</para>
      <para>Specified path                     | Function returns
-----------------------------------|-----------------
<code>\\_YourComputer_\C$\Windows</code>      | <code>\\_YourComputer_\C$\</code><code>\\?\UNC\_YourComputer_\C$\Windows</code>| <code>\\?\UNC\_YourComputer_\C$\</code><code>Q:\Windows</code>                       | <code>Q:\</code><code>\\?\Q:\Windows</code>                   | <code>\\?\Q:\</code><code>\\.\Q:\Windows</code>                   | <code>\\.\Q:\</code><code>\\?\UNC\W:\Windows</code>               | <b>FALSE</b> with error 123 because a specified remote path was not valid; W$ share does not exist or no user access granted.
<code>C:\COM2</code> (which exists)           | <code>\\.\COM2\</code><code>C:\COM3</code> (non-existent)           | <b>FALSE</b> with error 123 because a non-existent COM device was specified.</para>
      <para>For the following set of examples, the paths contain invalid trailing path elements.</para>
      <para>Specified path                                                | Function returns
--------------------------------------------------------------|-----------------
<code>G:\invalid</code> (invalid path)                                   | <code>G:\</code><code>\\.\I:\aaa\invalid</code> (invalid path)                           | <code>\\.\I:\</code><code>\\_YourComputer_\C$\invalid</code> (invalid trailing path element) | <code>\\_YourComputer_\C$\</code></para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/win32/FileIO/volume-management-functions">Volume Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/FileIO/volume-mount-points">Volume Mount Points</seealso>
  </member>
  <member name="Windows.GetVolumePathNameW">
    <summary>
      <para>Retrieves the volume mount point where the specified path is mounted.</para>
    </summary>
    <param name="lpszFileName">
      <para>A pointer to the input path string. Both absolute and relative file and directory names, for example, "..", are acceptable in this path.</para>
      <para>If you specify a relative directory or file name without a volume qualifier, <b>GetVolumePathName</b> returns the drive letter of the boot volume.</para>
      <para>If this parameter is an empty string, "", the function fails but the last error is set to <b>ERROR_SUCCESS</b>.</para>
    </param>
    <param name="lpszVolumePathName">
      <para>A pointer to a string that receives the volume mount point for the input path.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the output buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a specified path is passed, <b>GetVolumePathName</b> returns the path to the volume mount point, which means that it returns the root of the volume where the end point of the specified path is located.</para>
      <para>For example, assume that you have volume D mounted at <code>C:\Mnt\Ddrive</code> and volume E mounted at <code>C:\Mnt\Ddrive\Mnt\Edrive</code>. Also assume that you have a file with the path <code>E:\Dir\Subdir\MyFile</code>. If you pass <code>C:\Mnt\Ddrive\Mnt\Edrive\Dir\Subdir\MyFile</code> to <b>GetVolumePathName</b>, it returns the path <code>C:\Mnt\Ddrive\Mnt\Edrive\</code>.</para>
      <para>If either a relative directory or a file is passed without a volume qualifier, the function returns the drive letter of the boot volume. The drive letter of the boot volume is also returned if an invalid file or directory name is specified without a valid volume qualifier. If a valid volume specifier is given, and the volume exists, but an invalid file or directory name is specified, the function will succeed and that volume name will be returned. For examples, see the Examples section of this topic.</para>
      <para>You must specify a valid Win32 namespace path. If you specify an NT namespace path, for example, <code>\DosDevices\H:</code> or <code>\Device\HardDiskVolume6</code>, the function returns the drive letter of the boot volume, not the drive letter of that NT namespace path.</para>
      <para>For more information about path names and namespaces, see <a href="https://docs.microsoft.com//windows/win32/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>You can specify both local and remote paths. If you specify a local path, <b>GetVolumePathName</b> returns a full path whose prefix is the longest prefix that represents a volume.</para>
      <para>If a network share is specified, <b>GetVolumePathName</b> returns the shortest path for which <see cref="GetDriveType" /> returns <b>DRIVE_REMOTE</b>, which means that the path is validated as a remote drive that exists, which the current user can access.</para>
      <para>There are certain special cases that do not return a trailing backslash. These occur when the output buffer length is one character too short. For example, if <i>lpszFileName</i> is <code>C:</code> and <i>lpszVolumePathName</i> is 4 characters long, the value returned is <code>C:\</code>; however, if <i>lpszVolumePathName</i> is 3 characters long, the value returned is <code>C:</code>. A safer but slower way to set the size of the return buffer is to call the <see cref="GetFullPathName" /> function, and then make sure that the buffer size is at least the same size as the full path that <b>GetFullPathName</b> returns. If the output buffer is more than one character too short, the function will fail and return an error.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <para>Technology | Supported
-----------|----------
Server Message Block (SMB) 3.0 protocol|No
SMB 3.0 Transparent Failover (TFO)|No
SMB 3.0 with Scale-out File Shares (SO)|No
Cluster Shared Volume File System (CsvFS)|Yes
Resilient File System (ReFS)|Yes</para>
      <para>SMB does not support volume management functions.</para>
      <h3>Trailing Path Elements</h3>
      <para>Trailing path elements that are invalid are ignored. For remote paths, the entire path (not just trailing elements) is considered invalid if one of the following conditions is true:</para>
      <list type="bullet">
        <item>
          <description>The path is not formed correctly.</description>
        </item>
        <item>
          <description>The path does not exist.</description>
        </item>
        <item>
          <description>The current user does not have access to the path.</description>
        </item>
      </list>
      <h3>Junction Points and Mounted Folders</h3>
      <para>If the specified path traverses a junction point, <b>GetVolumePathName</b> returns the volume to which the   junction point refers. For example, if <code>W:\Adir</code> is a junction point that points to <code>C:\Adir</code>, then <b>GetVolumePathName</b> invoked on <code>W:\Adir\Afile</code> returns <code>C:\</code>. If the specified path traverses multiple junction points, the entire chain is followed, and <b>GetVolumePathName</b> returns the volume to which the   last junction point in the chain refers.</para>
      <para>If a remote path to a mounted folder or junction point is specified, the path is parsed as a remote path, and   the mounted folder or junction point are ignored. For example if <code>C:\Dir_C</code> is linked to <code>D:\Dir_D</code> and <code>C:</code> is mapped to <code>X:</code> on a remote computer, calling  <b>GetVolumePathName</b> and specifying <code>X:\Dir_C</code> on the remote computer returns <code>X:\</code>.</para>
      <h4>Examples</h4>
      <para>For the following set of examples, U: is mapped to the remote computer  <code>\\_YourComputer_\C$</code>, and Q is a local drive.</para>
      <para>Specified path                     | Function returns
-----------------------------------|-----------------
<code>\\_YourComputer_\C$\Windows</code>      | <code>\\_YourComputer_\C$\</code><code>\\?\UNC\_YourComputer_\C$\Windows</code>| <code>\\?\UNC\_YourComputer_\C$\</code><code>Q:\Windows</code>                       | <code>Q:\</code><code>\\?\Q:\Windows</code>                   | <code>\\?\Q:\</code><code>\\.\Q:\Windows</code>                   | <code>\\.\Q:\</code><code>\\?\UNC\W:\Windows</code>               | <b>FALSE</b> with error 123 because a specified remote path was not valid; W$ share does not exist or no user access granted.
<code>C:\COM2</code> (which exists)           | <code>\\.\COM2\</code><code>C:\COM3</code> (non-existent)           | <b>FALSE</b> with error 123 because a non-existent COM device was specified.</para>
      <para>For the following set of examples, the paths contain invalid trailing path elements.</para>
      <para>Specified path                                                | Function returns
--------------------------------------------------------------|-----------------
<code>G:\invalid</code> (invalid path)                                   | <code>G:\</code><code>\\.\I:\aaa\invalid</code> (invalid path)                           | <code>\\.\I:\</code><code>\\_YourComputer_\C$\invalid</code> (invalid trailing path element) | <code>\\_YourComputer_\C$\</code></para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/win32/FileIO/volume-management-functions">Volume Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/FileIO/volume-mount-points">Volume Mount Points</seealso>
  </member>
  <member name="Windows.LocalFileTimeToFileTime">
    <summary>
      <para>Converts a local file time to a file time based on the Coordinated Universal Time (UTC).</para>
    </summary>
    <param name="lpLocalFileTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that specifies the
local file time to be converted into a UTC-based file time.</para>
    </param>
    <param name="lpFileTime">
      <para>A pointer to a <see cref="FILETIME" /> structure to receive the
converted UTC-based file time. This parameter cannot be the same as the
<i>lpLocalFileTime</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>
        <b>LocalFileTimeToFileTime</b> uses the current
settings for the time zone and daylight saving time. Therefore, if it is daylight saving time, this function will
take daylight saving time into account, even if the time you are converting is in standard time.</para>
    </remarks>
    <seealso cref="FILETIME" />
    <seealso cref="FileTimeToLocalFileTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/local-time">Local Time</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.LockFile">
    <summary>
      <para>Locks the specified file  for exclusive access  by the calling process.</para>
      <para>To specify additional options, for example creating a shared lock or for block-on-fail operation, use the
<see cref="LockFileEx" /> function.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The file handle must have been created with the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwFileOffsetLow">
      <para>The low-order 32 bits of the starting byte offset in the file where the lock should begin.</para>
    </param>
    <param name="dwFileOffsetHigh">
      <para>The high-order 32 bits of the starting byte offset in the file where the lock should begin.</para>
    </param>
    <param name="nNumberOfBytesToLockLow">
      <para>The low-order 32 bits of the length of the byte range to be locked.</para>
    </param>
    <param name="nNumberOfBytesToLockHigh">
      <para>The high-order 32 bits of the length of the byte range to be locked.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero (<b>TRUE</b>).</para>
      <para>If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the call to <b>LockFile</b> completes synchronously, a completion entry may not be queued when a completion port is associated with the file handle.</para>
      <para>The
<see cref="UnlockFile" /> function unlocks a file region locked by
<b>LockFile</b>.</para>
      <para>Locking a region of a file gives the threads of the locking process exclusive access to the specified region using this file handle. If the file handle is  inherited by a process created by the locking process, the child process is not granted access to the locked region. If the locking process opens the file a second time, it cannot access the specified region through this second handle until it unlocks the region.</para>
      <para>Locking a region of a file does not prevent reading or writing from a mapped file view.</para>
      <para>You can lock bytes that are beyond the end of the current  file. This is useful to coordinate adding records to the end of a file.</para>
      <para>Exclusive locks cannot overlap an existing locked region of a file. For more information, see <see cref="LockFileEx" />.</para>
      <para>If
<b>LockFile</b> cannot lock a region of a file, it returns zero immediately. It does not block. To issue a file lock request that will block until the lock is acquired, use
<see cref="LockFileEx" /> without the <b>LOCKFILE_FAIL_IMMEDIATELY</b> flag.</para>
      <para>If a process terminates with a portion of a file locked or closes a file that has outstanding locks, the locks are unlocked by the operating system. However, the time it takes for the operating system to unlock these locks depends upon available system resources. Therefore, it is recommended that your process explicitly unlock all files it has locked when it terminates. If this is not done, access to these files may be denied if the operating system has not yet unlocked them.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/appending-one-file-to-another-file">Appending One File to Another File</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="LockFileEx" />
    <seealso cref="UnlockFile" />
  </member>
  <member name="Windows.LockFileEx">
    <summary>
      <para>Locks the specified file  for exclusive access  by the calling process. This function can operate either synchronously or asynchronously and can request either an exclusive or a shared lock.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The handle must have been created with either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter may be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOCKFILE_EXCLUSIVE_LOCK</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function requests an exclusive lock. Otherwise, it requests a shared lock.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOCKFILE_FAIL_IMMEDIATELY</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function returns immediately if it is unable to acquire the requested lock. Otherwise, it waits.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwReserved">
      <para>Reserved parameter; must be set to zero.</para>
    </param>
    <param name="nNumberOfBytesToLockLow">
      <para>The low-order 32 bits of the length of the byte range to lock.</para>
    </param>
    <param name="nNumberOfBytesToLockHigh">
      <para>The high-order 32 bits of the length of the byte range to lock.</para>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an
<see cref="OVERLAPPED" /> structure that the function uses with the locking request. This structure, which is required, contains the file offset of the beginning of the lock range. You must initialize the <b>hEvent</b> member to a valid handle or zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero (<b>TRUE</b>).</para>
      <para>If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Locking a region of a file is used to acquire shared or exclusive access to the specified region using this file handle. If the file handle is  inherited by a process created by the locking process, the child process is not granted access to the locked region. If the locking process opens the file a second time, it cannot access the specified region through this second handle until it unlocks the region.</para>
      <para>Locking a portion of a file for exclusive access denies all other processes both read and write access to the specified region of the file. Locking a region that goes beyond the current end-of-file position is not an error.</para>
      <para>Locking a portion of a file for shared access denies all processes write access to the specified region of the file, including the process that first locks the region. All processes can read the locked region.</para>
      <para>Locking a region of a file does not prevent reading or writing from a mapped file view.</para>
      <para>The
<b>LockFileEx</b> function operates asynchronously if the file handle was opened for asynchronous I/O, unless the <b>LOCKFILE_FAIL_IMMEDIATELY</b> flag is specified. If an exclusive lock is requested for a range of a file that already has a shared or exclusive lock, the function returns the error <b>ERROR_IO_PENDING</b>. The system will signal the event specified in the
<see cref="OVERLAPPED" /> structure after the lock is granted. To determine when the lock has been granted, use the
<see cref="GetOverlappedResult" /> function or one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.</para>
      <para>If the file handle was not opened for asynchronous I/O and the lock is not available, this call waits until the lock is granted or an error occurs, unless the <b>LOCKFILE_FAIL_IMMEDIATELY</b> flag is specified.</para>
      <para>Exclusive locks cannot overlap an existing locked region of a file. Shared locks can overlap a locked region provided locks held on that region are shared locks. A shared lock can overlap an exclusive lock if both locks were created using the same file handle. When a shared lock overlaps an exclusive lock, the only possible access is a read by the owner of the locks.
If the same range is locked with an exclusive and a shared lock, two unlock operations are necessary to unlock the region; the first unlock operation unlocks the exclusive lock, the second unlock operation unlocks the shared lock.</para>
      <para>If a process terminates with a portion of a file locked or closes a file that has outstanding locks, the locks are unlocked by the operating system. However, the time it takes for the operating system to unlock these locks depends upon available system resources. Therefore, it is recommended that your process explicitly unlock all files it has locked when it terminates. If this is not done, access to these files may be denied if the operating system has not yet unlocked them.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="LockFile" />
    <seealso cref="OVERLAPPED" />
    <seealso cref="UnlockFile" />
    <seealso cref="UnlockFileEx" />
  </member>
  <member name="Windows.QueryDosDevice">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current
mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device
names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into
a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>QueryDosDevice</b> function enables an application to query
the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific
junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing
backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the
<b>QueryDosDevice</b> function will store a list of all
existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or
more null-terminated strings. The final null-terminated string is followed by an additional
<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves
information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first
null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated
strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of
all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing
MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by
<i>lpTargetPath</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into
the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is
<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
    <remarks>
      <para>The <see cref="DefineDosDevice" /> function enables an application
to create and modify the junctions used to implement the MS-DOS device namespace.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>
        <b>QueryDosDevice</b> first searches the Local MS-DOS
Device namespace for the specified device name. If the device name is not found, the function will then search
the Global MS-DOS Device namespace.</para>
      <para>When all existing MS-DOS device names are queried, the list of device names that are returned is dependent on
whether it is running in the "LocalSystem" context. If so, only the device names included in the Global MS-DOS
Device namespace will be returned. If not, a concatenation of the device names in the Global and Local MS-DOS
Device namespaces will be returned. If a device name exists in both namespaces,
<b>QueryDosDevice</b> will return the entry in the Local MS-DOS
Device namespace.</para>
      <para>For more information on the Global and Local MS-DOS Device namespaces and changes to the accessibility of
MS-DOS device names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a></para>
      <para>or <a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="DefineDosDevice" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.QueryDosDeviceA">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current
mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device
names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into
a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>QueryDosDevice</b> function enables an application to query
the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific
junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing
backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the
<b>QueryDosDevice</b> function will store a list of all
existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or
more null-terminated strings. The final null-terminated string is followed by an additional
<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves
information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first
null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated
strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of
all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing
MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by
<i>lpTargetPath</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into
the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is
<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
    <remarks>
      <para>The <see cref="DefineDosDevice" /> function enables an application
to create and modify the junctions used to implement the MS-DOS device namespace.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>
        <b>QueryDosDevice</b> first searches the Local MS-DOS
Device namespace for the specified device name. If the device name is not found, the function will then search
the Global MS-DOS Device namespace.</para>
      <para>When all existing MS-DOS device names are queried, the list of device names that are returned is dependent on
whether it is running in the "LocalSystem" context. If so, only the device names included in the Global MS-DOS
Device namespace will be returned. If not, a concatenation of the device names in the Global and Local MS-DOS
Device namespaces will be returned. If a device name exists in both namespaces,
<b>QueryDosDevice</b> will return the entry in the Local MS-DOS
Device namespace.</para>
      <para>For more information on the Global and Local MS-DOS Device namespaces and changes to the accessibility of
MS-DOS device names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a></para>
      <para>or <a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="DefineDosDevice" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.QueryDosDeviceW">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current
mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device
names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into
a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>QueryDosDevice</b> function enables an application to query
the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific
junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing
backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the
<b>QueryDosDevice</b> function will store a list of all
existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or
more null-terminated strings. The final null-terminated string is followed by an additional
<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves
information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first
null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated
strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of
all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing
MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by
<i>lpTargetPath</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into
the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is
<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
    <remarks>
      <para>The <see cref="DefineDosDevice" /> function enables an application
to create and modify the junctions used to implement the MS-DOS device namespace.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>
        <b>QueryDosDevice</b> first searches the Local MS-DOS
Device namespace for the specified device name. If the device name is not found, the function will then search
the Global MS-DOS Device namespace.</para>
      <para>When all existing MS-DOS device names are queried, the list of device names that are returned is dependent on
whether it is running in the "LocalSystem" context. If so, only the device names included in the Global MS-DOS
Device namespace will be returned. If not, a concatenation of the device names in the Global and Local MS-DOS
Device namespaces will be returned. If a device name exists in both namespaces,
<b>QueryDosDevice</b> will return the entry in the Local MS-DOS
Device namespace.</para>
      <para>For more information on the Global and Local MS-DOS Device namespaces and changes to the accessibility of
MS-DOS device names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a></para>
      <para>or <a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="DefineDosDevice" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.ReadFileEx">
    <summary>
      <para>Reads data from the specified file or input/output (I/O) device. It reports its completion status
asynchronously, calling the specified completion routine when reading is completed or canceled and the calling
thread is in an alertable wait state.</para>
      <para>To read data from a file or device synchronously, use the
<see cref="ReadFile" /> function.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer,
tape drive, socket, communications resource, mailslot, or pipe).</para>
      <para>This parameter can be any handle opened with the <b>FILE_FLAG_OVERLAPPED</b> flag by the
<see cref="CreateFile" /> function, or a socket handle returned by the
<see cref="socket" /> or
<see cref="accept" /> function.</para>
      <para>This handle also must have the <b>GENERIC_READ</b> access right. For more information on
access rights, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the data read from the file or device.</para>
      <para>This buffer must remain valid for the duration of the read operation. The application should not use this
buffer until the read operation is completed.</para>
    </param>
    <param name="nNumberOfBytesToRead">
      <para>The number of bytes to be read.</para>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> data structure that
supplies data to be used during the asynchronous (overlapped) file read operation.</para>
      <para>For files that support byte offsets, you must specify a byte offset at which to start reading from the file.
You specify this offset by setting the <b>Offset</b> and
<b>OffsetHigh</b> members of the
<see cref="OVERLAPPED" /> structure. For files or devices that do not
support byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are
ignored.</para>
      <para>The <b>ReadFileEx</b> function ignores the
<see cref="OVERLAPPED" /> structure's
<b>hEvent</b> member. An application is free to use that member for its own purposes in the
context of a <b>ReadFileEx</b> call.
<b>ReadFileEx</b> signals completion of its read operation by
calling, or queuing a call to, the completion routine pointed to by
<i>lpCompletionRoutine</i>, so it does not need an event handle.</para>
      <para>The <b>ReadFileEx</b> function does use the
<see cref="OVERLAPPED" /> structure's
<b>Internal</b> and <b>InternalHigh</b> members. An application should
not set these members.</para>
      <para>The <see cref="OVERLAPPED" /> data structure must remain valid for
the duration of the read operation. It should not be a variable that can go out of scope while the read
operation is pending completion.</para>
    </param>
    <param name="lpCompletionRoutine">
      <para>A pointer to the completion routine to be called when the read operation is complete and the calling thread
is in an alertable wait state. For more information about the completion routine, see
<a href="https://docs.microsoft.com//windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the function succeeds, the calling thread has an asynchronous I/O operation pending: the overlapped read
operation from the file. When this I/O operation completes, and the calling thread is blocked in an alertable
wait state, the system calls the function pointed to by <i>lpCompletionRoutine</i>, and the
wait state completes with a return code of <b>WAIT_IO_COMPLETION</b>.</para>
      <para>If the function succeeds, and the file reading operation completes, but the calling thread is not in an
alertable wait state, the system queues the completion routine call, holding the call until the calling thread
enters an alertable wait state. For information about alertable waits and overlapped input/output operations,
see <a href="https://docs.microsoft.com//windows/desktop/Sync/about-synchronization">About Synchronization</a>.</para>
      <para>If <b>ReadFileEx</b> attempts to read past the
end-of-file (EOF), the call to
<see cref="GetOverlappedResult" /> for that operation returns
<b>FALSE</b> and <see cref="GetLastError" /></para>
      <para>returns <b>ERROR_HANDLE_EOF</b>.</para>
    </returns>
    <remarks>
      <para>When using <b>ReadFileEx</b> you should check
<see cref="GetLastError" /> even when the function returns "success" to
check for conditions that are "successes" but have some outcome you might want to know about. For example, a
buffer overflow when calling <b>ReadFileEx</b> will return
<b>TRUE</b>, but <b>GetLastError</b> will
report the overflow with <b>ERROR_MORE_DATA</b>. If the function call is successful and there
are no warning conditions, <b>GetLastError</b> will return
<b>ERROR_SUCCESS</b>.</para>
      <para>The <b>ReadFileEx</b> function may fail if there are too many
outstanding asynchronous I/O requests. In the event of such a failure,
<see cref="GetLastError" /> can return
<b>ERROR_INVALID_USER_BUFFER</b> or <b>ERROR_NOT_ENOUGH_MEMORY</b>.</para>
      <para>To cancel all pending asynchronous I/O operations, use either:</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/FileIO/cancelio">CancelIo</a>—this function only cancels
operations issued by the calling thread for the specified file handle.</description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/FileIO/cancelioex-func">CancelIoEx</a>—this function
cancels all operations issued by the threads for the specified file handle.</description>
        </item>
      </list>
      <para>Use <a href="https://docs.microsoft.com//windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</a> to cancel pending
synchronous I/O operations.</para>
      <para>I/O operations that are canceled complete with the error <b>ERROR_OPERATION_ABORTED</b>.</para>
      <para>If part of the file specified by <i>hFile</i> is locked by another process, and the read
operation specified in a call to <b>ReadFileEx</b> overlaps the
locked portion, the call to <b>ReadFileEx</b> fails.</para>
      <para>When attempting to read data from a mailslot whose buffer is too small,
<b>ReadFileEx</b> returns <b>FALSE</b>, and
<see cref="GetLastError" /> returns
<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
      <para>Accessing the input buffer while a read operation is using the buffer may lead to corruption of the data read
into that buffer. Applications must not read from, write to, reallocate, or free the input buffer that a read
operation is using until the read operation completes.</para>
      <para>An application uses the
<see cref="MsgWaitForMultipleObjectsEx" />,
<see cref="WaitForSingleObjectEx" />,
<see cref="WaitForMultipleObjectsEx" />, and
<see cref="SleepEx" /> functions to enter an alertable wait state. For more
information about alertable waits and overlapped input/output, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/about-synchronization">About Synchronization</a>.</para>
      <para>There are strict requirements for successfully working with files opened with
<see cref="CreateFile" /> using
<b>FILE_FLAG_NO_BUFFERING</b>. For details see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-buffering">File Buffering</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the file handle, then the function returns data from the transacted view of
the file. A transacted read handle is guaranteed to show the same view of a file for the duration of the handle.
For additional information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/about-transactional-ntfs">About Transactional NTFS</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/named-pipe-server-using-completion-routines">Named Pipe Server Using Completion Routines</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelio">CancelIo</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelioex-func">CancelIoEx</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</seealso>
    <seealso cref="MsgWaitForMultipleObjectsEx" />
    <seealso cref="ReadFile" />
    <seealso cref="SetErrorMode" />
    <seealso cref="SleepEx" />
    <seealso cref="WaitForMultipleObjectsEx" />
    <seealso cref="WaitForSingleObjectEx" />
    <seealso cref="WriteFileEx" />
  </member>
  <member name="Windows.ReadFileScatter">
    <summary>
      <para>Reads data from a file and stores it in an array of buffers.</para>
      <para>The function starts reading data from the file at a position that is specified by an
<see cref="OVERLAPPED" /> structure. The
<b>ReadFileScatter</b> function operates asynchronously.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file to be read.</para>
      <para>The file handle must be created with the <b>GENERIC_READ</b> right, and the
<b>FILE_FLAG_OVERLAPPED</b> and <b>FILE_FLAG_NO_BUFFERING</b> flags. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="aSegmentArray">
      <para>A pointer to an array of <see cref="FILE_SEGMENT_ELEMENT" /></para>
      <para>buffers that receives the data. For a description of this union, see Remarks.</para>
      <para>Each element can receive one page of data.</para>
      <para>
        <b>Note</b>  To determine the size of a system page, use
<see cref="GetSystemInfo" />.</para>
      <para>The array must contain enough elements to store <i>nNumberOfBytesToRead</i> bytes of data,
plus one element for the terminating <b>NULL</b>. For example, if there are 40 KB to be
read and the page size is 4 KB, the array must have 11 elements that includes 10 for the data and one for
the <b>NULL</b>.</para>
      <para>Each buffer must be at least the size of a system memory page and must be aligned on a system memory page
size boundary. The system reads one system memory page of data into each buffer.</para>
      <para>The function stores the data in the buffers in sequential order. For example, it stores data into the first
buffer, then into the second buffer, and so on until each buffer is filled and all the data is stored, or there
are no more buffers.</para>
    </param>
    <param name="nNumberOfBytesToRead">
      <para>The total number of bytes to be read from the file. Each element of <i>aSegmentArray</i></para>
      <para>contains a one-page chunk of this total. Because the file must be opened with
<b>FILE_FLAG_NO_BUFFERING</b>, the number of bytes must be a multiple of the sector size of
the file system where the file is located.</para>
    </param>
    <param name="lpReserved">
      <para>This parameter is reserved for future use and must be <b>NULL</b>.</para>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> data
structure.</para>
      <para>The <b>ReadFileScatter</b> function requires a valid
<see cref="OVERLAPPED" /> structure. The
<i>lpOverlapped</i> parameter
cannot be <b>NULL</b>.</para>
      <para>The <b>ReadFileScatter</b> function starts reading data
from the file at a position that is specified by the <b>Offset</b> and
<b>OffsetHigh</b> members of the
<see cref="OVERLAPPED" /> structure.</para>
      <para>The <b>ReadFileScatter</b> function may return before the
read operation is complete. In that scenario, the
<b>ReadFileScatter</b> function returns the value 0
(zero), and the <see cref="GetLastError" /> function returns the
value <b>ERROR_IO_PENDING</b>. This asynchronous operation of
<b>ReadFileScatter</b> lets the calling process continue
while the read operation completes. You can call the
<see cref="GetOverlappedResult" />,
<see cref="HasOverlappedIoCompleted" />, or
<see cref="GetQueuedCompletionStatus" /> functions to
obtain information about the completion of the read operation. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If <b>ReadFileScatter</b> attempts to read past the
end-of-file (EOF), the call to
<see cref="GetOverlappedResult" /> for that operation returns
<b>FALSE</b> and <see cref="GetLastError" /></para>
      <para>returns <b>ERROR_HANDLE_EOF</b>.</para>
      <para>If the function returns before the read operation is complete, the function returns zero (0), and
<see cref="GetLastError" /> returns
<b>ERROR_IO_PENDING</b>.</para>
    </returns>
    <remarks>
      <para>This function is not supported for 32-bit applications by WOW64 on Itanium-based systems.</para>
      <para>The <see cref="FILE_SEGMENT_ELEMENT" /> union is defined as follows:</para>
      <code>typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
</code>
      <para>Assigning a pointer to the <b>Buffer</b> member will sign-extend the value if the code is
compiled as 32-bits; this can break large-address aware applications running on systems configured with
<a href="https://docs.microsoft.com//windows/desktop/Memory/4-gigabyte-tuning">4-Gigabyte Tuning</a> or running on under WOW64 on 64-bit
Windows. Therefore, use the <b>PtrToPtr64</b> macro when assigning pointers to
<b>Buffer</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the file handle, then the function returns data from the transacted view of
the file. A transacted read handle is guaranteed to show the same view of a file for the duration of the
handle.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="FILE_SEGMENT_ELEMENT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetOverlappedResult" />
    <seealso cref="GetQueuedCompletionStatus" />
    <seealso cref="HasOverlappedIoCompleted" />
    <seealso cref="OVERLAPPED" />
    <seealso cref="ReadFile" />
    <seealso cref="ReadFileEx" />
    <seealso cref="WriteFileGather" />
  </member>
  <member name="Windows.RemoveDirectory">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process
must have delete access to the directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>RemoveDirectory</b> function marks a directory for
deletion on close. Therefore, the directory is not removed until the last handle to the directory is closed.</para>
      <para>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</para>
      <para>
        <b>RemoveDirectory</b> removes a directory junction, even
if the contents of the target are not empty; the function removes directory junctions regardless of the state of
the target object. For more information on junctions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines RemoveDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectoryTransacted" />
  </member>
  <member name="Windows.RemoveDirectoryA">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process
must have delete access to the directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>RemoveDirectory</b> function marks a directory for
deletion on close. Therefore, the directory is not removed until the last handle to the directory is closed.</para>
      <para>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</para>
      <para>
        <b>RemoveDirectory</b> removes a directory junction, even
if the contents of the target are not empty; the function removes directory junctions regardless of the state of
the target object. For more information on junctions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines RemoveDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectoryTransacted" />
  </member>
  <member name="Windows.RemoveDirectoryW">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process
must have delete access to the directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>RemoveDirectory</b> function marks a directory for
deletion on close. Therefore, the directory is not removed until the last handle to the directory is closed.</para>
      <para>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</para>
      <para>
        <b>RemoveDirectory</b> removes a directory junction, even
if the contents of the target are not empty; the function removes directory junctions regardless of the state of
the target object. For more information on junctions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines RemoveDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectoryTransacted" />
  </member>
  <member name="Windows.RemoveDirectory">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process
must have delete access to the directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>RemoveDirectory</b> function marks a directory for
deletion on close. Therefore, the directory is not removed until the last handle to the directory is closed.</para>
      <para>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</para>
      <para>
        <b>RemoveDirectory</b> removes a directory junction, even
if the contents of the target are not empty; the function removes directory junctions regardless of the state of
the target object. For more information on junctions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines RemoveDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectoryTransacted" />
  </member>
  <member name="Windows.RemoveDirectoryA">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process
must have delete access to the directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>RemoveDirectory</b> function marks a directory for
deletion on close. Therefore, the directory is not removed until the last handle to the directory is closed.</para>
      <para>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</para>
      <para>
        <b>RemoveDirectory</b> removes a directory junction, even
if the contents of the target are not empty; the function removes directory junctions regardless of the state of
the target object. For more information on junctions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines RemoveDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectoryTransacted" />
  </member>
  <member name="Windows.RemoveDirectoryW">
    <summary>
      <para>Deletes an existing empty directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="RemoveDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be removed. This path must specify an empty directory, and the calling process
must have delete access to the directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>RemoveDirectory</b> function marks a directory for
deletion on close. Therefore, the directory is not removed until the last handle to the directory is closed.</para>
      <para>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</para>
      <para>
        <b>RemoveDirectory</b> removes a directory junction, even
if the contents of the target are not empty; the function removes directory junctions regardless of the state of
the target object. For more information on junctions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines RemoveDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectoryTransacted" />
  </member>
  <member name="Windows.SetEndOfFile">
    <summary>
      <para>Sets the physical file size for the specified file to the current position of the file pointer.</para>
      <para>The physical file size is also referred to as the end of the file. The <b>SetEndOfFile</b> function can be used to truncate or extend a file. To set the logical end of a file, use the <see cref="SetFileValidData" /> function.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file to be extended or truncated.</para>
      <para>The file handle must be created with the <b>GENERIC_WRITE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>SetEndOfFile</b> function can be used to truncate or extend a file. If the file is extended, the contents of the file between the old end of the file  and the new  end of the file are not defined.</para>
      <para>Each file stream has the following:</para>
      <list type="bullet">
        <item>
          <description>File size: the size of the data in a file, to the byte.</description>
        </item>
        <item>
          <description>Allocation size: the size of the space that is allocated for a file on a disk, which is always an even multiple of the cluster size.</description>
        </item>
        <item>
          <description>Valid data length: the length of the data in a file that is actually written, to the byte. This value is always less than or equal to the file size.</description>
        </item>
      </list>
      <para>The <b>SetEndOfFile</b> function sets the file size. Use <see cref="SetFileValidData" /> to set the valid data length.</para>
      <para>If
<see cref="CreateFileMapping" /> is called to create a file mapping object for <i>hFile</i>, <see cref="UnmapViewOfFile" /> must be called first to unmap all views and call
<see cref="CloseHandle" /> to close the file mapping object before you can call
<b>SetEndOfFile</b>.</para>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the handle, then the change in the end-of-file position is transacted.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="SetFileInformationByHandle" />
    <seealso cref="SetFileValidData" />
    <seealso cref="UnmapViewOfFile" />
  </member>
  <member name="Windows.SetFileApisToANSI">
    <summary>
      <para>Causes the file I/O functions to use the ANSI character set code page for the current
process. This function is useful for 8-bit console input and output operations.</para>
    </summary>
    <remarks>
      <para>The file I/O functions whose code page is set by <b>SetFileApisToANSI</b> are those
functions exported by KERNEL32.DLL that accept or return a file name.
<b>SetFileApisToANSI</b> sets the code page per process, rather than per thread or per
computer.</para>
      <para>The <b>SetFileApisToANSI</b> function complements the
<see cref="SetFileApisToOEM" /> function, which causes the same set
of file I/O functions to use the OEM character set code page.</para>
      <para>The 8-bit console functions use the OEM code page by default. All other functions use the ANSI code page by
default. This means that strings returned by the console functions may not be processed correctly by other
functions, and vice versa. For example, if the
<see cref="FindFirstFileA" /> function returns a string that contains
certain extended ANSI characters, and the 8-bit console functions are set to use the OEM code page, then the
<a href="https://docs.microsoft.com//windows/console/writeconsole">WriteConsoleA</a> function does not display the string
properly.</para>
      <para>Use the <see cref="AreFileApisANSI" /> function to determine
which code page the set of file I/O functions is currently using. Use the
<a href="https://docs.microsoft.com//windows/console/setconsolecp">SetConsoleCP</a> and
<a href="https://docs.microsoft.com//windows/console/setconsoleoutputcp">SetConsoleOutputCP</a> functions to set the code page
for the 8-bit console functions.</para>
      <para>To solve the problem of code page incompatibility, it is best to use Unicode for console applications. Console
applications that use Unicode are much more versatile than those that use 8-bit console functions. Barring that
solution, a console application can call the
<see cref="SetFileApisToOEM" /> function to cause the
set of file I/O functions to use OEM character set strings rather than ANSI character set strings. Use the
<b>SetFileApisToANSI</b> function to set those functions back to the ANSI code
page.</para>
      <para>When dealing with command lines, a console application should obtain the command line in Unicode form and then
convert it to OEM form using the relevant character-to-OEM functions. Note also that the array in the
<i>argv</i> parameter of the command-line <b>main</b> function
contains ANSI character set strings in this case.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="AreFileApisANSI" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFileA" />
    <seealso href="https://docs.microsoft.com//windows/console/setconsolecp">SetConsoleCP</seealso>
    <seealso href="https://docs.microsoft.com//windows/console/setconsoleoutputcp">SetConsoleOutputCP</seealso>
    <seealso cref="SetFileApisToOEM" />
    <seealso href="https://docs.microsoft.com//windows/console/writeconsole">WriteConsoleA</seealso>
  </member>
  <member name="Windows.SetFileApisToOEM">
    <summary>
      <para>Causes the file I/O functions for the process to use the OEM character set code page. This
function is useful for 8-bit console input and output operations.</para>
    </summary>
    <remarks>
      <para>The file I/O functions whose code page is set by <b>SetFileApisToOEM</b> are those
functions exported by KERNEL32.DLL that accept or return a file name.
<b>SetFileApisToOEM</b> sets the code page per process, rather than per thread or per
computer.</para>
      <para>The <b>SetFileApisToOEM</b> function is complemented by the
<see cref="SetFileApisToANSI" /> function, which causes the same
set of file I/O functions to use the ANSI character set code page.</para>
      <para>The 8-bit console functions use the OEM code page by default. All other functions use the ANSI code page by
default. This means that strings returned by the console functions may not be processed correctly by other
functions, and vice versa. For example, if the
<see cref="FindFirstFileA" /> function returns a string that contains
certain extended ANSI characters, and the 8-bit console functions are set to use the OEM code page, then the
<a href="https://docs.microsoft.com//windows/console/writeconsole">WriteConsoleA</a> function will not display the string
properly.</para>
      <para>Use the <see cref="AreFileApisANSI" /> function to determine
which code page the set of file I/O functions is currently using. Use the
<a href="https://docs.microsoft.com//windows/console/setconsolecp">SetConsoleCP</a> and
<a href="https://docs.microsoft.com//windows/console/setconsoleoutputcp">SetConsoleOutputCP</a> functions to set the code page
for the 8-bit console functions.</para>
      <para>To solve the problem of code page incompatibility, it is best to use Unicode for console applications. Console
applications that use Unicode are much more versatile than those that use 8-bit console functions. Barring that
solution, a console application can call the <b>SetFileApisToOEM</b> function to cause
the set of file I/O functions to use OEM character set strings rather than ANSI character set strings. Use the
<see cref="SetFileApisToANSI" /> function to set those functions
back to the ANSI code page.</para>
      <para>When dealing with command lines, a console application should obtain the command line in Unicode form and then
convert it to OEM form using the relevant character-to-OEM functions. Note also that the array in the
<i>argv</i> parameter of the command-line <b>main</b> function
contains ANSI character set strings in this case.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="AreFileApisANSI" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFileA" />
    <seealso href="https://docs.microsoft.com//windows/console/setconsolecp">SetConsoleCP</seealso>
    <seealso href="https://docs.microsoft.com//windows/console/setconsoleoutputcp">SetConsoleOutputCP</seealso>
    <seealso cref="SetFileApisToANSI" />
    <seealso href="https://docs.microsoft.com//windows/console/writeconsole">WriteConsoleA</seealso>
  </member>
  <member name="Windows.SetFileAttributes">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>SetFileAttributesW</b>) and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values
override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that is an archive file or directory. Applications typically use this attribute to
mark files for backup or removal.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is hidden. It is not included in an ordinary directory listing.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </description>
              </item>
              <item>
                <description>128 (0x80)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that does not have other attributes set. This attribute is valid only when used alone.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </description>
              </item>
              <item>
                <description>8192 (0x2000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is not to be indexed by the content indexing service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </description>
              </item>
              <item>
                <description>4096 (0x1000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The data of a file is not available immediately. This attribute indicates that the file data is
physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical
storage management software. Applications should not arbitrarily change this attribute.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This
attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or
the System attributes of folders in Windows Server 2003, in Windows XP, or in
Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that the operating system uses a part of, or uses exclusively.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </description>
              </item>
              <item>
                <description>256 (0x100)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
sufficient cache memory is available, because typically, an application deletes a temporary file after the
handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is
written after the handle is closed.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following table describes how to set the attributes that cannot be set using
<b>SetFileAttributes</b>. For a complete list of all file
attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <list type="table">
        <listheader>
          <description>Attribute</description>
          <description>How to Set</description>
        </listheader>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_COMPRESSED</b>
            <para>0x800</para>
          </description>
          <description>
            <para>To set a file's compression state, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_compression">FSCTL_SET_COMPRESSION</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DEVICE</b>
            <para>0x40</para>
          </description>
          <description>
            <para>Reserved; do not use.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DIRECTORY</b>
            <para>0x10</para>
          </description>
          <description>
            <para>Files cannot be converted into directories. To create a directory, use the
<see cref="CreateDirectory" /> or
<see cref="CreateDirectoryEx" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_ENCRYPTED</b>
            <para>0x4000</para>
          </description>
          <description>
            <para>To create an encrypted file, use the
<see cref="CreateFile" /> function with the
<b>FILE_ATTRIBUTE_ENCRYPTED</b> attribute. To convert an existing file into an encrypted
file, use the <see cref="EncryptFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_REPARSE_POINT</b>
            <para>0x400</para>
          </description>
          <description>
            <para>To associate a reparse point with a file or directory, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_reparse_point">FSCTL_SET_REPARSE_POINT</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_SPARSE_FILE</b>
            <para>0x200</para>
          </description>
          <description>
            <para>To set a file's sparse attribute, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_sparse">FSCTL_SET_SPARSE</a> operation.</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines SetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributesTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS</seealso>
  </member>
  <member name="Windows.SetFileAttributesA">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>SetFileAttributesW</b>) and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values
override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that is an archive file or directory. Applications typically use this attribute to
mark files for backup or removal.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is hidden. It is not included in an ordinary directory listing.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </description>
              </item>
              <item>
                <description>128 (0x80)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that does not have other attributes set. This attribute is valid only when used alone.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </description>
              </item>
              <item>
                <description>8192 (0x2000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is not to be indexed by the content indexing service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </description>
              </item>
              <item>
                <description>4096 (0x1000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The data of a file is not available immediately. This attribute indicates that the file data is
physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical
storage management software. Applications should not arbitrarily change this attribute.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This
attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or
the System attributes of folders in Windows Server 2003, in Windows XP, or in
Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that the operating system uses a part of, or uses exclusively.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </description>
              </item>
              <item>
                <description>256 (0x100)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
sufficient cache memory is available, because typically, an application deletes a temporary file after the
handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is
written after the handle is closed.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following table describes how to set the attributes that cannot be set using
<b>SetFileAttributes</b>. For a complete list of all file
attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <list type="table">
        <listheader>
          <description>Attribute</description>
          <description>How to Set</description>
        </listheader>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_COMPRESSED</b>
            <para>0x800</para>
          </description>
          <description>
            <para>To set a file's compression state, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_compression">FSCTL_SET_COMPRESSION</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DEVICE</b>
            <para>0x40</para>
          </description>
          <description>
            <para>Reserved; do not use.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DIRECTORY</b>
            <para>0x10</para>
          </description>
          <description>
            <para>Files cannot be converted into directories. To create a directory, use the
<see cref="CreateDirectory" /> or
<see cref="CreateDirectoryEx" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_ENCRYPTED</b>
            <para>0x4000</para>
          </description>
          <description>
            <para>To create an encrypted file, use the
<see cref="CreateFile" /> function with the
<b>FILE_ATTRIBUTE_ENCRYPTED</b> attribute. To convert an existing file into an encrypted
file, use the <see cref="EncryptFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_REPARSE_POINT</b>
            <para>0x400</para>
          </description>
          <description>
            <para>To associate a reparse point with a file or directory, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_reparse_point">FSCTL_SET_REPARSE_POINT</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_SPARSE_FILE</b>
            <para>0x200</para>
          </description>
          <description>
            <para>To set a file's sparse attribute, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_sparse">FSCTL_SET_SPARSE</a> operation.</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines SetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributesTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS</seealso>
  </member>
  <member name="Windows.SetFileAttributesW">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>SetFileAttributesW</b>) and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values
override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that is an archive file or directory. Applications typically use this attribute to
mark files for backup or removal.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is hidden. It is not included in an ordinary directory listing.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </description>
              </item>
              <item>
                <description>128 (0x80)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that does not have other attributes set. This attribute is valid only when used alone.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </description>
              </item>
              <item>
                <description>8192 (0x2000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is not to be indexed by the content indexing service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </description>
              </item>
              <item>
                <description>4096 (0x1000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The data of a file is not available immediately. This attribute indicates that the file data is
physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical
storage management software. Applications should not arbitrarily change this attribute.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This
attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or
the System attributes of folders in Windows Server 2003, in Windows XP, or in
Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that the operating system uses a part of, or uses exclusively.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </description>
              </item>
              <item>
                <description>256 (0x100)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
sufficient cache memory is available, because typically, an application deletes a temporary file after the
handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is
written after the handle is closed.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following table describes how to set the attributes that cannot be set using
<b>SetFileAttributes</b>. For a complete list of all file
attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <list type="table">
        <listheader>
          <description>Attribute</description>
          <description>How to Set</description>
        </listheader>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_COMPRESSED</b>
            <para>0x800</para>
          </description>
          <description>
            <para>To set a file's compression state, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_compression">FSCTL_SET_COMPRESSION</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DEVICE</b>
            <para>0x40</para>
          </description>
          <description>
            <para>Reserved; do not use.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DIRECTORY</b>
            <para>0x10</para>
          </description>
          <description>
            <para>Files cannot be converted into directories. To create a directory, use the
<see cref="CreateDirectory" /> or
<see cref="CreateDirectoryEx" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_ENCRYPTED</b>
            <para>0x4000</para>
          </description>
          <description>
            <para>To create an encrypted file, use the
<see cref="CreateFile" /> function with the
<b>FILE_ATTRIBUTE_ENCRYPTED</b> attribute. To convert an existing file into an encrypted
file, use the <see cref="EncryptFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_REPARSE_POINT</b>
            <para>0x400</para>
          </description>
          <description>
            <para>To associate a reparse point with a file or directory, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_reparse_point">FSCTL_SET_REPARSE_POINT</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_SPARSE_FILE</b>
            <para>0x200</para>
          </description>
          <description>
            <para>To set a file's sparse attribute, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_sparse">FSCTL_SET_SPARSE</a> operation.</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines SetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributesTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS</seealso>
  </member>
  <member name="Windows.SetFileAttributes">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>SetFileAttributesW</b>) and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values
override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that is an archive file or directory. Applications typically use this attribute to
mark files for backup or removal.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is hidden. It is not included in an ordinary directory listing.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </description>
              </item>
              <item>
                <description>128 (0x80)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that does not have other attributes set. This attribute is valid only when used alone.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </description>
              </item>
              <item>
                <description>8192 (0x2000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is not to be indexed by the content indexing service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </description>
              </item>
              <item>
                <description>4096 (0x1000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The data of a file is not available immediately. This attribute indicates that the file data is
physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical
storage management software. Applications should not arbitrarily change this attribute.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This
attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or
the System attributes of folders in Windows Server 2003, in Windows XP, or in
Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that the operating system uses a part of, or uses exclusively.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </description>
              </item>
              <item>
                <description>256 (0x100)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
sufficient cache memory is available, because typically, an application deletes a temporary file after the
handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is
written after the handle is closed.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following table describes how to set the attributes that cannot be set using
<b>SetFileAttributes</b>. For a complete list of all file
attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <list type="table">
        <listheader>
          <description>Attribute</description>
          <description>How to Set</description>
        </listheader>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_COMPRESSED</b>
            <para>0x800</para>
          </description>
          <description>
            <para>To set a file's compression state, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_compression">FSCTL_SET_COMPRESSION</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DEVICE</b>
            <para>0x40</para>
          </description>
          <description>
            <para>Reserved; do not use.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DIRECTORY</b>
            <para>0x10</para>
          </description>
          <description>
            <para>Files cannot be converted into directories. To create a directory, use the
<see cref="CreateDirectory" /> or
<see cref="CreateDirectoryEx" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_ENCRYPTED</b>
            <para>0x4000</para>
          </description>
          <description>
            <para>To create an encrypted file, use the
<see cref="CreateFile" /> function with the
<b>FILE_ATTRIBUTE_ENCRYPTED</b> attribute. To convert an existing file into an encrypted
file, use the <see cref="EncryptFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_REPARSE_POINT</b>
            <para>0x400</para>
          </description>
          <description>
            <para>To associate a reparse point with a file or directory, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_reparse_point">FSCTL_SET_REPARSE_POINT</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_SPARSE_FILE</b>
            <para>0x200</para>
          </description>
          <description>
            <para>To set a file's sparse attribute, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_sparse">FSCTL_SET_SPARSE</a> operation.</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines SetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributesTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS</seealso>
  </member>
  <member name="Windows.SetFileAttributesA">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>SetFileAttributesW</b>) and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values
override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that is an archive file or directory. Applications typically use this attribute to
mark files for backup or removal.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is hidden. It is not included in an ordinary directory listing.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </description>
              </item>
              <item>
                <description>128 (0x80)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that does not have other attributes set. This attribute is valid only when used alone.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </description>
              </item>
              <item>
                <description>8192 (0x2000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is not to be indexed by the content indexing service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </description>
              </item>
              <item>
                <description>4096 (0x1000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The data of a file is not available immediately. This attribute indicates that the file data is
physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical
storage management software. Applications should not arbitrarily change this attribute.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This
attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or
the System attributes of folders in Windows Server 2003, in Windows XP, or in
Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that the operating system uses a part of, or uses exclusively.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </description>
              </item>
              <item>
                <description>256 (0x100)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
sufficient cache memory is available, because typically, an application deletes a temporary file after the
handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is
written after the handle is closed.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following table describes how to set the attributes that cannot be set using
<b>SetFileAttributes</b>. For a complete list of all file
attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <list type="table">
        <listheader>
          <description>Attribute</description>
          <description>How to Set</description>
        </listheader>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_COMPRESSED</b>
            <para>0x800</para>
          </description>
          <description>
            <para>To set a file's compression state, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_compression">FSCTL_SET_COMPRESSION</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DEVICE</b>
            <para>0x40</para>
          </description>
          <description>
            <para>Reserved; do not use.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DIRECTORY</b>
            <para>0x10</para>
          </description>
          <description>
            <para>Files cannot be converted into directories. To create a directory, use the
<see cref="CreateDirectory" /> or
<see cref="CreateDirectoryEx" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_ENCRYPTED</b>
            <para>0x4000</para>
          </description>
          <description>
            <para>To create an encrypted file, use the
<see cref="CreateFile" /> function with the
<b>FILE_ATTRIBUTE_ENCRYPTED</b> attribute. To convert an existing file into an encrypted
file, use the <see cref="EncryptFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_REPARSE_POINT</b>
            <para>0x400</para>
          </description>
          <description>
            <para>To associate a reparse point with a file or directory, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_reparse_point">FSCTL_SET_REPARSE_POINT</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_SPARSE_FILE</b>
            <para>0x200</para>
          </description>
          <description>
            <para>To set a file's sparse attribute, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_sparse">FSCTL_SET_SPARSE</a> operation.</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines SetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributesTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS</seealso>
  </member>
  <member name="Windows.SetFileAttributesW">
    <summary>
      <para>Sets the attributes for a file or directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="SetFileAttributesTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file whose attributes are to be set.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>SetFileAttributesW</b>) and prepend
"\\?\" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFileAttributes">
      <para>The file attributes to set for the file.</para>
      <para>This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values
override <b>FILE_ATTRIBUTE_NORMAL</b>.</para>
      <para>Not all attributes are supported by this function. For more information, see the Remarks section.</para>
      <para>The following is a list of supported attribute values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_ARCHIVE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that is an archive file or directory. Applications typically use this attribute to
mark files for backup or removal.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is hidden. It is not included in an ordinary directory listing.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NORMAL</b>
                </description>
              </item>
              <item>
                <description>128 (0x80)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that does not have other attributes set. This attribute is valid only when used alone.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b>
                </description>
              </item>
              <item>
                <description>8192 (0x2000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file or directory is not to be indexed by the content indexing service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_OFFLINE</b>
                </description>
              </item>
              <item>
                <description>4096 (0x1000)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The data of a file is not available immediately. This attribute indicates that the file data is
physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical
storage management software. Applications should not arbitrarily change this attribute.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_READONLY</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This
attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or
the System attributes of folders in Windows Server 2003, in Windows XP, or in
Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file or directory that the operating system uses a part of, or uses exclusively.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ATTRIBUTE_TEMPORARY</b>
                </description>
              </item>
              <item>
                <description>256 (0x100)</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
sufficient cache memory is available, because typically, an application deletes a temporary file after the
handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is
written after the handle is closed.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following table describes how to set the attributes that cannot be set using
<b>SetFileAttributes</b>. For a complete list of all file
attribute values and their descriptions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
      <list type="table">
        <listheader>
          <description>Attribute</description>
          <description>How to Set</description>
        </listheader>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_COMPRESSED</b>
            <para>0x800</para>
          </description>
          <description>
            <para>To set a file's compression state, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_compression">FSCTL_SET_COMPRESSION</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DEVICE</b>
            <para>0x40</para>
          </description>
          <description>
            <para>Reserved; do not use.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_DIRECTORY</b>
            <para>0x10</para>
          </description>
          <description>
            <para>Files cannot be converted into directories. To create a directory, use the
<see cref="CreateDirectory" /> or
<see cref="CreateDirectoryEx" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_ENCRYPTED</b>
            <para>0x4000</para>
          </description>
          <description>
            <para>To create an encrypted file, use the
<see cref="CreateFile" /> function with the
<b>FILE_ATTRIBUTE_ENCRYPTED</b> attribute. To convert an existing file into an encrypted
file, use the <see cref="EncryptFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_REPARSE_POINT</b>
            <para>0x400</para>
          </description>
          <description>
            <para>To associate a reparse point with a file or directory, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_reparse_point">FSCTL_SET_REPARSE_POINT</a> operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_ATTRIBUTE_SPARSE_FILE</b>
            <para>0x200</para>
          </description>
          <description>
            <para>To set a file's sparse attribute, use the
<see cref="DeviceIoControl" /> function with the
<a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_set_sparse">FSCTL_SET_SPARSE</a> operation.</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If a file is open for modification in a transaction, no other thread can open the file for modification until
the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try
modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when the transaction attempts to
open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The fileapi.h header defines SetFileAttributes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileAttributes" />
    <seealso cref="SetFileAttributesTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS</seealso>
  </member>
  <member name="Windows.SetFileInformationByHandle">
    <summary>
      <para>Sets the file information for the specified file.</para>
      <para>To retrieve file information using a file handle, see
<see cref="GetFileInformationByHandle" /> or
<see cref="GetFileInformationByHandleEx" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file for which to change information.</para>
      <para>This handle must be opened with the appropriate permissions for the requested change. For more information,
see the Remarks and Example Code sections.</para>
      <para>This handle should not be a pipe handle.</para>
    </param>
    <param name="FileInformationClass">
      <para>A <see cref="FILE_INFO_BY_HANDLE_CLASS" /> enumeration
value that specifies the type of information to be changed.</para>
      <para>For a table of valid values, see the Remarks section.</para>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to the buffer that contains the information to change  for the specified file information class.
The structure that this parameter points to corresponds to the class that is specified by
<i>FileInformationClass</i>.</para>
      <para>For a table of valid structure types, see the Remarks section.</para>
    </param>
    <param name="dwBufferSize">
      <para>The size of <i>lpFileInformation</i>, in bytes.</para>
    </param>
    <returns>
      <para>Returns nonzero if successful or zero otherwise.</para>
      <para>To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Certain file information classes behave slightly differently on different operating system releases. These
classes are supported by the underlying drivers, and any information they return is subject to change between
operating system releases.</para>
      <para>The following table shows the valid file information classes and their corresponding data structure types for
use with this function.</para>
      <list type="table">
        <listheader>
          <description>
            <i>FileInformationClass</i> value</description>
          <description>
            <i>lpFileInformation</i> type</description>
        </listheader>
        <item>
          <description>
            <b>FileBasicInfo</b>
            <para>0</para>
          </description>
          <description>
            <para>
              <see cref="FILE_BASIC_INFO" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>FileRenameInfo</b>
            <para>3</para>
          </description>
          <description>
            <para>
              <see cref="FILE_RENAME_INFO" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>FileDispositionInfo</b>
            <para>4</para>
          </description>
          <description>
            <para>
              <see cref="FILE_DISPOSITION_INFO" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>FileAllocationInfo</b>
            <para>5</para>
          </description>
          <description>
            <para>
              <see cref="FILE_ALLOCATION_INFO" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>FileEndOfFileInfo</b>
            <para>6</para>
          </description>
          <description>
            <para>
              <see cref="FILE_END_OF_FILE_INFO" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>FileIoPriorityHintInfo</b>
            <para>12</para>
          </description>
          <description>
            <para>
              <see cref="FILE_IO_PRIORITY_HINT_INFO" />
            </para>
          </description>
        </item>
      </list>
      <para>You must specify appropriate access flags when creating the file handle for use with
<b>SetFileInformationByHandle</b>. For example, if
the application is using <see cref="FILE_DISPOSITION_INFO" /> with
the <b>DeleteFile</b> member set to <b>TRUE</b>, the file would need
<b>DELETE</b> access requested in the call to the
<see cref="CreateFile" /> function. To see an example of this, see the
Example Code section. For more information about file permissions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If there is a transaction bound to the handle, then the changes made will be transacted for the information
classes <b>FileBasicInfo</b>, <b>FileRenameInfo</b>,
<b>FileAllocationInfo</b>, <b>FileEndOfFileInfo</b>, and
<b>FileDispositionInfo</b>. If <b>FileDispositionInfo</b> is specified,
only the delete operation is transacted if a <see cref="DeleteFile" /></para>
      <para>operation was requested. In this case, if the transaction is not committed before the handle is closed, the
deletion will not occur. For more information about TxF, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS (TxF)</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.</para>
      <h4>Examples</h4>
      <para>The following C++ example shows how to create a file and mark it for deletion when the handle is closed.</para>
      <code>//...
  HANDLE hFile = CreateFile( TEXT("tempfile"),
                             GENERIC_READ | GENERIC_WRITE | DELETE,
                             0 /* exclusive access */,
                             NULL,
                             CREATE_ALWAYS,
                             0,
                             NULL);

  if (hFile != INVALID_HANDLE_VALUE)
   {
    FILE_DISPOSITION_INFO fdi;
    fdi.DeleteFile = TRUE; // marking for deletion

    BOOL fResult = SetFileInformationByHandle( hFile,
                                               FileDispositionInfo,
                                               &amp;amp;amp;amp;amp;amp;fdi,
                                               sizeof(FILE_DISPOSITION_INFO) );

    if (fResult)
     {
      // File will be deleted upon CloseHandle.
      _tprintf( TEXT("SetFileInformationByHandle marked tempfile for deletion\n") );

      // ...
      // Now use the file for whatever temp data storage you need,
      // it will automatically be deleted upon CloseHandle or
      // application termination.
      // ...
     }
    else
     {
      _tprintf( TEXT("error %lu:  SetFileInformationByHandle could not mark tempfile for deletion\n"),
                GetLastError() );
     }

    CloseHandle(hFile);

    // At this point, the file is closed and deleted by the system.
   }
  else
   {
    _tprintf( TEXT("error %lu:  could not create tempfile\n"),
              GetLastError() );
 }
//...

</code>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</seealso>
    <seealso cref="GetFileInformationByHandle" />
    <seealso cref="GetFileInformationByHandleEx" />
  </member>
  <member name="Windows.SetFileIoOverlappedRange">
    <summary>
      <para>Associates a virtual address range with the specified file handle. This indicates that the
kernel should optimize any further asynchronous I/O requests with overlapped structures inside this range. The
overlapped range is locked in memory, and then unlocked when the file is closed. After a range is associated with
a file handle, it cannot be disassociated.</para>
    </summary>
    <param name="FileHandle">
      <para>A handle to the file.</para>
      <para>This file handle must be opened with <b>FILE_READ_ATTRIBUTES</b> access rights.</para>
    </param>
    <param name="OverlappedRangeStart">
      <para>The starting address for the range.</para>
    </param>
    <param name="Length">
      <para>The length of the range, in bytes.</para>
    </param>
    <returns>
      <para>Returns nonzero if successful or zero otherwise.</para>
      <para>To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>SetFileIoOverlappedRange</b> can be used to
improve performance in an application that issues a high number of asynchronous unbuffered I/O and uses a defined
range of overlapped structures. Because this range of structures is locked in memory, the kernel can avoid
acquiring certain locks when updating the overlapped structures with the results of the I/O request.</para>
      <para>
        <b>SetFileIoOverlappedRange</b> requires the
caller to have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
      <para>access privilege.</para>
      <para>This function has no effect on buffered and synchronous I/O.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.SetFilePointerEx">
    <summary>
      <para>Moves the file pointer of the specified file.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The file handle must have been created with the
<b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more
information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="liDistanceToMove">
      <para>The number of bytes to move the file pointer. A positive value moves the pointer forward in the file and a
negative value moves the file pointer backward.</para>
    </param>
    <param name="lpNewFilePointer">
      <para>A pointer to a variable to receive the new file pointer. If this parameter is
<b>NULL</b>, the new file pointer is not returned.</para>
    </param>
    <param name="dwMoveMethod">
      <para>The starting point for the file pointer move. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_BEGIN</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The starting point is zero or the beginning of the file. If this flag is specified, then the
<i>liDistanceToMove</i> parameter is interpreted as an unsigned value.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CURRENT</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The start point is the current value of the file pointer.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_END</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The starting point is the current end-of-file position.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file pointer returned by this function is not used for overlapped read and write operations. To specify
the offset for overlapped operations, use the <b>Offset</b> and
<b>OffsetHigh</b> members of the
<see cref="OVERLAPPED" /> structure.</para>
      <para>You cannot use the <b>SetFilePointerEx</b> function with a handle to a nonseeking
device such as a pipe or a communications device. To determine the file type for <i>hFile</i>,
use the <see cref="GetFileType" /> function.</para>
      <para>Use caution when setting the file pointer in a multithreaded application. You must synchronize access to
shared resources. For example, an application whose threads share a file handle, update the file pointer, and read
from the file must protect this sequence by using a critical section object or a mutex object. For more
information about these objects, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/critical-section-objects">Critical Section Objects</a></para>
      <para>and <a href="https://docs.microsoft.com//windows/desktop/Sync/mutex-objects">Mutex Objects</a>.</para>
      <para>If the <i>hFile</i> handle was opened with the
<b>FILE_FLAG_NO_BUFFERING</b> flag set, an application can move the file pointer only to
sector-aligned positions. A sector-aligned position is a position that is a whole number multiple of the volume's
sector size. An application can obtain a volume's sector size by calling the
<see cref="GetDiskFreeSpace" /> function. If an application
calls <b>SetFilePointerEx</b> with distance-to-move values that result in a position
that is not sector-aligned and a handle that was opened with <b>FILE_FLAG_NO_BUFFERING</b>, the
function fails, and <see cref="GetLastError" /> returns
<b>ERROR_INVALID_PARAMETER</b>. For additional information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-buffering">File Buffering</a>.</para>
      <para>Note that it is not an error to set the file pointer to a position beyond the end of the file. The size of the
file does not increase until you call the <see cref="SetEndOfFile" />,
<see cref="WriteFile" />, or
<see cref="WriteFileEx" /> function. A write operation increases the size
of the file to the file pointer position plus the size of the buffer written, leaving the intervening bytes
uninitialized.</para>
      <para>You can use <b>SetFilePointerEx</b> to determine the length of a file. To do this,
use <b>FILE_END</b> for <i>dwMoveMethod</i> and seek to location zero. The
file offset returned is the length of the file. However, this practice can have unintended side effects, such as
failure to save the current file pointer so that the program can return to that location. It is simpler and safer
to use the <see cref="GetFileSizeEx" /> function instead.</para>
      <para>You can also use <b>SetFilePointerEx</b> to query the current file pointer position.
To do this, specify a move method of <b>FILE_CURRENT</b> and a distance of zero.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso cref="GetFileSizeEx" />
    <seealso cref="GetFileType" />
    <seealso cref="SetEndOfFile" />
    <seealso cref="WriteFile" />
    <seealso cref="WriteFileEx" />
  </member>
  <member name="Windows.SetFileTime">
    <summary>
      <para>Sets the date and time that the specified file or directory was created, last accessed, or last
modified.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file or directory. The handle must have been created using the
<see cref="CreateFile" /> function  with the
<b>FILE_WRITE_ATTRIBUTES</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="lpCreationTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that contains the
new creation date and time for the file or directory. If
the application does not need to change this information, set this parameter either to <b>NULL</b> or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 0.</para>
    </param>
    <param name="lpLastAccessTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that
contains the new last access date and time for the file or directory. The last access time includes the last
time the file or directory was written to, read from, or (in the case of executable files) run. If
the application does not need to change this information, set this parameter
either to <b>NULL</b> or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 0.</para>
      <para>To prevent file operations using the given handle from modifying the last access time, call
<b>SetFileTime</b> immediately  after opening the file handle
and pass a <see cref="FILETIME" /> structure that has both the
<b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to
0xFFFFFFFF.</para>
    </param>
    <param name="lpLastWriteTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that
contains the new last modified date and time for the file or directory.  If the application does not need to change this information, set this parameter either  to <b>NULL</b>  or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 0.</para>
      <para>To prevent file operations using the given handle from modifying the last access time, call
<b>SetFileTime</b> immediately after opening the file handle
and pass a <see cref="FILETIME" /> structure that has both the
<b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to
0xFFFFFFFF.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Not all file systems can record creation and last access times and not all file systems record them in the
same manner. For example, on  FAT, create time has a resolution of 10 milliseconds, write time has a resolution of
2 seconds, and access time has a resolution of 1 day (really, the access date). Therefore, the
<see cref="GetFileTime" /> function may not return the same file time
information set using <b>SetFileTime</b>. NTFS delays updates to
the last access time for a file by up to one hour after the last access.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/changing-a-file-time-to-the-current-time">Changing a File Time to the Current Time</a>.</para>
    </remarks>
    <seealso cref="FILETIME" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/file-times">File Times</seealso>
    <seealso cref="GetFileSize" />
    <seealso cref="GetFileTime" />
    <seealso cref="GetFileType" />
    <seealso cref="SetFileInformationByHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.UnlockFile">
    <summary>
      <para>Unlocks a region in an open file. Unlocking a region enables other processes to access the region.</para>
      <para>For an alternate way to specify the region, use the
<see cref="UnlockFileEx" /> function.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file that contains a region locked with
<see cref="LockFile" />. The file handle must have been created with either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwFileOffsetLow">
      <para>The low-order word of the starting byte offset in the file where the locked region begins.</para>
    </param>
    <param name="dwFileOffsetHigh">
      <para>The high-order word of the starting byte offset in the file where the locked region begins.</para>
    </param>
    <param name="nNumberOfBytesToUnlockLow">
      <para>The low-order word of the length of the byte range to be unlocked.</para>
    </param>
    <param name="nNumberOfBytesToUnlockHigh">
      <para>The high-order word of the length of the byte range to be unlocked.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function always operates synchronously, but may not queue a completion entry when a completion port is associated with the file handle.</para>
      <para>Unlocking a region of a file releases a previously acquired lock on the file. The region to unlock must correspond exactly to an existing locked region. Two adjacent regions of a file cannot be locked separately and then unlocked using a single region that spans both locked regions.</para>
      <para>If a process terminates with a portion of a file locked or closes a file that has outstanding locks, the locks are unlocked by the operating system. However, the time it takes for the operating system to unlock these locks depends upon available system resources. Therefore, it is recommended that your process explicitly unlock all files it has locked when it terminates. If this is not done, access to these files may be denied if the operating system has not yet unlocked them.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="LockFile" />
    <seealso cref="UnlockFileEx" />
  </member>
  <member name="Windows.UnlockFileEx">
    <summary>
      <para>Unlocks a region in the specified file. This function can operate either synchronously or
asynchronously.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The handle must have been created with either the
<b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more
information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">
      <para>Reserved parameter; must be zero.</para>
    </param>
    <param name="nNumberOfBytesToUnlockLow">
      <para>The low-order part of the length of the byte range to unlock.</para>
    </param>
    <param name="nNumberOfBytesToUnlockHigh">
      <para>The high-order part of the length of the byte range to unlock.</para>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> structure that the
function uses with the unlocking request. This structure contains the file offset of the beginning of the unlock
range. You must initialize the <b>hEvent</b> member to a valid handle or zero. For more
information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero or <b>NULL</b>. To get extended error
information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Unlocking a region of a file releases a previously acquired lock on the file. The region to unlock must
correspond exactly to an existing locked region. Two adjacent regions of a file cannot be locked separately and
then unlocked using a single region that spans both locked regions.</para>
      <para>Locks are released before the <see cref="CloseHandle" /> function is
finished processing.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="LockFile" />
    <seealso cref="LockFileEx" />
    <seealso cref="OVERLAPPED" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</seealso>
    <seealso cref="UnlockFile" />
  </member>
  <member name="Windows.WriteFileEx">
    <summary>
      <para>Writes data to the specified file or input/output (I/O) device. It reports its completion status asynchronously, calling the specified completion routine when writing is completed or canceled and the calling thread is in an alertable wait state.</para>
      <para>To write data to a file or device synchronously, use the <see cref="WriteFile" /> function.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file or I/O device (for example, a file, file stream, physical disk, volume,  console buffer, tape drive,
socket, communications resource, mailslot, or  pipe).</para>
      <para>This parameter can be any handle opened with the <b>FILE_FLAG_OVERLAPPED</b> flag by the
<see cref="CreateFile" /> function, or a socket handle returned by the
<see cref="socket" /> or
<see cref="accept" /> function.</para>
      <para>Do not associate an I/O completion port with this handle. For more information, see the Remarks section.</para>
      <para>This handle also must have the <b>GENERIC_WRITE</b> access
right. For more information on access rights, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to the buffer containing the data to be written to the file or device.</para>
      <para>This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
until the write operation is completed.</para>
    </param>
    <param name="nNumberOfBytesToWrite">
      <para>The number of bytes to be written to the file or device.</para>
      <para>A value of zero specifies a null write operation. The behavior of a null write operation depends on the
underlying file system.</para>
      <para>Pipe write operations across a network are limited to 65,535 bytes per write. For more information regarding  pipes, see the Remarks section.</para>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> data structure that
supplies data to be used during the overlapped (asynchronous) write operation.</para>
      <para>For files that support byte offsets, you must specify a byte offset at which to start writing to the file.
You specify this offset by setting the <b>Offset</b> and
<b>OffsetHigh</b> members of the
<see cref="OVERLAPPED" /> structure. For files or devices that do not support
byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are ignored.</para>
      <para>To write to the end of file, specify both the <b>Offset</b> and <b>OffsetHigh</b> members of the <see cref="OVERLAPPED" /> structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the <see cref="CreateFile" /> function to open <i>hFile</i> using <b>FILE_APPEND_DATA</b> access.</para>
      <para>The <b>WriteFileEx</b> function ignores the
<see cref="OVERLAPPED" /> structure's
<b>hEvent</b> member. An application is free to use that member for its own purposes in the
context of a <b>WriteFileEx</b> call.
<b>WriteFileEx</b> signals completion of its writing operation
by calling, or queuing a call to, the completion routine pointed to by
<i>lpCompletionRoutine</i>, so it does not need an event handle.</para>
      <para>The <b>WriteFileEx</b> function does use the
<b>Internal</b> and <b>InternalHigh</b> members of the
<see cref="OVERLAPPED" /> structure. You should not change the value
of these members.</para>
      <para>The <see cref="OVERLAPPED" /> data structure must remain valid for
the duration of the write operation. It should not be a variable that can go out of scope while the write
operation is pending completion.</para>
    </param>
    <param name="lpCompletionRoutine">
      <para>A pointer to a completion routine to be called when the write operation has been completed and the calling
thread is in an alertable wait state. For more information about this completion routine, see
<a href="https://docs.microsoft.com//windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the <b>WriteFileEx</b> function succeeds, the calling
thread has an asynchronous I/O operation pending: the overlapped write operation to the file.
When this I/O operation finishes, and the calling thread is blocked in an alertable wait state, the
operating system calls the function pointed to by <i>lpCompletionRoutine</i>, and the wait
completes with a return code of <b>WAIT_IO_COMPLETION</b>.</para>
      <para>If the function succeeds and the file-writing operation finishes, but the calling thread is not in an
alertable wait state, the system queues the call to *<i>lpCompletionRoutine</i>, holding the
call until the calling thread enters an alertable wait state. For more information about
alertable wait states and overlapped input/output operations, see <a href="https://docs.microsoft.com//windows/desktop/Sync/about-synchronization">About Synchronization</a>.</para>
    </returns>
    <remarks>
      <para>When using <b>WriteFileEx</b> you should check
<see cref="GetLastError" /> even when the function returns "success" to
check for conditions that are "successes" but have some outcome you might want to know about. For example, a
buffer overflow when calling <b>WriteFileEx</b> will return
<b>TRUE</b>, but <b>GetLastError</b> will
report the overflow with <b>ERROR_MORE_DATA</b>. If the function call is successful and there
are no warning conditions, <b>GetLastError</b> will return
<b>ERROR_SUCCESS</b>.</para>
      <para>The <b>WriteFileEx</b> function will fail if the <i>hFile</i> parameter is associated with an <a href="https://docs.microsoft.com//windows/desktop/FileIO/i-o-completion-ports">I/O completion port</a>. To perform writes using this type of handle, use the <see cref="WriteFile" /> function.</para>
      <para>The <b>WriteFileEx</b> function may fail if there are too many outstanding asynchronous I/O requests. In the event of such a failure, <see cref="GetLastError" /> can return <b>ERROR_INVALID_USER_BUFFER</b> or <b>ERROR_NOT_ENOUGH_MEMORY</b>.</para>
      <para>To cancel all pending asynchronous I/O operations, use either:</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/FileIO/cancelio">CancelIo</a>—this function only cancels
operations issued by the calling thread for the specified file handle.</description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/FileIO/cancelioex-func">CancelIoEx</a>—this function
cancels all operations issued by the threads for the specified file handle.</description>
        </item>
      </list>
      <para>Use <a href="https://docs.microsoft.com//windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</a> to cancel pending
synchronous I/O operations.</para>
      <para>I/O operations that are canceled complete with the error
<b>ERROR_OPERATION_ABORTED</b>.</para>
      <para>If part of the file specified by <i>hFile</i> is locked by another process, and the specified write operation overlaps the locked
portion, <b>WriteFileEx</b> fails.</para>
      <para>When writing to a file, the last write time is not fully updated until all handles used for writing have been
closed. Therefore, to ensure an accurate last write time, close the file handle immediately after writing to the
file.</para>
      <para>Accessing the output buffer while a write operation is using the buffer may lead to corruption of the data
written from that buffer. Applications must not write to, reallocate, or free the output buffer that a write
operation is using until the write operation completes.</para>
      <para>Note that the time stamps may not be updated correctly for a remote file. To ensure consistent results, use
unbuffered I/O.</para>
      <para>The system interprets zero bytes to write as specifying a null write operation and
<see cref="WriteFile" /> does not truncate or extend the file. To truncate or extend a file, use the
<see cref="SetEndOfFile" /> function.</para>
      <para>An application uses the
<see cref="WaitForSingleObjectEx" />,
<see cref="WaitForMultipleObjectsEx" />,
<see cref="MsgWaitForMultipleObjectsEx" />,
<see cref="SignalObjectAndWait" />, and
<see cref="SleepEx" /> functions to enter an alertable wait state. For more information about alertable wait
states and overlapped I/O operations, see <a href="https://docs.microsoft.com//windows/desktop/Sync/about-synchronization">About Synchronization</a>.</para>
      <para>If you write directly to a volume that has a mounted file system, you must first obtain exclusive access to the volume. Otherwise, you risk causing data corruption or system instability, because your application's writes may conflict with other changes coming from the file system and leave the contents of the volume in an inconsistent state. To prevent these problems, the following changes have been made in Windows Vista and later:</para>
      <list type="bullet">
        <item>
          <description>A write on a volume handle will succeed if the volume does not have a mounted file system, or if one of the following conditions is true:<list type="bullet"><item><description>The sectors to be written to are boot sectors.</description></item><item><description>The sectors to be written to reside outside of file system space.</description></item><item><description>You have explicitly locked or dismounted the volume by using <a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_lock_volume">FSCTL_LOCK_VOLUME</a> or <a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_dismount_volume">FSCTL_DISMOUNT_VOLUME</a>.</description></item><item><description>The volume has no actual file system. (In other words, it has a RAW file system mounted.)</description></item></list></description>
        </item>
        <item>
          <description>A write on a disk handle will succeed if one of the following conditions is true:<list type="bullet"><item><description>The sectors to be written to do not fall within a volume's extents.</description></item><item><description>The sectors to be written to fall within a mounted volume, but you have explicitly locked or dismounted the volume by using <a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_lock_volume">FSCTL_LOCK_VOLUME</a> or <a href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_dismount_volume">FSCTL_DISMOUNT_VOLUME</a>.</description></item><item><description>The sectors to be written to fall within a volume that has no mounted file system other than RAW.</description></item></list></description>
        </item>
      </list>
      <para>There are strict requirements for successfully working with files opened with <see cref="CreateFile" /> using <b>FILE_FLAG_NO_BUFFERING</b>. For details see <a href="https://docs.microsoft.com//windows/desktop/FileIO/file-buffering">File Buffering</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the file handle, then the file write is transacted. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/about-transactional-ntfs">About Transactional NTFS</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/named-pipe-server-using-completion-routines">Named Pipe Server Using Completion Routines</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelio">CancelIo</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelioex-func">CancelIoEx</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</seealso>
    <seealso cref="MsgWaitForMultipleObjectsEx" />
    <seealso cref="ReadFileEx" />
    <seealso cref="SetEndOfFile" />
    <seealso cref="SetErrorMode" />
    <seealso cref="SignalObjectAndWait" />
    <seealso cref="SleepEx" />
    <seealso cref="WaitForMultipleObjectsEx" />
    <seealso cref="WaitForSingleObjectEx" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.WriteFileGather">
    <summary>
      <para>Retrieves data
from an array of buffers and writes the data to a file.</para>
      <para>The function starts writing data to the file at a position that is specified by an
<see cref="OVERLAPPED" /> structure. The
<b>WriteFileGather</b> function operates asynchronously.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The file handle must be created with the <b>GENERIC_WRITE</b></para>
      <para>access right, and the <b>FILE_FLAG_OVERLAPPED</b> and
<b>FILE_FLAG_NO_BUFFERING</b> flags. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="aSegmentArray">
      <para>A pointer to an array of <see cref="FILE_SEGMENT_ELEMENT" /></para>
      <para>buffers that contain the data. For a description of this union, see Remarks.</para>
      <para>Each element contains the address of one page of data.
<b>Note</b>  To determine the size of a system page, use the
<see cref="GetSystemInfo" /> function.
The array must contain enough elements to store <i>nNumberOfBytesToWrite</i> bytes of data,
and one element for the terminating <b>NULL</b>. For example, if there are 40 KB to be read
and the page size is 4 KB, the array must have 11 elements that includes 10 elements for the data and one
element for the <b>NULL</b>.</para>
      <para>Each buffer must be at least the size of a system memory page and must be aligned on a system memory page
size boundary. The system writes one system memory page of data from each buffer.</para>
      <para>The function gathers the data from the buffers in a sequential order. For example, it writes data to the file
from the first buffer, then the second buffer, and so on until there is no more data.</para>
      <para>Due to the asynchronous operation of this function, precautions must be taken to ensure that this parameter
always references valid memory for the lifetime of the asynchronous writes. For instance, a common programming
error is to use local stack storage and then allow execution to run out of scope.</para>
    </param>
    <param name="nNumberOfBytesToWrite">
      <para>The total number of bytes to be written. Each element of <i>aSegmentArray</i> contains a
one-page chunk of this total. Because the file must be opened with
<b>FILE_FLAG_NO_BUFFERING</b>, the number of bytes must be a multiple of the sector size of
the file system where the file is located.</para>
      <para>If <i>nNumberOfBytesToWrite</i> is zero (0), the function performs a null write operation.
The behavior of a null write operation depends on the underlying file system. If
<i>nNumberOfBytesToWrite</i> is not zero (0) and the offset and length of the write place
data beyond the current end of the file,
the <b>WriteFileGather</b> function extends the file.</para>
    </param>
    <param name="lpReserved">
      <para>This parameter is reserved for future use and must be <b>NULL</b>.</para>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> data
structure.</para>
      <para>The <b>WriteFileGather</b> function requires a valid
<see cref="OVERLAPPED" /> structure. The
<i>lpOverlapped</i> parameter cannot be <b>NULL</b>.</para>
      <para>The <b>WriteFileGather</b> function starts writing data to
the file at a position that is specified by the <b>Offset</b> and
<b>OffsetHigh</b> members of the
<see cref="OVERLAPPED" /> structure.</para>
      <para>The <b>WriteFileGather</b> function may return before the
write operation is complete. In that scenario, the
<b>WriteFileGather</b> function returns the value zero (0),
and the <see cref="GetLastError" /> function returns the
value <b>ERROR_IO_PENDING</b>. This asynchronous operation of the
<b>WriteFileGather</b> function lets the calling process
continue while the write operation completes. You can call the
<see cref="GetOverlappedResult" />,
<see cref="HasOverlappedIoCompleted" />, or
<see cref="GetQueuedCompletionStatus" /> function to
obtain information about the completion of the write operation. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the function returns before the write operation is complete, the function returns zero (0), and
the <see cref="GetLastError" /> function returns
<b>ERROR_IO_PENDING</b>.</para>
    </returns>
    <remarks>
      <para>This function is not supported for 32-bit applications by WOW64 on the Itanium-based systems.</para>
      <para>The <see cref="FILE_SEGMENT_ELEMENT" /> union is defined as follows:</para>
      <code>typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64   Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
</code>
      <para>Assigning a pointer to the <b>Buffer</b> member will sign-extend the value if the code is
compiled as 32-bits; this can break large-address aware applications running on systems configured with
<a href="https://docs.microsoft.com//windows/desktop/Memory/4-gigabyte-tuning">4-Gigabyte Tuning</a> or running under WOW64 on 64-bit
Windows. Therefore, use the <b>PtrToPtr64</b> macro when assigning pointers to
<b>Buffer</b>.</para>
      <para>If part of the file specified by <i>hFile</i> is locked by another process, and the write
operation overlaps the locked portion, the
<b>WriteFileGather</b> function fails.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the file handle, then the operation is transacted.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="FILE_SEGMENT_ELEMENT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetOverlappedResult" />
    <seealso cref="GetQueuedCompletionStatus" />
    <seealso cref="HasOverlappedIoCompleted" />
    <seealso cref="OVERLAPPED" />
    <seealso cref="ReadFile" />
    <seealso cref="ReadFileEx" />
    <seealso cref="ReadFileScatter" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</seealso>
  </member>
</doc>