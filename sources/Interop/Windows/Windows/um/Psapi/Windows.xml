<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.EmptyWorkingSet">
    <summary>
      <para>Removes as many pages as possible from the working set of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right and the <b>PROCESS_SET_QUOTA</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>You can also empty the working set by calling  the <see cref="SetProcessWorkingSetSize" /> or <see cref="SetProcessWorkingSetSizeEx" /> function with the <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> parameters set to the value <code>(SIZE_T)(-1)</code>.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EmptyWorkingSet</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as K32EmptyWorkingSet in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EmptyWorkingSet</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
K32EmptyWorkingSet. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso cref="SetProcessWorkingSetSize" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/working-set">Working Set</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
  <member name="Windows.K32EmptyWorkingSet">
    <summary>
      <para>Removes as many pages as possible from the working set of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right and the <b>PROCESS_SET_QUOTA</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>You can also empty the working set by calling  the <see cref="SetProcessWorkingSetSize" /> or <see cref="SetProcessWorkingSetSizeEx" /> function with the <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> parameters set to the value <code>(SIZE_T)(-1)</code>.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EmptyWorkingSet</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as K32EmptyWorkingSet in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EmptyWorkingSet</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
K32EmptyWorkingSet. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso cref="SetProcessWorkingSetSize" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/working-set">Working Set</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
  <member name="Windows.EnumDeviceDrivers">
    <summary>
      <para>Retrieves the load address for each device driver in the system.</para>
    </summary>
    <param name="lpImageBase">
      <para>An array that receives the list of load addresses for the device drivers.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>lpImageBase</i> array, in bytes. If the array is not large enough to store the load addresses, the <i>lpcbNeeded</i> parameter receives the required size of the array.</para>
    </param>
    <param name="lpcbNeeded">
      <para>The number of bytes returned in the <i>lpImageBase</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To determine how many device drivers were enumerated by the call to
<b>EnumDeviceDrivers</b>, divide the resulting value in the <i>lpcbNeeded</i> parameter by <code>sizeof(LPVOID)</code>.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32EnumDeviceDrivers</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>EnumDeviceDrivers</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32EnumDeviceDrivers</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>EnumDeviceDrivers</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="GetDeviceDriverBaseName" />
    <seealso cref="GetDeviceDriverFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32EnumDeviceDrivers">
    <summary>
      <para>Retrieves the load address for each device driver in the system.</para>
    </summary>
    <param name="lpImageBase">
      <para>An array that receives the list of load addresses for the device drivers.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>lpImageBase</i> array, in bytes. If the array is not large enough to store the load addresses, the <i>lpcbNeeded</i> parameter receives the required size of the array.</para>
    </param>
    <param name="lpcbNeeded">
      <para>The number of bytes returned in the <i>lpImageBase</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To determine how many device drivers were enumerated by the call to
<b>EnumDeviceDrivers</b>, divide the resulting value in the <i>lpcbNeeded</i> parameter by <code>sizeof(LPVOID)</code>.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32EnumDeviceDrivers</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>EnumDeviceDrivers</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32EnumDeviceDrivers</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>EnumDeviceDrivers</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="GetDeviceDriverBaseName" />
    <seealso cref="GetDeviceDriverFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.EnumPageFiles">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.EnumPageFilesA">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.EnumPageFilesW">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32EnumPageFiles">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32EnumPageFilesA">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32EnumPageFilesW">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.EnumPageFiles">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.EnumPageFilesA">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.EnumPageFilesW">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32EnumPageFiles">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32EnumPageFilesA">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32EnumPageFilesW">
    <summary>
      <para>Calls the callback routine for each installed pagefile in the system.</para>
    </summary>
    <param name="pCallBackRoutine">
      <para>A pointer to the routine called for each pagefile. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</a>.</para>
    </param>
    <param name="pContext">
      <para>The user-defined data passed to the callback routine.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumPageFiles</b> in Psapi.h and exported in Kernel32.lib and
Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as
<b>EnumPageFiles</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumPageFiles</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>EnumPageFiles</b>. To
ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b></para>
      <para>macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load
Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines EnumPageFiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/psapi/nc-psapi-penum_page_file_callbacka">EnumPageFilesProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.EnumProcesses">
    <summary>
      <para>Retrieves the process identifier for each process object in the system.</para>
    </summary>
    <param name="lpidProcess">
      <para>A pointer to an array that receives the list of process identifiers.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>pProcessIds</i> array, in bytes.</para>
    </param>
    <param name="lpcbNeeded">
      <para>The number of bytes returned in the <i>pProcessIds</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is a good idea to use a large array, because it is hard to predict how many processes there will be at the time you call
<b>EnumProcesses</b>.</para>
      <para>To determine how many processes were enumerated, divide the <i>lpcbNeeded</i> value by sizeof(DWORD). There is no indication given when the buffer is too small to store all process identifiers. Therefore, if <i>lpcbNeeded</i> equals <i>cb</i>, consider retrying the call with a larger array.</para>
      <para>To obtain process handles for the processes whose identifiers you have just obtained, call the <see cref="OpenProcess" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32EnumProcesses</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>EnumProcesses</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32EnumProcesses</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>EnumProcesses</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a> or
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
    </remarks>
    <seealso cref="CreateToolhelp32Snapshot" />
    <seealso cref="OpenProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
  </member>
  <member name="Windows.K32EnumProcesses">
    <summary>
      <para>Retrieves the process identifier for each process object in the system.</para>
    </summary>
    <param name="lpidProcess">
      <para>A pointer to an array that receives the list of process identifiers.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>pProcessIds</i> array, in bytes.</para>
    </param>
    <param name="lpcbNeeded">
      <para>The number of bytes returned in the <i>pProcessIds</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is a good idea to use a large array, because it is hard to predict how many processes there will be at the time you call
<b>EnumProcesses</b>.</para>
      <para>To determine how many processes were enumerated, divide the <i>lpcbNeeded</i> value by sizeof(DWORD). There is no indication given when the buffer is too small to store all process identifiers. Therefore, if <i>lpcbNeeded</i> equals <i>cb</i>, consider retrying the call with a larger array.</para>
      <para>To obtain process handles for the processes whose identifiers you have just obtained, call the <see cref="OpenProcess" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32EnumProcesses</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>EnumProcesses</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32EnumProcesses</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>EnumProcesses</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a> or
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
    </remarks>
    <seealso cref="CreateToolhelp32Snapshot" />
    <seealso cref="OpenProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
  </member>
  <member name="Windows.EnumProcessModules">
    <summary>
      <para>Retrieves a handle for each module in the specified process.</para>
      <para>To control whether a 64-bit application enumerates 32-bit modules, 64-bit modules, or both types of modules, use
the <see cref="EnumProcessModulesEx" /> function.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process.</para>
    </param>
    <param name="lphModule">
      <para>An array that receives the list of module handles.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>lphModule</i> array, in bytes.</para>
    </param>
    <param name="lpcbNeeded">
      <para>The number of bytes required to store all module handles in the <i>lphModule</i></para>
      <para>array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EnumProcessModules</b> function is primarily
designed for use by debuggers and similar applications that must extract module information from another process.
If the module list in the target process is corrupted or not yet initialized, or if the module list changes during
the function call as a result of DLLs being loaded or unloaded,
<b>EnumProcessModules</b> may fail or return incorrect
information.</para>
      <para>It is a good idea to specify a large array of <b>HMODULE</b> values, because it is hard
to predict how many modules there will be in the process at the time you call
<b>EnumProcessModules</b>. To determine if the
<i>lphModule</i> array is too small to hold all module handles for the process, compare the
value returned in <i>lpcbNeeded</i> with the value specified in <i>cb</i>.
If <i>lpcbNeeded</i> is greater than <i>cb</i>, increase the size of the
array and call <b>EnumProcessModules</b> again.</para>
      <para>To determine how many modules were enumerated by the call to
<b>EnumProcessModules</b>, divide the resulting value in
the <i>lpcbNeeded</i> parameter by
<code>sizeof(HMODULE)</code>.</para>
      <para>The <b>EnumProcessModules</b> function does not
retrieve handles for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> or similar  flags.
For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Do not call <see cref="CloseHandle" /> on any of the handles returned
by this function. The information comes from a snapshot, so there are no resources to be freed.</para>
      <para>If this function is called from a 32-bit application running on WOW64, it can only enumerate the modules of a
32-bit process. If the process is a 64-bit process, this function fails and the last error code is
<b>ERROR_PARTIAL_COPY</b> (299).</para>
      <para>To take a snapshot of specified processes and the heaps, modules, and threads used by these processes, use the
<see cref="CreateToolhelp32Snapshot" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumProcessModules</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>EnumProcessModules</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumProcessModules</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as
<b>EnumProcessModules</b>. To ensure correct resolution
of symbols, add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the
program with <b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load
Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a> or
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
    </remarks>
    <seealso cref="CreateToolhelp32Snapshot" />
    <seealso cref="EnumProcessModulesEx" />
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32EnumProcessModules">
    <summary>
      <para>Retrieves a handle for each module in the specified process.</para>
      <para>To control whether a 64-bit application enumerates 32-bit modules, 64-bit modules, or both types of modules, use
the <see cref="EnumProcessModulesEx" /> function.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process.</para>
    </param>
    <param name="lphModule">
      <para>An array that receives the list of module handles.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>lphModule</i> array, in bytes.</para>
    </param>
    <param name="lpcbNeeded">
      <para>The number of bytes required to store all module handles in the <i>lphModule</i></para>
      <para>array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EnumProcessModules</b> function is primarily
designed for use by debuggers and similar applications that must extract module information from another process.
If the module list in the target process is corrupted or not yet initialized, or if the module list changes during
the function call as a result of DLLs being loaded or unloaded,
<b>EnumProcessModules</b> may fail or return incorrect
information.</para>
      <para>It is a good idea to specify a large array of <b>HMODULE</b> values, because it is hard
to predict how many modules there will be in the process at the time you call
<b>EnumProcessModules</b>. To determine if the
<i>lphModule</i> array is too small to hold all module handles for the process, compare the
value returned in <i>lpcbNeeded</i> with the value specified in <i>cb</i>.
If <i>lpcbNeeded</i> is greater than <i>cb</i>, increase the size of the
array and call <b>EnumProcessModules</b> again.</para>
      <para>To determine how many modules were enumerated by the call to
<b>EnumProcessModules</b>, divide the resulting value in
the <i>lpcbNeeded</i> parameter by
<code>sizeof(HMODULE)</code>.</para>
      <para>The <b>EnumProcessModules</b> function does not
retrieve handles for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> or similar  flags.
For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Do not call <see cref="CloseHandle" /> on any of the handles returned
by this function. The information comes from a snapshot, so there are no resources to be freed.</para>
      <para>If this function is called from a 32-bit application running on WOW64, it can only enumerate the modules of a
32-bit process. If the process is a 64-bit process, this function fails and the last error code is
<b>ERROR_PARTIAL_COPY</b> (299).</para>
      <para>To take a snapshot of specified processes and the heaps, modules, and threads used by these processes, use the
<see cref="CreateToolhelp32Snapshot" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32EnumProcessModules</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>EnumProcessModules</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32EnumProcessModules</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as
<b>EnumProcessModules</b>. To ensure correct resolution
of symbols, add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the
program with <b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load
Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a> or
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
    </remarks>
    <seealso cref="CreateToolhelp32Snapshot" />
    <seealso cref="EnumProcessModulesEx" />
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.EnumProcessModulesEx">
    <summary>
      <para>Retrieves a handle for each module in the specified process that meets the specified filter criteria.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process.</para>
    </param>
    <param name="lphModule">
      <para>An array that receives the list of module handles.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>lphModule</i> array, in bytes.</para>
    </param>
    <param name="lpcbNeeded">
      <para>The number of bytes required to store all module handles in the <i>lphModule</i> array.</para>
    </param>
    <param name="dwFilterFlag">
      <para>The filter criteria. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LIST_MODULES_32BIT</b>
                </description>
              </item>
              <item>
                <description>0x01</description>
              </item>
            </list>
          </description>
          <description>
            <para>List the 32-bit modules.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LIST_MODULES_64BIT</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>List the 64-bit modules.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LIST_MODULES_ALL</b>
                </description>
              </item>
              <item>
                <description>0x03</description>
              </item>
            </list>
          </description>
          <description>
            <para>List all modules.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LIST_MODULES_DEFAULT</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Use the default behavior.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EnumProcessModulesEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>EnumProcessModulesEx</b> may fail or return incorrect information.</para>
      <para>This function is intended primarily for 64-bit applications. If the function is called by a 32-bit application running under WOW64, the <i>dwFilterFlag</i> option is ignored and the function provides the same results as the <see cref="EnumProcessModules" /> function.</para>
      <para>It is a good idea to specify a large array of <b>HMODULE</b> values, because it is hard to predict how many modules there will be in the process at the time you call
<b>EnumProcessModulesEx</b>. To determine if the <i>lphModule</i> array is too small to hold all module handles for the process, compare the value returned in <i>lpcbNeeded</i> with the value specified in <i>cb</i>. If <i>lpcbNeeded</i> is greater than <i>cb</i>, increase the size of the array and call
<b>EnumProcessModulesEx</b> again.</para>
      <para>To determine how many modules were enumerated by the call to
<b>EnumProcessModulesEx</b>, divide the resulting value in the <i>lpcbNeeded</i> parameter by <code>sizeof(HMODULE)</code>.</para>
      <para>The <b>EnumProcessModulesEx</b> function does not retrieve handles for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Do not call <see cref="CloseHandle" /> on any of the handles returned by this function. The information comes from a snapshot, so there are no resources to be freed.</para>
      <para>To take a snapshot of specified processes and the heaps, modules, and threads used by these processes, use the <see cref="CreateToolhelp32Snapshot" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32EnumProcessModulesEx</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>EnumProcessModulesEx</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32EnumProcessModulesEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>EnumProcessModulesEx</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="CreateToolhelp32Snapshot" />
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32EnumProcessModulesEx">
    <summary>
      <para>Retrieves a handle for each module in the specified process that meets the specified filter criteria.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process.</para>
    </param>
    <param name="lphModule">
      <para>An array that receives the list of module handles.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>lphModule</i> array, in bytes.</para>
    </param>
    <param name="lpcbNeeded">
      <para>The number of bytes required to store all module handles in the <i>lphModule</i> array.</para>
    </param>
    <param name="dwFilterFlag">
      <para>The filter criteria. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LIST_MODULES_32BIT</b>
                </description>
              </item>
              <item>
                <description>0x01</description>
              </item>
            </list>
          </description>
          <description>
            <para>List the 32-bit modules.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LIST_MODULES_64BIT</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>List the 64-bit modules.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LIST_MODULES_ALL</b>
                </description>
              </item>
              <item>
                <description>0x03</description>
              </item>
            </list>
          </description>
          <description>
            <para>List all modules.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LIST_MODULES_DEFAULT</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Use the default behavior.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EnumProcessModulesEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>EnumProcessModulesEx</b> may fail or return incorrect information.</para>
      <para>This function is intended primarily for 64-bit applications. If the function is called by a 32-bit application running under WOW64, the <i>dwFilterFlag</i> option is ignored and the function provides the same results as the <see cref="EnumProcessModules" /> function.</para>
      <para>It is a good idea to specify a large array of <b>HMODULE</b> values, because it is hard to predict how many modules there will be in the process at the time you call
<b>EnumProcessModulesEx</b>. To determine if the <i>lphModule</i> array is too small to hold all module handles for the process, compare the value returned in <i>lpcbNeeded</i> with the value specified in <i>cb</i>. If <i>lpcbNeeded</i> is greater than <i>cb</i>, increase the size of the array and call
<b>EnumProcessModulesEx</b> again.</para>
      <para>To determine how many modules were enumerated by the call to
<b>EnumProcessModulesEx</b>, divide the resulting value in the <i>lpcbNeeded</i> parameter by <code>sizeof(HMODULE)</code>.</para>
      <para>The <b>EnumProcessModulesEx</b> function does not retrieve handles for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Do not call <see cref="CloseHandle" /> on any of the handles returned by this function. The information comes from a snapshot, so there are no resources to be freed.</para>
      <para>To take a snapshot of specified processes and the heaps, modules, and threads used by these processes, use the <see cref="CreateToolhelp32Snapshot" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32EnumProcessModulesEx</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>EnumProcessModulesEx</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32EnumProcessModulesEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>EnumProcessModulesEx</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="CreateToolhelp32Snapshot" />
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverBaseName">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpFilename">
      <para>TBD</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
      <h4>- lpBaseName [out]</h4>
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverBaseNameA">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpFilename">
      <para>TBD</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
      <h4>- lpBaseName [out]</h4>
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverBaseNameW">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpFilename">
      <para>TBD</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
      <h4>- lpBaseName [out]</h4>
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverBaseName">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpFilename">
      <para>TBD</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
      <h4>- lpBaseName [out]</h4>
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverBaseNameA">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpFilename">
      <para>TBD</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
      <h4>- lpBaseName [out]</h4>
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverBaseNameW">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpFilename">
      <para>TBD</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
      <h4>- lpBaseName [out]</h4>
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverBaseName">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverBaseNameA">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverBaseNameW">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverBaseName">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverBaseNameA">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverBaseNameW">
    <summary>
      <para>Retrieves the base name of the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver. This value can be retrieved using the
<see cref="EnumDeviceDrivers" /></para>
      <para>function.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters. If the buffer is not large enough to store the base name plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverBaseName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverBaseName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverBaseName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-device-drivers-in-the-system">Enumerating all Device Drivers in the System</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverFileName">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverFileNameA">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverFileNameW">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverFileName">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverFileNameA">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverFileNameW">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverFileName">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverFileNameA">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetDeviceDriverFileNameW">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverFileName">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverFileNameA">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetDeviceDriverFileNameW">
    <summary>
      <para>Retrieves the path available for the specified device driver.</para>
    </summary>
    <param name="ImageBase">
      <para>The load address of the device driver.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the path to the device driver.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters. If the buffer is not large enough to store the path plus the terminating null character, the string is truncated.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, not including any terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects  the name used to call the function and the library that a program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as <b>K32GetDeviceDriverFileName</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If PSAPI_VERSION is 1, this function is defined as <b>GetDeviceDriverFileName</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetDeviceDriverFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>GetDeviceDriverFileName</b>. To ensure correct resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with –DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetDeviceDriverFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/device-driver-information">Device Driver Information</seealso>
    <seealso cref="EnumDeviceDrivers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetMappedFileName">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetMappedFileNameA">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetMappedFileNameW">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetMappedFileName">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetMappedFileNameA">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetMappedFileNameW">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetMappedFileName">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access rightF. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetMappedFileNameA">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access rightF. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetMappedFileNameW">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access rightF. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetMappedFileName">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access rightF. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetMappedFileNameA">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access rightF. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetMappedFileNameW">
    <summary>
      <para>Checks whether the specified address is within a memory-mapped file in the address space of the specified process. If so, the function returns the name of the memory-mapped file.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access rightF. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpv">
      <para>The address to be verified.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the buffer that receives the name of the memory-mapped file to which the address specified by <i>lpv</i> belongs.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetMappedFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetMappedFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetMappedFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetMappedFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetMappedFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/memory-mapped-file-information">Memory-Mapped File Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetModuleBaseName">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.GetModuleBaseNameA">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.GetModuleBaseNameW">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.K32GetModuleBaseName">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.K32GetModuleBaseNameA">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.K32GetModuleBaseNameW">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.GetModuleBaseName">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.GetModuleBaseNameA">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.GetModuleBaseNameW">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.K32GetModuleBaseName">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.K32GetModuleBaseNameA">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.K32GetModuleBaseNameW">
    <summary>
      <para>Retrieves the base name of the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, this function  returns the name of the file used to create the calling process.</para>
    </param>
    <param name="lpBaseName">
      <para>A pointer to the buffer that receives the base name of the module. If the base name is longer than maximum number of characters specified by the <i>nSize</i> parameter, the base name is truncated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpBaseName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer, in characters.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleBaseName</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleBaseName</b> may fail or return incorrect information.</para>
      <para>To retrieve the base name of a module in the current process, use the <see cref="GetModuleFileName" /> function to retrieve the full module name and then use a function call such as <code>strrchr(szmodulename, '\')</code> to scan to the beginning of the base name within the module name string. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a handle to the current process.</para>
      <para>To retrieve the base name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function to retrieve the module name and then use the <code>strrchr</code> function as described in the previous paragraph. This is more efficient and more reliable than calling  <b>GetModuleBaseName</b>  with a NULL module handle.</para>
      <para>The <b>GetModuleBaseName</b> function does not retrieve the base name for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleBaseName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleBaseName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleBaseName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleBaseName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-processes">Enumerating All Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleBaseName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//cpp/c-runtime-library/reference/strrchr-wcsrchr-mbsrchr-mbsrchr-l">strrchr, wcsrchr, _mbsrchr, _mbsrchr_l</seealso>
  </member>
  <member name="Windows.GetModuleFileNameEx">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetModuleFileNameExA">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetModuleFileNameExW">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetModuleFileNameEx">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetModuleFileNameExA">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetModuleFileNameExW">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetModuleFileNameEx">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetModuleFileNameExA">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetModuleFileNameExW">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetModuleFileNameEx">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetModuleFileNameExA">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetModuleFileNameExW">
    <summary>
      <para>Retrieves the fully qualified path for the file containing the specified module.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>The <b>GetModuleFileNameEx</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module. If this parameter is NULL, <b>GetModuleFileNameEx</b> returns the path of the executable file of the process specified in <i>hProcess</i>.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the <i>nSize</i> parameter, the function succeeds but the file name is truncated and null-terminated.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetModuleFileNameEx</b> function is primarily designed for use by debuggers and similar applications that must extract module information from another process. If the module list in the target process is corrupted or is not yet initialized, or if the module list changes during the function call as a result of DLLs being loaded or unloaded, <b>GetModuleFileNameEx</b> may fail or return incorrect information.</para>
      <para>To retrieve the name of a module in the current process, use the <see cref="GetModuleFileName" /> function. This is more efficient and more reliable than calling <b>GetModuleFileNameEx</b> with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process, use the <see cref="GetProcessImageFileName" /> or <see cref="QueryFullProcessImageName" /> function. This is more efficient and more reliable than calling the <b>GetModuleFileNameEx</b> function with a NULL module handle.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleFileNameEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetModuleFileNameEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleFileNameEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetModuleFileNameEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/enumerating-all-modules-for-a-process">Enumerating All Modules for a Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetModuleFileNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetModuleBaseName" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetModuleInformation">
    <summary>
      <para>Retrieves information about the specified module in the
<see cref="MODULEINFO" /> structure.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module.</para>
    </param>
    <param name="lpmodinfo">
      <para>A pointer to the
<see cref="MODULEINFO" /> structure that receives information about the module.</para>
    </param>
    <param name="cb">
      <para>The size of the
<see cref="MODULEINFO" /> structure, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To get information for the calling process, pass the handle returned by <see cref="GetCurrentProcess" />.</para>
      <para>The <b>GetModuleInformation</b> function does not retrieve information for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleInformation</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as K32GetModuleInformation in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleInformation</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
K32GetModuleInformation. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="MODULEINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetModuleInformation">
    <summary>
      <para>Retrieves information about the specified module in the
<see cref="MODULEINFO" /> structure.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process that contains the module.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="hModule">
      <para>A handle to the module.</para>
    </param>
    <param name="lpmodinfo">
      <para>A pointer to the
<see cref="MODULEINFO" /> structure that receives information about the module.</para>
    </param>
    <param name="cb">
      <para>The size of the
<see cref="MODULEINFO" /> structure, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To get information for the calling process, pass the handle returned by <see cref="GetCurrentProcess" />.</para>
      <para>The <b>GetModuleInformation</b> function does not retrieve information for modules that were loaded with the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetModuleInformation</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as K32GetModuleInformation in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetModuleInformation</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
K32GetModuleInformation. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="MODULEINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/module-information">Module Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetPerformanceInfo">
    <summary>
      <para>Retrieves the performance values contained in the
<see cref="PERFORMANCE_INFORMATION" /></para>
      <para>structure.</para>
    </summary>
    <param name="pPerformanceInformation">
      <para>A pointer to a
<see cref="PERFORMANCE_INFORMATION" /></para>
      <para>structure that receives the performance information.</para>
    </param>
    <param name="cb">
      <para>The size of the
<see cref="PERFORMANCE_INFORMATION" /> structure, in
bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. To get
extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for
the PSAPI functions. The PSAPI version number affects the name used to call the function and the library that a
program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as
<b>K32GetPerformanceInfo</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If
PSAPI_VERSION is 1, this function is defined as
<b>GetPerformanceInfo</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetPerformanceInfo</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as
<b>GetPerformanceInfo</b>. To ensure correct resolution
of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with
–DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa965225(v=vs.85)">Memory Performance Information</seealso>
    <seealso cref="PERFORMANCE_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.K32GetPerformanceInfo">
    <summary>
      <para>Retrieves the performance values contained in the
<see cref="PERFORMANCE_INFORMATION" /></para>
      <para>structure.</para>
    </summary>
    <param name="pPerformanceInformation">
      <para>A pointer to a
<see cref="PERFORMANCE_INFORMATION" /></para>
      <para>structure that receives the performance information.</para>
    </param>
    <param name="cb">
      <para>The size of the
<see cref="PERFORMANCE_INFORMATION" /> structure, in
bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. To get
extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for
the PSAPI functions. The PSAPI version number affects the name used to call the function and the library that a
program must load.</para>
      <para>If PSAPI_VERSION is 2 or greater, this function is defined as
<b>K32GetPerformanceInfo</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If
PSAPI_VERSION is 1, this function is defined as
<b>GetPerformanceInfo</b> in Psapi.h and exported in
Psapi.lib and Psapi.dll as a wrapper that calls <b>K32GetPerformanceInfo</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as
<b>GetPerformanceInfo</b>. To ensure correct resolution
of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program with
–DPSAPI_VERSION=1. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa965225(v=vs.85)">Memory Performance Information</seealso>
    <seealso cref="PERFORMANCE_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
  </member>
  <member name="Windows.GetProcessImageFileName">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.GetProcessImageFileNameA">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.GetProcessImageFileNameW">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.K32GetProcessImageFileName">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.K32GetProcessImageNameA">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.K32GetProcessImageNameW">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.GetProcessImageFileName">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.GetProcessImageFileNameA">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.GetProcessImageFileNameW">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.K32GetProcessImageFileName">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.K32GetProcessImageNameA">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.K32GetProcessImageNameW">
    <summary>
      <para>Retrieves the name of the executable file for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b>  or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpImageFileName">
      <para>A pointer to a buffer that receives the full path to the executable file.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpImageFileName</i> buffer, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the length of the string copied to the buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The file Psapi.dll is installed in the %windir%\System32 directory. If there is another copy of this DLL on your computer, it can lead to the following error when running applications on your system: "The procedure entry point GetProcessImageFileName could not be located in the dynamic link library PSAPI.DLL." To work around this problem, locate any versions that are not in the %windir%\System32 directory and delete or rename them, then restart.</para>
      <para>The <b>GetProcessImageFileName</b> function returns the path in device form, rather than drive letters. For example, the file name C:\Windows\System32\Ctype.nls would look as follows in device form:</para>
      <para>\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls</para>
      <para>To retrieve the module name of the current process, use the <see cref="GetModuleFileName" /> function with a NULL module handle. This is more efficient than calling the <b>GetProcessImageFileName</b> function with a handle to the current process.</para>
      <para>To retrieve the name of the main executable module for a remote process in win32 path format, use the <see cref="QueryFullProcessImageName" /> function.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessImageFileName</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessImageFileName</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessImageFileName</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessImageFileName</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <blockquote>
        <para>[!NOTE]
The psapi.h header defines GetProcessImageFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-information">Process Information</seealso>
    <seealso cref="QueryFullProcessImageName" />
  </member>
  <member name="Windows.GetProcessMemoryInfo">
    <summary>
      <para>Retrieves information about the memory usage of the specified process.</para>
    </summary>
    <param name="Process">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>**Windows Server 2003 and Windows XP:  **The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights.</para>
    </param>
    <param name="ppsmemCounters">
      <para>A pointer to the
<see cref="PROCESS_MEMORY_COUNTERS" /> or <see cref="PROCESS_MEMORY_COUNTERS_EX" /> structure that receives information about the memory usage of the process.</para>
    </param>
    <param name="cb">
      <para>The size of the
<i>ppsmemCounters</i> structure, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessMemoryInfo</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessMemoryInfo</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessMemoryInfo</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessMemoryInfo</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/collecting-memory-usage-information-for-a-process">Collecting Memory Usage Information for a Process</a>.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa965225(v=vs.85)">Memory Performance Information</seealso>
    <seealso cref="PROCESS_MEMORY_COUNTERS" />
    <seealso cref="PROCESS_MEMORY_COUNTERS_EX" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-memory-usage-information">Process Memory Usage Information</seealso>
  </member>
  <member name="Windows.K32GetProcessMemoryInfo">
    <summary>
      <para>Retrieves information about the memory usage of the specified process.</para>
    </summary>
    <param name="Process">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>**Windows Server 2003 and Windows XP:  **The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and <b>PROCESS_VM_READ</b> access rights.</para>
    </param>
    <param name="ppsmemCounters">
      <para>A pointer to the
<see cref="PROCESS_MEMORY_COUNTERS" /> or <see cref="PROCESS_MEMORY_COUNTERS_EX" /> structure that receives information about the memory usage of the process.</para>
    </param>
    <param name="cb">
      <para>The size of the
<i>ppsmemCounters</i> structure, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetProcessMemoryInfo</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetProcessMemoryInfo</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetProcessMemoryInfo</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetProcessMemoryInfo</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/psapi/collecting-memory-usage-information-for-a-process">Collecting Memory Usage Information for a Process</a>.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa965225(v=vs.85)">Memory Performance Information</seealso>
    <seealso cref="PROCESS_MEMORY_COUNTERS" />
    <seealso cref="PROCESS_MEMORY_COUNTERS_EX" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/process-memory-usage-information">Process Memory Usage Information</seealso>
  </member>
  <member name="Windows.GetWsChanges">
    <summary>
      <para>Retrieves information about the pages that have been added to the working set of the specified
process since the last time this function or the
<see cref="InitializeProcessForWsWatch" /> function was
called.</para>
      <para>To retrieve extended information, use the
<see cref="GetWsChangesEx" /> function.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b></para>
      <para>access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpWatchInfo">
      <para>A pointer to a user-allocated buffer that receives an array of
<see cref="PSAPI_WS_WATCH_INFORMATION" /> structures.
The array is terminated with a structure whose <b>FaultingPc</b> member is NULL.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>lpWatchInfo</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>
        <see cref="GetLastError" /> returns
<b>ERROR_INSUFFICIENT_BUFFER</b> if the <i>lpWatchInfo</i> buffer is not
large enough to contain all the working set change records; the buffer is returned empty. Reallocate a larger
block of memory for the buffer and call again.</para>
    </returns>
    <remarks>
      <para>The operating system uses one buffer per process to maintain working set change records. If more than one
application (or multiple threads in the same application) calls this function with the same process handle,
neither application will have a complete accounting of the working set changes because each call empties the
buffer.</para>
      <para>The operating system does not record new change records while it is processing the query (and emptying the
buffer). The function sets the error code to <b>NO_MORE_ENTRIES</b> if a concurrent query is
received while it is processing another query.</para>
      <para>If the buffer becomes full, no new records are added to the buffer until this function or the
<see cref="InitializeProcessForWsWatch" /> function is
called. You should call this method with enough frequency to prevent possible data loss. If records are lost, the
array is terminated with a structure whose <b>FaultingPc</b> member is NULL and whose
<b>FaultingVa</b> member is set to the number of records that were lost.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If records are lost, the array is terminated with a structure whose <b>FaultingPc</b></para>
      <para>member is NULL and whose <b>FaultingVa</b> member is 1.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetWsChanges</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetWsChanges</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetWsChanges</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetWsChanges</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="InitializeProcessForWsWatch" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso cref="PSAPI_WS_WATCH_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
  <member name="Windows.K32GetWsChanges">
    <summary>
      <para>Retrieves information about the pages that have been added to the working set of the specified
process since the last time this function or the
<see cref="InitializeProcessForWsWatch" /> function was
called.</para>
      <para>To retrieve extended information, use the
<see cref="GetWsChangesEx" /> function.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b></para>
      <para>access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpWatchInfo">
      <para>A pointer to a user-allocated buffer that receives an array of
<see cref="PSAPI_WS_WATCH_INFORMATION" /> structures.
The array is terminated with a structure whose <b>FaultingPc</b> member is NULL.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>lpWatchInfo</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>
        <see cref="GetLastError" /> returns
<b>ERROR_INSUFFICIENT_BUFFER</b> if the <i>lpWatchInfo</i> buffer is not
large enough to contain all the working set change records; the buffer is returned empty. Reallocate a larger
block of memory for the buffer and call again.</para>
    </returns>
    <remarks>
      <para>The operating system uses one buffer per process to maintain working set change records. If more than one
application (or multiple threads in the same application) calls this function with the same process handle,
neither application will have a complete accounting of the working set changes because each call empties the
buffer.</para>
      <para>The operating system does not record new change records while it is processing the query (and emptying the
buffer). The function sets the error code to <b>NO_MORE_ENTRIES</b> if a concurrent query is
received while it is processing another query.</para>
      <para>If the buffer becomes full, no new records are added to the buffer until this function or the
<see cref="InitializeProcessForWsWatch" /> function is
called. You should call this method with enough frequency to prevent possible data loss. If records are lost, the
array is terminated with a structure whose <b>FaultingPc</b> member is NULL and whose
<b>FaultingVa</b> member is set to the number of records that were lost.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If records are lost, the array is terminated with a structure whose <b>FaultingPc</b></para>
      <para>member is NULL and whose <b>FaultingVa</b> member is 1.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetWsChanges</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetWsChanges</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetWsChanges</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetWsChanges</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="InitializeProcessForWsWatch" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso cref="PSAPI_WS_WATCH_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
  <member name="Windows.GetWsChangesEx">
    <summary>
      <para>Retrieves extended information about the pages that have been added to the working set of the specified process since the
last time this function or the <see cref="InitializeProcessForWsWatch" /> function was called.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpWatchInfoEx">
      <para>A pointer to a user-allocated buffer that receives an array of
<see cref="PSAPI_WS_WATCH_INFORMATION_EX" /> structures. The array is terminated with a structure whose <b>FaultingPc</b> member is NULL.</para>
    </param>
    <param name="cb">
      <para>The size of the
<i>lpWatchInfoEx</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
the <see cref="GetLastError" /> function.</para>
      <para>The <see cref="GetLastError" /> function returns <b>ERROR_INSUFFICIENT_BUFFER</b> if the <i>lpWatchInfoEx</i> buffer is not large enough to contain all the working set change records; the buffer is returned empty. Reallocate a larger block of memory for the buffer and call again.</para>
    </returns>
    <remarks>
      <para>The operating system uses one buffer per process to maintain working set change records. If more than one application (or multiple threads in the same application) calls this function with the same process handle, neither application will have a complete accounting of the working set changes because each call empties the buffer.</para>
      <para>The operating system does not record new change records while it is processing the query (and emptying the buffer). This function sets the error code to <b>NO_MORE_ENTRIES</b> if a concurrent query is received while it is processing another query.</para>
      <para>If the buffer becomes full, no new records are added to the buffer until this function or the <see cref="InitializeProcessForWsWatch" /> function is called. You should call <b>GetWsChangesEx</b> with enough frequency to prevent possible data loss. If records are lost, the array is terminated with a structure whose <b>FaultingPc</b> member is NULL and whose <b>FaultingVa</b> member is set to the number of records that were lost.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetWsChangesEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetWsChangesEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetWsChangesEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetWsChangesEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="InitializeProcessForWsWatch" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso cref="PSAPI_WS_WATCH_INFORMATION_EX" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
  <member name="Windows.K32GetWsChangesEx">
    <summary>
      <para>Retrieves extended information about the pages that have been added to the working set of the specified process since the
last time this function or the <see cref="InitializeProcessForWsWatch" /> function was called.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpWatchInfoEx">
      <para>A pointer to a user-allocated buffer that receives an array of
<see cref="PSAPI_WS_WATCH_INFORMATION_EX" /> structures. The array is terminated with a structure whose <b>FaultingPc</b> member is NULL.</para>
    </param>
    <param name="cb">
      <para>The size of the
<i>lpWatchInfoEx</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
the <see cref="GetLastError" /> function.</para>
      <para>The <see cref="GetLastError" /> function returns <b>ERROR_INSUFFICIENT_BUFFER</b> if the <i>lpWatchInfoEx</i> buffer is not large enough to contain all the working set change records; the buffer is returned empty. Reallocate a larger block of memory for the buffer and call again.</para>
    </returns>
    <remarks>
      <para>The operating system uses one buffer per process to maintain working set change records. If more than one application (or multiple threads in the same application) calls this function with the same process handle, neither application will have a complete accounting of the working set changes because each call empties the buffer.</para>
      <para>The operating system does not record new change records while it is processing the query (and emptying the buffer). This function sets the error code to <b>NO_MORE_ENTRIES</b> if a concurrent query is received while it is processing another query.</para>
      <para>If the buffer becomes full, no new records are added to the buffer until this function or the <see cref="InitializeProcessForWsWatch" /> function is called. You should call <b>GetWsChangesEx</b> with enough frequency to prevent possible data loss. If records are lost, the array is terminated with a structure whose <b>FaultingPc</b> member is NULL and whose <b>FaultingVa</b> member is set to the number of records that were lost.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32GetWsChangesEx</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>GetWsChangesEx</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32GetWsChangesEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>GetWsChangesEx</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="InitializeProcessForWsWatch" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso cref="PSAPI_WS_WATCH_INFORMATION_EX" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
  <member name="Windows.InitializeProcessForWsWatch">
    <summary>
      <para>Initiates monitoring of the working set of the specified process. You must call this function before calling the
<see cref="GetWsChanges" /> function.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32InitializeProcessForWsWatch</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>InitializeProcessForWsWatch</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32InitializeProcessForWsWatch</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>InitializeProcessForWsWatch</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetWsChanges" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
  <member name="Windows.K32InitializeProcessForWsWatch">
    <summary>
      <para>Initiates monitoring of the working set of the specified process. You must call this function before calling the
<see cref="GetWsChanges" /> function.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32InitializeProcessForWsWatch</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>InitializeProcessForWsWatch</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32InitializeProcessForWsWatch</b>.</para>
      <para>Programs that must run on earlier versions of Windows as
well as Windows 7 and later versions should always call this function as
<b>InitializeProcessForWsWatch</b>. To ensure correct resolution of symbols,
add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso cref="GetWsChanges" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
  <member name="Windows.K32QueryWorkingSet">
    <summary>
      <para>Retrieves information about the pages currently added to the working set of the specified
process.</para>
      <para>To retrieve working set information for a subset of virtual addresses, or to retrieve information about pages
that are not part of the working set (such as AWE or large pages), use the
<see cref="QueryWorkingSetEx" /> function.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and
<b>PROCESS_VM_READ</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="pv">
      <para>A pointer to the buffer that receives the information. For more information, see
<see cref="PSAPI_WORKING_SET_INFORMATION" />.</para>
      <para>If the buffer pointed to by the <i>pv</i> parameter is not large enough to contain all
working set entries for the target process, the function fails with <b>ERROR_BAD_LENGTH</b>.
In this case, the <b>NumberOfEntries</b> member of the
<see cref="PSAPI_WORKING_SET_INFORMATION" /></para>
      <para>structure is set to the required number of entries, but the function does not return information about the
working set entries.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>pv</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32QueryWorkingSet</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>QueryWorkingSet</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32QueryWorkingSet</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>QueryWorkingSet</b>.
To ensure correct resolution of symbols, add Psapi.lib to the
<b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load
Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso cref="PSAPI_WORKING_SET_INFORMATION" />
    <seealso cref="QueryWorkingSetEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
  <member name="Windows.QueryWorkingSet">
    <summary>
      <para>Retrieves information about the pages currently added to the working set of the specified
process.</para>
      <para>To retrieve working set information for a subset of virtual addresses, or to retrieve information about pages
that are not part of the working set (such as AWE or large pages), use the
<see cref="QueryWorkingSetEx" /> function.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> and
<b>PROCESS_VM_READ</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="pv">
      <para>A pointer to the buffer that receives the information. For more information, see
<see cref="PSAPI_WORKING_SET_INFORMATION" />.</para>
      <para>If the buffer pointed to by the <i>pv</i> parameter is not large enough to contain all
working set entries for the target process, the function fails with <b>ERROR_BAD_LENGTH</b>.
In this case, the <b>NumberOfEntries</b> member of the
<see cref="PSAPI_WORKING_SET_INFORMATION" /></para>
      <para>structure is set to the required number of entries, but the function does not return information about the
working set entries.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>pv</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes
version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and
the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as
<b>K32QueryWorkingSet</b> in Psapi.h and exported in
Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this
function is defined as <b>QueryWorkingSet</b> in
Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls
<b>K32QueryWorkingSet</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions
should always call this function as <b>QueryWorkingSet</b>.
To ensure correct resolution of symbols, add Psapi.lib to the
<b>TARGETLIBS</b> macro and compile the program with
<b>-DPSAPI_VERSION=1</b>. To use run-time dynamic linking, load
Psapi.dll.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso cref="PSAPI_WORKING_SET_INFORMATION" />
    <seealso cref="QueryWorkingSetEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
  <member name="Windows.K32QueryWorkingSetEx">
    <summary>
      <para>Retrieves extended information about the pages at specific virtual addresses in the address space of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="pv">
      <para>A pointer to an array of <see cref="PSAPI_WORKING_SET_EX_INFORMATION" /> structures. On input, each item in the array specifies a virtual address of interest. On output, each item in the array receives information about the corresponding virtual page.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>pv</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Unlike the <see cref="QueryWorkingSet" /> function, which is limited to the working set of the target process, the <b>QueryWorkingSetEx</b> function can be used to query addresses that are not in the process working set but are still part of the process, such as AWE and large pages.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as <b>K32QueryWorkingSetEx</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as <b>QueryWorkingSetEx</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32QueryWorkingSetEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>QueryWorkingSetEx</b>. To ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with "–DPSAPI_VERSION=1". To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/Memory/allocating-memory-from-a-numa-node">Allocating Memory from a NUMA Node</a>.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso cref="PSAPI_WORKING_SET_EX_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
  <member name="Windows.QueryWorkingSetEx">
    <summary>
      <para>Retrieves extended information about the pages at specific virtual addresses in the address space of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="pv">
      <para>A pointer to an array of <see cref="PSAPI_WORKING_SET_EX_INFORMATION" /> structures. On input, each item in the array specifies a virtual address of interest. On output, each item in the array receives information about the corresponding virtual page.</para>
    </param>
    <param name="cb">
      <para>The size of the <i>pv</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Unlike the <see cref="QueryWorkingSet" /> function, which is limited to the working set of the target process, the <b>QueryWorkingSetEx</b> function can be used to query addresses that are not in the process working set but are still part of the process, such as AWE and large pages.</para>
      <para>Starting with Windows 7 and Windows Server 2008 R2, Psapi.h establishes version numbers for the PSAPI functions. The PSAPI version number affects the name used to call the function and the library that a program must load.</para>
      <para>If <b>PSAPI_VERSION</b> is 2 or greater, this function is defined as <b>K32QueryWorkingSetEx</b> in Psapi.h and exported in Kernel32.lib and Kernel32.dll. If <b>PSAPI_VERSION</b> is 1, this function is defined as <b>QueryWorkingSetEx</b> in Psapi.h and exported in Psapi.lib and Psapi.dll as a wrapper that calls <b>K32QueryWorkingSetEx</b>.</para>
      <para>Programs that must run on earlier versions of Windows as well as Windows 7 and later versions should always call this function as <b>QueryWorkingSetEx</b>. To ensure correct resolution of symbols, add Psapi.lib to the <b>TARGETLIBS</b> macro and compile the program with "–DPSAPI_VERSION=1". To use run-time dynamic linking, load Psapi.dll.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/Memory/allocating-memory-from-a-numa-node">Allocating Memory from a NUMA Node</a>.</para>
    </remarks>
    <seealso cref="EnumProcesses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/psapi-functions">PSAPI Functions</seealso>
    <seealso cref="PSAPI_WORKING_SET_EX_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/psapi/working-set-information">Working Set Information</seealso>
  </member>
</doc>