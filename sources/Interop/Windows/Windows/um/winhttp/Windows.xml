<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.WinHttpAddRequestHeaders">
    <summary>
      <para>The <b>WinHttpAddRequestHeaders</b> function adds one or more HTTP request headers to the HTTP request handle.</para>
    </summary>
    <param name="hRequest">
      <para>A <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle returned by a call to the
<see cref="WinHttpOpenRequest" /> function.</para>
    </param>
    <param name="lpszHeaders">
      <para>A pointer to a string variable that contains the headers to append to the request. Each header except the last must be terminated by a carriage return/line feed (CR/LF).</para>
    </param>
    <param name="dwHeadersLength">
      <para>An unsigned long integer value that contains the length, in characters, of
<i>pwszHeaders</i>. If this parameter is -1L, the function assumes that
<i>pwszHeaders</i> is zero-terminated (ASCIIZ), and the length is computed.</para>
    </param>
    <param name="dwModifiers">
      <para>An unsigned long integer value that contains the flags used to modify the semantics of this function. Can be one or more of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_ADD</b>
          </description>
          <description>
            <para>Adds the header if it does not exist. Used with
<b>WINHTTP_ADDREQ_FLAG_REPLACE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_ADD_IF_NEW</b>
          </description>
          <description>
            <para>Adds the header only if it does not already exist; otherwise, an error is returned.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_COALESCE</b>
          </description>
          <description>
            <para>Merges headers of the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA</b>
          </description>
          <description>
            <para>Merges headers of the same name using a comma. For example, adding "Accept: text/<i>" followed by "Accept: audio/</i>" with this flag results in a single header "Accept: text/<i>, audio/</i>". This causes the first header found to be merged. The calling application must  to ensure a cohesive scheme with respect to merged and separate headers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON</b>
          </description>
          <description>
            <para>Merges headers of the same name using a semicolon.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_REPLACE</b>
          </description>
          <description>
            <para>Replaces or removes a header. If the header value is empty and the header is found, it is removed. If the value is not empty, it is replaced.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be performed because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Headers are transferred across redirects. This can be a security issue. To avoid having headers transferred when a redirect occurs, use the  <a href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_STATUS_CALLBACK</a> callback to correct the specific headers when a  redirect occurs.</para>
      <para>Even when WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The
<b>WinHttpAddRequestHeaders</b> function appends additional free-format headers to the HTTP request handle and is intended for use by sophisticated clients that require detailed control over the exact request sent to the HTTP server.</para>
      <para>The name and value of request headers added with this function are validated.  Headers must be well formed. For more information about valid HTTP headers, see
<a href="https://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>.  If an invalid header is used, this function fails and
<see cref="GetLastError" /> returns
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/error-messages">ERROR_INVALID_PARAMETER</a>.  The invalid header is not added.</para>
      <para>If you are sending a Date: request header, you can use the <see cref="WinHttpTimeFromSystemTime" /> function to create structure for the header.</para>
      <para>For basic
<b>WinHttpAddRequestHeaders</b>, the application can pass in multiple headers in a single buffer.</para>
      <para>An application can also use
<see cref="WinHttpSendRequest" /> to add additional headers to the HTTP request handle before sending a request.</para>
      <para>
        <b>Note</b>  For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a>.</para>
      <h4>Examples</h4>
      <para>The following code example includes an If-Modified-Since header in a request.  The response header is interpreted to determine whether the target document has been updated.</para>
      <code>
  DWORD dwSize = sizeof(DWORD);
  DWORD dwStatusCode = 0;
  BOOL  bResults = FALSE;
  HINTERNET hSession = NULL,
        hConnect = NULL,
        hRequest = NULL;

  // Use WinHttpOpen to obtain a session handle.
  hSession = WinHttpOpen( L"A WinHTTP Example Program/1.0",
                          WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                          WINHTTP_NO_PROXY_NAME,
                          WINHTTP_NO_PROXY_BYPASS,
                          0 );

  // Specify an HTTP server.
  if( hSession )
    hConnect = WinHttpConnect( hSession,
                               L"www.microsoft.com",
                               INTERNET_DEFAULT_HTTP_PORT,
                               0 );

  // Create an HTTP Request handle.
  if( hConnect )
    hRequest = WinHttpOpenRequest( hConnect,
                                   L"GET",
                                   NULL,
                                   NULL,
                                   WINHTTP_NO_REFERER,
                                   WINHTTP_DEFAULT_ACCEPT_TYPES,
                                   0 );

  // Add a request header.
  if( hRequest )
    bResults = WinHttpAddRequestHeaders( hRequest,
                 L"If-Modified-Since: Mon, 20 Nov 2000 20:00:00 GMT",
                                         (ULONG)-1L,
                                         WINHTTP_ADDREQ_FLAG_ADD );

  // Send a Request.
  if( bResults )
    bResults = WinHttpSendRequest( hRequest,
                                   WINHTTP_NO_ADDITIONAL_HEADERS,
                                   0,
                                   WINHTTP_NO_REQUEST_DATA,
                                   0,
                                   0,
                                   0 );

  // End the request.
  if( bResults )
    bResults = WinHttpReceiveResponse( hRequest, NULL);

  // Use WinHttpQueryHeaders to obtain the header buffer.
  if( bResults )
    bResults = WinHttpQueryHeaders( hRequest,
                WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                                    NULL,
                                    &amp;amp;amp;amp;amp;amp;dwStatusCode,
                                    &amp;amp;amp;amp;amp;amp;dwSize,
                                    WINHTTP_NO_HEADER_INDEX );

  // Based on the status code, determine whether
  // the document was recently updated.
  if( bResults )
  {
    if( dwStatusCode == 304 )
      printf( "Document has not been updated.\n" );
    else if( dwStatusCode == 200 )
      printf( "Document has been updated.\n" );
    else
      printf( "Status code = %u.\n",dwStatusCode );
  }

  // Report any errors.
  if( !bResults )
    printf( "Error %d has occurred.\n", GetLastError( ) );

  // Close open handles.
  if( hRequest ) WinHttpCloseHandle( hRequest );
  if( hConnect ) WinHttpCloseHandle( hConnect );
  if( hSession ) WinHttpCloseHandle( hSession );

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpOpenRequest" />
    <seealso cref="WinHttpSendRequest" />
  </member>
  <member name="Windows.WinHttpAddRequestHeadersEx">
    <summary>
      <para>Adds one or more HTTP request headers to an HTTP request handle, allowing you to use separate name/value strings.</para>
    </summary>
    <param name="hRequest">
      <para>Type: IN <b><a href="https://docs.microsoft.com//windows/win32/winhttp/hinternet-handles-in-winhttp">HINTERNET</a></b></para>
      <para>An <b>HINTERNET</b> handle returned by a call to <see cref="WinHttpOpenRequest" />.</para>
    </param>
    <param name="dwModifiers">
      <para>Type: IN <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">DWORD</a></b></para>
      <para>An unsigned long integer value that contains the flags used to modify the semantics of this function. Can be one or more of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_ADD</b>
          </description>
          <description>
            <para>Adds the header if it does not exist. Used with
<b>WINHTTP_ADDREQ_FLAG_REPLACE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_ADD_IF_NEW</b>
          </description>
          <description>
            <para>Adds the header only if it does not already exist; otherwise, an error is returned.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_COALESCE</b>
          </description>
          <description>
            <para>Merges headers of the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA</b>
          </description>
          <description>
            <para>Merges headers of the same name using a comma. For example, adding "Accept: text/<i>" followed by "Accept: audio/</i>" with this flag results in a single header "Accept: text/<i>, audio/</i>". This causes the first header found to be merged. The calling application must  to ensure a cohesive scheme with respect to merged and separate headers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON</b>
          </description>
          <description>
            <para>Merges headers of the same name using a semicolon.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_ADDREQ_FLAG_REPLACE</b>
          </description>
          <description>
            <para>Replaces or removes a header. If the header value is empty and the header is found, it is removed. If the value is not empty, it is replaced.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="ullFlags">
      <para>Type: IN <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">ULONGLONG</a></b></para>
      <para>Pass <b>WINHTTP_EXTENDED_HEADER_FLAG_UNICODE</b> to indicate that the strings passed in are Unicode strings.</para>
    </param>
    <param name="ullExtra">
      <para>Type: IN <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">ULONGLONG</a></b></para>
      <para>Reserved.</para>
    </param>
    <param name="cHeaders">
      <para>Type: IN <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">DWORD</a></b></para>
      <para>The number of elements in <i>pHeaders</i>.</para>
    </param>
    <param name="pHeaders">
      <para>Type: _In_reads_(cHeaders) <b><see cref="WINHTTP_EXTENDED_HEADER" />*</b></para>
      <para>An array of <b>WINHTTP_EXTENDED_HEADER</b> structures.</para>
    </param>
    <returns>
      <para>A status code indicating the result of the operation. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be performed because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/win32/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/WinHttp/winhttp-versions">WinHTTP versions</seealso>
    <seealso cref="WinHttpOpenRequest" />
    <seealso cref="WinHttpSendRequest" />
  </member>
  <member name="Windows.WinHttpCheckPlatform">
    <summary>
      <para>The <b>WinHttpCheckPlatform</b> function determines whether the current platform is supported by this version of Microsoft Windows HTTP Services (WinHTTP).</para>
    </summary>
    <returns>
      <para>The return value is <b>TRUE</b> if the platform is supported by Microsoft Windows HTTP Services (WinHTTP), or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function is useful if your application uses Microsoft Windows HTTP Services (WinHTTP), but also supports platforms that WinHTTP does not.</para>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>WinHTTP version 5.1 is  an operating-system component of Windows 2000 with Service Pack 3 (SP3) and later (except Datacenter Server), Windows XP with Service Pack 1 (SP1) and later, and Windows Server 2003. In Windows Server 2003, WinHTTP is a system side-by-side assembly.</para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a>.</para>
      <h4>Examples</h4>
      <para>The following example shows how to determine whether the current platform is supported.</para>
      <code>    if (WinHttpCheckPlatform( ))
        printf("This platform is supported by WinHTTP.\n");
    else
        printf("This platform is NOT supported by WinHTTP.\n");

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
  </member>
  <member name="Windows.WinHttpCloseHandle">
    <summary>
      <para>The <b>WinHttpCloseHandle</b> function closes a single <b>HINTERNET</b> handle (see <a href="https://docs.microsoft.com//windows/win32/winhttp/hinternet-handles-in-winhttp">HINTERNET Handles in WinHTTP</a>).</para>
    </summary>
    <param name="hInternet">
      <para>A valid <b>HINTERNET</b> handle (see <a href="https://docs.microsoft.com//windows/win32/winhttp/hinternet-handles-in-winhttp">HINTERNET Handles in WinHTTP</a>) to be closed.</para>
    </param>
    <returns>
      <para>
        <b>TRUE</b> if the handle is successfully closed, otherwise <b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Codes</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_SHUTDOWN</b>
            </para>
          </description>
          <description>
            <para>The WinHTTP function support is being shut down or unloaded.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If there is a status callback registered for the handle being closed and the handle was created with a non-<b>NULL</b> context value, a <b>WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING</b> callback is made. This  is the last callback made from the handle and indicates that the handle is being destroyed.</para>
      <para>An application can terminate an in-progress asynchronous request by closing the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> request handle using <b>WinHttpCloseHandle</b>. Keep the following points in mind:</para>
      <list type="bullet">
        <item>
          <description>
            <para>After an application calls <b>WinHttpCloseHandle</b> on a WinHTTP handle, it cannot call any other WinHTTP API functions using that handle from any thread.</para>
          </description>
        </item>
        <item>
          <description>
            <para>Even after a call to <b>WinHttpCloseHandle</b> returns, the application must still be prepared to receive callbacks for the closed handle, because WinHTTP can tear down the handle asynchronously. If the asynchronous request was not able to complete successfully, the callback  receives a WINHTTP_CALLBACK_STATUS_REQUEST_ERROR notification.</para>
          </description>
        </item>
        <item>
          <description>
            <para>If an application associates a context data structure or object with the handle, it should maintain that binding until the callback function receives a <b>WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING</b> notification. This is the last callback notification WinHTTP sends prior to deleting a handle object from memory. In order to receive the <b>WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING</b> callback notification, the application must enable the <b>WINHTTP_CALLBACK_FLAG_HANDLES</b> flag in the <see cref="WinHttpSetStatusCallback" /> call.</para>
          </description>
        </item>
        <item>
          <description>
            <para>Before calling <b>WinHttpCloseHandle</b>, an application can call <see cref="WinHttpSetStatusCallback" /> to indicate that no more callbacks should be made:</para>
            <para>
              <code>WinHttpSetStatusCallback( hRequest, NULL, 0, 0 );</code>
            </para>
            <para>It might seem that the context data structure could then be freed immediately rather than having to wait for a <b>WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING</b> notification, but this is not the case: WinHTTP does not synchronize <see cref="WinHttpSetStatusCallback" /> with callbacks originating in worker threads. As a result, a callback could already be in progress from another thread, and the application could receive a callback notification even after having <b>NULL</b> ed-out the callback function pointer and deleted the handle's context data structure. Because of this potential race condition, be conservative in freeing the context structure until after having received the <b>WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING</b> notification.</para>
          </description>
        </item>
      </list>
      <para>An application should never call <b>WinHttpCloseHandle</b> on a synchronous request. This can create a race condition. See <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET Handles in WinHTTP</a> for more information.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpConnect" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpOpenRequest" />
  </member>
  <member name="Windows.WinHttpConnect">
    <summary>
      <para>The <b>WinHttpConnect</b> function specifies the initial target server of an HTTP request and returns an <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> connection handle to an HTTP session for that initial target.</para>
    </summary>
    <param name="hSession">
      <para>Valid
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> WinHTTP session handle returned by a previous call to
<see cref="WinHttpOpen" />.</para>
    </param>
    <param name="pswzServerName">
      <para>Pointer to a <b>null</b>-terminated string that contains the host name of an HTTP server. Alternately, the string can contain the IP address of the site in ASCII, for example, 10.0.1.45.
Note that WinHttp does not accept international host names without converting them first to <a href="https://docs.microsoft.com//previous-versions/windows/internet-explorer/ie-developer/">Punycode</a>. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/handling-internationalized-domain-names--idns">Handling Internationalized Domain Names (IDNs)</a>.</para>
    </param>
    <param name="nServerPort">
      <para>Unsigned integer that specifies the TCP/IP port on the server to which a connection is made.  This parameter can be any valid TCP/IP port number, or one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>INTERNET_DEFAULT_HTTP_PORT</b>
          </description>
          <description>
            <para>Uses the default port for HTTP servers (port 80).</para>
          </description>
        </item>
        <item>
          <description>
            <b>INTERNET_DEFAULT_HTTPS_PORT</b>
          </description>
          <description>
            <para>Uses the default port for HTTPS servers (port 443).  Selecting this port does not automatically establish a secure connection.  You must still specify the use of secure transaction semantics by using the
<see cref="WINHTTP_FLAG_SECURE" /> flag with
<see cref="WinHttpOpenRequest" />.</para>
          </description>
        </item>
        <item>
          <description>
            <b>INTERNET_DEFAULT_PORT</b>
          </description>
          <description>
            <para>Uses port 80 for HTTP and port 443 for Secure Hypertext Transfer Protocol (HTTPS).</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwReserved">
      <para>This parameter is reserved and must be 0.</para>
    </param>
    <returns>
      <para>Returns a valid connection handle to the HTTP session if the connection is successful, or <b>NULL</b> otherwise. To retrieve extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Codes</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INVALID_URL</b>
            </para>
          </description>
          <description>
            <para>The URL is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_OPERATION_CANCELLED</b>
            </para>
          </description>
          <description>
            <para>The operation was canceled, usually because the handle on which the request was operating was closed before the operation completed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b>
            </para>
          </description>
          <description>
            <para>The URL scheme could not be recognized, or is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_SHUTDOWN</b>
            </para>
          </description>
          <description>
            <para>The WinHTTP function support is being shut down or unloaded.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>After the calling application has finished using the
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle returned by
<b>WinHttpConnect</b>, it must be closed using the
<see cref="WinHttpCloseHandle" /> function.</para>
      <para>
        <b>WinHttpConnect</b> specifies the target HTTP server, however a response can come from another server if the request was redirected.  You can determine the URL of the server sending the response by calling
<see cref="WinHttpQueryOption" /> with the WINHTTP_OPTION_URL flag.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
      <h4>Examples</h4>
      <para>The following example shows how to use secure transaction semantics to download a resource from an HTTPS server. The sample code initializes the Microsoft Windows HTTP Services (WinHTTP) application programming interface (API), selects a target HTTPS server, then opens and sends a request for this secure resource.
<see cref="WinHttpQueryDataAvailable" /> is used with the request handle to determine how much data is available for download, then
<see cref="WinHttpReadData" /> is used to read that data.  This process repeats until the entire document has been retrieved and displayed.</para>
      <code>
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    BOOL  bResults = FALSE;
    HINTERNET  hSession = NULL,
               hConnect = NULL,
               hRequest = NULL;

    // Use WinHttpOpen to obtain a session handle.
    hSession = WinHttpOpen( L"WinHTTP Example/1.0",
                            WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                            WINHTTP_NO_PROXY_NAME,
                            WINHTTP_NO_PROXY_BYPASS, 0);

    // Specify an HTTP server.
    if (hSession)
        hConnect = WinHttpConnect( hSession, L"www.microsoft.com",
                                   INTERNET_DEFAULT_HTTPS_PORT, 0);

    // Create an HTTP request handle.
    if (hConnect)
        hRequest = WinHttpOpenRequest( hConnect, L"GET", NULL,
                                       NULL, WINHTTP_NO_REFERER,
                                       WINHTTP_DEFAULT_ACCEPT_TYPES,
                                       WINHTTP_FLAG_SECURE);

    // Send a request.
    if (hRequest)
        bResults = WinHttpSendRequest( hRequest,
                                       WINHTTP_NO_ADDITIONAL_HEADERS,
                                       0, WINHTTP_NO_REQUEST_DATA, 0,
                                       0, 0);


    // End the request.
    if (bResults)
        bResults = WinHttpReceiveResponse( hRequest, NULL);

    // Keep checking for data until there is nothing left.
    if (bResults)
        do
        {
            // Check for available data.
            dwSize = 0;
            if (!WinHttpQueryDataAvailable( hRequest, &amp;amp;amp;amp;amp;amp;dwSize))
                printf("Error %u in WinHttpQueryDataAvailable.\n", GetLastError());

            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize+1];
            if (!pszOutBuffer)
            {
                printf("Out of memory\n");
                dwSize=0;
            }
            else
            {
                // Read the Data.
                ZeroMemory(pszOutBuffer, dwSize+1);

                if (!WinHttpReadData( hRequest, (LPVOID)pszOutBuffer,
                                      dwSize, &amp;amp;amp;amp;amp;amp;dwDownloaded))
                    printf( "Error %u in WinHttpReadData.\n", GetLastError());
                else
                    printf( "%s\n", pszOutBuffer);

                // Free the memory allocated to the buffer.
                delete [] pszOutBuffer;
            }

        } while (dwSize &gt; 0);


    // Report any errors.
    if (!bResults)
        printf("Error %d has occurred.\n", GetLastError());

    // Close any open handles.
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpOpenRequest" />
  </member>
  <member name="Windows.WinHttpCrackUrl">
    <summary>
      <para>The <b>WinHttpCrackUrl</b> function separates a URL into its component parts such as host name and path.</para>
    </summary>
    <param name="pwszUrl">
      <para>Pointer to a string that contains the canonical URL to separate. <b>WinHttpCrackUrl</b> does not check this URL for validity or correct format before attempting to crack it.</para>
    </param>
    <param name="dwUrlLength">
      <para>The length of the
<i>pwszUrl</i> string, in characters. If
<i>dwUrlLength</i> is set to zero,
<b>WinHttpCrackUrl</b> assumes that the
<i>pwszUrl</i> string is <b>null</b> terminated and  determines the length of the
<i>pwszUrl</i> string based on that assumption.</para>
    </param>
    <param name="dwFlags">
      <para>The flags that control the operation. This parameter can be a combination of one or more of the following flags (values can be bitwise OR'd together). Or, the parameter can be 0, which performs no special operations.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ICU_DECODE</b>
          </description>
          <description>
            <para>Converts characters that are "escape encoded" (%xx) to their non-escaped form.  This does not decode other encodings, such as UTF-8. This feature can be used only if the user provides buffers in the <see cref="URL_COMPONENTS" /> structure to copy the components into.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICU_ESCAPE</b>
          </description>
          <description>
            <para>Escapes certain characters to their escape sequences (%xx). Characters to be escaped are non-ASCII characters or those ASCII characters that must be escaped to be represented in an HTTP request.  This feature can be used only if the user provides buffers in the
<see cref="URL_COMPONENTS" /> structure to copy the components into.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICU_REJECT_USERPWD</b>
          </description>
          <description>
            <para>Rejects URLs as input that contain embedded credentials (either a username, a password, or both). If the function fails because of an invalid URL, then subsequent calls to GetLastError return <b>ERROR_WINHTTP_INVALID_URL</b>.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpUrlComponents">
      <para>Pointer to a
<see cref="URL_COMPONENTS" /> structure that receives the URL components.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if the function succeeds, or <b>FALSE</b> otherwise. To get extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Codes</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INVALID_URL</b>
            </para>
          </description>
          <description>
            <para>The URL is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b>
            </para>
          </description>
          <description>
            <para>The URL scheme could not be recognized, or is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The required components are indicated by members of the
<see cref="URL_COMPONENTS" /> structure. Each component has a pointer to the value and has a member that stores the length of the stored value. If both the value and the length for a component are equal to zero, that component is not returned. If the pointer to the value of the component is not <b>NULL</b> and the value of its corresponding length member is nonzero, the address of the first character of the corresponding component in the
<i>pwszUrl</i> string is stored in the pointer, and the length of the component is stored in the length member.</para>
      <para>If the pointer contains the address of the user-supplied buffer, the length member must contain the size of the buffer. The
<b>WinHttpCrackUrl</b> function copies the component into the buffer, and the length member is set to the length of the copied component, minus 1 for the trailing string terminator. If a user-supplied buffer is not large enough, <b>WinHttpCrackUrl</b> returns <b>FALSE</b>, and <see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
      <para>For
<b>WinHttpCrackUrl</b> to work properly, the size of the
<see cref="URL_COMPONENTS" /> structure must be stored in the
<see cref="dwStructSize" /> member of that structure.</para>
      <para>If the Internet protocol of the URL passed in for
<i>pwszUrl</i> is not HTTP or HTTPS, then
<b>WinHttpCrackUrl</b>  returns  <b>FALSE</b> and
<see cref="GetLastError" />  indicates
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/error-messages">ERROR_WINHTTP_UNRECOGNIZED_SCHEME</a>.</para>
      <para>
        <b>WinHttpCrackUrl</b> does not check the validity or format of a URL before attempting to crack it. As a result, if a string such as ""http://server?Bad=URL"" is passed in, the function returns incorrect results.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
      <h4>Examples</h4>
      <para>This example shows how to break a URL into its components, update a component, then reconstruct the URL.</para>
      <code>    URL_COMPONENTS urlComp;
    LPCWSTR pwszUrl1 =
      L"http://search.msn.com/results.asp?RS=CHECKED&amp;amp;amp;amp;amp;amp;FORM=MSNH&amp;amp;amp;amp;amp;amp;v=1&amp;amp;amp;amp;amp;amp;q=wininet";
    DWORD dwUrlLen = 0;

    // Initialize the URL_COMPONENTS structure.
    ZeroMemory(&amp;amp;amp;amp;amp;amp;urlComp, sizeof(urlComp));
    urlComp.dwStructSize = sizeof(urlComp);

    // Set required component lengths to non-zero
    // so that they are cracked.
    urlComp.dwSchemeLength    = (DWORD)-1;
    urlComp.dwHostNameLength  = (DWORD)-1;
    urlComp.dwUrlPathLength   = (DWORD)-1;
    urlComp.dwExtraInfoLength = (DWORD)-1;

    // Crack the URL.
    if (!WinHttpCrackUrl( pwszUrl1, (DWORD)wcslen(pwszUrl1), 0, &amp;amp;amp;amp;amp;amp;urlComp))
    {
        printf("Error %u in WinHttpCrackUrl.\n", GetLastError());
    }
    else
    {
        // Change the search information.
        // New info is the same length.
        urlComp.lpszExtraInfo = L"?RS=CHECKED&amp;amp;amp;amp;amp;amp;FORM=MSNH&amp;amp;amp;amp;amp;amp;v=1&amp;amp;amp;amp;amp;amp;q=winhttp";

        // Obtain the size of the new URL and allocate memory.
        WinHttpCreateUrl( &amp;amp;amp;amp;amp;amp;urlComp, 0, NULL, &amp;amp;amp;amp;amp;amp;dwUrlLen);
        LPWSTR pwszUrl2 = new WCHAR[dwUrlLen];

        // Create a new URL.
        if(!WinHttpCreateUrl( &amp;amp;amp;amp;amp;amp;urlComp, 0, pwszUrl2, &amp;amp;amp;amp;amp;amp;dwUrlLen))
        {
            printf("Error %u in WinHttpCreateUrl.\n", GetLastError());
        }
        else
        {
            // Show both URLs.
            printf("Old URL:  %S\nNew URL:  %S\n", pwszUrl1, pwszUrl2);
        }

        // Free allocated memory.
        delete [] pwszUrl2;
    }

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/uniform-resource-locators--urls--in-winhttp">Handling Uniform Resource Locators</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCreateUrl" />
  </member>
  <member name="Windows.WinHttpCreateProxyResolver">
    <summary>
      <para>The <b>WinHttpCreateProxyResolver</b> function creates a handle for use by <see cref="WinHttpGetProxyForUrlEx" />.</para>
    </summary>
    <param name="hSession">
      <para>Valid <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> WinHTTP session handle returned by a previous call to
<see cref="WinHttpOpen" />. The session handle must be opened using <b>WINHTTP_FLAG_ASYNC</b>.</para>
    </param>
    <param name="phResolver">
      <para>A pointer to a new handle for use by <see cref="WinHttpGetProxyForUrlEx" />.  When finished or cancelling an outstanding operation, close this handle with <see cref="WinHttpCloseHandle" />.</para>
    </param>
    <returns>
      <para>A status code indicating the result of the operation.</para>
      <list type="table">
        <listheader>
          <description>The following codes may be returned.</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_SUCCESS</b>
            </para>
          </description>
          <description>
            <para>The operation succeeded.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_HANDLE</b>
            </para>
          </description>
          <description>
            <i>hSession</i> is NULL.
</description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <i>hSession</i> is not the result of a call to <see cref="WinHttpOpen" /> or <i>hSession</i> is not marked as asynchronous using <b>WINHTTP_FLAG_ASYNC</b>.
</description>
        </item>
      </list>
    </returns>
  </member>
  <member name="Windows.WinHttpCreateUrl">
    <summary>
      <para>The <b>WinHttpCreateUrl</b> function creates a URL from component parts such as the host name and path.</para>
    </summary>
    <param name="lpUrlComponents">
      <para>Pointer to a
<see cref="URL_COMPONENTS" /> structure that contains the components from which to create the URL.</para>
    </param>
    <param name="dwFlags">
      <para>Flags that control the operation of this function. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ICU_ESCAPE</b>
          </description>
          <description>
            <para>Converts all unsafe characters to their corresponding escape sequences in the path string pointed to by the <b>lpszUrlPath</b> member and in <b>lpszExtraInfo</b> the extra-information string pointed to by the member of the <see cref="URL_COMPONENTS" /> structure pointed to by the <i>lpUrlComponents</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICU_REJECT_USERPWD</b>
          </description>
          <description>
            <para>Rejects URLs as input that contains either a username, or a password, or both. If the function fails because of an invalid URL, subsequent calls to GetLastError will return ERROR_WINHTTP_INVALID_URL.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pwszUrl">
      <para>Pointer to a character buffer that receives the URL as a wide character (Unicode) string.</para>
    </param>
    <param name="pdwUrlLength">
      <para>Pointer to a variable of type unsigned long integer that receives the length of the
<i>pwszUrl</i> buffer in wide (Unicode) characters. When the function returns, this parameter receives the length of the URL string wide in characters, minus 1 for the terminating character. If
<see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER, this parameter receives the number of wide characters required to hold the created URL.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if the function succeeds, or <b>FALSE</b> otherwise. To get extended error data, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is used in asynchronous mode, that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />, this function operates synchronously. The return value indicates success or failure.  To get extended error data, call
<see cref="GetLastError" />.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
      <h4>Examples</h4>
      <para>The following  example shows how to decompile, or crack, a URL into its subcomponents, update a component, then reconstruct the URL.</para>
      <code>
    URL_COMPONENTS urlComp;
    LPCWSTR pwszUrl1 =
       L"http://search.msn.com/results.asp?RS=CHECKED&amp;amp;amp;amp;amp;amp;FORM=MSNH&amp;amp;amp;amp;amp;amp;v=1&amp;amp;amp;amp;amp;amp;q=wininet";
    DWORD dwUrlLen = 0;

    // Initialize the URL_COMPONENTS structure.
    ZeroMemory(&amp;amp;amp;amp;amp;amp;urlComp, sizeof(urlComp));
    urlComp.dwStructSize = sizeof(urlComp);

    // Set required component lengths to non-zero,
    // so that they are cracked.
    urlComp.dwSchemeLength    = (DWORD)-1;
    urlComp.dwHostNameLength  = (DWORD)-1;
    urlComp.dwUrlPathLength   = (DWORD)-1;
    urlComp.dwExtraInfoLength = (DWORD)-1;

    // Crack the URL.
    if (!WinHttpCrackUrl( pwszUrl1, (DWORD)wcslen(pwszUrl1), 0, &amp;amp;amp;amp;amp;amp;urlComp))
    {
        printf("Error %u in WinHttpCrackUrl.\n", GetLastError());
    }
    else
    {
        // Change the search data. New data is the same length.
        urlComp.lpszExtraInfo = L"?RS=CHECKED&amp;amp;amp;amp;amp;amp;FORM=MSNH&amp;amp;amp;amp;amp;amp;v=1&amp;amp;amp;amp;amp;amp;q=winhttp";

        // Obtain the size of the new URL and allocate memory.
        WinHttpCreateUrl( &amp;amp;amp;amp;amp;amp;urlComp, 0, NULL, &amp;amp;amp;amp;amp;amp;dwUrlLen);
        LPWSTR pwszUrl2 = new WCHAR[dwUrlLen];

        // Create a new URL.
        if(!WinHttpCreateUrl( &amp;amp;amp;amp;amp;amp;urlComp, 0, pwszUrl2, &amp;amp;amp;amp;amp;amp;dwUrlLen))
        {
            printf( "Error %u in WinHttpCreateUrl.\n", GetLastError());
        }
        else
        {
            // Show both URLs.
            printf( "Old URL:  %S\nNew URL:  %S\n", pwszUrl1, pwszUrl2);
        }

        // Free allocated memory.
        delete [] pwszUrl2;
    }

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/uniform-resource-locators--urls--in-winhttp">Handling Uniform Resource Locators</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCrackUrl" />
  </member>
  <member name="Windows.WinHttpDetectAutoProxyConfigUrl">
    <summary>
      <para>The <b>WinHttpDetectAutoProxyConfigUrl</b> function finds the URL for the Proxy Auto-Configuration (PAC) file. This function reports the URL of the PAC file, but it does not download the file.</para>
    </summary>
    <param name="dwAutoDetectFlags">
      <para>A data type that specifies what protocols to use to locate the PAC file. If both the DHCP and DNS auto detect flags are set, DHCP is used first; if no PAC URL is discovered using DHCP, then DNS is used.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>WINHTTP_AUTO_DETECT_TYPE_DHCP</b>
          </description>
          <description>
            <para>Use DHCP to locate the proxy auto-configuration file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTO_DETECT_TYPE_DNS_A</b>
          </description>
          <description>
            <para>Use DNS to attempt to locate the proxy auto-configuration file at a well-known location on the domain of the local computer.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="ppwstrAutoConfigUrl">
      <para>A data type that returns a pointer to a null-terminated Unicode string that contains the configuration URL that receives the proxy data. You must free the string pointed to by <i>ppwszAutoConfigUrl</i> using the <see cref="GlobalFree" /> function.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_AUTODETECTION_FAILED</b>
            </para>
          </description>
          <description>
            <para>Returned if WinHTTP was unable to discover the URL of the Proxy Auto-Configuration (PAC) file.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>WinHTTP implements the <a href="http://tools.ietf.org/html/draft-ietf-wrec-wpad-01">Web Proxy Auto-Discovery (WPAD) protocol</a>, often referred to as <i>autoproxy</i>. For more information about well-known locations, see the  <a href="http://tools.ietf.org/html/draft-ietf-wrec-wpad-01">Discovery Process</a> section of the WPAD protocol document.</para>
      <para>Note that because the <b>WinHttpDetectAutoProxyConfigUrl</b> function takes time to complete its operation, it should not be called from  a UI thread.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
  </member>
  <member name="Windows.WinHttpFreeProxyResult">
    <summary>
      <para>The <b>WinHttpFreeProxyResult</b> function frees the data retrieved from a previous call to <see cref="WinHttpGetProxyResult" />.</para>
    </summary>
    <param name="pProxyResult">
      <para>A pointer to a <see cref="WINHTTP_PROXY_RESULT" /> structure retrieved from a previous call to <see cref="WinHttpGetProxyResult" />.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
    </returns>
    <remarks>
      <para>Upon completion, all internal members of <i>pProxyResult</i> will be zeroed and the memory allocated to those members will be freed. If <i>pProxyResult</i> is an allocated pointer, the caller must free the pointer.</para>
    </remarks>
  </member>
  <member name="Windows.WinHttpFreeQueryConnectionGroupResult">
    <summary>
      <para>Frees the memory allocated by a previous call to <see cref="WinHttpQueryConnectionGroup" />.</para>
    </summary>
    <param name="pResult">
      <para>Type: _Inout_ <b><see cref="WINHTTP_QUERY_CONNECTION_GROUP_RESULT" />*</b></para>
      <para>A pointer to the <see cref="WINHTTP_QUERY_CONNECTION_GROUP_RESULT" /> object to free.</para>
    </param>
    <seealso cref="WinHttpQueryConnectionGroup" />
  </member>
  <member name="Windows.WinHttpGetDefaultProxyConfiguration">
    <summary>
      <para>The <b>WinHttpGetDefaultProxyConfiguration</b> function retrieves the default WinHTTP proxy configuration from the registry.</para>
    </summary>
    <param name="pProxyInfo">
      <para>A pointer to a variable of type
<see cref="WINHTTP_PROXY_INFO" /> that receives the default proxy configuration.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To retrieve a specific error message, call
<see cref="GetLastError" />. Error codes returned include the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>WinHttpGetDefaultProxyConfiguration</b> retrieves the proxy configuration set by
<see cref="WinHttpSetDefaultProxyConfiguration" /> or
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/proxycfg-exe--a-proxy-configuration-tool">ProxyCfg.exe</a>.</para>
      <para>The default proxy configuration can be overridden for a WinHTTP session by calling
<see cref="WinHttpSetOption" /> and specifying the
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/option-flags">WINHTTP_OPTION_PROXY</a> flag.
<b>WinHttpGetDefaultProxyConfiguration</b> does not retrieve the configuration for the current session.  It retrieves the configuration specified in the registry.</para>
      <para>If the registry contains a list of proxy servers, the
<b>dwAccessType</b> member of
<i>pProxyInfo</i> is set to
<b>WINHTTP_ACCESS_TYPE_NAMED_PROXY</b>.  Otherwise, it is set to
<b>WINHTTP_ACCESS_TYPE_NO_PROXY</b>.</para>
      <para>
        <b>WinHttpGetDefaultProxyConfiguration</b> allocates memory for the string members of
<i>pProxyInfo</i>.  To free this memory, call <see cref="GlobalFree" />.</para>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHTTP Start Page.</para>
      <h4>Examples</h4>
      <para>The following code example shows how to retrieve the default proxy configuration from the registry.</para>
      <code>    WINHTTP_PROXY_INFO proxyInfo;

    // Retrieve the default proxy configuration.
    WinHttpGetDefaultProxyConfiguration( &amp;amp;amp;amp;amp;amp;proxyInfo );

    // Display the proxy servers and free memory
    // allocated to this string.
    if (proxyInfo.lpszProxy != NULL)
    {
        printf("Proxy server list: %S\n", proxyInfo.lpszProxy);
        GlobalFree( proxyInfo.lpszProxy );
    }

    // Display the bypass list and free memory
    // allocated to this string.
    if (proxyInfo.lpszProxyBypass != NULL)
    {
        printf("Proxy bypass list: %S\n", proxyInfo.lpszProxyBypass);
        GlobalFree( proxyInfo.lpszProxyBypass );
    }

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/proxycfg-exe--a-proxy-configuration-tool">ProxyCfg.exe, a Proxy Configuration Tool</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpSetDefaultProxyConfiguration" />
  </member>
  <member name="Windows.WinHttpGetIEProxyConfigForCurrentUser">
    <summary>
      <para>The <b>WinHttpGetIEProxyConfigForCurrentUser</b> function retrieves the Internet Explorer proxy configuration for the current user.</para>
    </summary>
    <param name="pProxyConfig">
      <para>A pointer, on input, to a <see cref="WINHTTP_CURRENT_USER_IE_PROXY_CONFIG" /> structure. On output, the structure contains the Internet Explorer proxy settings for the current active network connection (for example, LAN, dial-up, or VPN connection).</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_FILE_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>No Internet Explorer proxy settings can be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>In Internet Explorer, the proxy settings are found on the <b>Connections</b> tab of the <b>Tools</b> / <b>Internet Options</b> menu option. Proxy settings are configured on a per-connection basis; that is, the proxy settings for a LAN connection are separate from those for a dial-up or VPN connection. <b>WinHttpGetIEProxyConfigForCurrentUser</b> returns the proxy settings for the current active connection.</para>
      <para>This function is useful in client applications running in network environments in which the Web Proxy Auto-Discovery (WPAD) protocol is not implemented (meaning that no Proxy Auto-Configuration file is available). If a PAC file is not available, then the <see cref="WinHttpGetProxyForUrl" /> function fails. The <b>WinHttpGetIEProxyConfigForCurrentUser</b> function can be used as a fall-back mechanism to discover a workable proxy configuration by retrieving the user's proxy configuration in Internet Explorer.</para>
      <para>This function should not be used in a service process that does not impersonate a logged-on user.If the caller does not impersonate a logged on user, WinHTTP attempts to retrieve the Internet Explorer settings for the current service process: for example, the local service or the network service. If the Internet Explorer settings are not configured for these system accounts, the call to <b>WinHttpGetIEProxyConfigForCurrentUser</b> will fail.</para>
      <para>The caller must free the <b>lpszProxy</b>, <b>lpszProxyBypass</b>  and <b>lpszAutoConfigUrl</b> strings in the <see cref="WINHTTP_CURRENT_USER_IE_PROXY_CONFIG" />  structure if they are non-<b>NULL</b>. Use <see cref="GlobalFree" /> to free the strings.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
  </member>
  <member name="Windows.WinHttpGetProxyForUrl">
    <summary>
      <para>The <b>WinHttpGetProxyForUrl</b> function retrieves the proxy data for the specified URL.</para>
    </summary>
    <param name="hSession">
      <para>The WinHTTP session handle returned by the <see cref="WinHttpOpen" /> function.</para>
    </param>
    <param name="lpcwszUrl">
      <para>A pointer to a null-terminated Unicode string that contains the URL of the HTTP request that the application is preparing to send.</para>
    </param>
    <param name="pAutoProxyOptions">
      <para>A pointer to a <see cref="WINHTTP_AUTOPROXY_OPTIONS" /> structure that specifies the auto-proxy options to use.</para>
    </param>
    <param name="pProxyInfo">
      <para>A pointer to a <see cref="WINHTTP_PROXY_INFO" /> structure that receives the proxy setting. This structure is then applied to the request handle using the WINHTTP_OPTION_PROXY option. Free the <b>lpszProxy</b> and <b>lpszProxyBypass</b> strings contained in this structure (if they are non-NULL) using the <see cref="GlobalFree" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns <b>TRUE</b>.</para>
      <para>If the function fails, it returns <b>FALSE</b>. For extended error data, call
<see cref="GetLastError" />.</para>
      <para>Possible error codes include the folllowing.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR</b>
            </para>
          </description>
          <description>
            <para>Returned by <see cref="WinHttpGetProxyForUrl" /> when a proxy for the specified URL cannot be located.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT</b>
            </para>
          </description>
          <description>
            <para>An error occurred executing the script code in the Proxy Auto-Configuration (PAC) file.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INVALID_URL</b>
            </para>
          </description>
          <description>
            <para>The URL is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_LOGIN_FAILURE</b>
            </para>
          </description>
          <description>
            <para>The login attempt failed.  When this error is encountered, close the request handle with
<see cref="WinHttpCloseHandle" />.  A new request handle must be created before retrying the function that originally produced this error.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_OPERATION_CANCELLED</b>
            </para>
          </description>
          <description>
            <para>The operation was canceled, usually because the handle on which the request was operating was closed before the operation completed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT</b>
            </para>
          </description>
          <description>
            <para>The PAC file could not be downloaded. For example, the server referenced by the PAC URL may not have been reachable, or  the server returned a 404 NOT FOUND response.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b>
            </para>
          </description>
          <description>
            <para>The URL of the PAC file specified a scheme other than "http:" or "https:".</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function implements the Web Proxy Auto-Discovery (WPAD) protocol for automatically configuring the proxy settings for an HTTP request. The WPAD protocol downloads a Proxy Auto-Configuration (PAC) file, which is a script that identifies the proxy server to use for a given target URL. PAC files are typically deployed by the IT department within a corporate network environment. The URL of the PAC file can either be specified explicitly or <b>WinHttpGetProxyForUrl</b> can be instructed to automatically discover the location of the PAC file on the local network.</para>
      <para>
        <b>WinHttpGetProxyForUrl</b> supports only ECMAScript-based PAC files.</para>
      <para>
        <b>WinHttpGetProxyForUrl</b> must be called on a per-URL basis, because the PAC file can return a different proxy server for different URLs. This is useful because the PAC file enables an IT department to implement proxy server load balancing by mapping (hashing) the target URL (specified by the <i>lpcwszUrl</i> parameter) to a certain proxy in a proxy server array.</para>
      <para>
        <b>WinHttpGetProxyForUrl</b> caches the autoproxy URL and the autoproxy script when auto-discovery is specified in the <b>dwFlags</b> member of the <i>pAutoProxyOptions</i> structure. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinHttp/autoproxy-cache">Autoproxy Cache</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
  </member>
  <member name="Windows.WinHttpGetProxyForUrlEx">
    <summary>
      <para>The  <b>WinHttpGetProxyForUrlEx</b> function retrieves the proxy data for the specified URL.</para>
    </summary>
    <param name="hResolver">
      <para>The WinHTTP resolver handle returned by the <see cref="WinHttpCreateProxyResolver" /> function.</para>
    </param>
    <param name="pcwszUrl">
      <para>A pointer to a null-terminated Unicode string that contains a URL for which proxy information will be determined.</para>
    </param>
    <param name="pAutoProxyOptions">
      <para>A pointer to a <see cref="WINHTTP_AUTOPROXY_OPTIONS" /> structure that specifies the auto-proxy options to use.</para>
    </param>
    <param name="pContext">
      <para>Context data that will be passed to the completion callback function.</para>
    </param>
    <returns>
      <para>A status code indicating the result of the operation.</para>
      <list type="table">
        <listheader>
          <description>The following codes may be returned.</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_IO_PENDING</b>
            </para>
          </description>
          <description>
            <para>The operation is continuing asynchronously.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR</b>
            </para>
          </description>
          <description>
            <para>Returned by <see cref="WinHttpGetProxyForUrlEx" /> when a proxy for the specified URL cannot be located.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT</b>
            </para>
          </description>
          <description>
            <para>An error occurred executing the script code in the Proxy Auto-Configuration (PAC) file.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INVALID_URL</b>
            </para>
          </description>
          <description>
            <para>The URL is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_OPERATION_CANCELLED</b>
            </para>
          </description>
          <description>
            <para>The operation was canceled, usually because the handle on which the request was operating was closed before the operation completed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT</b>
            </para>
          </description>
          <description>
            <para>The PAC file could not be downloaded. For example, the server referenced by the PAC URL may not have been reachable, or  the server returned a 404 NOT FOUND response.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b>
            </para>
          </description>
          <description>
            <para>The URL of the PAC file specified a scheme other than "http:" or "https:".</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function implements the Web Proxy Auto-Discovery (WPAD) protocol for automatically configuring the proxy settings for an HTTP request. The WPAD protocol downloads a Proxy Auto-Configuration (PAC) file, which is a script that identifies the proxy server to use for a given target URL. PAC files are typically deployed by the IT department within a corporate network environment. The URL of the PAC file can either be specified explicitly or <b>WinHttpGetProxyForUrlEx</b> can be instructed to automatically discover the location of the PAC file on the local network.</para>
      <para>
        <b>WinHttpGetProxyForUrlEx</b> supports only ECMAScript-based PAC files.</para>
      <para>
        <b>WinHttpGetProxyForUrlEx</b> must be called on a per-URL basis, because the PAC file can return a different proxy server for different URLs. This is useful because the PAC file enables an IT department to implement proxy server load balancing by mapping (hashing) the target URL (specified by the <i>lpcwszUrl</i> parameter) to a certain proxy in a proxy server array.</para>
      <para>
        <b>WinHttpGetProxyForUrlEx</b> caches the autoproxy URL and the autoproxy script when auto-discovery is specified in the <b>dwFlags</b> member of the <i>pAutoProxyOptions</i> structure. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinHttp/autoproxy-cache">Autoproxy Cache</a>.</para>
      <para>
        <b>WinHttpGetProxyForUrlEx</b> provides a fully Asynchronous and cancellable API that <see cref="WinHttpGetProxyForUrl" /> does not.  <b>WinHttpGetProxyForUrlEx</b> also provides the application with the full proxy list that was returned by the PAC script allowing the application to better handle failover to "DIRECT" and to understand SOCKS if desired.</para>
      <para>
        <b>WinHttpGetProxyForUrlEx</b> always executes asynchronously and returns immediately with <b>ERROR_IO_PENDING</b> on success. The callback is set by calling <see cref="WinHttpSetStatusCallback" /> on the <i>hSession</i> provided by <see cref="WinHttpOpen" />.  Alternately call <b>WinHttpSetStatusCallback</b> on the <i>hResolver</i> provided by <see cref="WinHttpCreateProxyResolver" /> to have a specific callback for each call.</para>
      <para>You must call <see cref="WinHttpSetStatusCallback" /> before <see cref="WinHttpCreateProxyResolver" />. When calling <b>WinHttpSetStatusCallback</b>, use <b>WINHTTP_CALLBACK_FLAG_REQUEST_ERROR |
WINHTTP_CALLBACK_FLAG_GETPROXYFORURL_COMPLETE</b>. See <a href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_STATUS_CALLBACK</a> for information on the use of the callback.</para>
      <para>Once a callback of status <b>WINHTTP_CALLBACK_STATUS_GETPROXYFORURL_COMPLETE</b> is returned, the application can call <see cref="WinHttpGetProxyResult" /> on the resolver handle used to issue <b>WinHttpGetProxyForUrlEx</b> to receive the results of that call.</para>
      <para>If the call fails after returning <b>ERROR_IO_PENDING</b> then a callback of <b>WINHTTP_CALLBACK_STATUS_REQUEST_ERROR</b> will be issued.</para>
      <para>This function always executes out-of-process.</para>
    </remarks>
  </member>
  <member name="Windows.WinHttpGetProxyResult">
    <summary>
      <para>The <b>WinHttpGetProxyResult</b> function retrieves the results of a call to <see cref="WinHttpGetProxyForUrlEx" />.</para>
    </summary>
    <param name="hResolver">
      <para>The resolver handle used to issue a previously completed call to <see cref="WinHttpGetProxyForUrlEx" />.</para>
    </param>
    <param name="pProxyResult">
      <para>A pointer to a <see cref="WINHTTP_PROXY_RESULT" /> structure that contains the results of a previous call to <see cref="WinHttpGetProxyForUrlEx" />.  The results must be freed by calling <see cref="WinHttpFreeProxyResult" />.</para>
    </param>
    <returns>
      <para>A status code indicating the result of the operation.</para>
      <list type="table">
        <listheader>
          <description>The following codes may be returned.</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The resolver handle has not successfully completed a call to <see cref="WinHttpGetProxyForUrlEx" />.</para>
          </description>
        </item>
      </list>
    </returns>
  </member>
  <member name="Windows.WinHttpOpenRequest">
    <summary>
      <para>The <b>WinHttpOpenRequest</b> function creates an HTTP request handle.</para>
    </summary>
    <param name="hConnect">
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> connection handle to an HTTP session returned by
<see cref="WinHttpConnect" />.</para>
    </param>
    <param name="pwszVerb">
      <para>Pointer to a string that contains the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/glossary">HTTP verb</a> to use in the request. If this parameter is <b>NULL</b>, the function uses GET as the <i>HTTP verb</i>. <b>Note</b>  This string should be all uppercase. Many servers treat HTTP verbs as case-sensitive, and the Internet Engineering Task Force (IETF)  Requests for Comments (RFCs) spell these verbs using uppercase characters only.</para>
    </param>
    <param name="pwszObjectName">
      <para>Pointer to a string that contains the name of the target resource of the specified HTTP verb. This is generally a file name, an executable module, or a search specifier.</para>
    </param>
    <param name="pwszVersion">
      <para>Pointer to a string that contains the HTTP version. If this parameter is <b>NULL</b>, the function uses HTTP/1.1.</para>
    </param>
    <param name="pwszReferrer">
      <para>Pointer to a string that specifies the URL of the document from which the URL in the request
<i>pwszObjectName</i> was obtained. If this parameter is set to <b>WINHTTP_NO_REFERER</b>, no referring document is specified.</para>
    </param>
    <param name="ppwszAcceptTypes">
      <para>Pointer to a <b>null</b>-terminated array of string pointers that specifies media types accepted by the client. If this parameter is set to <b>WINHTTP_DEFAULT_ACCEPT_TYPES</b>, no types are accepted by the client. Typically, servers handle a lack of accepted types as indication that the client accepts only documents of type "text/*"; that is, only text documents—no pictures or other binary files. For a list of valid media types, see Media Types defined by IANA at http://www.iana.org/assignments/media-types/.</para>
    </param>
    <param name="dwFlags">
      <para>Unsigned long integer value that contains the Internet flag values. This can be one or more of the following values:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>WINHTTP_FLAG_BYPASS_PROXY_CACHE</b>
          </description>
          <description>
            <para>This flag provides the same behavior as
<b>WINHTTP_FLAG_REFRESH</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_FLAG_ESCAPE_DISABLE</b>
          </description>
          <description>
            <para>Unsafe characters in the URL passed in for
<i>pwszObjectName</i> are not converted to escape sequences.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_FLAG_ESCAPE_DISABLE_QUERY</b>
          </description>
          <description>
            <para>Unsafe characters in the query component of the URL passed in for
<i>pwszObjectName</i> are not converted to escape sequences.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_FLAG_ESCAPE_PERCENT</b>
          </description>
          <description>
            <para>The string passed in for
<i>pwszObjectName</i> is converted from an <b>LPCWSTR</b> to an <b>LPSTR</b>.  All unsafe characters are converted to an escape sequence including the percent symbol.  By default, all unsafe characters except the percent symbol are converted to an escape sequence.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_FLAG_NULL_CODEPAGE</b>
          </description>
          <description>
            <para>The string passed in for
<i>pwszObjectName</i> is assumed to consist of valid ANSI characters represented by <b>WCHAR</b>.  No check are done for unsafe characters.</para>
            <para>
              <b>Windows 7:  </b>This option is obsolete.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_FLAG_REFRESH</b>
          </description>
          <description>
            <para>Indicates that the request should be forwarded to the originating server rather than sending a cached version of a resource from a proxy server.  When this flag is used, a "Pragma: no-cache" header is added to the request handle.  When creating an HTTP/1.1 request header, a "Cache-Control: no-cache" is also added.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_FLAG_SECURE</b>
          </description>
          <description>
            <para>Uses secure transaction semantics. This translates to using Secure Sockets Layer (SSL)/Transport Layer Security (TLS).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>Returns a valid HTTP request handle if successful, or <b>NULL</b> if not. For extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INVALID_URL</b>
            </para>
          </description>
          <description>
            <para>The URL is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_OPERATION_CANCELLED</b>
            </para>
          </description>
          <description>
            <para>The operation was canceled, usually because the handle on which the request was operating was closed before the operation completed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b>
            </para>
          </description>
          <description>
            <para>The URL specified a scheme other than "http:" or "https:".</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The
<b>WinHttpOpenRequest</b> function creates a new HTTP request handle and stores the specified parameters in that handle. An HTTP request handle holds a request to send to an HTTP server and contains all <a href="https://www.ietf.org/rfc/rfc0822.txt">RFC822</a>/MIME/HTTP headers to be sent as part of the request.</para>
      <para>If
<i>pwszVerb</i> is set to "HEAD", the Content-Length header is ignored.</para>
      <para>If a status callback function has been installed with
<see cref="WinHttpSetStatusCallback" />, then a <b>WINHTTP_CALLBACK_STATUS_HANDLE_CREATED</b> notification indicates that
<b>WinHttpOpenRequest</b> has created a request handle.</para>
      <para>After the calling application finishes using the
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle returned by
<b>WinHttpOpenRequest</b>, it must be closed using the
<see cref="WinHttpCloseHandle" /> function.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
      <h4>Examples</h4>
      <para>This example shows how to obtain an
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle, open an HTTP
session, create a request header, and send that header to the server.</para>
      <code>
    BOOL  bResults = FALSE;
    HINTERNET hSession = NULL,
              hConnect = NULL,
              hRequest = NULL;

    // Use WinHttpOpen to obtain a session handle.
    hSession = WinHttpOpen(  L"A WinHTTP Example Program/1.0",
                             WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                             WINHTTP_NO_PROXY_NAME,
                             WINHTTP_NO_PROXY_BYPASS, 0);

    // Specify an HTTP server.
    if (hSession)
        hConnect = WinHttpConnect( hSession, L"www.wingtiptoys.com",
                                   INTERNET_DEFAULT_HTTP_PORT, 0);

    // Create an HTTP Request handle.
    if (hConnect)
        hRequest = WinHttpOpenRequest( hConnect, L"PUT",
                                       L"/writetst.txt",
                                       NULL, WINHTTP_NO_REFERER,
                                       WINHTTP_DEFAULT_ACCEPT_TYPES,
                                       0);

    // Send a Request.
    if (hRequest)
        bResults = WinHttpSendRequest( hRequest,
                                       WINHTTP_NO_ADDITIONAL_HEADERS,
                                       0, WINHTTP_NO_REQUEST_DATA, 0,
                                       0, 0);

    // PLACE ADDITIONAL CODE HERE.

    // Report any errors.
    if (!bResults)
        printf( "Error %d has occurred.\n", GetLastError());

    // Close any open handles.
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpConnect" />
    <seealso cref="WinHttpOpen" />
  </member>
  <member name="Windows.WinHttpQueryAuthSchemes">
    <summary>
      <para>The <b>WinHttpQueryAuthSchemes</b> function returns the authorization schemes that are supported by the server.</para>
    </summary>
    <param name="hRequest">
      <para>Valid
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle returned by
<see cref="WinHttpOpenRequest" /></para>
    </param>
    <param name="lpdwSupportedSchemes">
      <para>An unsigned integer that specifies a flag that contains the supported authentication schemes.  This parameter can return one or more flags that are identified in the following table.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_BASIC</b>
          </description>
          <description>
            <para>Indicates basic authentication is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_NTLM</b>
          </description>
          <description>
            <para>Indicates NTLM authentication is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_PASSPORT</b>
          </description>
          <description>
            <para>Indicates passport authentication is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_DIGEST</b>
          </description>
          <description>
            <para>Indicates digest authentication is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_NEGOTIATE</b>
          </description>
          <description>
            <para>Selects between NTLM and Kerberos authentication.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpdwFirstScheme">
      <para>An unsigned integer that specifies a flag that contains the  first authentication scheme listed by the server.  This parameter can return one or more flags that are identified in the following table.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_BASIC</b>
          </description>
          <description>
            <para>Indicates basic authentication is first.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_NTLM</b>
          </description>
          <description>
            <para>Indicates NTLM authentication is first.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_PASSPORT</b>
          </description>
          <description>
            <para>Indicates passport authentication is first.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_DIGEST</b>
          </description>
          <description>
            <para>Indicates digest authentication is first.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_NEGOTIATE</b>
          </description>
          <description>
            <para>Selects between NTLM and Kerberos authentication.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pdwAuthTarget">
      <para>An unsigned integer that specifies a flag that contains the authentication target.  This parameter can return one or more flags that are identified in the following table.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>WINHTTP_AUTH_TARGET_SERVER</b>
          </description>
          <description>
            <para>Authentication target is a server. Indicates that a 401 status code has been received.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_TARGET_PROXY</b>
          </description>
          <description>
            <para>Authentication target is a proxy. Indicates that a 407 status code has been received.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> if unsuccessful. To get extended error information, call
<see cref="GetLastError" />. The following table identifies the error codes that are returned.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> is set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>
        <b>WinHttpQueryAuthSchemes</b> cannot be used before calling
<see cref="WinHttpQueryHeaders" />.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000 see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
      <h4>Examples</h4>
      <para>The following example shows how to retrieve a specified document from an HTTP server when authentication is required.  The status code is retrieved from the response to determine if the server or proxy is requesting authentication.  If a 200 status code is found, the document is available. If a status code of 401 or 407 is found, authentication is required before the document can be retrieved.  For any other status code an error message is displayed.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;winhttp.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "winhttp.lib")

DWORD ChooseAuthScheme( DWORD dwSupportedSchemes )
{
  //  It is the server's responsibility only to accept
  //  authentication schemes that provide a sufficient level
  //  of security to protect the server's resources.
  //
  //  The client is also obligated only to use an authentication
  //  scheme that adequately protects its username and password.
  //
  //  Thus, this sample code does not use Basic authentication
  //  because Basic authentication exposes the client's username
  //  and password to anyone monitoring the connection.

  if( dwSupportedSchemes &amp;amp;amp;amp;amp;amp; WINHTTP_AUTH_SCHEME_NEGOTIATE )
    return WINHTTP_AUTH_SCHEME_NEGOTIATE;
  else if( dwSupportedSchemes &amp;amp;amp;amp;amp;amp; WINHTTP_AUTH_SCHEME_NTLM )
    return WINHTTP_AUTH_SCHEME_NTLM;
  else if( dwSupportedSchemes &amp;amp;amp;amp;amp;amp; WINHTTP_AUTH_SCHEME_PASSPORT )
    return WINHTTP_AUTH_SCHEME_PASSPORT;
  else if( dwSupportedSchemes &amp;amp;amp;amp;amp;amp; WINHTTP_AUTH_SCHEME_DIGEST )
    return WINHTTP_AUTH_SCHEME_DIGEST;
  else
    return 0;
}

struct SWinHttpSampleGet
{
  LPCWSTR szServer;
  LPCWSTR szPath;
  BOOL fUseSSL;
  LPCWSTR szServerUsername;
  LPCWSTR szServerPassword;
  LPCWSTR szProxyUsername;
  LPCWSTR szProxyPassword;
};

void WinHttpAuthSample( IN SWinHttpSampleGet *pGetRequest )
{
  DWORD dwStatusCode = 0;
  DWORD dwSupportedSchemes;
  DWORD dwFirstScheme;
  DWORD dwSelectedScheme;
  DWORD dwTarget;
  DWORD dwLastStatus = 0;
  DWORD dwSize = sizeof(DWORD);
  BOOL  bResults = FALSE;
  BOOL  bDone = FALSE;

  DWORD dwProxyAuthScheme = 0;
  HINTERNET  hSession = NULL,
             hConnect = NULL,
             hRequest = NULL;

  // Use WinHttpOpen to obtain a session handle.
  hSession = WinHttpOpen( L"WinHTTP Example/1.0",
                          WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                          WINHTTP_NO_PROXY_NAME,
                          WINHTTP_NO_PROXY_BYPASS, 0 );

  INTERNET_PORT nPort = ( pGetRequest-&gt;fUseSSL ) ?
                        INTERNET_DEFAULT_HTTPS_PORT  :
                        INTERNET_DEFAULT_HTTP_PORT;

  // Specify an HTTP server.
  if( hSession )
    hConnect = WinHttpConnect( hSession,
                               pGetRequest-&gt;szServer,
                               nPort, 0 );

  // Create an HTTP request handle.
  if( hConnect )
    hRequest = WinHttpOpenRequest( hConnect,
                                   L"GET",
                                   pGetRequest-&gt;szPath,
                                   NULL,
                                   WINHTTP_NO_REFERER,
                                   WINHTTP_DEFAULT_ACCEPT_TYPES,
                                   ( pGetRequest-&gt;fUseSSL ) ?
                                       WINHTTP_FLAG_SECURE : 0 );

  // Continue to send a request until status code is not 401 or 407.
  if( hRequest == NULL )
    bDone = TRUE;

  while( !bDone )
  {
    //  If a proxy authentication challenge was responded to, reset
    //  those credentials before each SendRequest, because the proxy
    //  may require re-authentication after responding to a 401 or to
    //  a redirect. If you don't, you can get into a 407-401-407-401
    //  loop.
    if( dwProxyAuthScheme != 0 )
      bResults = WinHttpSetCredentials( hRequest,
                                        WINHTTP_AUTH_TARGET_PROXY,
                                        dwProxyAuthScheme,
                                        pGetRequest-&gt;szProxyUsername,
                                        pGetRequest-&gt;szProxyPassword,
                                        NULL );
    // Send a request.
    bResults = WinHttpSendRequest( hRequest,
                                   WINHTTP_NO_ADDITIONAL_HEADERS,
                                   0,
                                   WINHTTP_NO_REQUEST_DATA,
                                   0,
                                   0,
                                   0 );

    // End the request.
    if( bResults )
      bResults = WinHttpReceiveResponse( hRequest, NULL );

    // Resend the request in case of
    // ERROR_WINHTTP_RESEND_REQUEST error.
    if( !bResults &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; GetLastError( ) == ERROR_WINHTTP_RESEND_REQUEST)
        continue;

    // Check the status code.
    if( bResults )
      bResults = WinHttpQueryHeaders( hRequest,
                                      WINHTTP_QUERY_STATUS_CODE |
                                          WINHTTP_QUERY_FLAG_NUMBER,
                                      NULL,
                                      &amp;amp;amp;amp;amp;amp;dwStatusCode,
                                      &amp;amp;amp;amp;amp;amp;dwSize,
                                      NULL );

    if( bResults )
    {
      switch( dwStatusCode )
      {
        case 200:
          // The resource was successfully retrieved.
          // You can use WinHttpReadData to read the contents
          // of the server's response.
          printf( "The resource was successfully retrieved.\n" );
          bDone = TRUE;
          break;

        case 401:
          // The server requires authentication.
          printf(
           "The server requires authentication. Sending credentials\n");

          // Obtain the supported and preferred schemes.
          bResults = WinHttpQueryAuthSchemes( hRequest,
                                              &amp;amp;amp;amp;amp;amp;dwSupportedSchemes,
                                              &amp;amp;amp;amp;amp;amp;dwFirstScheme,
                                              &amp;amp;amp;amp;amp;amp;dwTarget );

          // Set the credentials before re-sending the request.
          if( bResults )
          {
            dwSelectedScheme = ChooseAuthScheme( dwSupportedSchemes );

            if( dwSelectedScheme == 0 )
              bDone = TRUE;
            else
              bResults = WinHttpSetCredentials(
                                        hRequest, dwTarget,
                                        dwSelectedScheme,
                                        pGetRequest-&gt;szServerUsername,
                                        pGetRequest-&gt;szServerPassword,
                                        NULL );
          }

          // If the same credentials are requested twice, abort the
          // request.  For simplicity, this sample does not check for
          // a repeated sequence of status codes.
          if( dwLastStatus == 401 )
            bDone = TRUE;

          break;

        case 407:
          // The proxy requires authentication.
          printf(
           "The proxy requires authentication. Sending credentials\n");

          // Obtain the supported and preferred schemes.
          bResults = WinHttpQueryAuthSchemes( hRequest,
                                              &amp;amp;amp;amp;amp;amp;dwSupportedSchemes,
                                              &amp;amp;amp;amp;amp;amp;dwFirstScheme,
                                              &amp;amp;amp;amp;amp;amp;dwTarget );

          // Set the credentials before re-sending the request.
          if( bResults )
            dwProxyAuthScheme = ChooseAuthScheme(dwSupportedSchemes);

          // If the same credentials are requested twice, abort the
          // request.  For simplicity, this sample does not check for
          // a repeated sequence of status codes.
          if( dwLastStatus == 407 )
            bDone = TRUE;
          break;

        default:
          // The status code does not indicate success.
          printf( "Error. Status code %d returned.\n", dwStatusCode );
          bDone = TRUE;
      }
    }

    // Keep track of the last status code.
    dwLastStatus = dwStatusCode;

    // If there are any errors, break out of the loop.
    if( !bResults )
        bDone = TRUE;
  }

  // Report any errors.
  if( !bResults )
  {
    DWORD dwLastError = GetLastError( );
    printf( "Error %d has occurred.\n", dwLastError );
  }

  // Close any open handles.
  if( hRequest ) WinHttpCloseHandle( hRequest );
  if( hConnect ) WinHttpCloseHandle( hConnect );
  if( hSession ) WinHttpCloseHandle( hSession );
}


</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpSetCredentials" />
  </member>
  <member name="Windows.WinHttpQueryConnectionGroup">
    <summary>
      <para>Retrieves a description of the current state of WinHttp's connections.</para>
    </summary>
    <param name="hInternet">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/winhttp/hinternet-handles-in-winhttp#about-hinternet-handles">HINTERNET</a></b></para>
      <para>A request handle or a connect handle.</para>
      <para>If a connect handle, then WinHttp assumes that the host uses HTTPS by default. But you can pass <b>WINHTTP_QUERY_CONNECTION_GROUP_FLAG_INSECURE</b> (0x0000000000000001ull) in <i>ullFlags</i> to indicate that you want non-HTTPS connections.</para>
    </param>
    <param name="pGuidConnection">
      <para>Type: _In_ <b><see cref="GUID" />*</b></para>
      <para>An optional GUID. If provided, then only connections matching the GUID are returned. Otherwise, the function returns all connections to the host (specified in <i>hInternet</i> either by a request handle or a connect handle).</para>
    </param>
    <param name="ullFlags">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">ULONGLONG</a></b></para>
      <para>Flags. Pass <b>WINHTTP_QUERY_CONNECTION_GROUP_FLAG_INSECURE</b> to indicate that you want non-HTTPS connections (see <i>hInternet</i>).</para>
    </param>
    <param name="ppResult">
      <para>Type: _Inout_ <b><see cref="PWINHTTP_QUERY_CONNECTION_GROUP_RESULT" />*</b></para>
      <para>The address of a pointer to a <see cref="WINHTTP_QUERY_CONNECTION_GROUP_RESULT" />, through which the results are returned.</para>
      <para>WinHttp performs an allocation internally, so once you're done with it you must free this pointer by calling <see cref="WinHttpFreeQueryConnectionGroupResult" />.</para>
    </param>
    <seealso cref="WINHTTP_QUERY_CONNECTION_GROUP_RESULT" />
    <seealso cref="WinHttpFreeQueryConnectionGroupResult" />
  </member>
  <member name="Windows.WinHttpQueryDataAvailable">
    <summary>
      <para>The <b>WinHttpQueryDataAvailable</b> function returns the amount of data, in bytes, available to be read with
<see cref="WinHttpReadData" />.</para>
    </summary>
    <param name="hRequest">
      <para>A valid
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle returned by
<see cref="WinHttpOpenRequest" />. <see cref="WinHttpReceiveResponse" /> must have been called for this handle and have completed before <b>WinHttpQueryDataAvailable</b> is called.</para>
    </param>
    <param name="lpdwNumberOfBytesAvailable">
      <para>A pointer to an unsigned long integer variable that receives the number of available bytes. When WinHTTP is used in asynchronous mode, always set this parameter to <b>NULL</b> and retrieve data in the callback function; not doing so can cause a memory fault.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if the function succeeds, or <b>FALSE</b> otherwise. To get extended error data, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_CONNECTION_ERROR</b>
            </para>
          </description>
          <description>
            <para>The connection with the server has been reset or terminated, or an incompatible SSL protocol was encountered. For example, WinHTTP version 5.1 does not support SSL2 unless the client specifically enables it.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot complete because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_OPERATION_CANCELLED</b>
            </para>
          </description>
          <description>
            <para>The operation was canceled, usually because the handle on which the request was operating was closed before the operation completed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_TIMEOUT</b>
            </para>
          </description>
          <description>
            <para>The request has timed out.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function can operate either synchronously or asynchronously.  If it returns <b>FALSE</b>, it failed and you can call
<see cref="GetLastError" /> to get extended error information. If it returns <b>TRUE</b>, use the WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE completion to determine whether this function was successful and the value of the parameters.  The WINHTTP_CALLBACK_STATUS_REQUEST_ERROR completion indicates that the operation completed asynchronously, but failed.</para>
      <para>
        <b>Warning</b>  When WinHTTP is used in asynchronous mode, always set the <i>lpdwNumberOfBytesAvailable</i> parameter to <b>NULL</b> and retrieve the bytes available in the callback function; otherwise, a memory fault can occur.</para>
      <para>This function returns the number of bytes of data that are available to read immediately by a subsequent call to
<see cref="WinHttpReadData" />. If no data is available and the end of the file has not been reached, one of two things happens.  If the session is synchronous, the request waits until data becomes available. If the session is asynchronous, the function returns <b>TRUE</b>, and when data becomes available, calls the callback function with WINHTTP_STATUS_CALLBACK_DATA_AVAILABLE and indicates the number of bytes immediately available  to read by calling <b>WinHttpReadData</b>.</para>
      <para>The amount of data that remains is not recalculated until all available data indicated by the call to
<b>WinHttpQueryDataAvailable</b> is read.</para>
      <para>Use the return value of <see cref="WinHttpReadData" /> to determine when a response has been completely read.</para>
      <para>
        <b>Important</b>  Do not use the return value of <b>WinHttpQueryDataAvailable</b> to determine whether the end of a response has been reached, because not all servers terminate responses properly, and an improperly terminated response causes <b>WinHttpQueryDataAvailable</b> to anticipate more data.</para>
      <para>For
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handles created by the
<see cref="WinHttpOpenRequest" /> function and sent by
<see cref="WinHttpSendRequest" />, a call to
<see cref="WinHttpReceiveResponse" /> must be made on the handle before
<b>WinHttpQueryDataAvailable</b> can be used.</para>
      <para>If a status callback function has been installed with
<see cref="WinHttpSetStatusCallback" />, then those of the following notifications  that  have been set in the <i>dwNotificationFlags</i> parameter of <b>WinHttpSetStatusCallback</b> indicate progress in checking for available data:</para>
      <list type="bullet">
        <item>
          <description>WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE</description>
        </item>
      </list>
      <b>Note</b>  For more information about Windows XP and Windows 2000, see <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a>.
</remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpConnect" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpOpenRequest" />
    <seealso cref="WinHttpReadData" />
    <seealso cref="WinHttpSendRequest" />
  </member>
  <member name="Windows.WinHttpQueryHeaders">
    <summary>
      <para>The <b>WinHttpQueryHeaders</b> function retrieves header information associated with an HTTP request.</para>
      <para>Also see <see cref="WinHttpQueryHeadersEx" />, which offers a way to retrieve parsed header name and value strings.</para>
    </summary>
    <param name="hRequest">
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> request handle returned by
<see cref="WinHttpOpenRequest" />.
WinHttpReceiveResponse must have been called for this handle and have completed before <b>WinHttpQueryHeaders</b> is called.</para>
    </param>
    <param name="dwInfoLevel">
      <para>Value of type <b>DWORD</b> that specifies a combination of attribute and modifier flags listed on the
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/query-info-flags">Query Info Flags</a> page. These attribute and modifier flags indicate that the information is being requested and how it is to be formatted.</para>
    </param>
    <param name="pwszName">
      <para>Pointer to a string that contains the header name. If the flag in
<i>dwInfoLevel</i> is not
<b>WINHTTP_QUERY_CUSTOM</b>, set this parameter to WINHTTP_HEADER_NAME_BY_INDEX.</para>
    </param>
    <param name="lpBuffer">
      <para>Pointer to the buffer that receives the information. Setting this parameter to WINHTTP_NO_OUTPUT_BUFFER causes this function to return <b>FALSE</b>.  Calling
<see cref="GetLastError" /> then returns
<b>ERROR_INSUFFICIENT_BUFFER</b> and
<i>lpdwBufferLength</i> contains the number of bytes required to hold the requested information.</para>
    </param>
    <param name="lpdwBufferLength">
      <para>Pointer to a value of type <b>DWORD</b> that specifies the length of the data buffer, in bytes. When the function returns, this parameter contains the pointer to a value that specifies the length of the information written to the buffer. When the function returns strings, the following rules apply.</para>
      <list type="bullet">
        <item>
          <description>If the function succeeds,
<i>lpdwBufferLength</i> specifies the length of the string, in bytes, minus 2 for the terminating null. </description>
        </item>
        <item>
          <description>If the function fails and
<b>ERROR_INSUFFICIENT_BUFFER</b> is returned,
<i>lpdwBufferLength</i> specifies the number of bytes that the application must allocate to receive the string. </description>
        </item>
      </list>
    </param>
    <param name="lpdwIndex">
      <para>Pointer to a zero-based header index used to enumerate multiple headers with the same name. When calling the function, this parameter is the index of the specified header to return. When the function returns, this parameter is the index of the next header. If the next index cannot be found,
<b>ERROR_WINHTTP_HEADER_NOT_FOUND</b> is returned. Set this parameter to WINHTTP_NO_HEADER_INDEX to specify that only the first occurrence of a header should be returned.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. To get extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_HEADER_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The requested header could not be located.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be carried out because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>By default
<b>WinHttpQueryHeaders</b> returns a string.  However, you can request data in the form of a
<see cref="SYSTEMTIME" /> structure or <b>DWORD</b> by including the appropriate modifier flag in
<i>dwInfoLevel</i>.  The following table shows the possible data types that
<b>WinHttpQueryHeaders</b> can return along with the modifier flag that you use to select that data type.</para>
      <list type="table">
        <listheader>
          <description>Data type</description>
          <description>Modifier flag</description>
        </listheader>
        <item>
          <description>
            <b>LPCWSTR</b>
          </description>
          <description>Default.  No modifier flag required.</description>
        </item>
        <item>
          <description>
            <b>SYSTEMTIME</b>
          </description>
          <description>
            <b>WINHTTP_QUERY_FLAG_SYSTEMTIME</b>
          </description>
        </item>
        <item>
          <description>
            <b>DWORD</b>
          </description>
          <description>
            <b>WINHTTP_QUERY_FLAG_NUMBER</b>
          </description>
        </item>
      </list>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
      <h4>Examples</h4>
      <para>The following example shows how to obtain an
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle, open an HTTP session, create and send a request header, and examine the returned response header.</para>
      <code>    DWORD dwSize = 0;
    LPVOID lpOutBuffer = NULL;
    BOOL  bResults = FALSE;
    HINTERNET hSession = NULL,
              hConnect = NULL,
              hRequest = NULL;

    // Use WinHttpOpen to obtain a session handle.
    hSession = WinHttpOpen(  L"A WinHTTP Example Program/1.0",
                             WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                             WINHTTP_NO_PROXY_NAME,
                             WINHTTP_NO_PROXY_BYPASS, 0);

    // Specify an HTTP server.
    if (hSession)
        hConnect = WinHttpConnect( hSession, L"www.microsoft.com",
                                   INTERNET_DEFAULT_HTTP_PORT, 0);

    // Create an HTTP request handle.
    if (hConnect)
        hRequest = WinHttpOpenRequest( hConnect, L"GET", NULL,
                                       NULL, WINHTTP_NO_REFERER,
                                       WINHTTP_DEFAULT_ACCEPT_TYPES,
                                       0);

    // Send a request.
    if (hRequest)
        bResults = WinHttpSendRequest( hRequest,
                                       WINHTTP_NO_ADDITIONAL_HEADERS,
                                       0, WINHTTP_NO_REQUEST_DATA, 0,
                                       0, 0);

    // End the request.
    if (bResults)
        bResults = WinHttpReceiveResponse( hRequest, NULL);

    // First, use WinHttpQueryHeaders to obtain the size of the buffer.
    if (bResults)
    {
        WinHttpQueryHeaders( hRequest, WINHTTP_QUERY_RAW_HEADERS_CRLF,
                             WINHTTP_HEADER_NAME_BY_INDEX, NULL,
                             &amp;amp;amp;amp;amp;amp;dwSize, WINHTTP_NO_HEADER_INDEX);

        // Allocate memory for the buffer.
        if( GetLastError( ) == ERROR_INSUFFICIENT_BUFFER )
        {
            lpOutBuffer = new WCHAR[dwSize/sizeof(WCHAR)];

            // Now, use WinHttpQueryHeaders to retrieve the header.
            bResults = WinHttpQueryHeaders( hRequest,
                                       WINHTTP_QUERY_RAW_HEADERS_CRLF,
                                       WINHTTP_HEADER_NAME_BY_INDEX,
                                       lpOutBuffer, &amp;amp;amp;amp;amp;amp;dwSize,
                                       WINHTTP_NO_HEADER_INDEX);
        }
    }

    // Print the header contents.
    if (bResults)
        printf("Header contents: \n%S",lpOutBuffer);

    // Free the allocated memory.
    delete [] lpOutBuffer;

    // Report any errors.
    if (!bResults)
        printf("Error %d has occurred.\n",GetLastError());

    // Close any open handles.
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpConnect" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpOpenRequest" />
  </member>
  <member name="Windows.WinHttpQueryHeadersEx">
    <summary>
      <para>Retrieves header information associated with an HTTP request; offers a way to retrieve parsed header name and value strings.</para>
    </summary>
    <param name="hRequest">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/winhttp/hinternet-handles-in-winhttp">HINTERNET</a></b></para>
      <para>Request handle returned by <see cref="WinHttpOpenRequest" />. The <see cref="WinHttpReceiveResponse" /> call for this handle must have completed before calling <b>WinHttpQueryHeadersEx</b>. If you're querying trailers, then the <see cref="WinHttpReadData" /> call for this handle must return 0 bytes read before calling <b>WinHttpQueryHeadersEx</b>.</para>
    </param>
    <param name="dwInfoLevel">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">DWORD</a></b></para>
      <para>Value of type <b>DWORD</b> that specifies a combination of attribute and modifier flags listed in the
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/query-info-flags">Query info flags</a> topic. These attribute and modifier flags indicate the information that is being requested, and how it is to be formatted.</para>
      <blockquote>
        <para>[!NOTE]
The following flags return <b>ERROR_INVALID_PARAMETER</b> if used: <b>WINHTTP_QUERY_VERSION</b>, <b>WINHTTP_QUERY_STATUS_CODE</b>, <b>WINHTTP_QUERY_STATUS_TEXT</b>, <b>WINHTTP_QUERY_FLAG_NUMBER</b>, <b>WINHTTP_QUERY_FLAG_NUMBER64</b>, <b>WINHTTP_QUERY_FLAG_SYSTEMTIME</b>, and <b>WINHTTP_QUERY_RAW_HEADERS_CRLF</b>.</para>
      </blockquote>
      <para>The flag <b>WINHTTP_QUERY_EX_ALL_HEADERS</b> returns all the headers.</para>
      <para>If you're not querying for all of the headers, then you can pass the flag corresponding to a specific known header, or you can pass <b>WINHTTP_QUERY_CUSTOM</b> along with a string for the header name in the <i>pHeaderName</i> parameter.</para>
      <para>Passing <b>WINHTTP_QUERY_FLAG_WIRE_ENCODING</b> returns the headers in the format in which they're sent over the wire (you should access/set the <i>psz*</i> members of <see cref="WINHTTP_EXTENDED_HEADER" /> and <see cref="WINHTTP_HEADER_NAME" />). If you don't set the wire encoding flag, then the default behavior is to return headers in Unicode format (you should access/set the <i>pwsz*</i> members of <see cref="WINHTTP_EXTENDED_HEADER" /> and <see cref="WINHTTP_HEADER_NAME" />).</para>
    </param>
    <param name="ullFlags">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">ULONGLONG</a></b></para>
      <para>Reserved. Set to 0.</para>
    </param>
    <param name="uiCodePage">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">UINT</a></b></para>
      <para>The code page to use for Unicode conversion. You should pass in 0 for default behavior (CP_ACP), or when using <b>WINHTTP_QUERY_FLAG_WIRE_ENCODING</b>. No validation is done for this parameter.</para>
    </param>
    <param name="pdwIndex">
      <para>Type: _Inout_opt_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">PDWORD</a></b></para>
      <para>The address of a zero-based index used to enumerate multiple headers with the same name. When calling the function, this parameter is the index of the specified header to return. When the function returns, this parameter is the index of the next header. Pass <b>NULL</b> to access the first instance of a given header.</para>
    </param>
    <param name="pHeaderName">
      <para>Type: _Inout_opt_ <b><see cref="PWINHTTP_HEADER_NAME" /></b></para>
      <para>The address of a <see cref="WINHTTP_HEADER_NAME" /> structure.</para>
      <para>Set <i>pHeaderName</i> to <b>NULL</b> when retrieving all headers. If this parameter is not <b>NULL</b>, and you pass <b>WINHTTP_QUERY_CUSTOM</b> with <i>dwInfoLevel</i>, then <b>WinHttpQueryHeadersEx</b> will retrieve only the header specified by this parameter. If you pass <b>WINHTTP_QUERY_FLAG_WIRE_ENCODING</b> with <i>dwInfoLevel</i>, then you should use the <i>pszName</i> member (if the flag is not set, then use <i>pwszName</i> member).</para>
    </param>
    <param name="pBuffer">
      <para>Type: _Out_writes_bytes_to_opt_(*pdwBufferLength, *pdwBufferLength) <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">LPVOID</a></b></para>
      <para>A caller-provided buffer to store the parsed header pointers and the headers. If this parameter is <b>NULL</b> or too small, then <b>WinHttpQueryHeadersEx</b> returns <b>ERROR_INSUFFICIENT_BUFFER</b>, and the <i>pdwBufferLength</i> parameter contains the required buffer size in bytes.</para>
    </param>
    <param name="pdwBufferLength">
      <para>Type: _Inout_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">PDWORD</a></b></para>
      <para>Length of the caller-provided buffer. If <i>pBuffer</i> is <b>NULL</b> or too small, then <b>WinHttpQueryHeadersEx</b> writes the required buffer size in bytes to this parameter.</para>
    </param>
    <param name="ppHeaders">
      <para>Type: _Out_writes_opt_(*pdwHeadersCount) <b><see cref="PWINHTTP_EXTENDED_HEADER" />*</b></para>
      <para>A handle to an array of <see cref="WINHTTP_EXTENDED_HEADER" /> for accessing parsed header names/values. You should pass in the address of a <b>WINHTTP_EXTENDED_HEADER</b> pointer that's initialized to <b>NULL</b>. Upon completion, you should access the <i>pszName</i>/<i>pszValue</i> parameters if using <b>WINHTTP_QUERY_FLAG_WIRE_ENCODING</b>, and <i>pwszName</i>/<i>pwszValue</i> otherwise.</para>
    </param>
    <param name="pdwHeadersCount">
      <para>Type: _Out_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">PDWORD</a></b></para>
      <para>The number of headers returned. You shouldn't try to access beyond <code>ppHeaders[cHeaders - 1]</code>, because that is out of bounds of the array.</para>
    </param>
    <returns>
      <para>A status code indicating the result of the operation. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_HEADER_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The requested header could not be located.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be carried out because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>WinHttpQueryHeadersEx</b> builds on the functionality of <see cref="WinHttpQueryHeaders" />. <b>WinHttpQueryHeaders</b> allows you to query request or response headers (or response trailers) in the form of a string, a number (DWORD), or a timestamp (SYSTEMTIME). Querying for all headers returns a single serialized string with CRLF or NULL characters delimiting different headers. For example, "Name1: value1\r\nName2: value2\r\n\r\n". Or "Name1: value1\0Name2: value2\0\0". A double delimiter is used to indicate the end of the string.</para>
      <para>
        <b>WinHttpQueryHeadersEx</b> gives you a way to retrieve parsed header name and value strings.</para>
    </remarks>
  </member>
  <member name="Windows.WinHttpQueryOption">
    <summary>
      <para>The <b>WinHttpQueryOption</b> function queries an Internet option on the specified handle.</para>
    </summary>
    <param name="hInternet">
      <para>An <b>HINTERNET</b> handle on which to query information. Note that this can be either a Session handle or a Request handle, depending on what option is being queried; see the  <a href="https://docs.microsoft.com//windows/desktop/WinHttp/option-flags">Option Flags</a> topic to determine which handle is appropriate to use in querying a particular option.</para>
    </param>
    <param name="dwOption">
      <para>An unsigned long integer value that contains the Internet option to query. This can be one of the
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/option-flags">Option Flags</a> values.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the option setting. Strings returned by the
<b>WinHttpQueryOption</b> function are globally allocated, so the calling application must globally free the string when it finishes using it. Setting this parameter to <b>NULL</b> causes this function to return <b>FALSE</b>.  Calling
<see cref="GetLastError" /> then returns ERROR_INSUFFICIENT_BUFFER and
<i>lpdwBufferLength</i>          contains the number of bytes required to hold the requested information.</para>
    </param>
    <param name="lpdwBufferLength">
      <para>A pointer to an unsigned long integer variable that contains the length of
<i>lpBuffer</i>, in bytes. When the function returns, the variable receives the length of the data placed into
<i>lpBuffer</i>. If
<see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER, this parameter receives the number of bytes required to hold the requested information.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. To get a specific error message, call
<see cref="GetLastError" />. Among the error codes returned are the following:</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be carried out because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INVALID_OPTION</b>
            </para>
          </description>
          <description>
            <para>An invalid option value was specified.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>
        <see cref="GetLastError" /> returns the ERROR_INVALID_PARAMETER if an option flag that is invalid for the specified handle type is passed to the
<i>dwOption</i> parameter.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
      <h4>Examples</h4>
      <para>This example demonstrates retrieving the connection
time-out value:</para>
      <code>    DWORD data;
    DWORD dwSize = sizeof(DWORD);

    // Use WinHttpOpen to obtain an HINTERNET handle.
    HINTERNET hSession = WinHttpOpen(L"A WinHTTP Example Program/1.0",
                                    WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                                    WINHTTP_NO_PROXY_NAME,
                                    WINHTTP_NO_PROXY_BYPASS, 0);
    if (hSession)
    {


        // Use WinHttpQueryOption to retrieve internet options.
        if (WinHttpQueryOption( hSession,
                                WINHTTP_OPTION_CONNECT_TIMEOUT,
                                &amp;amp;amp;amp;amp;amp;data, &amp;amp;amp;amp;amp;amp;dwSize))
        {
            printf("Connection timeout: %u ms\n\n",data);
        }
        else
        {
            printf( "Error %u in WinHttpQueryOption.\n", GetLastError());
        }

        // When finished, release the HINTERNET handle.
        WinHttpCloseHandle(hSession);
    }
    else
    {
        printf("Error %u in WinHttpOpen.\n", GetLastError());
    }

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/option-flags">Option Flags</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpConnect" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpOpenRequest" />
  </member>
  <member name="Windows.WinHttpReadData">
    <summary>
      <para>The <b>WinHttpReadData</b> function reads data from a handle opened by the
<see cref="WinHttpOpenRequest" /> function.</para>
      <para>Also see <see cref="WinHttpReadDataEx" />.</para>
    </summary>
    <param name="hRequest">
      <para>Valid
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle returned from a previous call to
<see cref="WinHttpOpenRequest" />. <see cref="WinHttpReceiveResponse" /> or <see cref="WinHttpQueryDataAvailable" /> must have been called for this handle and must have completed before <b>WinHttpReadData</b> is called. Although calling <b>WinHttpReadData</b> immediately after completion of <b>WinHttpReceiveResponse</b> avoids the expense of a buffer copy, doing so requires that the application use a fixed-length buffer for reading.</para>
    </param>
    <param name="lpBuffer">
      <para>Pointer to a buffer that receives the data read. Make sure that this buffer remains valid until <b>WinHttpReadData</b> has completed.</para>
    </param>
    <param name="dwNumberOfBytesToRead">
      <para>Unsigned long integer value that contains the number of bytes to read.</para>
    </param>
    <param name="lpdwNumberOfBytesRead">
      <para>Pointer to an unsigned long integer variable that receives the number of bytes read.
<b>WinHttpReadData</b> sets this value to zero before doing any work or error checking.  When using WinHTTP asynchronously, always set this parameter to <b>NULL</b> and retrieve the information in the callback function; not doing so can cause a memory fault.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. The following table identifies the error codes that are returned.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_CONNECTION_ERROR</b>
            </para>
          </description>
          <description>
            <para>The connection with the server has been reset or terminated, or an incompatible SSL protocol was encountered. For example, WinHTTP 5.1 does not support SSL2 unless the client specifically enables it.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be carried out because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_OPERATION_CANCELLED</b>
            </para>
          </description>
          <description>
            <para>The operation was canceled, usually because the handle on which the request was operating was closed before the operation completed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>Returned when an incoming response exceeds an internal WinHTTP size limit.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_TIMEOUT</b>
            </para>
          </description>
          <description>
            <para>The request has timed out.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Starting in Windows Vista and Windows Server 2008, WinHttp enables applications to perform chunked transfer encoding on data sent to the server. When the Transfer-Encoding header is present on the WinHttp  response, <b>WinHttpReadData</b> strips the chunking information before giving the data to the application.</para>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function can operate either synchronously or asynchronously.  If this function returns <b>FALSE</b>, this function failed and you can call
<see cref="GetLastError" /> to get extended error information. If this function returns <b>TRUE</b>, use the WINHTTP_CALLBACK_STATUS_READ_COMPLETE completion to determine whether this function was successful and the value of the parameters.  The WINHTTP_CALLBACK_STATUS_REQUEST_ERROR completion indicates that the operation completed asynchronously, but failed.</para>
      <para>
        <b>Warning</b>  When  WinHTTP is used in asynchronous mode, always set the <i>lpdwNumberOfBytesRead</i> parameter to <b>NULL</b> and retrieve the bytes read in the callback function; otherwise, a memory fault can occur.</para>
      <para>When the read buffer is very small,
<b>WinHttpReadData</b> might complete synchronously.  If the WINHTTP_CALLBACK_STATUS_READ_COMPLETE completion triggers another call to
<b>WinHttpReadData</b>, the situation can result in a stack overflow.  In general, it is best to use a read buffer that is comparable in size, or larger than the internal read buffer used by WinHTTP, which is 8 KB.</para>
      <para>If you are using <b>WinHttpReadData</b> synchronously, and the return value is <b>TRUE</b> and the number of bytes read is zero, the transfer has been completed and there are no more bytes to read on the handle. This is analogous to reaching end-of-file in a local file. If you are using the function asynchronously, the <a href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_CALLBACK_STATUS_READ_COMPLETE</a> callback is called with the <i>dwStatusInformationLength</i> parameter set to zero when the end of a response is found.</para>
      <para>
        <b>WinHttpReadData</b> tries to fill the buffer pointed to by
<i>lpBuffer</i> until there is no more data available from the response.  If sufficient data has not arrived from the server, the buffer is not filled.</para>
      <para>For
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handles created by the
<see cref="WinHttpOpenRequest" /> function and sent by
<see cref="WinHttpSendRequest" />, a call to
<see cref="WinHttpReceiveResponse" /> must be made on the handle before
<b>WinHttpReadData</b> can be used.</para>
      <para>Single byte characters retrieved with
<b>WinHttpReadData</b> are not converted to multi-byte characters.</para>
      <para>When the read buffer is very small, <b>WinHttpReadData</b> may complete synchronously, and if the <b>WINHTTP_CALLBACK_STATUS_READ_COMPLETE</b> completion then triggers another call to <b>WinHttpReadData</b>, a stack overflow can result. It is best to use a read buffer that is 8 Kilobytes or larger in size.</para>
      <para>If sufficient data has not arrived from the server, <b>WinHttpReadData</b> does not entirely fill the buffer pointed to by <i>lpBuffer</i>. The buffer must be large enough at least to hold the HTTP headers on the first read, and when reading HTML encoded directory entries, it must be large enough to hold at least one complete entry.</para>
      <para>If a status callback function has been installed by using <see cref="WinHttpSetStatusCallback" />, then those of the following notifications  that  have been set in the <i>dwNotificationFlags</i> parameter of <b>WinHttpSetStatusCallback</b> indicate progress in checking for available data:</para>
      <list type="bullet">
        <item>
          <description>WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_READ_COMPLETE</description>
        </item>
      </list>
      <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/win32/winhttp/winhttp-start-page#run-time-requirements">Run-Time Requirements</a> section of the WinHttp start page.
<h4>Examples</h4><para>The following example shows how to use secure transaction semantics to download a resource from an Secure Hypertext Transfer Protocol (HTTPS) server. The sample code initializes the WinHTTP application programming interface (API), selects a target HTTPS server, then opens and sends a request for this secure resource.
<see cref="WinHttpQueryDataAvailable" /> is used with the request handle to determine how much data is available for download, then
<b>WinHttpReadData</b> is used to read that data.  This process repeats until the entire document has been retrieved and displayed.</para><code>    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    BOOL  bResults = FALSE;
    HINTERNET  hSession = NULL,
               hConnect = NULL,
               hRequest = NULL;

    // Use WinHttpOpen to obtain a session handle.
    hSession = WinHttpOpen( L"WinHTTP Example/1.0",
                            WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                            WINHTTP_NO_PROXY_NAME,
                            WINHTTP_NO_PROXY_BYPASS, 0);

    // Specify an HTTP server.
    if (hSession)
        hConnect = WinHttpConnect( hSession, L"www.microsoft.com",
                                   INTERNET_DEFAULT_HTTPS_PORT, 0);

    // Create an HTTP request handle.
    if (hConnect)
        hRequest = WinHttpOpenRequest( hConnect, L"GET", NULL,
                                       NULL, WINHTTP_NO_REFERER,
                                       WINHTTP_DEFAULT_ACCEPT_TYPES,
                                       WINHTTP_FLAG_SECURE);

    // Send a request.
    if (hRequest)
        bResults = WinHttpSendRequest( hRequest,
                                       WINHTTP_NO_ADDITIONAL_HEADERS,
                                       0, WINHTTP_NO_REQUEST_DATA, 0,
                                       0, 0);


    // End the request.
    if (bResults)
        bResults = WinHttpReceiveResponse( hRequest, NULL);

    // Keep checking for data until there is nothing left.
    if (bResults)
    {
        do
        {
            // Check for available data.
            dwSize = 0;
            if (!WinHttpQueryDataAvailable( hRequest, &amp;amp;amp;amp;amp;amp;dwSize))
            {
                printf( "Error %u in WinHttpQueryDataAvailable.\n",
                        GetLastError());
                break;
            }

            // No more available data.
            if (!dwSize)
                break;

            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize+1];
            if (!pszOutBuffer)
            {
                printf("Out of memory\n");
                break;
            }

            // Read the Data.
            ZeroMemory(pszOutBuffer, dwSize+1);

            if (!WinHttpReadData( hRequest, (LPVOID)pszOutBuffer,
                                  dwSize, &amp;amp;amp;amp;amp;amp;dwDownloaded))
            {
                printf( "Error %u in WinHttpReadData.\n", GetLastError());
            }
            else
            {
                printf("%s", pszOutBuffer);
            }

            // Free the memory allocated to the buffer.
            delete [] pszOutBuffer;

            // This condition should never be reached since WinHttpQueryDataAvailable
            // reported that there are bits to read.
            if (!dwDownloaded)
                break;

        } while (dwSize &gt; 0);
    }
    else
    {
        // Report any errors.
        printf( "Error %d has occurred.\n", GetLastError() );
    }

    // Close any open handles.
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);

</code></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpConnect" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpOpenRequest" />
    <seealso cref="WinHttpQueryDataAvailable" />
    <seealso cref="WinHttpSendRequest" />
    <seealso cref="WinHttpWriteData" />
  </member>
  <member name="Windows.WinHttpReceiveResponse">
    <summary>
      <para>The <b>WinHttpReceiveResponse</b> function waits to receive the response to an HTTP request initiated by <see cref="WinHttpSendRequest" />. When <b>WinHttpReceiveResponse</b> completes successfully, the status code and response headers have been received and are available for the application to inspect using <see cref="WinHttpQueryHeaders" />. An application must call <b>WinHttpReceiveResponse</b> before it can use <see cref="WinHttpQueryDataAvailable" /> and <see cref="WinHttpReadData" /> to access the response entity body (if any).</para>
    </summary>
    <param name="hRequest">
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle returned by
<see cref="WinHttpOpenRequest" /> and sent by
<see cref="WinHttpSendRequest" />.  Wait until <b>WinHttpSendRequest</b> has completed for this handle before calling  <b>WinHttpReceiveResponse</b>.</para>
    </param>
    <param name="lpReserved">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_CANNOT_CONNECT</b>
            </para>
          </description>
          <description>
            <para>Returned if  connection to the server failed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_CHUNKED_ENCODING_HEADER_SIZE_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>Returned when an overflow condition is encountered in the course of parsing chunked encoding.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED</b>
            </para>
          </description>
          <description>
            <para>Returned when the server requests client authentication.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_CONNECTION_ERROR</b>
            </para>
          </description>
          <description>
            <para>The connection with the server has been reset or terminated, or an incompatible SSL protocol was encountered. For example, WinHTTP version 5.1 does not support SSL2 unless the client specifically enables it.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_HEADER_COUNT_EXCEEDED</b>
            </para>
          </description>
          <description>
            <para>Returned when a larger number of headers were present in a response than WinHTTP could receive.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_HEADER_SIZE_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>Returned by <see cref="WinHttpReceiveResponse" /> when the size of headers received  exceeds the limit for the request handle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be carried out because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INVALID_SERVER_RESPONSE</b>
            </para>
          </description>
          <description>
            <para>The server response could not be parsed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INVALID_URL</b>
            </para>
          </description>
          <description>
            <para>The URL is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_LOGIN_FAILURE</b>
            </para>
          </description>
          <description>
            <para>The login attempt failed.  When this error is encountered, the request handle should be closed with
<see cref="WinHttpCloseHandle" />.  A new request handle must be created before retrying the function that originally produced this error.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_NAME_NOT_RESOLVED</b>
            </para>
          </description>
          <description>
            <para>The server name could not be resolved.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_OPERATION_CANCELLED</b>
            </para>
          </description>
          <description>
            <para>The operation was canceled, usually because the handle on which the request was operating was closed before the operation completed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_REDIRECT_FAILED</b>
            </para>
          </description>
          <description>
            <para>The redirection failed because either the scheme changed or all attempts made to redirect failed (default is five attempts).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_RESEND_REQUEST</b>
            </para>
          </description>
          <description>
            <para>The WinHTTP function failed.  The desired function can be retried on the same request handle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>Returned when an incoming response exceeds an internal WinHTTP size limit.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_SECURE_FAILURE</b>
            </para>
          </description>
          <description>
            <para>One or more errors were found in the Secure Sockets Layer (SSL) certificate sent by the server.  To determine what type of error was encountered, check for a
<a href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_CALLBACK_STATUS_SECURE_FAILURE</a> notification in a status callback function.  For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_STATUS_CALLBACK</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_TIMEOUT</b>
            </para>
          </description>
          <description>
            <para>The request has timed out.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b>
            </para>
          </description>
          <description>
            <para>The URL specified a scheme other than "http:" or "https:".</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function can operate either synchronously or asynchronously.  If this function returns <b>FALSE</b>, this function failed and you can call
<see cref="GetLastError" /> to get extended error information. If this function returns <b>TRUE</b>, the application should expect either the <b>WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE</b> completion callback, indicating success, or the <b>WINHTTP_CALLBACK_STATUS_REQUEST_ERROR</b> completion callback, indicating that the operation completed asynchronously, but failed.</para>
      <para>If a status callback function has been installed with
<see cref="WinHttpSetStatusCallback" />, then those of the following notifications  that  have been set in the <i>dwNotificationFlags</i> parameter of <b>WinHttpSetStatusCallback</b> indicate progress in receiving the response:</para>
      <list type="bullet">
        <item>
          <description>WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE </description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE </description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_REDIRECT</description>
        </item>
      </list>
      <para>If the server closes the connection, the following notifications will also be reported, provided that they have been set in the <i>dwNotificationFlags</i> parameter of <see cref="WinHttpSetStatusCallback" />:</para>
      <list type="bullet">
        <item>
          <description>WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED</description>
        </item>
      </list>
      <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.
<h4>Examples</h4><para>This example shows code that  writes data to an HTTP server.  The server name supplied in the example, www.wingtiptoys.com, is fictitious and must be replaced with the name of a server for which you have write access.</para><code>    LPSTR pszData = "WinHttpWriteData Example";
    DWORD dwBytesWritten = 0;
    BOOL  bResults = FALSE;
    HINTERNET hSession = NULL,
              hConnect = NULL,
              hRequest = NULL;

    // Use WinHttpOpen to obtain a session handle.
    hSession = WinHttpOpen(  L"A WinHTTP Example Program/1.0",
                             WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                             WINHTTP_NO_PROXY_NAME,
                             WINHTTP_NO_PROXY_BYPASS, 0);

    // Specify an HTTP server.
    if (hSession)
        hConnect = WinHttpConnect( hSession, L"www.wingtiptoys.com",
                                   INTERNET_DEFAULT_HTTP_PORT, 0);

    // Create an HTTP Request handle.
    if (hConnect)
        hRequest = WinHttpOpenRequest( hConnect, L"PUT",
                                       L"/writetst.txt",
                                       NULL, WINHTTP_NO_REFERER,
                                       WINHTTP_DEFAULT_ACCEPT_TYPES,
                                       0);

    // Send a Request.
    if (hRequest)
        bResults = WinHttpSendRequest( hRequest,
                                       WINHTTP_NO_ADDITIONAL_HEADERS,
                                       0, WINHTTP_NO_REQUEST_DATA, 0,
                                       (DWORD)strlen(pszData), 0);

    // Write data to the server.
    if (bResults)
        bResults = WinHttpWriteData( hRequest, pszData,
                                     (DWORD)strlen(pszData),
                                     &amp;amp;amp;amp;amp;amp;dwBytesWritten);

    // End the request.
    if (bResults)
        bResults = WinHttpReceiveResponse( hRequest, NULL);

    // Report any errors.
    if (!bResults)
        printf("Error %d has occurred.\n",GetLastError());


    // Close any open handles.
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);

</code></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpOpenRequest" />
    <seealso cref="WinHttpSendRequest" />
  </member>
  <member name="Windows.WinHttpResetAutoProxy">
    <summary>
      <para>The <b>WinHttpResetAutoProxy</b> function resets the auto-proxy.</para>
    </summary>
    <param name="hSession">
      <para>A valid
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> WinHTTP session handle returned by a previous call to
the <see cref="WinHttpOpen" /> function.</para>
    </param>
    <param name="dwFlags">
      <para>A set of flags that affects the reset operation.</para>
      <para>The following flags are supported as defined in the <i>Winhttp.h</i> header file.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WINHTTP_RESET_STATE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Forces a flush and retry of non-persistent proxy information on the current network.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WINHTTP_RESET_SWPAD_CURRENT_NETWORK</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Flush the PAD information for the current network.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WINHTTP_RESET_SWPAD_ALL</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Flush the PAD information for all networks.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WINHTTP_RESET_SCRIPT_CACHE</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Flush the persistent HTTP cache of proxy scripts.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WINHTTP_RESET_ALL</b>
                </description>
              </item>
              <item>
                <description>0x0000FFFF</description>
              </item>
            </list>
          </description>
          <description>
            <para>Forces a flush and retry of all proxy information on the current network.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WINHTTP_RESET_NOTIFY_NETWORK_CHANGED</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Flush the current proxy information and notify that the network changed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WINHTTP_RESET_OUT_OF_PROC</b>
                </description>
              </item>
              <item>
                <description>0x00020000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Act on the autoproxy service instead of the current process.  <b>Note</b>  This flag is required.</para>
            <para>Applications that use the  <see cref="WinHttpGetProxyForUrl" /> function to purge in-process caching should close the <i>hInternet</i> handle and open a new handle for future calls.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>A code indicating the success or failure of the operation.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_SUCCESS</b>
            </para>
          </description>
          <description>
            <para>The operation was successful.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_HANDLE</b>
            </para>
          </description>
          <description>
            <para>The <i>hSession</i> parameter is not a valid handle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE TYPE</b>
            </para>
          </description>
          <description>
            <para>The <i>hSession</i> parameter is not the product of a call to <see cref="WinHttpOpen" />.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>To reset everything, set the <i>dwFlags</i> parameter to include <b>WINHTTP_RESET_ALL</b> and <b>WINHTTP_RESET_OUT_OF_PROC</b>.</para>
      <para>
        <b>Note</b>  If you make subsequent calls to the <b>WinHttpResetAutoProxy</b> function, there must be at least 30 seconds delay between calls to reset the state of the auto-proxy. If there is less than 30 seconds, the <b>WinHttpResetAutoProxy</b> function call may return <b>ERROR_SUCCESS</b> but the reset won't happen.</para>
    </remarks>
  </member>
  <member name="Windows.WinHttpSendRequest">
    <summary>
      <para>The <b>WinHttpSendRequest</b> function sends the specified request to the HTTP server.</para>
    </summary>
    <param name="hRequest">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle returned by
<see cref="WinHttpOpenRequest" />.</para>
    </param>
    <param name="lpszHeaders">
      <para>A pointer to a string  that contains the additional headers to append to the request. This parameter can be <b>WINHTTP_NO_ADDITIONAL_HEADERS</b> if there are no additional headers to append.</para>
    </param>
    <param name="dwHeadersLength">
      <para>An unsigned long integer value that contains the length, in characters, of the additional headers. If this parameter is <b>-1L</b> and
<i>pwszHeaders</i> is not <b>NULL</b>, this function assumes that
<i>pwszHeaders</i> is <b>null</b>-terminated, and the length is calculated.</para>
    </param>
    <param name="lpOptional">
      <para>A pointer to a buffer that contains any optional data to send immediately after the request headers. This parameter is generally used for POST and PUT operations. The optional data can be the resource or data posted to the server. This parameter can be <b>WINHTTP_NO_REQUEST_DATA</b> if there is no optional data to send.</para>
      <para>If the <i>dwOptionalLength</i> parameter is 0, this parameter is ignored and set to <b>NULL</b>.</para>
      <para>This buffer must remain available until the request handle is closed or the call to <see cref="WinHttpReceiveResponse" /> has completed.</para>
    </param>
    <param name="dwOptionalLength">
      <para>An unsigned long integer value that contains the length, in bytes, of the optional data. This parameter can be zero if there is no optional data to send.</para>
      <para>This parameter must contain a valid length when the <i>lpOptional</i> parameter is not <b>NULL</b>. Otherwise, <i>lpOptional</i> is ignored and set to <b>NULL</b>.</para>
    </param>
    <param name="dwTotalLength">
      <para>An unsigned long integer value that contains the length, in bytes, of the total data sent.  This parameter specifies the Content-Length header of the request.  If the value of this parameter is greater than the length specified by
<i>dwOptionalLength</i>, then
<see cref="WinHttpWriteData" /> can be used to send additional data.</para>
      <para>
        <i>dwTotalLength</i> must not change between calls to <b>WinHttpSendRequest</b> for the same request.  If <i>dwTotalLength</i> needs to be changed, the caller should create a new request.</para>
    </param>
    <param name="dwContext">
      <para>A pointer to a pointer-sized variable that contains an application-defined value that is passed, with the request handle, to any callback functions.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. Error codes are listed in the following table.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_CANNOT_CONNECT</b>
            </para>
          </description>
          <description>
            <para>Returned if  connection to the server failed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED</b>
            </para>
          </description>
          <description>
            <para>The secure HTTP server requires a client certificate. The application retrieves the list of certificate issuers by calling <see cref="WinHttpQueryOption" /> with the <b>WINHTTP_OPTION_CLIENT_CERT_ISSUER_LIST</b> option.</para>
            <para>If the server requests the client certificate, but does not require it, the application can alternately call <see cref="WinHttpSetOption" /> with the <b>WINHTTP_OPTION_CLIENT_CERT_CONTEXT</b> option. In this case, the application specifies the WINHTTP_NO_CLIENT_CERT_CONTEXT macro in the <i>lpBuffer</i> parameter of <b>WinHttpSetOption</b>. For more information, see the <b>WINHTTP_OPTION_CLIENT_CERT_CONTEXT</b> option.<b>Windows Server 2003 with SP1, Windows XP with SP2 and Windows 2000:  </b>This error is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_CONNECTION_ERROR</b>
            </para>
          </description>
          <description>
            <para>The connection with the server has been reset or terminated, or an incompatible SSL protocol was encountered. For example, WinHTTP version 5.1 does not support SSL2 unless the client specifically enables it.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be carried out because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INVALID_URL</b>
            </para>
          </description>
          <description>
            <para>The URL is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_LOGIN_FAILURE</b>
            </para>
          </description>
          <description>
            <para>The login attempt failed.  When this error is encountered, the request handle should be closed with
<see cref="WinHttpCloseHandle" />.  A new request handle must be created before retrying the function that originally produced this error.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_NAME_NOT_RESOLVED</b>
            </para>
          </description>
          <description>
            <para>The server name cannot be resolved.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_OPERATION_CANCELLED</b>
            </para>
          </description>
          <description>
            <para>The operation was canceled, usually because the handle on which the request was operating was closed before the operation completed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>Returned when an incoming response exceeds an internal WinHTTP size limit.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_SECURE_FAILURE</b>
            </para>
          </description>
          <description>
            <para>One or more errors were found in the Secure Sockets Layer (SSL) certificate sent by the server.  To determine what type of error was encountered, verify through a
<a href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_CALLBACK_STATUS_SECURE_FAILURE</a> notification in a status callback function.  For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_STATUS_CALLBACK</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_SHUTDOWN</b>
            </para>
          </description>
          <description>
            <para>The WinHTTP function support is shut down or unloaded.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_TIMEOUT</b>
            </para>
          </description>
          <description>
            <para>The request timed out.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b>
            </para>
          </description>
          <description>
            <para>The URL specified a scheme other than "http:" or "https:".</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
            <para>
              <b>Windows Server 2003, Windows XP and Windows 2000:  </b>The TCP reservation range set with the <b>WINHTTP_OPTION_PORT_RESERVATION</b> option is not large enough to send this request.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The content length specified in the <i>dwTotalLength</i> parameter does not match the length specified in the Content-Length header.</para>
            <para>The <i>lpOptional</i> parameter must be <b>NULL</b> and the <i>dwOptionalLength</i> parameter must be zero when the Transfer-Encoding header is present.</para>
            <para>The Content-Length header cannot be present when the Transfer-Encoding header is present.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b> ERROR_WINHTTP_RESEND_REQUEST</b>
            </para>
          </description>
          <description>
            <para>The application must call <see cref="WinHttpSendRequest" /> again due to a redirect or authentication challenge.</para>
            <para>
              <b>Windows Server 2003 with SP1, Windows XP with SP2 and Windows 2000:  </b>This error is not supported.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when WinHTTP is used in asynchronous mode, that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />, this function can operate either synchronously or asynchronously.  In either case, if the request is sent successfully, the application is called back with the completion status set to <b>WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE</b>. The <b>WINHTTP_CALLBACK_STATUS_REQUEST_ERROR</b> completion indicates that the operation completed asynchronously, but failed.  Upon receiving the <b>WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE</b> status callback, the application can start to receive a response from the server with <see cref="WinHttpReceiveResponse" />. Before then, no other asynchronous functions can be called, otherwise, <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b> is returned.</para>
      <para>An application must not delete or alter the buffer pointed to by <i>lpOptional</i> until the request handle is closed or the call to <see cref="WinHttpReceiveResponse" /> has completed, because an authentication challenge or redirect that required the optional data could be encountered in the course of receiving the response. If the operation must be aborted with <see cref="WinHttpCloseHandle" />, the application must keep the buffer valid until it receives the callback  <b>WINHTTP_CALLBACK_STATUS_REQUEST_ERROR</b> with an <b>ERROR_WINHTTP_OPERATION_CANCELLED</b> error code.</para>
      <para>If  WinHTTP  is used synchronously, that is, when <b>WINHTP_FLAG_ASYNC</b> was not set in <see cref="WinHttpOpen" />, an application is not called with a completion status even if a callback function is registered. While in this mode, the application can call <see cref="WinHttpReceiveResponse" /> when <b>WinHttpSendRequest</b> returns.</para>
      <para>The
<b>WinHttpSendRequest</b> function sends the specified request to the HTTP server and allows the client to specify additional headers to send along with the request.</para>
      <para>This function also lets the client specify optional data to send to the HTTP server immediately following the request headers. This feature is generally used for write operations such as PUT and POST.</para>
      <para>An application can use the same HTTP request handle in multiple calls to
<b>WinHttpSendRequest</b> to re-send the same request, but the application must read all data returned from the previous call before calling this function again.</para>
      <para>The name and value of request headers added with this function are validated.  Headers must be well formed.  For more information about valid HTTP headers, see
<a href="https://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>.  If an invalid header is used, this function fails and
<see cref="GetLastError" /> returns
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/error-messages">ERROR_INVALID_PARAMETER</a>.  The invalid header is not added.</para>
      <para>
        <b>Windows 2000:  </b>When sending requests from multiple threads, there may be a significant decrease in network and CPU performance.</para>
      <para>
        <b>Windows XP and Windows 2000:  </b>See <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a>.</para>
      <h3>WinHttpSetStatusCallback</h3>
      <para>If a status callback function has been installed with
<see cref="WinHttpSetStatusCallback" />, then those of the following notifications  that  have been set in the <i>dwNotificationFlags</i> parameter of <b>WinHttpSetStatusCallback</b>  indicate the progress in sending the request:</para>
      <list type="bullet">
        <item>
          <description>WINHTTP_CALLBACK_STATUS_DETECTING_PROXY (not implemented)</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE (only in asynchronous mode)</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_REDIRECT</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_SECURE_FAILURE</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE</description>
        </item>
      </list>
      <b>Note</b>  On Windows 7 and Windows Server 2008 R2, all of the following notifications are deprecated.
<list type="bullet"><item><description>WINHTTP_CALLBACK_STATUS_RESOLVING_NAME</description></item><item><description>WINHTTP_CALLBACK_STATUS_NAME_RESOLVED</description></item><item><description>WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER</description></item><item><description>WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER</description></item><item><description>WINHTTP_CALLBACK_STATUS_SENDING_REQUEST</description></item><item><description>WINHTTP_CALLBACK_STATUS_REQUEST_SENT</description></item><item><description>WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE</description></item><item><description>WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED</description></item></list><para>If the server closes the connection, the following notifications are also sent, provided that they  have been set in the <i>dwNotificationFlags</i> parameter of <see cref="WinHttpSetStatusCallback" />:</para><list type="bullet"><item><description>WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION</description></item><item><description>WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED</description></item></list><h3>Support for Greater Than 4-GB Upload</h3><para>Starting in Windows Vista and Windows Server 2008, WinHttp supports uploading files up to the size of a LARGE_INTEGER (2^64 bytes) using the Content-Length header. Payload lengths specified in the call to <b>WinHttpSendRequest</b> are limited to the size of a <b>DWORD</b> (2^32 bytes). To upload data to a URL larger than a <b>DWORD</b>, the application must provide the length in the Content-Length header of the request. In this case, the WinHttp client application calls <b>WinHttpSendRequest</b> with the <i>dwTotalLength</i> parameter set to <b>WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH</b>.</para><para>If the Content-Length header specifies a length less than a 2^32, the application must also specify the content length in the call to <b>WinHttpSendRequest</b>. If the <i>dwTotalLength</i> parameter does not match the length specified in the Content-Length header, the call fails and returns <b>ERROR_INVALID_PARAMETER</b>.</para><para>The Content-Length header can be added in the call to <see cref="WinHttpAddRequestHeaders" />, or it can be specified in the <i>lpszHeader</i> parameter of <b>WinHttpSendRequest</b> as shown in the following code example.</para><code>BOOL fRet = WinHttpSendRequest(
            hReq,
            L"Content-Length: 68719476735\r\n",
            -1L,
            WINHTTP_NO_REQUEST_DATA,
            0,
            WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH,
            pMyContent);
</code><h3>Transfer-Encoding Header</h3><para>Starting in Windows Vista and Windows Server 2008, WinHttp enables applications to perform chunked transfer encoding on data sent to the server. When the Transfer-Encoding header is present on the WinHttp request, the <i>dwTotalLength</i> parameter in the call to <b>WinHttpSendRequest</b> is set to <b>WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH</b> and the application sends the entity body in one or more calls to <see cref="WinHttpWriteData" />. The <i>lpOptional</i> parameter of <b>WinHttpSendRequest</b> must be <b>NULL</b> and the <i>dwOptionLength</i> parameter must be zero, otherwise an <b>ERROR_WINHTTP_INVALID_PARAMETER</b> error is returned. To terminate the chunked data transfer, the application generates a zero length chunk and sends it in the last call to <b>WinHttpWriteData</b>.</para><h4>Examples</h4><para>The following code example shows how to obtain an
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle, open an HTTP
session, create a request header, and send that header to the server.</para><code>    BOOL  bResults = FALSE;
    HINTERNET hSession = NULL,
              hConnect = NULL,
              hRequest = NULL;

    // Use WinHttpOpen to obtain a session handle.
    hSession = WinHttpOpen(  L"A WinHTTP Example Program/1.0",
                             WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                             WINHTTP_NO_PROXY_NAME,
                             WINHTTP_NO_PROXY_BYPASS, 0);

    // Specify an HTTP server.
    if (hSession)
        hConnect = WinHttpConnect( hSession, L"www.wingtiptoys.com",
                                   INTERNET_DEFAULT_HTTP_PORT, 0);

    // Create an HTTP Request handle.
    if (hConnect)
        hRequest = WinHttpOpenRequest( hConnect, L"PUT",
                                       L"/writetst.txt",
                                       NULL, WINHTTP_NO_REFERER,
                                       WINHTTP_DEFAULT_ACCEPT_TYPES,
                                       0);

    // Send a Request.
    if (hRequest)
        bResults = WinHttpSendRequest( hRequest,
                                       WINHTTP_NO_ADDITIONAL_HEADERS,
                                       0, WINHTTP_NO_REQUEST_DATA, 0,
                                       0, 0);

    // Place additional code here.


    // Report errors.
    if (!bResults)
        printf("Error %d has occurred.\n",GetLastError());

    // Close open handles.
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);

</code></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpConnect" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpOpenRequest" />
    <seealso cref="WinHttpReceiveResponse" />
  </member>
  <member name="Windows.WinHttpSetCredentials">
    <summary>
      <para>The <b>WinHttpSetCredentials</b> function passes the required authorization credentials to the server.</para>
    </summary>
    <param name="hRequest">
      <para>Valid
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle returned by
<see cref="WinHttpOpenRequest" />.</para>
    </param>
    <param name="AuthTargets">
      <para>An unsigned integer that specifies a flag that contains the authentication target.  Can be one of the  values in the following table.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>WINHTTP_AUTH_TARGET_SERVER</b>
          </description>
          <description>
            <para>Credentials are passed to a server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_TARGET_PROXY</b>
          </description>
          <description>
            <para>Credentials are passed to a proxy.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="AuthScheme">
      <para>An unsigned integer that specifies a flag that contains the authentication scheme.  Must be one of the supported authentication schemes returned from
<see cref="WinHttpQueryAuthSchemes" />. The following table identifies the possible values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_BASIC</b>
          </description>
          <description>
            <para>Use basic authentication.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_NTLM</b>
          </description>
          <description>
            <para>Use NTLM authentication.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_PASSPORT</b>
          </description>
          <description>
            <para>Use passport authentication.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_DIGEST</b>
          </description>
          <description>
            <para>Use digest authentication.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_AUTH_SCHEME_NEGOTIATE</b>
          </description>
          <description>
            <para>Selects between NTLM and Kerberos authentication.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pwszUserName">
      <para>Pointer to a string that contains a valid user name.</para>
    </param>
    <param name="pwszPassword">
      <para>Pointer to a string that contains a valid password.  The password can be blank.</para>
    </param>
    <param name="pAuthParams">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. The following table identifies the error codes returned.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be carried out because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation (Windows error code).</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is  used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The credentials set by <b>WinHttpSetCredentials</b> are only used for a single request; WinHTTP does not cache these credentials for use in subsequent requests. As a result, applications must be written so that they can respond to multiple challenges. If an authenticated connection is re-used, subsequent requests cannot be challenged, but your code should be able to respond to a challenge at any point.</para>
      <para>For sample code that illustrates the use of <b>WinHttpSetCredentials</b>, see <a href="https://docs.microsoft.com//windows/desktop/WinHttp/authentication-in-winhttp">Authentication in WinHTTP</a>.</para>
      <para>
        <b>Note</b>  When using Passport authentication and responding to a 407 status code, a WinHTTP application must use <see cref="WinHttpSetOption" /> to provide proxy credentials rather than <b>WinHttpSetCredentials</b>. This is only true when using Passport authentication; in all other circumstances,  use <b>WinHttpSetCredentials</b>, because <b>WinHttpSetOption</b>  is less secure.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/authentication-in-winhttp">Authentication in WinHTTP</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpConnect" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpOpenRequest" />
    <seealso cref="WinHttpQueryAuthSchemes" />
  </member>
  <member name="Windows.WinHttpSetDefaultProxyConfiguration">
    <summary>
      <blockquote>
        <para>[!IMPORTANT]
Use of <b>WinHttpSetDefaultProxyConfiguration</b> is deprecated on Windows 8.1 and newer. Most proxy configurations are not supported by <b>WinHttpSetDefaultProxyConfiguration</b>, nor does it support proxy authentication. Instead, use <b>WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY</b> with <see cref="WinHttpOpen" />.</para>
      </blockquote>
      <para>The <b>WinHttpSetDefaultProxyConfiguration</b> function sets the default WinHTTP proxy configuration in the registry.</para>
    </summary>
    <param name="pProxyInfo">
      <para>A pointer to a variable of type
<see cref="WINHTTP_PROXY_INFO" /> that specifies the default proxy configuration.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The default proxy configuration set by <b>WinHttpSetDefaultProxyConfiguration</b> can be overridden for an existing WinHTTP session by calling
<see cref="WinHttpSetOption" /> and specifying the
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/option-flags">WINHTTP_OPTION_PROXY</a> flag.  The default proxy configuration can be overridden for a new session by specifying the configuration with the
<see cref="WinHttpOpen" /> function.</para>
      <para>The <i>dwAccessType</i> member of
the <see cref="WINHTTP_PROXY_INFO" /> structure pointed to by <i>pProxyInfo</i> should be set to
<b>WINHTTP_ACCESS_TYPE_NAMED_PROXY</b> if a proxy is specified.  Otherwise, it should be set to
<b>WINHTTP_ACCESS_TYPE_DEFAULT_PROXY</b>.</para>
      <para>Any new sessions created after calling this function use the new default proxy configuration.</para>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHTTP start page.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/winhttp/winhttp-versions">WinHTTP versions</seealso>
    <seealso cref="WinHttpGetDefaultProxyConfiguration" />
  </member>
  <member name="Windows.WinHttpSetOption">
    <summary>
      <para>The <b>WinHttpSetOption</b> function sets an Internet option.</para>
    </summary>
    <param name="hInternet">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle on which to set data. Be aware  that this can be either a Session handle or a Request handle, depending on what option is being set. For more information about how to determine which handle is appropriate to use in setting a particular option, see the  <a href="https://docs.microsoft.com//windows/desktop/WinHttp/option-flags">Option Flags</a>.</para>
    </param>
    <param name="dwOption">
      <para>An unsigned long integer value that contains the Internet option to set. This can be one of the
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/option-flags">Option Flags</a> values.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that contains the option setting.</para>
    </param>
    <param name="dwBufferLength">
      <para>Unsigned long integer value that contains the length of the
<i>lpBuffer</i> buffer. The length of the buffer is specified in characters for the following options; for all other options, the length is specified in bytes.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following:</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be carried out because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INVALID_OPTION</b>
            </para>
          </description>
          <description>
            <para>A request to
<see cref="WinHttpQueryOption" /> or
<see cref="WinHttpSetOption" /> specified an invalid option value.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>A parameter is not valid.</para>
            <para>This value will be returned if <b>WINHTTP_OPTION_WEB_SOCKET_KEEPALIVE_INTERVAL</b> is set to a value lower than 15000.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_OPTION_NOT_SETTABLE</b>
            </para>
          </description>
          <description>
            <para>The requested option cannot be set, only queried.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>A parameter is not valid.</para>
            <para>This value will be returned if <b>WINHTTP_OPTION_WEB_SOCKET_KEEPALIVE_INTERVAL</b> is set to a value lower than 15000.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Credentials passed to <b>WinHttpSetOption</b> could be unexpectedly sent in plaintext. It is  strongly recommended that you  use <see cref="WinHttpQueryAuthSchemes" />  and <see cref="WinHttpSetCredentials" /> instead of <b>WinHttpSetOption</b> for setting credentials.</para>
      <para>
        <b>Note</b>  When using Passport authentication, however, a WinHTTP application responding to a 407 status code must use <b>WinHttpSetOption</b> to provide proxy credentials rather than <see cref="WinHttpSetCredentials" />. This is only true when using Passport authentication; in all other circumstances,  use <b>WinHttpSetCredentials</b>.</para>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>
        <see cref="GetLastError" /> returns the error ERROR_INVALID_PARAMETER if an option flag is specified that cannot be set.</para>
      <para>For more information and code examples that show the use of <b>WinHttpSetOption</b>, see <a href="https://docs.microsoft.com//windows/desktop/WinHttp/authentication-in-winhttp">Authentication in WinHTTP</a>.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/authentication-in-winhttp">Authentication in WinHTTP</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/option-flags">Option Flags</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpQueryOption" />
  </member>
  <member name="Windows.WinHttpSetStatusCallback">
    <summary>
      <para>The <b>WinHttpSetStatusCallback</b> function sets up a callback function that WinHTTP can call as progress is made during an operation.</para>
    </summary>
    <param name="hInternet">
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle for which the callback is to be set.</para>
    </param>
    <param name="lpfnInternetCallback">
      <para>Pointer to the callback function to call when progress is made.  Set this to <b>NULL</b> to remove the existing callback function. For more information about the callback function, see
<a href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_STATUS_CALLBACK</a>.</para>
    </param>
    <param name="dwNotificationFlags">
      <para>Unsigned long integer value that specifies flags to indicate which
events  activate the callback function.</para>
      <para>The possible values are as follows.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_ALL_COMPLETIONS</b>
          </description>
          <description>
            <para>Activates upon any completion notification.  This flag specifies that all notifications required for read or write operations are used. See
<a href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_STATUS_CALLBACK</a> for a list of completions.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS</b>
          </description>
          <description>
            <para>Activates upon any status change notification including completions.  See
<a href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_STATUS_CALLBACK</a> for a list of notifications.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_RESOLVE_NAME</b>
          </description>
          <description>
            <para>Activates upon beginning and completing name resolution.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_CONNECT_TO_SERVER</b>
          </description>
          <description>
            <para>Activates upon beginning and completing connection to the server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_DETECTING_PROXY</b>
          </description>
          <description>
            <para>Activates when detecting the proxy server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_DATA_AVAILABLE</b>
          </description>
          <description>
            <para>Activates when completing a query for data.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_HEADERS_AVAILABLE</b>
          </description>
          <description>
            <para>Activates when the response headers are available for retrieval.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_READ_COMPLETE</b>
          </description>
          <description>
            <para>Activates upon completion of a data-read operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_REQUEST_ERROR</b>
          </description>
          <description>
            <para>Activates when an asynchronous error occurs.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_SEND_REQUEST</b>
          </description>
          <description>
            <para>Activates upon beginning and completing the sending of a request
header with
<see cref="WinHttpSendRequest" />.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_SENDREQUEST_COMPLETE</b>
          </description>
          <description>
            <para>Activates when a request header has been sent with
<see cref="WinHttpSendRequest" />.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_WRITE_COMPLETE</b>
          </description>
          <description>
            <para>Activates upon completion of a data-post operation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_RECEIVE_RESPONSE</b>
          </description>
          <description>
            <para>Activates upon beginning and completing the receipt of a
resource from the HTTP server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_CLOSE_CONNECTION</b>
          </description>
          <description>
            <para>Activates when beginning and completing the closing of an
HTTP connection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_HANDLES</b>
          </description>
          <description>
            <para>Activates when an
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle is
created or closed.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_REDIRECT</b>
          </description>
          <description>
            <para>Activates when the request is redirected.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_INTERMEDIATE_RESPONSE</b>
          </description>
          <description>
            <para>Activates when receiving an intermediate (100 level) status
code message from the server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINHTTP_CALLBACK_FLAG_SECURE_FAILURE</b>
          </description>
          <description>
            <para>Activates upon a secure connection failure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwReserved">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If successful, returns a pointer to the previously defined status callback function or  <b>NULL</b> if there was no previously defined status callback function. Returns <b>WINHTTP_INVALID_STATUS_CALLBACK</b> if the callback function could not be installed. For extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If you set the callback on the session handle before creating the request handle, the request handle inherits the callback function pointer from its parent session.</para>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Both synchronous and asynchronous functions use the callback function to indicate the progress of the request, such as resolving a name, connecting to a server, and so on. The callback function is required for an asynchronous operation.</para>
      <para>A callback function can be set on any handle and is inherited by derived handles. A callback function can be changed using
<b>WinHttpSetStatusCallback</b>, provided there are no pending requests that need to use the previous callback value. However, changing the callback function on a handle does not change the callbacks on derived handles, such as that returned by
<see cref="WinHttpConnect" />. You must change the callback function at each level.</para>
      <para>Many WinHTTP functions perform several operations on the network. Each operation can take time to complete and each can fail.</para>
      <para>After initiating the
<b>WinHttpSetStatusCallback</b> function, the callback function can be accessed from within WinHTTP for monitoring time-intensive network operations.</para>
      <para>At the end of asynchronous processing, the application may set the callback function to <b>NULL</b>. This prevents the client application from receiving additional notifications.</para>
      <para>The following code snippet shows the recommended method for setting the callback function to <b>NULL</b>.</para>
      <code>WinHttpSetStatusCallback( hOpen,
                          NULL,
                          WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS,
                          NULL );

</code>
      <para>Note, however, that WinHTTP does not synchronize <b>WinHttpSetStatusCallback</b> with worker threads. If  a callback originating in another thread is in progress when an application calls <b>WinHttpSetStatusCallback</b>, the application still receives a callback notification even after <b>WinHttpSetStatusCallback</b> successfully sets the callback function to <b>NULL</b> and returns.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
      <h4>Examples</h4>
      <para>The following example shows how to install a callback function for asynchronous WinHTTP functions.  The example assumes that a
<a href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_STATUS_CALLBACK</a> function named "AsyncCallback( )" has been previously implemented:</para>
      <code>    // Use WinHttpOpen to obtain an HINTERNET handle.
    HINTERNET hSession = WinHttpOpen(L"A WinHTTP Example Program/1.0",
                                    WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                                    WINHTTP_NO_PROXY_NAME,
                                    WINHTTP_NO_PROXY_BYPASS, 0);
    if (hSession)
    {
        // Install the status callback function.
        WINHTTP_STATUS_CALLBACK isCallback = WinHttpSetStatusCallback( hSession,
                                               (WINHTTP_STATUS_CALLBACK)AsyncCallback,
                                               WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS,
                                               NULL);

        // Place additional code here.

        // When finished, release the HINTERNET handle.
        WinHttpCloseHandle(hSession);
    }
    else
    {
        printf("Error %u in WinHttpOpen.\n", GetLastError());
    }

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winhttp/nc-winhttp-winhttp_status_callback">WINHTTP_STATUS_CALLBACK</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpConnect" />
    <seealso cref="WinHttpOpen" />
  </member>
  <member name="Windows.WinHttpSetTimeouts">
    <summary>
      <para>The <b>WinHttpSetTimeouts</b> function sets time-outs involved with HTTP transactions.</para>
    </summary>
    <param name="hInternet">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle returned by
<see cref="WinHttpOpen" /> or <see cref="WinHttpOpenRequest" />.</para>
    </param>
    <param name="nResolveTimeout">
      <para>A value of type integer that specifies the time-out value, in milliseconds, to use for name resolution. If resolution takes longer than this time-out value, the action is canceled. The initial value is zero, meaning no time-out (infinite).</para>
      <para>
        <b>Windows Vista and Windows XP:  </b>If DNS timeout is specified using NAME_RESOLUTION_TIMEOUT, there is an overhead of one thread per request.</para>
    </param>
    <param name="nConnectTimeout">
      <para>A value of type integer that specifies the time-out value, in milliseconds, to use for server connection requests. If a connection request takes longer than this time-out value, the request is canceled. The initial value is 60,000 (60 seconds).</para>
      <para>TCP/IP can time out while setting up the socket during the three leg SYN/ACK exchange, regardless of the value of this parameter.</para>
    </param>
    <param name="nSendTimeout">
      <para>A value of type integer that specifies the time-out value, in milliseconds, to use for sending requests. If sending a request takes longer than this time-out value, the send is canceled. The initial value is 30,000 (30 seconds).</para>
    </param>
    <param name="nReceiveTimeout">
      <para>A value of type integer that specifies the time-out value, in milliseconds, to receive a response to a request. If a response takes longer than this time-out value, the request is canceled. The initial value is 30,000 (30 seconds).</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. Among the error codes returned are the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be carried out because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One or more of the timeout parameters has a negative value other than -1.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>A value of 0 or -1 sets a time-out to wait infinitely.  A value greater than 0 sets the time-out value in milliseconds.  For example, 30,000 would set the time-out to 30 seconds.  All negative values other than -1 cause the function to fail with ERROR_INVALID_PARAMETER.</para>
      <para>
        <b>Important</b>  If a small timeout is set using <see cref="WinHttpSetOption" /> and <a href="https://docs.microsoft.com//windows/desktop/WinHttp/option-flags">WINHTTP_OPTION_RECEIVE_TIMEOUT</a>, it can override the value set with the <i>dwReceiveTimeout</i> parameter, causing a response to terminate earlier than expected. To avoid this, do not set a timeout with the <b>WINHTTP_OPTION_RECEIVE_TIMEOUT</b> option that is smaller than the value set using <i>dwReceiveTimeout</i>.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHTTP start page.</para>
      <h4>Examples</h4>
      <para>This example shows how to set new time-out values using
<b>WinHttpSetTimeouts</b>.</para>
      <code>    // Use WinHttpOpen to obtain an HINTERNET handle.
    HINTERNET hSession = WinHttpOpen(L"A WinHTTP Example Program/1.0",
                                    WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                                    WINHTTP_NO_PROXY_NAME,
                                    WINHTTP_NO_PROXY_BYPASS, 0);
    if (hSession)
    {
        // Use WinHttpSetTimeouts to set a new time-out values.
        if (!WinHttpSetTimeouts( hSession, 10000, 10000, 10000, 10000))
            printf( "Error %u in WinHttpSetTimeouts.\n", GetLastError());

        // PLACE ADDITIONAL CODE HERE.

        // When finished, release the HINTERNET handle.
        WinHttpCloseHandle(hSession);
    }
    else
    {
        printf("Error %u in WinHttpOpen.\n", GetLastError());
    }

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpConnect" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpOpenRequest" />
  </member>
  <member name="Windows.WinHttpTimeFromSystemTime">
    <summary>
      <para>The <b>WinHttpTimeFromSystemTime</b> function formats a date and time according to the HTTP version 1.0 specification.</para>
    </summary>
    <param name="pst">
      <para>A pointer to a
<see cref="SYSTEMTIME" /> structure that contains the date and time to format.</para>
    </param>
    <param name="pwszTime">
      <para>A pointer to a string buffer that receives the formatted date and time. The buffer should equal to the size, in bytes, of WINHTTP_TIME_FORMAT_BUFSIZE.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. To get  extended error information, call
<see cref="GetLastError" />. Error codes include the following.</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHTTP Start Page.</para>
      <h4>Examples</h4>
      <para>The following  code example code shows how to convert a
<see cref="SYSTEMTIME" /> structure to a string that contains the time in HTTP format.</para>
      <code>    SYSTEMTIME  sTime;
    LPWSTR      pwszTimeStr;

    // Get the current time.
    GetSystemTime(&amp;amp;amp;amp;amp;amp;sTime);

    // Allocate memory for the string.
    // Note: WINHTTP_TIME_FORMAT_BUFSIZE is a byte count.
    //       Therefore, you must divide the array by
    //       sizeof WCHAR to get the proper string length.
    pwszTimeStr = new WCHAR[WINHTTP_TIME_FORMAT_BUFSIZE/sizeof(WCHAR)];

    // Convert the current time to HTTP format.
    if(!WinHttpTimeFromSystemTime( &amp;amp;amp;amp;amp;amp;sTime, pwszTimeStr))
    {
        printf( "Error %u in WinHttpTimeFromSystemTime.\n", GetLastError());
    }
    else
    {
        // Print the time.
        printf("Current time is (%S)\n", pwszTimeStr);
    }

    // Free the memory.
    delete [] pwszTimeStr;

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpTimeToSystemTime" />
  </member>
  <member name="Windows.WinHttpTimeToSystemTime">
    <summary>
      <para>The <b>WinHttpTimeToSystemTime</b> function takes an HTTP time/date string and converts it to a
<see cref="SYSTEMTIME" /> structure.</para>
    </summary>
    <param name="pwszTime">
      <para>Pointer to a null-terminated date/time string to convert. This value must use the format defined in section 3.3 of the <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC2616</a>.</para>
    </param>
    <param name="pst">
      <para>Pointer to the
<see cref="SYSTEMTIME" /> structure that receives the converted time.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. Among the error codes returned is:</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function operates synchronously. The return value indicates success or failure.  To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHttp start page.</para>
      <h4>Examples</h4>
      <para>This example shows how to convert an HTTP formatted date to a
<see cref="SYSTEMTIME" /> structure.</para>
      <code>    SYSTEMTIME  sTime;
    LPCWSTR     pwszTimeStr = L"Tue, 21 Nov 2000 01:06:53 GMT";

    // Convert the HTTP string to a SYSTEMTIME structure.
    if (!WinHttpTimeToSystemTime( pwszTimeStr, &amp;amp;amp;amp;amp;amp;sTime))
    {
        printf( "Error %u in WinHttpTimeToSystemTime.\n", GetLastError());
    }
    else
    {
        // Print the date.
        printf( "The U.S. formatted date is (%u/%u/%u)\n",
                sTime.wMonth, sTime.wDay, sTime.wYear);
    }

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpTimeFromSystemTime" />
  </member>
  <member name="Windows.WinHttpWebSocketClose">
    <summary>
      <para>The <b>WinHttpWebSocketClose</b> function closes a WebSocket connection.</para>
    </summary>
    <param name="hWebSocket">
      <para>Type: <b>HINTERNET</b></para>
      <para>Handle to a WebSocket.<b>Note</b>  <b>WinHttpWebSocketClose</b> does not close this handle. To close the handle, call <see cref="WinHttpCloseHandle" /> on <i>hWebSocket</i> once it is no longer needed.</para>
    </param>
    <param name="usStatus">
      <para>Type: <b>USHORT</b></para>
      <para>A close status code. See <see cref="WINHTTP_WEB_SOCKET_CLOSE_STATUS" /> for possible values.</para>
    </param>
    <param name="pvReason">
      <para>Type: <b>PVOID</b></para>
      <para>A detailed reason for the close.</para>
    </param>
    <param name="dwReasonLength">
      <para>Type: <b>DWORD</b></para>
      <para>The length of <i>pvReason</i>, in bytes.</para>
      <para>If <i>pvReason</i> is NULL, this must be 0. This value must be within the range of 0 to 123.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>With the following exception, all error codes indicate that the underlying TCP connection has been aborted.</para>
      <list type="table">
        <listheader>
          <description></description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_OPERATION</b>
            </para>
          </description>
          <description>
            <para>A close or send is pending.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>A parameter is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_SERVER_RESPONSE</b>
            </para>
          </description>
          <description>
            <para>Invalid data was received from the server.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>WinHttpWebSocketClose</b> completely closes a WebSocket connection. To close the send channel while still leaving the receive channel open, use <see cref="WinHttpWebSocketShutdown" />.</para>
      <para>It is possible to  receive a close frame during regular receive operations. In this case, <b>WinHttpWebSocketClose</b> will also send a close frame.</para>
      <para>The close timer can be set by the property
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/option-flags">WINHTTP_OPTION_WEB_SOCKET_CLOSE_TIMEOUT</a>.
The default is 10 seconds.</para>
    </remarks>
    <seealso cref="WINHTTP_WEB_SOCKET_CLOSE_STATUS" />
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpWebSocketShutdown" />
  </member>
  <member name="Windows.WinHttpWebSocketCompleteUpgrade">
    <summary>
      <para>The <b>WinHttpWebSocketCompleteUpgrade</b> function completes a WebSocket handshake started by <see cref="WinHttpSendRequest" />.</para>
    </summary>
    <param name="hRequest">
      <para>Type: <b>HINTERNET</b></para>
      <para>HTTP request handle used to send a WebSocket handshake.</para>
    </param>
    <param name="pContext">
      <para>Type: <b>DWORD_PTR</b></para>
      <para>Context to be associated with the new handle.</para>
    </param>
    <returns>
      <para>Type: <b>HINTERNET</b></para>
      <para>A new WebSocket handle. If NULL, call <see cref="GetLastError" /> to determine the cause of failure.</para>
    </returns>
    <remarks>
      <para>
        <b>WinHttpWebSocketCompleteUpgrade</b> can be called on an open HTTP request to get a WebSocket handle for performing other WebSocket operations.</para>
      <para>The request handle must be marked as a WebSocket upgrade by calling <see cref="WinHttpSetOption" /> with <b>WINHTTP_OPTION_UPGRADE_TO_WEB_SOCKET</b> before sending the request.</para>
      <para>The caller should check the HTTP status code returned by the server and call this function only if the status code was 101. Calling it with any other status code will result in a failure.</para>
    </remarks>
  </member>
  <member name="Windows.WinHttpWebSocketQueryCloseStatus">
    <summary>
      <para>The <b>WinHttpWebSocketQueryCloseStatus</b> function retrieves the close status sent by a server.</para>
    </summary>
    <param name="hWebSocket">
      <para>Type: <b>HINTERNET</b></para>
      <para>Handle to a WebSocket</para>
    </param>
    <param name="pusStatus">
      <para>Type: <b>USHORT*</b></para>
      <para>A pointer to a close status code that will be filled upon return. See <see cref="WINHTTP_WEB_SOCKET_CLOSE_STATUS" /> for possible values.</para>
    </param>
    <param name="pvReason">
      <para>Type: <b>PVOID</b></para>
      <para>A pointer to a buffer that will receive a close reason on return.</para>
    </param>
    <param name="dwReasonLength">
      <para>Type: <b>DWORD</b></para>
      <para>The length of the <i>pvReason</i> buffer, in bytes.</para>
    </param>
    <param name="pdwReasonLengthConsumed">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of bytes consumed. If <i>pvReason</i> is <b>NULL</b> and <i>dwReasonLength</i> is 0, <i>pdwReasonLengthConsumed</i> will contain the size of the buffer that needs to be allocated by the calling application.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>
        <b>NO_ERROR</b> on success. Otherwise an error code.</para>
      <list type="table">
        <listheader>
          <description></description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>There is not enough space in <i>pvReason</i> to write the whole close reason.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_OPERATION</b>
            </para>
          </description>
          <description>
            <para>No close frame has been received yet.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>A parameter is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Call <b>WinHttpWebSocketQueryCloseStatus</b> only after <see cref="WinHttpWebSocketClose" /> succeeds or if <see cref="WinHttpWebSocketReceive" /> returns <b>WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE</b>.</para>
      <para>
        <i>pdwReasonLengthConsumed</i> will never be greater than 123, so allocating buffer with at least 123 will guarantee that <b>ERROR_INSUFFICIENT_BUFFER</b> will never be returned.</para>
    </remarks>
    <seealso cref="WINHTTP_WEB_SOCKET_CLOSE_STATUS" />
    <seealso cref="WinHttpWebSocketClose" />
    <seealso cref="WinHttpWebSocketReceive" />
  </member>
  <member name="Windows.WinHttpWebSocketReceive">
    <summary>
      <para>The <b>WinHttpWebSocketReceive</b> function receives data from a WebSocket connection.</para>
    </summary>
    <param name="hWebSocket">
      <para>Type: <b>HINTERNET</b></para>
      <para>Handle to a WebSocket.</para>
    </param>
    <param name="pvBuffer">
      <para>Type: <b>PVOID</b></para>
      <para>Pointer to a buffer to receive the data.</para>
    </param>
    <param name="dwBufferLength">
      <para>Type: <b>DWORD</b></para>
      <para>Length of <i>pvBuffer</i>, in bytes.</para>
    </param>
    <param name="pdwBytesRead">
      <para>Type: <b>DWORD*</b></para>
      <para>Pointer to a <b>DWORD</b> that receives the number of bytes read from the connection at the end of the operation. This is set only if <b>WinHttpWebSocketReceive</b> returns <b>NO_ERROR</b> and the handle was opened in synchronous mode.</para>
    </param>
    <param name="peBufferType">
      <para>Type: <b><see cref="WINHTTP_WEB_SOCKET_BUFFER_TYPE" />*</b></para>
      <para>The type of a returned buffer. This is only set if <b>WinHttpWebSocketReceive</b> returns <b>NO_ERROR</b> and the handle was opened in synchronous mode.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>
        <b>NO_ERROR</b> on success. Otherwise an error code.</para>
      <list type="table">
        <listheader>
          <description></description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_OPERATION</b>
            </para>
          </description>
          <description>
            <para>A close or send is pending, or the receive channel has already been closed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>A parameter is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_SERVER_RESPONSE</b>
            </para>
          </description>
          <description>
            <para>Invalid data was received from the server.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_OPERATION_CANCELLED</b>
            </para>
          </description>
          <description>
            <para>The operation was cancelled because <see cref="WinHttpWebSocketClose" /> was called to close the connection.</para>
          </description>
        </item>
      </list>
    </returns>
  </member>
  <member name="Windows.WinHttpWebSocketSend">
    <summary>
      <para>The <b>WinHttpWebSocketSend</b> function sends data over a WebSocket connection.</para>
    </summary>
    <param name="hWebSocket">
      <para>Type: <b>HINTERNET</b></para>
      <para>Handle to a websocket.</para>
    </param>
    <param name="eBufferType">
      <para>Type: <b><see cref="WINHTTP_WEB_SOCKET_BUFFER_TYPE" /></b></para>
      <para>Type of buffer.<b>Note</b>  Do not specify <b>WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE</b>. Use <see cref="WinHttpWebSocketClose" /> or <see cref="WinHttpWebSocketShutdown" /> to close the connection.</para>
    </param>
    <param name="pvBuffer">
      <para>Type: <b>PVOID</b></para>
      <para>Pointer to a buffer containing the data to send. Can be <b>NULL</b> only if <i>dwBufferLength</i> is 0.</para>
    </param>
    <param name="dwBufferLength">
      <para>Type: <b>DWORD</b></para>
      <para>Length of <i>pvBuffer</i>.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>
        <b>NO_ERROR</b> on success. Otherwise an error code.</para>
      <list type="table">
        <listheader>
          <description></description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_OPERATION</b>
            </para>
          </description>
          <description>
            <para>A close or send is pending, or the send channel has already been closed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>A parameter is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso cref="WINHTTP_WEB_SOCKET_BUFFER_TYPE" />
  </member>
  <member name="Windows.WinHttpWebSocketShutdown">
    <summary>
      <para>The <b>WinHttpWebSocketShutdown</b> function sends a close frame to a WebSocket server to close the send channel, but leaves the receive channel open.</para>
    </summary>
    <param name="hWebSocket">
      <para>Type: <b>HINTERNET</b></para>
      <para>Handle to a WebSocket.<b>Note</b>  <b>WinHttpWebSocketShutdown</b> does not close this handle. To close the handle, call <see cref="WinHttpCloseHandle" /> on <i>hWebSocket</i> once it is no longer needed.</para>
    </param>
    <param name="usStatus">
      <para>Type: <b>USHORT</b></para>
      <para>A close status code. See <see cref="WINHTTP_WEB_SOCKET_CLOSE_STATUS" /> for possible values.</para>
    </param>
    <param name="pvReason">
      <para>Type: <b>PVOID</b></para>
      <para>A detailed reason for the close.</para>
    </param>
    <param name="dwReasonLength">
      <para>Type: <b>DWORD</b></para>
      <para>The length of <i>pvReason</i>, in bytes.</para>
      <para>If <i>pvReason</i> is NULL, this must be 0. This value must be within the range of 0 to 123.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>With the following exception, all error codes indicate that the underlying TCP connection has been aborted.</para>
      <list type="table">
        <listheader>
          <description></description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_IO_PENDING</b>
            </para>
          </description>
          <description>
            <para>The operation will complete asynchronously.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>WinHttpWebSocketShutdown</b> sends a close frame and prevents additional data from being sent over the WebSocket connection. It does not close the receive channel. Use <see cref="WinHttpWebSocketClose" /> when you want to completely close the connection and prevent any subsequent receive operations.</para>
      <para>The application is responsible for receiving the close frame from the server (through regular receive operations).</para>
      <para>After <b>WinHttpWebSocketShutdown</b> is called, the application can call <see cref="WinHttpWebSocketClose" /> if it does not want to receive a close frame on its own and delegate it to the stack.</para>
    </remarks>
    <seealso cref="WINHTTP_WEB_SOCKET_CLOSE_STATUS" />
    <seealso cref="WinHttpCloseHandle" />
    <seealso cref="WinHttpWebSocketClose" />
  </member>
  <member name="Windows.WinHttpWriteData">
    <summary>
      <para>The <b>WinHttpWriteData</b> function writes request data to an HTTP server.</para>
    </summary>
    <param name="hRequest">
      <para>Valid
<a href="https://docs.microsoft.com//windows/desktop/WinHttp/hinternet-handles-in-winhttp">HINTERNET</a> handle returned by
<see cref="WinHttpOpenRequest" />. Wait until <see cref="WinHttpSendRequest" /> has completed before calling  this function.</para>
    </param>
    <param name="lpBuffer">
      <para>Pointer to a buffer that contains the data to be sent to the server. Be sure that this buffer remains valid until after <b>WinHttpWriteData</b> completes.</para>
    </param>
    <param name="dwNumberOfBytesToWrite">
      <para>Unsigned long integer value that contains the number of bytes to be written to the file.</para>
    </param>
    <param name="lpdwNumberOfBytesWritten">
      <para>Pointer to an unsigned long integer variable that receives the number of bytes written to the buffer. The
<b>WinHttpWriteData</b> function sets this value to zero before doing any work or error checking.  When using WinHTTP asynchronously, this parameter must be set to <b>NULL</b> and retrieve the information in the callback function. Not doing so can cause a memory fault.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call
<see cref="GetLastError" />. Among the error codes returned are:</para>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_CONNECTION_ERROR</b>
            </para>
          </description>
          <description>
            <para>The connection with the server has been reset or terminated, or an incompatible SSL protocol was encountered. For example, WinHTTP version 5.1 does not support SSL2 unless the client specifically enables it.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b>
            </para>
          </description>
          <description>
            <para>The requested operation cannot be carried out because the handle supplied is not in the correct state.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b>
            </para>
          </description>
          <description>
            <para>The type of handle supplied is incorrect for this operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_INTERNAL_ERROR</b>
            </para>
          </description>
          <description>
            <para>An internal error has occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_OPERATION_CANCELLED</b>
            </para>
          </description>
          <description>
            <para>The operation was canceled, usually because the handle on which the request was operating was closed before the operation completed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_WINHTTP_TIMEOUT</b>
            </para>
          </description>
          <description>
            <para>The request has timed out.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory was available to complete the requested operation. (Windows error code)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Even when  WinHTTP is  used in asynchronous mode (that is, when <b>WINHTTP_FLAG_ASYNC</b> has been set in <see cref="WinHttpOpen" />), this function can operate either synchronously or asynchronously.  If this function returns <b>FALSE</b>, you can call
<see cref="GetLastError" /> to get extended error information. If this function returns <b>TRUE</b>, use the WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE completion to determine whether this function was successful and the value of the parameters.  The WINHTTP_CALLBACK_STATUS_REQUEST_ERROR completion indicates that the operation completed asynchronously, but failed.</para>
      <para>
        <b>Warning</b>  When using WinHTTP asynchronously, always set the <i>lpdwNumberOfBytesWritten</i> parameter to <b>NULL</b> and retrieve the bytes written in the callback function; otherwise, a memory fault can occur.</para>
      <para>When the application is sending data, it can call
<see cref="WinHttpReceiveResponse" /> to end the data transfer.  If
<see cref="WinHttpCloseHandle" /> is called, then the data transfer is aborted.</para>
      <para>If a status callback function has been installed with
<see cref="WinHttpSetStatusCallback" />, then those of the following notifications  that  have been set in the <i>dwNotificationFlags</i> parameter of <b>WinHttpSetStatusCallback</b> indicate progress in sending data to the server:</para>
      <list type="bullet">
        <item>
          <description>WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_DATA_WRITTEN </description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_SENDING_REQUEST</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_REQUEST_SENT</description>
        </item>
        <item>
          <description>WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE</description>
        </item>
      </list>
      <para>Two issues can arise when attempting to POST (or PUT) data to proxies or servers that challenge using NTLM or Negotiate authentication.</para>
      <para>First, these proxies or servers may send 401/407 challenges and close the connection before all the data can be POST'ed, in which case not only does <b>WinHttpWriteData</b> fail, but also WinHTTP cannot handle the authentication challenges. NTLM and Negotiate require that all authentication handshakes be exchanged on the same socket connection, so authentication fails if the connection is broken prematurely.</para>
      <para>Secondly, NTLM and Negotiate may require multiple handshakes to complete authentication, which requires data to be re-POST'ed for each authentication legs. This  can be very inefficient for large data uploads.</para>
      <para>To work around these two issues, one solution is to send an idempotent warm-up request such as HEAD to the authenticating v-dir first, handle the authentication challenges associated with this request, and only then POST data. As long as the same socket is re-used to handle the POST'ing,  no further authentication challenges should be encountered and all data can be uploaded at once. Since an authenticated socket can only be reused for subsequent requests within the same session, the POST should  go out in the same socket as long as the socket is not pooled with concurrent requests  competing for it.</para>
      <para>
        <b>Note</b>  For Windows XP and Windows 2000, see the <a href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-start-page">Run-Time Requirements</a> section of the WinHTTP start page.</para>
      <h4>Examples</h4>
      <para>This example shows code that  writes data to an HTTP server.  The server name supplied in the example, www.wingtiptoys.com, is fictitious and must be replaced with the name of a server for which you have write access.</para>
      <code>    PCSTR pszData = "WinHttpWriteData Example";
    DWORD dwBytesWritten = 0;
    BOOL  bResults = FALSE;
    HINTERNET hSession = NULL,
              hConnect = NULL,
              hRequest = NULL;

    // Use WinHttpOpen to obtain a session handle.
    hSession = WinHttpOpen(  L"A WinHTTP Example Program/1.0",
                             WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                             WINHTTP_NO_PROXY_NAME,
                             WINHTTP_NO_PROXY_BYPASS, 0);

    // Specify an HTTP server.
    if (hSession)
        hConnect = WinHttpConnect( hSession, L"www.wingtiptoys.com",
                                   INTERNET_DEFAULT_HTTP_PORT, 0);

    // Create an HTTP Request handle.
    if (hConnect)
        hRequest = WinHttpOpenRequest( hConnect, L"PUT",
                                       L"/writetst.txt",
                                       NULL, WINHTTP_NO_REFERER,
                                       WINHTTP_DEFAULT_ACCEPT_TYPES,
                                       0);

    // Send a Request.
    if (hRequest)
        bResults = WinHttpSendRequest( hRequest,
                                       WINHTTP_NO_ADDITIONAL_HEADERS,
                                       0, WINHTTP_NO_REQUEST_DATA, 0,
                                       (DWORD)strlen(pszData), 0);

    // Write data to the server.
    if (bResults)
        bResults = WinHttpWriteData( hRequest, pszData,
                                     (DWORD)strlen(pszData),
                                     &amp;amp;amp;amp;amp;amp;dwBytesWritten);

    // End the request.
    if (bResults)
        bResults = WinHttpReceiveResponse( hRequest, NULL);

    // Report any errors.
    if (!bResults)
        printf("Error %d has occurred.\n",GetLastError());


    // Close any open handles.
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/about-winhttp">About Microsoft Windows HTTP Services (WinHTTP)</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinHttp/winhttp-versions">WinHTTP Versions</seealso>
    <seealso cref="WinHttpConnect" />
    <seealso cref="WinHttpOpen" />
    <seealso cref="WinHttpOpenRequest" />
  </member>
</doc>