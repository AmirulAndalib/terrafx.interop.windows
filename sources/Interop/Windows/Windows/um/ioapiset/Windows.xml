<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.CancelIo">
    <summary>
      <para>Cancels all pending input and output (I/O) operations that are issued by the calling thread for the specified file. The function does not cancel I/O operations that other threads issue for a file handle.</para>
      <para>To cancel I/O operations from another thread, use the <a href="https://docs.microsoft.com//windows/desktop/FileIO/cancelioex-func">CancelIoEx</a> function.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file.</para>
      <para>The function cancels all pending I/O operations for this file handle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued by the calling thread for the specified file handle was successfully requested. The thread can use the <see cref="GetOverlappedResult" /> function to determine when the I/O operations themselves have been completed.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>If there are any pending I/O operations in progress for the specified file handle, and they are issued by the calling thread, the <b>CancelIo</b> function cancels them. <b>CancelIo</b> cancels only outstanding I/O on the handle, it does not change the state of the handle; this means that you cannot rely on the state of the handle because you cannot know whether the operation was completed successfully or canceled.</para>
      <para>The I/O operations must be issued as overlapped I/O. If they are not, the I/O operations do not  return to allow the thread to call the
<b>CancelIo</b> function. Calling the
<b>CancelIo</b> function with a file handle that is not opened with <b>FILE_FLAG_OVERLAPPED</b> does nothing.</para>
      <para>All I/O operations that are canceled complete with the error <b>ERROR_OPERATION_ABORTED</b>, and all completion notifications for the I/O operations occur normally.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelioex-func">CancelIoEx</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="DeviceIoControl" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="LockFileEx" />
    <seealso cref="ReadDirectoryChangesW" />
    <seealso cref="ReadFile" />
    <seealso cref="ReadFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</seealso>
    <seealso cref="WriteFile" />
    <seealso cref="WriteFileEx" />
  </member>
  <member name="Windows.CancelSynchronousIo">
    <summary>
      <para>Marks pending synchronous I/O operations that are issued by the specified thread as
canceled.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If this function cannot find a request to cancel, the return value is 0 (zero), and
<see cref="GetLastError" /> returns
<b>ERROR_NOT_FOUND</b>.</para>
    </returns>
    <remarks>
      <para>The caller must have the
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">THREAD_TERMINATE</a> access right.</para>
      <para>If there are any pending I/O operations in progress for the specified thread, the
<b>CancelSynchronousIo</b> function marks them for
cancellation. Most types of operations can be canceled immediately; other operations can continue toward
completion before they are actually canceled and the caller is notified. The
<b>CancelSynchronousIo</b> function does not wait for
all canceled operations to complete. For more information, see
<a href="https://www.microsoft.com/whdc/driver/kernel/iocancel.mspx">I/O Completion/Cancellation Guidelines</a>.</para>
      <para>The operation being canceled is completed with one of three statuses; you must check the completion status to
determine the completion state. The three statuses are:</para>
      <list type="bullet">
        <item>
          <description>
            <b>The operation completed normally.</b> This can occur even if the operation was
canceled, because the cancel request might not have been submitted in time to cancel the operation.</description>
        </item>
        <item>
          <description>
            <b>The operation was canceled.</b> The
<see cref="GetLastError" /> function returns
<b>ERROR_OPERATION_ABORTED</b>.</description>
        </item>
        <item>
          <description>
            <b>The operation failed with another error.</b> The
<see cref="GetLastError" /> function returns the relevant error
code.</description>
        </item>
      </list>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelio">CancelIo</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelioex-func">CancelIoEx</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</seealso>
  </member>
  <member name="Windows.DeviceIoControl">
    <summary>
      <para>Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.</para>
      <para>See the <a href="https://github.com/microsoft/windows-classic-samples/tree/master/samples/win7samples/winbase/io/dledit">Assign drive letter sample</a>.</para>
    </summary>
    <param name="hDevice">
      <para>A handle to the device on which the operation is to be performed. The device is typically a volume,
directory, file, or stream. To retrieve a device handle, use the
<see cref="CreateFile" /> function. For more information, see
Remarks.</para>
    </param>
    <param name="dwIoControlCode">
      <para>The control code for the operation. This value identifies the specific operation to be performed and the
type of device on which to perform it.</para>
      <para>For a list of the control codes, see Remarks. The documentation for each control code provides usage details
for the <i>lpInBuffer</i>, <i>nInBufferSize</i>,
<i>lpOutBuffer</i>, and <i>nOutBufferSize</i> parameters.</para>
    </param>
    <param name="lpInBuffer">
      <para>A pointer to the input buffer that contains the data required to perform the operation. The format of this
data depends on the value of the <i>dwIoControlCode</i> parameter.</para>
      <para>This parameter can be <b>NULL</b> if <i>dwIoControlCode</i> specifies
an operation that does not require input data.</para>
    </param>
    <param name="nInBufferSize">
      <para>The size of the input buffer, in bytes.</para>
    </param>
    <param name="lpOutBuffer">
      <para>A pointer to the output buffer that is to receive the data returned by the operation. The format of this
data depends on the value of the <i>dwIoControlCode</i> parameter.</para>
      <para>This parameter can be <b>NULL</b> if <i>dwIoControlCode</i> specifies
an operation that does not return data.</para>
    </param>
    <param name="nOutBufferSize">
      <para>The size of the output buffer, in bytes.</para>
    </param>
    <param name="lpBytesReturned">
      <para>A pointer to a variable that receives the size of the data stored in the output buffer, in bytes.</para>
      <para>If the output buffer is too small to receive any data,  the call fails,
<see cref="GetLastError" /> returns
<b>ERROR_INSUFFICIENT_BUFFER</b>, and <i>lpBytesReturned</i> is zero.</para>
      <para>If the output buffer is too small to hold all of the data but can hold some entries, some drivers will return
as much data as fits. In this case, the call fails,
<see cref="GetLastError" /> returns
<b>ERROR_MORE_DATA</b>, and <i>lpBytesReturned</i> indicates the amount
of data received. Your application should call
<b>DeviceIoControl</b> again with the same operation,
specifying a new starting point.</para>
      <para>If <i>lpOverlapped</i> is <b>NULL</b>,
<i>lpBytesReturned</i> cannot be <b>NULL</b>. Even when an operation
returns no output data and <i>lpOutBuffer</i> is <b>NULL</b>,
<b>DeviceIoControl</b> makes use of
<i>lpBytesReturned</i>. After such an operation, the value of
<i>lpBytesReturned</i> is meaningless.</para>
      <para>If <i>lpOverlapped</i> is not <b>NULL</b>,
<i>lpBytesReturned</i> can be <b>NULL</b>. If this parameter is not
<b>NULL</b> and the operation returns data, <i>lpBytesReturned</i> is
meaningless until the overlapped operation has completed. To retrieve the number of bytes returned, call
<see cref="GetOverlappedResult" />. If
<i>hDevice</i> is associated with an I/O completion port, you can retrieve the number of
bytes returned by calling
<see cref="GetQueuedCompletionStatus" />.</para>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> structure.</para>
      <para>If <i>hDevice</i> was opened without specifying
<b>FILE_FLAG_OVERLAPPED</b>, <i>lpOverlapped</i> is ignored.</para>
      <para>If <i>hDevice</i> was opened with the <b>FILE_FLAG_OVERLAPPED</b> flag,
the operation is performed as an overlapped (asynchronous) operation. In this case,
<i>lpOverlapped</i> must point to a valid
<see cref="OVERLAPPED" /> structure that contains a handle to an
event object. Otherwise, the function fails in unpredictable ways.</para>
      <para>For overlapped operations,
<b>DeviceIoControl</b> returns immediately, and the event
object is signaled when the operation has been completed. Otherwise, the function does not return until the
operation has been completed or an error occurs.</para>
    </param>
    <returns>
      <para>If the operation completes successfully, the return value is nonzero (TRUE).</para>
      <para>If the operation fails or is pending, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To retrieve a handle to the device, you must call the
<see cref="CreateFile" /> function with either the name of a device or
the name of the driver associated with a device. To specify a device name, use the following format:</para>
      <para>\.\<i>DeviceName</i></para>
      <para>
        <b>DeviceIoControl</b> can accept a handle to a specific
device. For example, to open a handle to the logical drive A: with
<see cref="CreateFile" />, specify \.\a:. Alternatively, you can use the
names \.\PhysicalDrive0, \.\PhysicalDrive1, and so on, to open handles to the physical drives on a system.</para>
      <para>You should specify the <b>FILE_SHARE_READ</b> and
<b>FILE_SHARE_WRITE</b> access flags when calling
<see cref="CreateFile" /> to open a handle to a device driver. However,
when you open a communications resource, such as a serial port, you must specify exclusive access. Use the other
<b>CreateFile</b> parameters as follows when opening a device
handle:</para>
      <list type="bullet">
        <item>
          <description>The <i>fdwCreate</i> parameter must specify
<b>OPEN_EXISTING</b>.</description>
        </item>
        <item>
          <description>The <i>hTemplateFile</i> parameter must be <b>NULL</b>.</description>
        </item>
        <item>
          <description>The <i>fdwAttrsAndFlags</i> parameter can specify
<b>FILE_FLAG_OVERLAPPED</b> to indicate that the returned handle can be used in overlapped
(asynchronous) I/O operations.</description>
        </item>
      </list>
      <para>For lists of supported control codes, see the following topics:</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/DevIO/communications-control-codes">Communications Control Codes</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/DevIO/device-management-control-codes">Device Management Control Codes</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-control-codes">Directory Management Control Codes</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/FileIO/disk-management-control-codes">Disk Management Control Codes</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-control-codes">File Management Control Codes</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/Power/power-management-control-codes">Power Management Control Codes</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-control-codes">Volume Management Control Codes</a>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example that uses <b>DeviceIoControl</b>, see <a href="https://docs.microsoft.com//windows/desktop/DevIO/calling-deviceiocontrol">Calling DeviceIoControl</a>.</para>
    </remarks>
    <seealso cref="CreateEvent" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/device-input-and-output-control-ioctl-">Device Input and Output Control (IOCTL)</seealso>
    <seealso cref="GetOverlappedResult" />
    <seealso cref="GetQueuedCompletionStatus" />
    <seealso cref="OVERLAPPED" />
    <seealso href="https://github.com/microsoft/windows-classic-samples/tree/master/samples/win7samples/winbase/io/dledit">Assign drive letter sample</seealso>
  </member>
  <member name="Windows.GetOverlappedResult">
    <summary>
      <para>Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device. To specify a timeout interval or wait on an alertable thread, use <see cref="GetOverlappedResultEx" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file, named pipe, or communications device. This is the same handle that was specified when the overlapped operation was started by a call to any of the following functions:</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="ReadFile" />
          </description>
        </item>
        <item>
          <description>
            <see cref="WriteFile" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ConnectNamedPipe" />
          </description>
        </item>
        <item>
          <description>
            <see cref="TransactNamedPipe" />
          </description>
        </item>
        <item>
          <description>
            <see cref="DeviceIoControl" />
          </description>
        </item>
        <item>
          <description>
            <see cref="WaitCommEvent" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ReadDirectoryChangesW" />
          </description>
        </item>
        <item>
          <description>
            <see cref="LockFileEx" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ReadDirectoryChangesW" />
          </description>
        </item>
      </list>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an
<see cref="OVERLAPPED" /> structure that was specified when the overlapped operation was started.</para>
    </param>
    <param name="lpNumberOfBytesTransferred">
      <para>A pointer to a variable that receives the number of bytes that were actually transferred by a read or write operation. For a
<see cref="TransactNamedPipe" /> operation, this is the number of bytes that were read from the pipe. For a
<see cref="DeviceIoControl" /> operation, this is the number of bytes of output data returned by the device driver. For a
<see cref="ConnectNamedPipe" /> or
<see cref="WaitCommEvent" /> operation, this value is undefined.</para>
    </param>
    <param name="bWait">
      <para>If this parameter is <b>TRUE</b>, and the <b>Internal</b> member of the <i>lpOverlapped</i> structure is <b>STATUS_PENDING</b>, the function does not return until the operation has been completed. If this parameter is <b>FALSE</b> and the operation is still pending, the function returns <b>FALSE</b> and the
<see cref="GetLastError" /> function returns <b>ERROR_IO_INCOMPLETE</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The results reported by the
<b>GetOverlappedResult</b> function are those of the specified handle's last overlapped operation to which the specified
<see cref="OVERLAPPED" /> structure was provided, and for which the operation's results were pending. A pending operation is indicated when the function that started the operation returns <b>FALSE</b>, and the <see cref="GetLastError" /> function returns <b>ERROR_IO_PENDING</b>. When an I/O operation is pending, the function that started the operation resets the <b>hEvent</b> member of the
<b>OVERLAPPED</b> structure to the nonsignaled state. Then when the pending operation has been completed, the system sets the event object to the signaled state.</para>
      <para>If the <i>bWait</i> parameter is <b>TRUE</b>,
<b>GetOverlappedResult</b> determines whether the pending operation has been completed by waiting for the event object to be in the signaled state.</para>
      <para>If the <b>hEvent</b> member of the
<see cref="OVERLAPPED" /> structure is <b>NULL</b>, the system uses the state of the <i>hFile</i> handle to signal when the operation has been completed. Use of file, named pipe, or communications-device handles for this purpose is discouraged. It is safer to use an event object because of the confusion that can occur when multiple simultaneous overlapped operations are performed on the same file, named pipe, or communications device. In this situation, there is no way to know which operation caused the object's state to be signaled.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetOverlappedResult</b>, see <a href="https://docs.microsoft.com//windows/win32/fileio/testing-for-the-end-of-a-file">Testing for the End of a File</a></para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/FileIO/cancelio">CancelIo</seealso>
    <seealso cref="CreateEvent" />
    <seealso cref="GetOverlappedResultEx" />
    <seealso cref="OVERLAPPED" />
    <seealso href="https://docs.microsoft.com//windows/win32/Sync/synchronization-and-overlapped-input-and-output">Overlapped Input and Output</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.GetOverlappedResultEx">
    <summary>
      <para>Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device within the  specified time-out interval.  The calling thread can perform an alertable wait.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file, named pipe, or communications device. This is the same handle that was specified when the overlapped operation was started by a call to the
<see cref="ReadFile" />,
<see cref="WriteFile" />,
<see cref="ConnectNamedPipe" />,
<see cref="TransactNamedPipe" />,
<see cref="DeviceIoControl" />, or
<see cref="WaitCommEvent" /> function.</para>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an
<see cref="OVERLAPPED" /> structure that was specified when the overlapped operation was started.</para>
    </param>
    <param name="lpNumberOfBytesTransferred">
      <para>A pointer to a variable that receives the number of bytes that were actually transferred by a read or write operation. For a
<see cref="TransactNamedPipe" /> operation, this is the number of bytes that were read from the pipe. For a
<see cref="DeviceIoControl" /> operation, this is the number of bytes of output data returned by the device driver. For a
<see cref="ConnectNamedPipe" /> or
<see cref="WaitCommEvent" /> operation, this value is undefined.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds.</para>
      <para>If <i>dwMilliseconds</i> is zero and the operation is still in progress, the function  returns immediately and the <see cref="GetLastError" /> function returns <b>ERROR_IO_INCOMPLETE</b>.</para>
      <para>If <i>dwMilliseconds</i> is nonzero and the operation is still in progress, the function waits until the object is signaled, an I/O completion routine or APC is queued, or the interval elapses before returning. Use <see cref="GetLastError" /> to get extended error information.</para>
      <para>If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function returns only when the object is signaled or an I/O completion routine or APC is queued.</para>
      <para>
        <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value includes time spent in low-power states. For example, the timeout continues counting down while the computer is asleep.</para>
      <para>
        <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not continue counting down while the computer is asleep.</para>
    </param>
    <param name="bAlertable">
      <para>If this parameter is <b>TRUE</b> and the calling thread is in the waiting state, the function returns when the system queues an I/O completion routine or APC. The calling thread then runs the routine or function. Otherwise, the function does not return, and the completion routine or APC function is not executed.</para>
      <para>A completion routine is queued when the <see cref="ReadFileEx" /> or <see cref="WriteFileEx" /> function in which it was specified has completed. The function returns and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b>, and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call <see cref="QueueUserAPC" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Common error codes include the following:</para>
      <list type="bullet">
        <item>
          <description>If <i>dwMilliseconds</i> is zero and the operation is still in progress,  <see cref="GetLastError" /> returns <b>ERROR_IO_INCOMPLETE</b>.</description>
        </item>
        <item>
          <description>If <i>dwMilliseconds</i> is nonzero, and an I/O completion routine or APC is queued, <see cref="GetLastError" /> returns <b>WAIT_IO_COMPLETION</b>. </description>
        </item>
        <item>
          <description>If <i>dwMilliseconds</i> is nonzero and the specified timeout interval elapses, <see cref="GetLastError" /> returns <b>WAIT_TIMEOUT</b>. </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetOverlappedResultEx</b> function differs from <see cref="GetOverlappedResult" /> in the following ways: The <i>dwMilliseconds</i> parameter can specify a timeout interval for the operation, and the <i>bAlertable</i> parameter can specify that the calling thread should perform an alertable wait.</para>
      <para>The results reported by the
<b>GetOverlappedResultEx</b> function are those of the specified handle's last overlapped operation to which the specified
<see cref="OVERLAPPED" /> structure was provided, and for which the operation's results were pending. A pending operation is indicated when the function that started the operation returns FALSE, and the <see cref="GetLastError" /> function returns <b>ERROR_IO_PENDING</b>. When an I/O operation is pending, the function that started the operation resets the <b>hEvent</b> member of the
<b>OVERLAPPED</b> structure to the nonsignaled state. Then when the pending operation has been completed, the system sets the event object to the signaled state.</para>
      <para>Specify a manual-reset event object in the
<see cref="OVERLAPPED" /> structure. If an auto-reset event object is used, the event handle must not be specified in any other wait operation in the interval between starting the overlapped operation and the call to
<b>GetOverlappedResultEx</b>. For example, the event object is sometimes specified in one of the wait functions to wait for the operation's completion. When the wait function returns, the system sets an auto-reset event's state to nonsignaled, and a subsequent call to
<b>GetOverlappedResultEx</b> with the <i>dwMilliseconds</i> parameter set to <b>INFINITE</b> causes the function to be blocked indefinitely.</para>
      <para>If the <b>hEvent</b> member of the
<see cref="OVERLAPPED" /> structure is <b>NULL</b>, the system uses the state of the <i>hFile</i> handle to signal when the operation has been completed. Use of file, named pipe, or communications-device handles for this purpose is discouraged. It is safer to use an event object because of the confusion that can occur when multiple simultaneous overlapped operations are performed on the same file, named pipe, or communications device. In this situation, there is no way to know which operation caused the object's state to be signaled.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelio">CancelIo</seealso>
    <seealso cref="ConnectNamedPipe" />
    <seealso cref="CreateEvent" />
    <seealso cref="DeviceIoControl" />
    <seealso cref="GetLastError" />
    <seealso cref="GetOverlappedResult" />
    <seealso cref="OVERLAPPED" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-and-overlapped-input-and-output">Overlapped Input and Output</seealso>
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso cref="TransactNamedPipe" />
    <seealso cref="WaitCommEvent" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.GetQueuedCompletionStatus">
    <summary>
      <para>Attempts to dequeue an I/O completion packet from the specified I/O completion port. If there is no completion packet queued, the function waits for a pending I/O operation associated
with the completion port to complete.</para>
      <para>To dequeue multiple I/O completion packets at once, use the <a href="https://docs.microsoft.com//windows/desktop/FileIO/getqueuedcompletionstatusex-func">GetQueuedCompletionStatusEx</a> function.</para>
    </summary>
    <param name="CompletionPort">
      <para>A handle to the completion port. To create a completion port, use the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a> function.</para>
    </param>
    <param name="lpNumberOfBytesTransferred">
      <para>A pointer to a variable that receives the number of bytes transferred in a completed I/O operation.</para>
    </param>
    <param name="lpCompletionKey">
      <para>A pointer to a variable that receives the completion key value associated with the file handle whose I/O operation has completed. A completion key is a per-file key that is specified in a call to
<a href="https://docs.microsoft.com//windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a>.</para>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to a variable that receives the address of the
<see cref="OVERLAPPED" /> structure that was specified when the completed I/O operation was started.</para>
      <para>Even if you have passed the function a file handle associated with a completion port and a valid
<see cref="OVERLAPPED" /> structure, an application can prevent completion port notification. This is done by specifying a valid event handle for the <b>hEvent</b> member of the <b>OVERLAPPED</b> structure, and setting its low-order bit. A valid event handle whose low-order bit is set keeps I/O completion from being queued to the completion port.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The number of milliseconds that the caller is willing to wait for a completion packet to appear at the completion port. If a completion packet does not appear within the specified time, the function times out, returns <b>FALSE</b>, and sets *<i>lpOverlapped</i> to <b>NULL</b>.</para>
      <para>If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will never time out. If <i>dwMilliseconds</i> is zero and there is no I/O operation to dequeue, the function will time out immediately.</para>
      <para>
        <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value includes time spent in low-power states. For example, the timeout continues counting down while the computer is asleep.</para>
      <para>
        <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not continue counting down while the computer is asleep.</para>
    </param>
    <returns>
      <para>Returns nonzero (<b>TRUE</b>) if successful or zero (<b>FALSE</b>) otherwise.</para>
      <para>To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>For more information, see the Remarks section.</para>
    </returns>
    <remarks>
      <para>This function associates a thread with the specified completion port. A thread can be associated with at most one completion port.</para>
      <para>If a call to <b>GetQueuedCompletionStatus</b> fails because the completion port handle associated with it is closed while the call is outstanding, the function returns <b>FALSE</b>, <i>*lpOverlapped</i> will be <b>NULL</b>,  and <see cref="GetLastError" /> will return <b>ERROR_ABANDONED_WAIT_0</b>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>Closing the completion port handle while a call is outstanding will not result in the previously stated behavior.  The function will continue to wait until an entry is removed from the port or until a time-out occurs, if specified as a value other than <b>INFINITE</b>.</para>
      <para>If the <b>GetQueuedCompletionStatus</b> function succeeds, it dequeued a completion packet for a successful I/O operation from the completion port and has stored information in the variables pointed to by the
following parameters: <i>lpNumberOfBytes</i>, <i>lpCompletionKey</i>, and <i>lpOverlapped</i>. Upon failure (the return value is <b>FALSE</b>), those same parameters can contain particular value combinations as follows:</para>
      <list type="bullet">
        <item>
          <description>If *<i>lpOverlapped</i> is <b>NULL</b>, the function did not dequeue a completion packet from the completion port. In this case, the function does not store information in
the variables pointed to by the <i>lpNumberOfBytes</i> and <i>lpCompletionKey</i> parameters, and their values are indeterminate.</description>
        </item>
        <item>
          <description>If *<i>lpOverlapped</i> is not <b>NULL</b> and the function dequeues a completion packet for a failed I/O operation from the completion port, the function stores
information about the failed operation in the variables pointed to by <i>lpNumberOfBytes</i>, <i>lpCompletionKey</i>, and <i>lpOverlapped</i>. To get extended error information, call <see cref="GetLastError" />.</description>
        </item>
      </list>
      <para>For more information on I/O completion port theory, usage, and associated functions, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/i-o-completion-ports">I/O Completion Ports</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="ConnectNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</seealso>
    <seealso cref="DeviceIoControl" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/getqueuedcompletionstatusex-func">GetQueuedCompletionStatusEx</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/i-o-completion-ports">I/O Completion Ports</seealso>
    <seealso cref="LockFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/postqueuedcompletionstatus">PostQueuedCompletionStatus</seealso>
    <seealso cref="ReadFile" />
    <seealso cref="TransactNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WaitCommEvent" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.GetQueuedCompletionStatusEx">
    <summary>
      <para>Retrieves  multiple completion port entries simultaneously. It waits for pending I/O
operations that are associated with the specified completion port to complete.</para>
      <para>To dequeue I/O completion packets one at a time, use the
<see cref="GetQueuedCompletionStatus" /> function.</para>
    </summary>
    <param name="CompletionPort">
      <para>A handle to the completion port. To create a completion port, use the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a> function.</para>
    </param>
    <param name="lpCompletionPortEntries">
      <para>On input, points to a pre-allocated array of
<see cref="OVERLAPPED_ENTRY" /> structures.</para>
      <para>On output, receives an array of <see cref="OVERLAPPED_ENTRY" /></para>
      <para>structures that hold the entries. The number of array elements is provided by
<i>ulNumEntriesRemoved</i>.</para>
      <para>The number of bytes transferred during each I/O, the completion key that indicates on which file each I/O
occurred, and the overlapped structure address used in each original I/O are all returned in the
<i>lpCompletionPortEntries</i> array.</para>
    </param>
    <param name="ulCount">
      <para>The maximum number of entries to remove.</para>
    </param>
    <param name="ulNumEntriesRemoved">
      <para>A pointer to a variable that receives the number of entries actually removed.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The number of milliseconds that the caller is willing to wait for a completion packet to appear at the
completion port. If a completion packet does not appear within the specified time, the function times out and
returns <b>FALSE</b>.</para>
      <para>If <i>dwMilliseconds</i> is <b>INFINITE</b> (0xFFFFFFFF), the function
will never time out. If <i>dwMilliseconds</i> is zero and there is no I/O operation to
dequeue, the function will time out immediately.</para>
      <para>
        <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2:  </b>The <i>dwMilliseconds</i> value includes time spent in low-power states. For example, the timeout continues counting down while the computer is asleep.</para>
      <para>
        <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016:  </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not continue counting down while the computer is asleep.</para>
    </param>
    <param name="fAlertable">
      <para>If this parameter is <b>FALSE</b>, the function does not return until the time-out period
has elapsed or an entry is retrieved.</para>
      <para>If the parameter is <b>TRUE</b> and there are no available entries, the function performs
an alertable wait. The thread returns when the system queues an I/O completion routine or APC to the thread and
the thread executes the function.</para>
      <para>A completion routine is queued when the <see cref="ReadFileEx" /> or
<see cref="WriteFileEx" /> function in which it was specified has
completed, and the calling thread is the thread that initiated the operation. An APC is queued when you call
<see cref="QueueUserAPC" />.</para>
    </param>
    <returns>
      <para>Returns nonzero (<b>TRUE</b>) if successful or zero (<b>FALSE</b>) otherwise.</para>
      <para>To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function associates a thread with the specified completion port. A thread can be associated with at most
one completion port.</para>
      <para>This function returns <b>TRUE</b> when at least one pending I/O is completed, but it is
possible that one or more I/O operations failed. Note that it is up to the user of this function to check the
list of returned entries in the <i>lpCompletionPortEntries</i> parameter to determine which of
them correspond to any possible failed I/O operations by looking at the status contained in the
<b>lpOverlapped</b> member in each
<see cref="OVERLAPPED_ENTRY" />.</para>
      <para>This function returns <b>FALSE</b> when no I/O operation was dequeued. This typically means
that an error occurred while processing the parameters to this call, or that the
<i>CompletionPort</i> handle was closed or is otherwise invalid. The
<see cref="GetLastError" /> function provides extended error
information.</para>
      <para>If a call to <see cref="GetQueuedCompletionStatusEx" /></para>
      <para>fails because the handle associated with it is closed, the function returns <b>FALSE</b> and
<see cref="GetLastError" /> will return
<b>ERROR_ABANDONED_WAIT_0</b>.</para>
      <para>Server applications may have several threads calling the
<b>GetQueuedCompletionStatusEx</b> function
for the same completion port.  As I/O operations complete, they are queued to this port in first-in-first-out
order. If a thread is actively waiting on this call, one or more queued requests complete the call for that
thread only.</para>
      <para>For more information on I/O completion port theory, usage, and associated functions, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/i-o-completion-ports">I/O Completion Ports</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="ConnectNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</seealso>
    <seealso cref="DeviceIoControl" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/getqueuedcompletionstatusex-func">GetQueuedCompletionStatusEx</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/i-o-completion-ports">I/O Completion Ports</seealso>
    <seealso cref="LockFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/postqueuedcompletionstatus">PostQueuedCompletionStatus</seealso>
    <seealso cref="ReadFile" />
    <seealso cref="TransactNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</seealso>
    <seealso cref="WaitCommEvent" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.PostQueuedCompletionStatus">
    <summary>
      <para>Posts an I/O completion packet to an I/O completion port.</para>
    </summary>
    <param name="CompletionPort">
      <para>A handle to an I/O completion port to which the I/O completion packet is to be posted.</para>
    </param>
    <param name="dwNumberOfBytesTransferred">
      <para>The value to be returned through the <i>lpNumberOfBytesTransferred</i> parameter of the
<see cref="GetQueuedCompletionStatus" /> function.</para>
    </param>
    <param name="dwCompletionKey">
      <para>The value to be returned through the <i>lpCompletionKey</i> parameter of the
<see cref="GetQueuedCompletionStatus" /> function.</para>
    </param>
    <param name="lpOverlapped">
      <para>The value to be returned through the <i>lpOverlapped</i> parameter of the
<see cref="GetQueuedCompletionStatus" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" /> .</para>
    </returns>
    <remarks>
      <para>The I/O completion packet will satisfy an outstanding call to the
<see cref="GetQueuedCompletionStatus" /> function. This function returns with the three values passed as the second, third, and fourth parameters of the call to
<b>PostQueuedCompletionStatus</b>. The system does not use or validate these values. In particular, the <i>lpOverlapped</i> parameter need not point to an <see cref="OVERLAPPED" /> structure.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs will do redirected IO for compressed files.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetQueuedCompletionStatus" />
    <seealso cref="OVERLAPPED" />
  </member>
</doc>