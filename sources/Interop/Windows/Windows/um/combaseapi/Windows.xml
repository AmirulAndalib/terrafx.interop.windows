<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.CLSIDFromProgID">
    <summary>
      <para>Looks up a CLSID in the registry, given a ProgID.</para>
    </summary>
    <param name="lpszProgID">
      <para>A pointer to the ProgID whose CLSID is requested.</para>
    </param>
    <param name="lpclsid">
      <para>Receives a pointer to the retrieved CLSID on return.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The CLSID was retrieved successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_CLASSSTRING</b>
            </para>
          </description>
          <description>
            <para>The registered CLSID for the ProgID is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_WRITEREGDB</b>
            </para>
          </description>
          <description>
            <para>An error occurred writing the CLSID to the registry. See Remarks below.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Given a ProgID, <b>CLSIDFromProgID</b> looks up its associated CLSID in the registry. If the ProgID cannot be found in the registry, <b>CLSIDFromProgID</b> creates an OLE 1 CLSID for the ProgID and a CLSID entry in the registry. Because of the restrictions placed on OLE 1 CLSID values, <b>CLSIDFromProgID</b> and <see cref="CLSIDFromString" /> are the only two functions that can be used to generate a CLSID for an OLE 1 object.</para>
    </remarks>
    <seealso cref="CLSIDFromProgIDEx" />
    <seealso cref="ProgIDFromCLSID" />
  </member>
  <member name="Windows.CLSIDFromProgIDEx">
    <summary>
      <para>Triggers automatic installation if the COMClassStore policy is enabled.</para>
      <para>This is analogous to the behavior of <see cref="CoCreateInstance" /> when neither CLSCTX_ENABLE_CODE_DOWNLOAD nor CLSCTX_NO_CODE_DOWNLOAD are specified.</para>
    </summary>
    <param name="lpszProgID">
      <para>A pointer to the ProgID whose CLSID is requested.</para>
    </param>
    <param name="lpclsid">
      <para>Receives a pointer to the retrieved CLSID on return.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The CLSID was retrieved successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_CLASSSTRING</b>
            </para>
          </description>
          <description>
            <para>The registered CLSID for the ProgID is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_WRITEREGDB</b>
            </para>
          </description>
          <description>
            <para>An error occurred writing the CLSID to the registry. See Remarks below.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>CLSCTX_ENABLE_CODE_DOWNLOAD enables automatic installation of missing classes through IntelliMirror/Application Management from the Active Directory. If this flag is not specified, the COMClassStore Policy ("Download missing COM components") determines the behavior (default: no download).</para>
      <para>If the COMClassStore Policy enables automatic installation, CLSCTX_NO_CODE_DOWNLOAD can be used to explicitly disallow download for an activation.</para>
      <para>If either of the following registry values are enabled (meaning set to 1), automatic download of missing classes is enabled:</para>
      <list type="bullet">
        <item>
          <description>
            <b>HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\App Management</b>\<b>COMClassStore</b></description>
        </item>
        <item>
          <description>
            <b>HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\App Management
</b>\<b>COMClassStore</b></description>
        </item>
      </list>
    </remarks>
    <seealso cref="ProgIDFromCLSID" />
  </member>
  <member name="Windows.CLSIDFromString">
    <summary>
      <para>Converts a string generated by the <see cref="StringFromCLSID" /> function back into the original CLSID.</para>
    </summary>
    <param name="lpsz">
      <para>The string representation of the CLSID.</para>
    </param>
    <param name="pclsid">
      <para>A pointer to the CLSID.</para>
    </param>
    <returns>
      <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>NOERROR</b>
            </para>
          </description>
          <description>
            <para>The CLSID was obtained successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_CLASSSTRING</b>
            </para>
          </description>
          <description>
            <para>The class string was improperly formatted.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_CLASSNOTREG</b>
            </para>
          </description>
          <description>
            <para>The CLSID corresponding to the class string was not found in the registry.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_READREGDB</b>
            </para>
          </description>
          <description>
            <para>The registry could not be opened for reading.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso cref="CLSIDFromProgID" />
    <seealso cref="StringFromCLSID" />
  </member>
  <member name="Windows.CoAddRefServerProcess">
    <summary>
      <para>Increments a global per-process reference count.</para>
    </summary>
    <returns>
      <para>The current reference count.</para>
    </returns>
    <remarks>
      <para>Servers can call <b>CoAddRefServerProcess</b> to increment a global per-process reference count. This function is particularly helpful to servers that are implemented with multiple threads, either multi-apartmented or free-threaded. Servers of these types must coordinate the decision to shut down with activation requests across multiple threads. Calling <b>CoAddRefServerProcess</b> increments a global per-process reference count, and calling <see cref="CoReleaseServerProcess" /> decrements that count.</para>
      <para>When that count reaches zero, OLE automatically calls <see cref="CoSuspendClassObjects" />, which prevents new activation requests from coming in. This permits the server to deregister its class objects from its various threads without worry that another activation request may come in. New activation requests result in launching a new instance of the local server process.</para>
      <para>The simplest way for a local server application to make use of these functions is to call <b>CoAddRefServerProcess</b> in the constructor for each of its instance objects, and in each of its <see cref="IClassFactory.LockServer" /> methods when the <i>fLock</i> parameter is <b>TRUE</b>. The server application should also call <see cref="CoReleaseServerProcess" /> in the destruction of each of its instance objects, and in each of its <b>LockServer</b> methods when the <i>fLock</i> parameter is <b>FALSE</b>. Finally, the server application should pay attention to the return code from <b>CoReleaseServerProcess</b> and if it returns 0, the server application should initiate its cleanup, which, for a server with multiple threads, typically means that it should signal its various threads to exit their message loops and call <see cref="CoRevokeClassObject" /> and <see cref="CoUninitialize" />.</para>
      <para>If these functions are used at all, they must be called in both the object instances and the <see cref="LockServer" /> method, otherwise the server application may be shut down prematurely. In-process servers typically should not call <b>CoAddRefServerProcess</b> or <see cref="CoReleaseServerProcess" />.</para>
    </remarks>
    <seealso cref="CoReleaseServerProcess" />
    <seealso cref="IClassFactory.LockServer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/out-of-process-server-implementation-helpers">Out-of-Process Server Implementation Helpers</seealso>
  </member>
  <member name="Windows.CoAllowUnmarshalerCLSID">
    <summary>
      <para>Adds an unmarshaler CLSID to the allowed list for the calling process only.</para>
    </summary>
    <param name="clsid">
      <para>The CLSID of the unmarshaler to be added to the per-process allowed list.</para>
    </param>
    <returns>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>Don't call the <b>CoAllowUnmarshalerCLSID</b> function until after <see cref="CoInitializeSecurity" /> has been called in the current process.</para>
      <para>The <b>CoAllowUnmarshalerCLSID</b> function provides more granular control over unmarshaling policy than is provided by the policy options. If the process applies any unmarshaling policy, the effect of the <b>CoAllowUnmarshalerCLSID</b> function is to make the policy comparatively weaker. For this reason, only call <b>CoAllowUnmarshalerCLSID</b> when the security impact is well understood. Usually, this is used to facilitate applying a stronger unmarshaling policy option for the broad attack surface reduction this provides, when a specific unmarshaler CLSID not allowed by that option is needed due to other constraints.</para>
      <para>For example, it's appropriate to call the <b>CoAllowUnmarshalerCLSID</b> function when an unmarshaler is known or believed to have a vulnerability but is required by an app. Also, it's appropriate to call <b>CoAllowUnmarshalerCLSID</b> if the unmarshaler is used in multiple processes, but only as part of an uncommon feature. Don't use the <b>CoAllowUnmarshalerCLSID</b> function as a replacement for hardening the unmarshaler.</para>
    </remarks>
    <seealso cref="GLOBALOPT_UNMARSHALING_POLICY_VALUES" />
    <seealso cref="IMarshalingStream" />
  </member>
  <member name="Windows.CoCancelCall">
    <summary>
      <para>Requests cancellation of an outbound DCOM method call pending on a specified thread.</para>
    </summary>
    <param name="dwThreadId">
      <para>The identifier of the thread on which the pending DCOM call is to be canceled. If this parameter is 0, the call is on the current thread.</para>
    </param>
    <param name="ulTimeout">
      <para>The number of seconds <b>CoCancelCall</b> waits for the server to complete the outbound call after the client requests cancellation.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The cancellation request was made.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_NOINTERFACE</b>
            </para>
          </description>
          <description>
            <para>There is no cancel object corresponding to the specified thread.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_CANCEL_DISABLED</b>
            </para>
          </description>
          <description>
            <para>Call cancellation is not enabled on the specified thread.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_E_CALL_COMPLETE</b>
            </para>
          </description>
          <description>
            <para>The call was completed during the timeout interval.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_E_CALL_CANCELED</b>
            </para>
          </description>
          <description>
            <para>The call was already canceled.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>CoCancelCall</b> calls <see cref="CoGetCancelObject" /> and then <see cref="ICancelMethodCalls.Cancel" /> on the cancel object for the call being executed.</para>
      <para>This function does not locate cancel objects for asynchronous calls.</para>
      <para>The object server can determine if the call has been canceled by periodically calling <see cref="CoTestCancel" />. If the call has been canceled, the object server should clean up and return control to the client.</para>
    </remarks>
    <seealso cref="CoTestCancel" />
  </member>
  <member name="Windows.CoCopyProxy">
    <summary>
      <para>Makes a private copy of the specified proxy.</para>
    </summary>
    <param name="pProxy">
      <para>A pointer to the <see cref="IUnknown" /> interface on the proxy to be copied. This parameter cannot be <b>NULL</b>.</para>
    </param>
    <param name="ppCopy">
      <para>Address of the pointer variable that receives the interface pointer to the copy of the proxy. This parameter cannot be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Indicates success.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>One or more arguments are invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>CoCopyProxy</b> makes a private copy of the specified proxy. Typically, this function is called when a client needs to change the authentication information of its proxy through a call to either <see cref="CoSetProxyBlanket" /> or <see cref="IClientSecurity.SetBlanket" /> without changing this information for other clients. <b>CoSetProxyBlanket</b> affects all the users of an instance of a proxy, so creating a private copy of the proxy through a call to <b>CoCopyProxy</b> and then calling <b>CoSetProxyBlanket</b> (or <b>IClientSecurity.SetBlanket</b>) using the copy eliminates the problem.</para>
      <para>This helper function encapsulates the following sequence of common calls (error handling excluded):</para>
      <code>    pProxy-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;amp;amp;amp;amp;amp;amp;pcs);
    pcs-&gt;CopyProxy(punkProxy, ppunkCopy);
    pcs-&gt;Release();

</code>
      <para>Local interfaces may not be copied. <see cref="IUnknown" /> and <see cref="IClientSecurity" /> are examples of existing local interfaces.</para>
      <para>Copies of the same proxy have a special relationship with respect to <see cref="QueryInterface" />. Given a proxy, a, of the IA interface of a remote object, suppose a copy of a is created, called b. In this case, calling <b>QueryInterface</b> from the b proxy for IID_IA will not retrieve the IA interface on b, but the one on a, the original proxy with the "default" security settings for the IA interface.</para>
    </remarks>
    <seealso cref="CoSetProxyBlanket" />
    <seealso cref="IClientSecurity.SetBlanket" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/security-in-com">Security in COM</seealso>
  </member>
  <member name="Windows.CoCreateFreeThreadedMarshaler">
    <summary>
      <para>Creates an aggregatable object capable of context-dependent marshaling.</para>
    </summary>
    <param name="punkOuter">
      <para>A pointer to the aggregating object's controlling <see cref="IUnknown" />.</para>
    </param>
    <param name="ppunkMarshal">
      <para>Address of the pointer variable that receives the interface pointer to the aggregatable marshaler.</para>
    </param>
    <returns>
      <para>This function can return the standard return value E_OUTOFMEMORY, as well as the following value.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The marshaler was created.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CoCreateFreeThreadedMarshaler</b> function enables an object to efficiently marshal interface pointers between threads in the same process. If your objects do not support interthread marshaling, you have no need to call this function. It is intended for use by free-threaded DLL servers that must be accessed directly by all threads in a process, even those threads associated with single-threaded apartments. It custom-marshals the real memory pointer over into other apartments as a bogus "proxy" and thereby gives direct access to all callers, even if they are not free-threaded.</para>
      <para>The <b>CoCreateFreeThreadedMarshaler</b> function performs the following tasks:</para>
      <list type="number">
        <item>
          <description>Creates a free-threaded marshaler object.</description>
        </item>
        <item>
          <description>Aggregates this marshaler to the object specified by the <i>punkOuter</i> parameter. This object is normally the one whose interface pointers are to be marshaled.</description>
        </item>
      </list>
      <para>The aggregating object's implementation of <see cref="IMarshal" /> should delegate <see cref="QueryInterface" /> calls for IID_IMarshal to the <see cref="IUnknown" /> of the free-threaded marshaler. Upon receiving a call, the free-threaded marshaler performs the following tasks:</para>
      <list type="number">
        <item>
          <description>Checks the destination context specified by the <see cref="CoMarshalInterface" /> function's <i>dwDestContext</i> parameter.</description>
        </item>
        <item>
          <description>If the destination context is MSHCTX_INPROC, copies the interface pointer into the marshaling stream.</description>
        </item>
        <item>
          <description>If the destination context is any other value, finds or creates an instance of COM's default (standard) marshaler and delegates marshaling to it.
</description>
        </item>
      </list>
      <para>Values for <i>dwDestContext</i> come from the <see cref="MSHCTX" /> enumeration. MSHCTX_INPROC indicates that the interface pointer is to be marshaled between different threads in the same process. Because both threads have access to the same address space, the client thread can dereference the pointer directly rather than having to direct calls to a proxy. In all other cases, a proxy is required, so <b>CoCreateFreeThreadedMarshaler</b> delegates the marshaling job to COM's default implementation.</para>
      <para>Great care should be exercised in using the <b>CoCreateFreeThreadedMarshaler</b> function. This is because the performance of objects which aggregate the free-threaded marshaler is obtained through a calculated violation of the rules of COM, with the ever-present risk of undefined behavior unless the object operates within certain restrictions. The most important restrictions are:</para>
      <list type="bullet">
        <item>
          <description>A free-threaded marshaler object cannot hold direct pointers to interfaces on an object that does not aggregate the free-threaded marshaler as part of its state. If the object were to use direct references to ordinary single-threaded aggregate objects, it may break their single threaded property. If the object were to use direct references to ordinary multithreaded aggregate objects, these objects can behave in ways that show no sensitivity to the needs of direct single-threaded aggregate clients. For example, these objects can spin new threads and pass parameters to the threads that are references to ordinary single-threaded aggregate objects.
</description>
        </item>
        <item>
          <description>A free-threaded marshaler object cannot hold references to proxies to objects in other apartments. Proxies are sensitive to the threading model and can return RPC_E_WRONG_THREAD if called by the wrong client.
</description>
        </item>
      </list>
    </remarks>
    <seealso cref="CoGetInterfaceAndReleaseStream" />
    <seealso cref="CoMarshalInterThreadInterfaceInStream" />
  </member>
  <member name="Windows.CoCreateGuid">
    <summary>
      <para>Creates a GUID, a unique 128-bit integer used for CLSIDs and interface identifiers.</para>
    </summary>
    <param name="pguid">
      <para>A pointer to the requested GUID.</para>
    </param>
    <returns>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The GUID was successfully created.</para>
          </description>
        </item>
      </list>
      <para>Errors returned by <see cref="UuidCreate" /> are wrapped as an <b>HRESULT</b>.</para>
    </returns>
    <remarks>
      <para>The <b>CoCreateGuid</b> function calls the RPC function <see cref="UuidCreate" />, which creates a GUID, a globally unique 128-bit integer. Use <b>CoCreateGuid</b> when you need an absolutely unique number that you will use as a persistent identifier in a distributed environment. To a very high degree of certainty, this function returns a unique value – no other invocation, on the same or any other system (networked or not), should return the same value.</para>
    </remarks>
    <seealso cref="UuidCreate" />
  </member>
  <member name="Windows.CoCreateInstance">
    <summary>
      <para>Creates and default-initializes a single object of the class associated with a specified CLSID.</para>
      <para>Call <b>CoCreateInstance</b> when you want to create only one object on the local system. To create a single object on a remote system, call the <see cref="CoCreateInstanceEx" /> function. To create multiple objects based on a single CLSID, call the <see cref="CoGetClassObject" /> function.</para>
    </summary>
    <param name="rclsid">
      <para>The CLSID associated with the data and code that will be used to create the object.</para>
    </param>
    <param name="pUnkOuter">
      <para>If <b>NULL</b>, indicates that the object is not being created as part of an aggregate. If non-<b>NULL</b>, pointer to the aggregate object's <see cref="IUnknown" /> interface (the controlling <b>IUnknown</b>).</para>
    </param>
    <param name="dwClsContext">
      <para>Context in which the code that manages the newly created object will run. The values are taken from the enumeration <see cref="CLSCTX" />.</para>
    </param>
    <param name="riid">
      <para>A reference to the identifier of the interface to be used to communicate with the object.</para>
    </param>
    <param name="ppv">
      <para>Address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful return, *<i>ppv</i> contains the requested interface pointer. Upon failure, *<i>ppv</i> contains <b>NULL</b>.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>An instance of the specified object class was successfully created.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_CLASSNOTREG</b>
            </para>
          </description>
          <description>
            <para>A specified class is not registered in the registration database. Also can indicate that the type of server you requested in the <see cref="CLSCTX" /> enumeration is not registered or the values for the server types in the registry are corrupt.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CLASS_E_NOAGGREGATION</b>
            </para>
          </description>
          <description>
            <para>This class cannot be created as part of an aggregate.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_NOINTERFACE</b>
            </para>
          </description>
          <description>
            <para>The specified class does not implement the requested interface, or the controlling <see cref="IUnknown" /> does not expose the requested interface.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The <i>ppv</i> parameter is <b>NULL</b>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CoCreateInstance</b> function provides a convenient shortcut by connecting to the class object associated with the specified CLSID, creating a default-initialized instance, and releasing the class object. As such, it encapsulates the following functionality:</para>
      <code>CoGetClassObject(rclsid, dwClsContext, NULL, IID_IClassFactory, &amp;amp;amp;amp;amp;amp;pCF);
hresult = pCF-&gt;CreateInstance(pUnkOuter, riid, ppvObj);
pCF-&gt;Release();

</code>
      <para>It is convenient to use <b>CoCreateInstance</b> when you need to create only a single instance of an object on the local machine. If you are creating an instance on remote computer, call <see cref="CoCreateInstanceEx" />. When you are creating multiple instances, it is more efficient to obtain a pointer to the class object's <see cref="IClassFactory" /> interface and use its methods as needed. In the latter case, you should use the <see cref="CoGetClassObject" /> function.</para>
      <para>In the <see cref="CLSCTX" /> enumeration, you can specify the type of server used to manage the object. The constants can be CLSCTX_INPROC_SERVER, CLSCTX_INPROC_HANDLER, CLSCTX_LOCAL_SERVER, CLSCTX_REMOTE_SERVER or any combination of these values. The constant CLSCTX_ALL is defined as the combination of all four. For more information about the use of one or a combination of these constants, see <see cref="CLSCTX" />.</para>
      <h3>UWP applications</h3>
      <para>Although there are no restrictions on which CLSIDs a UWP application can pass to <b>CoCreateInstance</b>, many objects will fail with <b>E_ACCESSDENIED</b> for security reasons, especially if they do not run in-process. Additionally, even if you can successfully create an object, it might fail at a later time due to UWP security constraints, app-model differences, etc. In particular, background tasks should limit the objects they communicate with to avoid hangs or other complications due to connected stand-by.</para>
    </remarks>
    <seealso cref="CoCreateInstanceEx" />
    <seealso cref="CoGetClassObject" />
    <seealso cref="IClassFactory.CreateInstance" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/instance-creation-helper-functions">Instance Creation Helper Functions</seealso>
  </member>
  <member name="Windows.CoCreateInstanceEx">
    <summary>
      <para>Creates an instance of a specific class on a specific computer.</para>
    </summary>
    <param name="Clsid">
      <para>The CLSID of the object to be created.</para>
    </param>
    <param name="punkOuter">
      <para>If this parameter non-<b>NULL</b>, indicates the instance is being created as part of an aggregate, and <i>punkOuter</i> is to be used as the new instance's controlling <see cref="IUnknown" />. Aggregation is currently not supported cross-process or cross-computer. When instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if <i>punkOuter</i> is non-<b>NULL</b>.</para>
    </param>
    <param name="dwClsCtx">
      <para>A value from the <see cref="CLSCTX" /> enumeration.</para>
    </param>
    <param name="pServerInfo">
      <para>Information about the computer on which to instantiate the object. See <see cref="COSERVERINFO" />. This parameter can be <b>NULL</b>, in which case the object is instantiated on the local computer or at the computer specified in the registry under the class's <a href="https://docs.microsoft.com//windows/desktop/com/remoteservername">RemoteServerName</a> value, according to the interpretation of the <i>dwClsCtx</i> parameter.</para>
    </param>
    <param name="dwCount">
      <para>The number of structures in <i>pResults</i>. This value must be greater than 0.</para>
    </param>
    <param name="pResults">
      <para>An array of <see cref="MULTI_QI" /> structures. Each structure has three members: the identifier for a requested interface (<b>pIID</b>), the location to return the interface pointer (<b>pItf</b>) and the return value of the call to <see cref="QueryInterface" /> (<b>hr</b>).</para>
    </param>
    <returns>
      <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Indicates success.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_CLASSNOTREG</b>
            </para>
          </description>
          <description>
            <para>A specified class is not registered in the registration database. Also can indicate that the type of server you requested in the <see cref="CLSCTX" /> enumeration is not registered or the values for the server types in the registry are corrupt.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CLASS_E_NOAGGREGATION</b>
            </para>
          </description>
          <description>
            <para>This class cannot be created as part of an aggregate.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_S_NOTALLINTERFACES</b>
            </para>
          </description>
          <description>
            <para>At least one, but not all of the interfaces requested in the <i>pResults</i> array were successfully retrieved. The <b>hr</b> member of each of the <see cref="MULTI_QI" /> structures in <i>pResults</i> indicates with S_OK or E_NOINTERFACE whether the specific interface was returned.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_NOINTERFACE</b>
            </para>
          </description>
          <description>
            <para>None of the interfaces requested in the <i>pResults</i> array were successfully retrieved.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>CoCreateInstanceEx</b> creates a single uninitialized object associated with the given CLSID on a specified remote computer. This is an extension of the function <see cref="CoCreateInstance" />, which creates an object on the local computer only. In addition, rather than requesting a single interface and obtaining a single pointer to that interface, <b>CoCreateInstanceEx</b> makes it possible to specify an array of structures, each pointing to an interface identifier (IID) on input, and, on return, containing (if available) a pointer to the requested interface and the return value of the <see cref="QueryInterface" /> call for that interface. This permits fewer round trips between computers.</para>
      <para>This function encapsulates three calls: first, to <see cref="CoGetClassObject" /> to connect to the class object associated with the specified CLSID, specifying the location of the class; second, to <see cref="IClassFactory.CreateInstance" /> to create an uninitialized instance, and finally, to <see cref="IClassFactory.Release" />, to release the class object.</para>
      <para>The object so created must still be initialized through a call to one of the initialization interfaces (such as <see cref="IPersistStorage.Load" />). Two functions, <see cref="CoGetInstanceFromFile" /> and <see cref="CoGetInstanceFromIStorage" /> encapsulate both the instance creation and initialization from the obvious sources.</para>
      <para>The <see cref="COSERVERINFO" /> structure passed as the <i>pServerInfo</i> parameter contains the security settings that COM will use when creating a new instance of the specified object. Note that this parameter does not influence the security settings used when making method calls on the instantiated object. Those security settings are configurable, on a per-interface basis, with the <see cref="CoSetProxyBlanket" /> function. Also see, <see cref="IClientSecurity.SetBlanket" />.</para>
    </remarks>
    <seealso cref="CoGetInstanceFromFile" />
    <seealso cref="CoGetInstanceFromIStorage" />
  </member>
  <member name="Windows.CoCreateInstanceFromApp">
    <summary>
      <para>Creates an instance of a specific class on a specific computer from within an app container.</para>
    </summary>
    <param name="Clsid">
      <para>The CLSID of the object to be created.</para>
    </param>
    <param name="punkOuter">
      <para>If this parameter non-<b>NULL</b>, indicates the instance is being created as part of an aggregate, and <i>punkOuter</i> is to be used as the new instance's controlling <see cref="IUnknown" />. Aggregation is currently not supported cross-process or cross-computer. When instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if <i>punkOuter</i> is non-<b>NULL</b>.</para>
    </param>
    <param name="dwClsCtx">
      <para>A value from the <see cref="CLSCTX" /> enumeration.</para>
    </param>
    <param name="reserved">
      <para>Reserved for future use.</para>
    </param>
    <param name="dwCount">
      <para>The number of structures in <i>pResults</i>. This value must be greater than 0.</para>
    </param>
    <param name="pResults">
      <para>An array of <see cref="MULTI_QI" /> structures. Each structure has three members: the identifier for a requested interface (<b>pIID</b>), the location to return the interface pointer (<b>pItf</b>) and the return value of the call to <see cref="QueryInterface" /> (<b>hr</b>).</para>
    </param>
    <returns>
      <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Indicates success.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_CLASSNOTREG</b>
            </para>
          </description>
          <description>
            <para>A specified class is not registered in the registration database, or the class is not supported in the app container. Also can indicate that the type of server you requested in the <see cref="CLSCTX" /> enumeration is not registered or the values for the server types in the registry are corrupt.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CLASS_E_NOAGGREGATION</b>
            </para>
          </description>
          <description>
            <para>This class cannot be created as part of an aggregate.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_S_NOTALLINTERFACES</b>
            </para>
          </description>
          <description>
            <para>At least one, but not all of the interfaces requested in the <i>pResults</i> array were successfully retrieved. The <b>hr</b> member of each of the <see cref="MULTI_QI" /> structures in <i>pResults</i> indicates with S_OK or E_NOINTERFACE whether the specific interface was returned.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_NOINTERFACE</b>
            </para>
          </description>
          <description>
            <para>None of the interfaces requested in the <i>pResults</i> array were successfully retrieved.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CoCreateInstanceFromApp</b> function is the same as the  <see cref="CoCreateInstanceEx" /> function, with the following differences.</para>
      <list type="bullet">
        <item>
          <description>The <b>CoCreateInstanceFromApp</b> function reads class registrations only from application contexts, and from the HKLM\SOFTWARE\Classes\CLSID registry hive.</description>
        </item>
        <item>
          <description>Only built-in classes that are supported in the app container are supplied. Attempts to activate unsupported classes, including all classes installed by 3rd-party code as well as many Windows classes, result in error code <b>REGDB_E_CLASSNOTREG</b>.</description>
        </item>
        <item>
          <description>The <b>CoCreateInstanceFromApp</b> function is available to Windows Store apps. Desktop applications can call this function, but they have the same restrictions as Windows Store apps.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="CoCreateInstanceEx" />
    <seealso href="https://docs.microsoft.com//dotnet/framework/unmanaged-api/fusion/index">Fusion (Unmanaged API Reference)</seealso>
  </member>
  <member name="Windows.CoDecodeProxy">
    <summary>
      <para>Locates the implementation of a Component Object Model (COM) interface in a server process given an  interface to a proxied object.</para>
    </summary>
    <param name="dwClientPid">
      <para>The process ID of the process that contains the proxy.</para>
    </param>
    <param name="ui64ProxyAddress">
      <para>The address of an interface on a proxy to the object.  <i>ui64ProxyAddress</i> is considered a 64-bit value type, rather than a pointer  to a 64-bit value, and isn't a pointer to an object in the debugger process. Instead, this address is passed to the <see cref="ReadProcessMemory" /> function.</para>
    </param>
    <param name="pServerInformation">
      <para>A structure that contains the process ID, the thread ID, and the address of the server.</para>
    </param>
    <returns>
      <para>This function can return one of these values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The server information was successfully retrieved.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>The caller is an app container, or the developer license is not installed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_E_INVALID_IPID</b>
            </para>
          </description>
          <description>
            <i>ui64ProxyAddress</i> does not point to a proxy.
</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CoDecodeProxy</b> function is a COM API that enables native debuggers to locate the implementation of a COM interface in a server process given an interface on a proxy to the object.</para>
      <para>Also, the <b>CoDecodeProxy</b> function enables the debugger to monitor cross-apartment function calls and fail such calls when appropriate.</para>
      <para>You can call the <b>CoDecodeProxy</b> function from a 32-bit or 64-bit process. <i>ui64ProxyAddress</i> can be a 32-bit or 64-bit address. The <b>CoDecodeProxy</b> function returns a 32-bit or 64-bit address in the <i>pServerInformation</i> field. If it returns a 64-bit address, you should pass the address to the <see cref="ReadProcessMemory" /> function only from a 64-bit process.</para>
    </remarks>
    <seealso cref="ReadProcessMemory" />
    <seealso cref="ServerInformation" />
  </member>
  <member name="Windows.CoDecrementMTAUsage">
    <summary>
      <para>Releases the increment made by a previous call to the <see cref="CoIncrementMTAUsage" /> function.</para>
    </summary>
    <param name="Cookie">
      <para>A <b>PVOID</b> variable that was set by a previous call to the <see cref="CoIncrementMTAUsage" /> function.</para>
    </param>
    <returns>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>
        <i>Cookie</i> must be a valid value returned by a successful previous call to the  <see cref="CoIncrementMTAUsage" /> function. If the overall count of MTA usage reaches 0, including both through this API and through the <see cref="CoInitializeEx" /> and <see cref="CoUninitialize" /> functions, the system frees resources related to MTA support.</para>
      <para>You can call <see cref="CoIncrementMTAUsage" /> from one thread and <b>CoDecrementMTAUsage</b> from another as long as a cookie previously returned by <b>CoIncrementMTAUsage</b> is passed to <b>CoDecrementMTAUsage</b>.</para>
      <para>Don't call <b>CoDecrementMTAUsage</b> during process shutdown or inside dllmain. You can call <b>CoDecrementMTAUsage</b> before the call to start the shutdown process.</para>
    </remarks>
    <seealso cref="CoIncrementMTAUsage" />
  </member>
  <member name="Windows.CoDisableCallCancellation">
    <summary>
      <para>Undoes the action of a call to <see cref="CoEnableCallCancellation" />. Disables cancellation of synchronous calls on the calling thread when all calls to <b>CoEnableCallCancellation</b> are balanced by calls to <b>CoDisableCallCancellation</b>.</para>
    </summary>
    <param name="pReserved">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Call cancellation was successfully disabled on the thread.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_CANCEL_DISABLED</b>
            </para>
          </description>
          <description>
            <para>There have been more successful calls to <see cref="CoEnableCallCancellation" /> on the thread than there have been calls to <see cref="CoDisableCallCancellation" />. Cancellation is still enabled on the thread.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>When call cancellation is enabled on a thread, marshaled synchronous calls from that thread to objects on the same computer can suffer serious performance degradation. By default, then, synchronous calls cannot be canceled, even if a cancel object is available. To enable call cancellation, you must call <see cref="CoEnableCallCancellation" /> first.</para>
      <para>When call cancellation is disabled, attempts to gain a pointer to a call object will fail. If the calling thread already has a pointer to a call object, calls on that object will fail.</para>
      <para>Unless you want to enable call cancellation on a thread at all times, you should pair calls to <see cref="CoEnableCallCancellation" /> with calls to <b>CoDisableCallCancellation</b>. Call cancellation is disabled only if each successful call to <b>CoEnableCallCancellation</b> is balanced by a successful call to <b>CoDisableCallCancellation</b>.</para>
      <para>A call will be cancelable or not depending on the state of the thread at the time the call was made. Subsequently enabling or disabling call cancellation has no effect on any calls that are pending on the thread.</para>
      <para>If a thread is uninitialized and then reinitialized by calls to <see cref="CoUninitialize" /> and <see cref="CoInitialize" />, call cancellation is disabled on the thread, even if it was enabled when the thread was uninitialized.</para>
    </remarks>
    <seealso cref="CoEnableCallCancellation" />
    <seealso cref="ICancelMethodCalls" />
  </member>
  <member name="Windows.CoDisconnectContext">
    <summary>
      <para>Disconnects all proxy connections that are being maintained on behalf of all interface pointers that point to objects in the current context.</para>
      <para>This function blocks connections until all objects are successfully disconnected or the time-out expires. Only the context that actually manages the objects should call <b>CoDisconnectContext</b>.</para>
    </summary>
    <param name="dwTimeout">
      <para>The time in milliseconds after which <b>CoDisconnectContext</b> returns even if the proxy connections for all objects have not been disconnected. INFINITE is an acceptable value for this parameter.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_FAIL, E_INVALIDARG, and E_OUTOFMEMORY, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The proxy connections for all objects were successfully disconnected.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_E_TIMEOUT</b>
            </para>
          </description>
          <description>
            <para>Not all proxy connections were successfully deleted in the time specified in <i>dwTimeout</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_NOTSUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The current context cannot be disconnected.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CONTEXT_E_WOULD_DEADLOCK</b>
            </para>
          </description>
          <description>
            <para>An object tried to call <see cref="CoDisconnectContext" /> on the context it is residing in. This would cause the function to time-out and deadlock if <i>dwTimeout</i> were set to INFINITE.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CoDisconnectContext</b> function is used to support unloading services in shared service hosts where you must unload your service's binaries without affecting other COM servers that are running in the same process. If you control the process lifetime and you do not unload until the process exits, the COM infrastructure will perform the necessary cleanup automatically and you do not have to call this function.</para>
      <para>The <b>CoDisconnectContext</b> function enables a server to correctly disconnect all external clients of all objects in the current context. Default contexts cannot be disconnected. To use <b>CoDisconnectContext</b>, you must first create a context that can be disconnected and register your class factories for objects from which you want to disconnect within that context. You can do this with the <see cref="IContextCallback" /> interface.</para>
      <para>If <b>CoDisconnectContext</b> returns RPC_E_TIMEOUT, this does not indicate that the function did not disconnect the objects, but that not all disconnections could be completed in the time specified by <i>dwTimeout</i> because of outstanding calls on the objects. All objects will be disconnected after all calls on them have been completed.</para>
      <para>It is not safe to unload the DLL that hosts the service until <b>CoDisconnectContext</b> returns S_OK. If the function returns RPC_E_TIMEOUT, the service may perform other clean-up. The service must call the function until it returns S_OK, and then it can safely unload its DLL.</para>
      <para>The <b>CoDisconnectContext</b> function performs the following tasks:</para>
      <list type="bullet">
        <item>
          <description>Calls <see cref="CoDisconnectObject" /> on all objects in the current context.</description>
        </item>
        <item>
          <description>Blocks until all objects have been disconnected or the time-out has expired.</description>
        </item>
      </list>
      <para>The <b>CoDisconnectContext</b> function has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>Asynchronous COM calls are not supported.</description>
        </item>
        <item>
          <description>In-process objects must be registered and enabled using the CLSCTX_LOCAL_SERVER flag, or they will not be disconnected.
</description>
        </item>
        <item>
          <description>COM+ is not supported.</description>
        </item>
        <item>
          <description>COM interface pointers are context-sensitive. Therefore, any interface pointer created in the context to be disconnected can only be used within that context.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <code>IContextCallback *icc;
hr = CoCreateInstance(CLSID_ContextSwitcher, NULL, CLSCTX_INPROC_SERVER, IID_IContextCallback, (void**)&amp;amp;amp;amp;amp;amp;icc);

icc-&gt;ContextCallback(EnterCallback, NULL, IID_IContextCallback, 5, NULL);

HRESULT __stdcall EnterCallback(ComCallData *pv)
{
    return CoRegisterClassObject(...);
}

/* All objects created by the class factories registered in the callback will be put into the newly created context.
To disconnect, re-enter the context, revoke the class factories, and call CoDisconnectContext. */

icc-&gt;ContextCallback(DisconnectCallback, NULL, IID_IContextCallback, 5, NULL);

HRESULT __stdcall DisconnectCallback(ComCallData *pv)
{
    CoRevokeClassObject(...);
    return CoDisconnectContext(timeout);
}


</code>
    </remarks>
    <seealso cref="CoDisconnectObject" />
    <seealso cref="IContextCallback" />
  </member>
  <member name="Windows.CoDisconnectObject">
    <summary>
      <para>Disconnects all remote process connections being maintained on behalf of all the interface pointers that point to a specified object.</para>
      <para>Only the process that actually manages the object should call <b>CoDisconnectObject</b>.</para>
    </summary>
    <param name="pUnk">
      <para>A pointer to any interface derived from <see cref="IUnknown" /> on the object to be disconnected.</para>
    </param>
    <param name="dwReserved">
      <para>This parameter is reserved and must be 0.</para>
    </param>
    <returns>
      <para>This function returns S_OK to indicate that all connections to remote processes were successfully deleted.</para>
    </returns>
    <remarks>
      <para>The <b>CoDisconnectObject</b> function enables a server to correctly disconnect all external clients to the object specified by <i>pUnk</i>.</para>
      <para>It performs the following tasks:</para>
      <list type="number">
        <item>
          <description>Checks to see whether the object to be disconnected implements the <see cref="IMarshal" /> interface. If so, it gets the pointer to that interface; if not, it gets a pointer to the standard marshaler's (i.e., COM's) <b>IMarshal</b> implementation.</description>
        </item>
        <item>
          <description>Using whichever <see cref="IMarshal" /> interface pointer it has acquired, the function then calls <see cref="IMarshal.DisconnectObject" /> to disconnect all out-of-process clients.</description>
        </item>
      </list>
      <para>An object's client does not call <b>CoDisconnectObject</b> to disconnect itself from the server (clients should use <see cref="IUnknown.Release" /> for this purpose). Rather, an OLE server calls <b>CoDisconnectObject</b> to forcibly disconnect an object's clients, usually in response to a user closing the server application.</para>
      <para>Similarly, an OLE container that supports external links to its embedded objects can call <b>CoDisconnectObject</b> to destroy those links. Again, this call is normally made in response to a user closing the application. The container should first call <see cref="IOleObject.Close" /> for all its OLE objects, each of which should send <see cref="IAdviseSink.OnClose" /> notifications to their various clients. Then the container can call <b>CoDisconnectObject</b> to close any existing connections.</para>
      <para>
        <b>CoDisconnectObject</b> does not necessarily disconnect out-of-process clients immediately. If any marshaled calls are pending on the server object, <b>CoDisconnectObject</b> disconnects the object only when those calls have returned. In the meantime, <b>CoDisconnectObject</b> sets a flag that causes any new marshaled calls to return CO_E_OBJNOTCONNECTED.</para>
    </remarks>
    <seealso cref="IAdviseSink.OnClose" />
    <seealso cref="IMarshal.DisconnectObject" />
    <seealso cref="IOleObject.Close" />
  </member>
  <member name="Windows.CoEnableCallCancellation">
    <summary>
      <para>Enables cancellation of synchronous calls on the calling thread.</para>
    </summary>
    <param name="pReserved">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>This function can return the standard return values S_OK, E_FAIL, E_INVALIDARG, and E_OUTOFMEMORY.</para>
    </returns>
    <remarks>
      <para>When call cancellation is enabled on a thread, marshaled synchronous calls from that thread to objects on the same computer can suffer serious performance degradation. By default, synchronous calls cannot be canceled, even if a cancel object is available. To enable call cancellation, you must call <b>CoEnableCallCancellation</b> first.</para>
      <para>Unless you want to enable call cancellation on a thread at all times, you should pair calls to <b>CoEnableCallCancellation</b> with calls to <see cref="CoDisableCallCancellation" />. Call cancellation is disabled only if <b>CoDisableCallCancellation</b> has been called once for each time <b>CoEnableCallCancellation</b> was called successfully.</para>
      <para>A call will be cancelable or not depending on the state of the thread at the time the call was made. Subsequently enabling or disabling call cancellation has no effect on any calls that are pending on the thread.</para>
    </remarks>
    <seealso cref="CoEnableCallCancellation" />
    <seealso cref="ICancelMethodCalls" />
  </member>
  <member name="Windows.CoFileTimeNow">
    <summary>
      <para>Returns the current time as a <see cref="FILETIME" /> structure.
<b>Note</b>  This function is provided for compatibility with 16-bit Windows.</para>
    </summary>
    <param name="lpFileTime">
      <para>A pointer to the <see cref="FILETIME" /> structure that receives the current time.</para>
    </param>
    <returns>
      <para>This function returns S_OK to indicate success.</para>
    </returns>
    <seealso cref="CoDosDateTimeToFileTime" />
    <seealso cref="CoFileTimeToDosDateTime" />
  </member>
  <member name="Windows.CoFreeUnusedLibraries">
    <summary>
      <para>Unloads any DLLs that are no longer in use, probably because the DLL no longer has any instantiated COM objects outstanding.
<b>Note</b>  This function is provided for compatibility with 16-bit Windows.</para>
    </summary>
    <remarks>
      <para>Applications can call <b>CoFreeUnusedLibraries</b> periodically to free resources. It is most efficient to call it either at the top of a message loop or in some idle-time task. <b>CoFreeUnusedLibraries</b> internally calls <see cref="DllCanUnloadNow" /> for DLLs that implement and export that function.</para>
    </remarks>
    <seealso cref="CoFreeAllLibraries" />
    <seealso cref="CoFreeLibrary" />
    <seealso cref="CoFreeUnusedLibrariesEx" />
    <seealso cref="CoLoadLibrary" />
  </member>
  <member name="Windows.CoFreeUnusedLibrariesEx">
    <summary>
      <para>Unloads any DLLs that are no longer in use and whose unload delay has expired.</para>
    </summary>
    <param name="dwUnloadDelay">
      <para>The delay in milliseconds between the time that the DLL has stated it can be unloaded until it becomes a candidate to unload. Setting this parameter to INFINITE uses the system default delay (10 minutes). Setting this parameter to 0 forces the unloading of any DLLs without any delay.</para>
    </param>
    <param name="dwReserved">
      <para>This parameter is reserved and must be 0.</para>
    </param>
    <remarks>
      <para>COM supplies functions to reclaim memory held by DLLs containing components. The most commonly used function is <see cref="CoFreeUnusedLibraries" />. <b>CoFreeUnusedLibraries</b> does not immediately release DLLs that have no active object. There is a 10-minute delay for multithreaded apartments (MTAs) and neutral apartments (NAs). For single-threaded apartments (STAs), there is no delay.</para>
      <para>The 10-minute delay for <see cref="CoFreeUnusedLibraries" /> is to avoid multithread race conditions caused by unloading a component DLL. This default delay may be too long for many applications.</para>
      <para>COM maintains a list of active DLLs that have had components loaded for the apartments that can be hosted on the thread where this function is called. When <b>CoFreeUnusedLibrariesEx</b> is called, each DLL on that list has its <see cref="DllCanUnloadNow" /> function called. If <b>DllCanUnloadNow</b> returns S_FALSE (or is not exported), this DLL is not ready to be unloaded. If <b>DllCanUnloadNow</b> returns S_OK, this DLL is moved off the active list to a "candidate-for-unloading" list.</para>
      <para>Adding the DLL to the candidate-for-unloading list time-stamps the DLL <i>dwUnloadDelay</i> milliseconds from when this move occurs. When <b>CoFreeUnusedLibrariesEx</b> (or <see cref="CoFreeUnusedLibraries" />) is called again, at least <i>dwUnloadDelay</i> milliseconds from the call that moved the DLL to the candidate-for-unloading list, the DLL is actually freed from memory. If COM uses the component DLL while the DLL is on the candidate-for-unloading list, it is moved back to the active list.</para>
      <para>Setting <i>dwUnloadDelay</i> to 0 may have unexpected consequences. The component DLL may need some time for cleanup after it returns from the <see cref="DllCanUnloadNow" /> function. For example, if the DLL had its own worker threads, using a value of 0 would most likely lead to a problem because the code executing on these threads would be unmapped, caused by the unloading of the DLL before the worker threads have a chance to exit. Also, using too brief of a value for <i>dwUnloadDelay</i> can lead to performance issues because there is more overhead in reloading a DLL than letting it page out.</para>
      <para>This behavior is triggered by the DLL supplying components with threading models set to Free, Neutral, or Both. For a threading model set to Apartment (or if no threading model is specified), <i>dwUnloadDelay</i> is treated as 0 because these components are tied to the single thread hosting the apartment.</para>
    </remarks>
    <seealso cref="CoFreeAllLibraries" />
    <seealso cref="CoFreeLibrary" />
    <seealso cref="CoFreeUnusedLibraries" />
    <seealso cref="CoLoadLibrary" />
    <seealso cref="DllCanUnloadNow" />
  </member>
  <member name="Windows.CoGetCallContext">
    <summary>
      <para>Retrieves the context of the current call on the current thread.</para>
    </summary>
    <param name="riid">
      <para>Interface identifier (IID) of the call context that is being requested. If you are using the default call context supported by standard marshaling, IID_IServerSecurity is available. For COM+ applications using role-based security, IID_ISecurityCallContext is available.</para>
    </param>
    <param name="ppInterface">
      <para>Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *<i>ppInterface</i> contains the requested interface pointer.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The context was retrieved successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_NOINTERFACE</b>
            </para>
          </description>
          <description>
            <para>The call context does not support the interface specified by <i>riid</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>CoGetCallContext</b> retrieves the context of the current call on the current thread. The <i>riid</i> parameter specifies the interface on the context to be retrieved. This is one of the functions provided to give the server access to any contextual information of the caller.</para>
    </remarks>
    <seealso cref="IServerSecurity" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/security-in-com">Security in COM</seealso>
  </member>
  <member name="Windows.CoGetCallerTID">
    <summary>
      <para>Returns a pointer to a <b>DWORD</b> that contains the apartment ID of the caller's thread.</para>
    </summary>
    <param name="lpdwTID">
      <para>Receives the apartment ID of the caller's thread. For a single threaded apartment (STA), this is the current thread ID. For a multithreaded apartment (MTA), the value is 0.  For a neutral apartment (NA), the value is -1.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_TRUE</b>
            </para>
          </description>
          <description>
            <para>The caller's thread ID is set and the caller is in the same process.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>The caller's thread ID is set and the caller is in a different process.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_OUTOFMEMORY</b>
            </para>
          </description>
          <description>
            <para>The caller's thread ID was not set.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the caller is not running on the same computer, this function does not return the apartment ID and the return value is S_FALSE.</para>
      <para>There is no guarantee that the information returned from this API is not tampered with, so do not use the ID that is returned to make security decisions. The ID can only be used for logging and diagnostic purposes.</para>
    </remarks>
  </member>
  <member name="Windows.CoGetCancelObject">
    <summary>
      <para>Obtains a pointer to a call control interface, normally <see cref="ICancelMethodCalls" />, on the cancel object corresponding to an outbound COM method call pending on the same or another client thread.</para>
    </summary>
    <param name="dwThreadId">
      <para>The identifier of the thread on which the pending COM call is to be canceled. If this parameter is 0, the call is on the current thread.</para>
    </param>
    <param name="iid">
      <para>The globally unique identifier of an interface on the cancel object for the call to be canceled. This argument is usually IID_ICancelMethodCalls.</para>
    </param>
    <param name="ppUnk">
      <para>Receives the address of a pointer to the interface specified by <i>riid</i>.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The call control object was retrieved successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_NOINTERFACE</b>
            </para>
          </description>
          <description>
            <para>The object on which the call is executing does not support the interface specified by <i>riid</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If two or more calls are pending on the same thread through nested calls, the thread ID may not be sufficient to identify the call to be canceled. In this case, <b>CoGetCancelObject</b> returns a cancel interface corresponding to the innermost call that is pending on the thread and has registered a cancel object.</para>
      <para>This function does not locate cancel objects for asynchronous calls.</para>
    </remarks>
  </member>
  <member name="Windows.CoGetClassObject">
    <summary>
      <para>Provides a pointer to an interface on a class object associated with a specified CLSID. <b>CoGetClassObject</b> locates, and if necessary, dynamically loads the executable code required to do this.</para>
      <para>Call <b>CoGetClassObject</b> directly to create multiple objects through a class object for which there is a CLSID in the system registry. You can also retrieve a class object from a specific remote computer. Most class objects implement the <see cref="IClassFactory" /> interface. You would then call <see cref="CreateInstance" /> to create an uninitialized object. It is not always necessary to go through this process however. To create a single object, call the <see cref="CoCreateInstanceEx" /> function, which allows you to create an instance on a remote machine. This replaces the <see cref="CoCreateInstance" /> function, which can still be used to create an instance on a local computer. Both functions encapsulate connecting to the class object, creating the instance, and releasing the class object. Two other functions, <see cref="CoGetInstanceFromFile" /> and <see cref="CoGetInstanceFromIStorage" />, provide both instance creation on a remote system and object activation. There are numerous functions and interface methods whose purpose is to create objects of a single type and provide a pointer to an interface on that object.</para>
    </summary>
    <param name="rclsid">
      <para>The CLSID associated with the data and code that you will use to create the objects.</para>
    </param>
    <param name="dwClsContext">
      <para>The context in which the executable code is to be run. To enable a remote activation, include CLSCTX_REMOTE_SERVER. For more information on the context values and their use, see the <see cref="CLSCTX" /> enumeration.</para>
    </param>
    <param name="pvReserved">
      <para>A pointer to computer on which to instantiate the class object. If this parameter is <b>NULL</b>, the class object is instantiated on the current computer or at the computer specified under the class's <a href="https://docs.microsoft.com//windows/desktop/com/remoteservername">RemoteServerName</a> key, according to the interpretation of the <i>dwClsCtx</i> parameter. See <see cref="COSERVERINFO" />.</para>
    </param>
    <param name="riid">
      <para>Reference to the identifier of the interface, which will be supplied in <i>ppv</i> on successful return. This interface will be used to communicate with the class object. Typically this value is IID_IClassFactory, although other values such as IID_IClassFactory2 which supports a form of licensing are allowed. All OLE-defined interface IIDs are defined in the OLE header files as IID_interfacename, where interfacename is the name of the interface.</para>
    </param>
    <param name="ppv">
      <para>The address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful return, *<i>ppv</i> contains the requested interface pointer.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Location and connection to the specified class object was successful.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_CLASSNOTREG</b>
            </para>
          </description>
          <description>
            <para>The CLSID is not properly registered. This error can also indicate that the value you specified in <i>dwClsContext</i> is not in the registry.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>E_NOINTERFACE
</b>
                </description>
              </item>
            </list>
          </description>
          <description>
            <para>Either the object pointed to by <i>ppv</i> does not support the interface identified by <i>riid</i>, or the <see cref="QueryInterface" /> operation on the class object returned E_NOINTERFACE.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_READREGDB</b>
            </para>
          </description>
          <description>
            <para>There was an error reading the registration database.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_DLLNOTFOUND</b>
            </para>
          </description>
          <description>
            <para>Either the in-process DLL or handler DLL was not found (depending  on the context).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_APPNOTFOUND</b>
            </para>
          </description>
          <description>
            <para>The executable (.exe) was not found (CLSCTX_LOCAL_SERVER only).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>There was a general access failure on load.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_ERRORINDLL</b>
            </para>
          </description>
          <description>
            <para>There is an error in the executable image.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_APPDIDNTREG</b>
            </para>
          </description>
          <description>
            <para>The executable was launched, but it did not register the class object (and it may have shut down).</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>A class object in OLE is an intermediate object that supports an interface that permits operations common to a group of objects. The objects in this group are instances derived from the same object definition represented by a single CLSID. Usually, the interface implemented on a class object is <a href="https://docs.microsoft.com//windows/desktop/com/implementing-iclassfactory">IClassFactory</a>, through which you can create object instances of a given definition (class).</para>
      <para>A call to <b>CoGetClassObject</b> creates, initializes, and gives the caller access (through a pointer to an interface specified with the <i>riid</i> parameter) to the class object. The class object is the one associated with the CLSID that you specify in the <i>rclsid</i> parameter. The details of how the system locates the associated code and data within a computer are transparent to the caller, as is the dynamic loading of any code that is not already loaded.</para>
      <para>If the class context is CLSCTX_REMOTE_SERVER, indicating remote activation is required, the <see cref="COSERVERINFO" /> structure provided in the <i>pServerInfo</i> parameter allows you to specify the computer on which the server is located. For information on the algorithm used to locate a remote server when <i>pServerInfo</i> is <b>NULL</b>, refer to the <see cref="CLSCTX" /> enumeration.</para>
      <para>There are two places to find a CLSID for a class:</para>
      <list type="bullet">
        <item>
          <description>The registry holds an association between CLSIDs and file suffixes, and between CLSIDs and file signatures for determining the class of an object.</description>
        </item>
        <item>
          <description>When an object is saved to persistent storage, its CLSID is stored with its data.</description>
        </item>
      </list>
      <para>To create and initialize embedded or linked OLE document objects, it is not necessary to call <b>CoGetClassObject</b> directly. Instead, call the <see cref="OleCreate" /> or <b>OleCreate</b><i>XXX</i> function. These functions encapsulate the entire object instantiation and initialization process, and call, among other functions, <b>CoGetClassObject</b>.</para>
      <para>The <i>riid</i> parameter specifies the interface the client will use to communicate with the class object. In most cases, this interface is <a href="https://docs.microsoft.com//windows/desktop/com/implementing-iclassfactory">IClassFactory</a>. This provides access to the <see cref="CreateInstance" /> method, through which the caller can then create an uninitialized object of the kind specified in its implementation. All classes registered in the system with a CLSID must implement <see cref="IClassFactory" />.</para>
      <para>In rare cases, however, you may want to specify some other interface that defines operations common to a set of objects. For example, in the way OLE implements monikers, the interface on the class object is <see cref="IParseDisplayName" />, used to transform the display name of an object into a moniker.</para>
      <para>The <i>dwClsContext</i> parameter specifies the execution context, allowing one CLSID to be associated with different pieces of code in different execution contexts. The <see cref="CLSCTX" /> enumeration specifies the available context flags. <b>CoGetClassObject</b> consults (as appropriate for the context indicated) both the registry and the class objects that are currently registered by calling the <see cref="CoRegisterClassObject" /> function.</para>
      <para>To release a class object, use the class object's <see cref="Release" /> method. The function <see cref="CoRevokeClassObject" /> is to be used only to remove a class object's CLSID from the system registry.</para>
    </remarks>
    <seealso cref="CLSCTX" />
    <seealso cref="COSERVERINFO" />
    <seealso cref="CoCreateInstanceEx" />
    <seealso cref="CoRegisterClassObject" />
    <seealso cref="CoRevokeClassObject" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/creating-an-object-through-a-class-object">Creating an Object Through a Class Object</seealso>
    <seealso cref="OleCreate" />
    <seealso cref="OleLoad" />
  </member>
  <member name="Windows.CoGetContextToken">
    <summary>
      <para>Returns a pointer to an implementation of <see cref="IObjContext" /> for the current context.</para>
    </summary>
    <param name="pToken">
      <para>A pointer to an implementation of <see cref="IObjContext" /> for the current context.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The token was retrieved successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The caller did not pass a valid token pointer variable.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_NOTINITIALIZED</b>
            </para>
          </description>
          <description>
            <para>The caller is not in an initialized apartment.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso cref="IContext" />
    <seealso cref="IObjContext" />
  </member>
  <member name="Windows.CoGetCurrentLogicalThreadId">
    <summary>
      <para>Returns the logical thread identifier of the current physical thread.</para>
    </summary>
    <param name="pguid">
      <para>A pointer to a GUID that contains the logical thread ID on return.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The logical thread ID was retrieved successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>An invalid pointer was passed in for the <i>pguid</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_OUTOFMEMORY</b>
            </para>
          </description>
          <description>
            <para>A memory allocation failed during the operation of the function.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function retrieves the identifier of the current logical thread under which this physical thread is operating. The current physical thread takes on the logical thread identifier of any client thread that makes a COM call into this application. Similarly, the logical thread identifier of the current physical thread is used to denote the causality for outgoing COM calls from this physical thread.</para>
    </remarks>
  </member>
  <member name="Windows.CoGetCurrentProcess">
    <summary>
      <para>Returns a value that is unique to the current thread. <b>CoGetCurrentProcess</b> can be used to avoid thread ID reuse problems.</para>
    </summary>
    <returns>
      <para>The function returns the unique identifier of the current thread.</para>
    </returns>
    <remarks>
      <para>Using the value returned from a call to <b>CoGetCurrentProcess</b> can help you in maintaining tables that are keyed by threads or in uniquely identifying a thread to other threads or processes.</para>
      <para>
        <b>CoGetCurrentProcess</b> returns a value that is effectively unique, because it is not used again until 2³² more threads have been created on the current workstation or until the workstation is restarted.</para>
      <para>The value returned by <b>CoGetCurrentProcess</b> will uniquely identify the same thread for the life of the caller. Because thread IDs can be reused without notice as threads are created and destroyed, this value is more reliable than the value returned by the <see cref="GetCurrentThreadId" /> function.</para>
    </remarks>
  </member>
  <member name="Windows.CoGetDefaultContext">
    <summary>
      <para>Retrieves a reference to the default context of the specified apartment.</para>
    </summary>
    <param name="aptType">
      <para>The apartment type of the default context that is being requested. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>APTTYPE_CURRENT</b>
                </description>
              </item>
              <item>
                <description>-1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The caller's apartment.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>APTTYPE_MTA</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The multithreaded apartment for the current process.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>APTTYPE_NA</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The neutral apartment for the current process.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>APTTYPE_MAINSTA</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The main single-threaded apartment for the current process.</para>
          </description>
        </item>
      </list>
      <para>The <see cref="APTTYPE" /> value APTTYPE_STA (0) is not supported. A process can contain multiple single-threaded apartments, each with its own context, so <b>CoGetDefaultContext</b> could not determine which STA is of interest. Therefore, this function returns E_INVALIDARG if APTTYPE_STA is specified.</para>
    </param>
    <param name="riid">
      <para>The interface identifier (IID) of the interface that is being requested on the default context. Typically, the caller requests IID_IObjectContext. The default context does not support all of the normal object context interfaces.</para>
    </param>
    <param name="ppv">
      <para>A reference to the interface specified by riid on the default context. If the object's component is non-configured, (that is, the object's component has not been imported into a COM+ application), or if the <b>CoGetDefaultContext</b> function is called from a constructor or an <see cref="IUnknown" /> method, this parameter is set to a <b>NULL</b> pointer.</para>
    </param>
    <returns>
      <para>This method can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The method completed successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_NOTINITIALIZED</b>
            </para>
          </description>
          <description>
            <para>The caller is not in an initialized apartment.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_NOINTERFACE</b>
            </para>
          </description>
          <description>
            <para>The object context does not support the interface specified by <i>riid</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Every COM apartment has a special context called the default context. A default context is different from all the other, non-default contexts in an apartment because it does not provide runtime services. It does not support all of the normal object context interfaces.</para>
      <para>The default context is also used by instances of non-configured COM components, (that is, components that have not been part of a COM+ application), when they are created from an apartment that does not support their threading model. In other words, if a COM object creates an instance of a non-configured component and the new object cannot be added to its creator's context because of its threading model, the new object is instead added to the default context of an apartment that supports its threading model.</para>
      <para>An object should never pass an <see cref="IObjectContext" /> reference to another object. If you pass an <b>IObjectContext</b> reference to another object, it is no longer a valid reference.</para>
      <para>When an object obtains a reference to an <see cref="IObjectContext" />, it must release the <b>IObjectContext</b> object when it is finished with it.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/cossdk/com--contexts-and-threading-models">COM+ Contexts and Threading Models</seealso>
  </member>
  <member name="Windows.CoGetMalloc">
    <summary>
      <para>Retrieves a pointer to the default OLE task memory allocator (which supports the system implementation of the <see cref="IMalloc" /> interface) so applications can call its methods to manage memory.</para>
    </summary>
    <param name="dwMemContext">
      <para>This parameter must be 1.</para>
    </param>
    <param name="ppMalloc">
      <para>The address of an <b>IMalloc*</b> pointer variable that receives the interface pointer to the memory allocator.</para>
    </param>
    <returns>
      <para>This function can return the standard return values S_OK, E_INVALIDARG, and E_OUTOFMEMORY.</para>
    </returns>
    <remarks>
      <para>The pointer to the <see cref="IMalloc" /> interface pointer received through the <i>ppMalloc</i> parameter cannot be used from a remote process; each process must have its own allocator.</para>
    </remarks>
    <seealso cref="CoTaskMemAlloc" />
    <seealso cref="IMalloc" />
  </member>
  <member name="Windows.CoGetMarshalSizeMax">
    <summary>
      <para>Returns an upper bound on the number of bytes needed to marshal the specified interface pointer to the specified object.</para>
    </summary>
    <param name="pulSize">
      <para>A pointer to the upper-bound value on the size, in bytes, of the data packet to be written to the marshaling stream. If this parameter is 0, the size of the packet is unknown.</para>
    </param>
    <param name="riid">
      <para>A reference to the identifier of the interface whose pointer is to be marshaled. This interface must be derived from the <see cref="IUnknown" /> interface.</para>
    </param>
    <param name="pUnk">
      <para>A pointer to the interface to be marshaled. This interface must be derived from the <see cref="IUnknown" /> interface.</para>
    </param>
    <param name="dwDestContext">
      <para>The destination context where the specified interface is to be unmarshaled. Values for <i>dwDestContext</i> come from the enumeration <see cref="MSHCTX" />.</para>
    </param>
    <param name="pvDestContext">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <param name="mshlflags">
      <para>Indicates whether the data to be marshaled is to be transmitted back to the client process the normal case or written to a global table, where it can be retrieved by multiple clients. Values come from the enumeration <see cref="MSHLFLAGS" />.</para>
    </param>
    <returns>
      <para>This function can return the standard return value E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The upper bound was returned successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_NOTINITIALIZED</b>
            </para>
          </description>
          <description>
            <para>Before this function can be called, either the <see cref="CoInitialize" /> or <see cref="OleInitialize" /> function must be called.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function performs the following tasks:</para>
      <list type="number">
        <item>
          <description>Queries the object for an <see cref="IMarshal" /> pointer or, if the object does not implement <b>IMarshal</b>, gets a pointer to COM's standard marshaler.
</description>
        </item>
        <item>
          <description>Using the pointer obtained in the preceding item, calls <see cref="IMarshal.GetMarshalSizeMax" />.
</description>
        </item>
        <item>
          <description>Adds to the value returned by the call to <see cref="GetMarshalSizeMax" /> the size of the marshaling data header and, possibly, that of the proxy CLSID to obtain the maximum size in bytes of the amount of data to be written to the marshaling stream.</description>
        </item>
      </list>
      <para>You do not explicitly call this function unless you are implementing <see cref="IMarshal" />, in which case your marshaling stub should call this function to get the correct size of the data packet to be marshaled.</para>
      <para>The value returned by this method is guaranteed to be valid only as long as the internal state of the object being marshaled does not change. Therefore, the actual marshaling should be done immediately after this function returns, or the stub runs the risk that the object, because of some change in state, might require more memory to marshal than it originally indicated.</para>
    </remarks>
    <seealso cref="CoMarshalInterface" />
    <seealso cref="IMarshal.GetMarshalSizeMax" />
  </member>
  <member name="Windows.CoGetObjectContext">
    <summary>
      <para>Returns the context for the current object.</para>
    </summary>
    <param name="riid">
      <para>A reference to the ID of an interface that is implemented on the context object.</para>
      <para>For objects running within COM applications, IID_IComThreadingInfo, IID_IContext, and IID_IContextCallback are available.</para>
      <para>For objects running within COM+ applications, IID_IObjectContext, IID_IObjectContextActivity IID_IObjectContextInfo, and IID_IContextState are available.</para>
    </param>
    <param name="ppv">
      <para>The address of a pointer to the interface specified by <i>riid</i> on the context object.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The object context was successfully retrieved.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_NOINTERFACE</b>
            </para>
          </description>
          <description>
            <para>The requested interface was not available.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_NOTINITIALIZED</b>
            </para>
          </description>
          <description>
            <para>Before this function can be called, the <see cref="CoInitializeEx" /> function must be called on the current thread.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>CoGetObjectContext</b> retrieves the context for the object from which it is called, and returns a pointer to an interface that can be used to manipulate context properties. Context properties are used to provide services to configured components running within COM+ applications.</para>
      <para>For components running within COM applications, the following interfaces are supported for accessing context properties: <see cref="IComThreadingInfo" />, <see cref="IContext" />, and <see cref="IContextCallback" />.</para>
      <para>For components running within COM+ applications, the following interfaces are supported for accessing context properties: <see cref="IObjectContext" />, <see cref="IObjectContextActivity" />, <see cref="IObjectContextInfo" />, and <see cref="IContextState" />.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/cossdk/com--contexts-and-threading-models">Contexts and Threading Models</seealso>
  </member>
  <member name="Windows.CoGetPSClsid">
    <summary>
      <para>Returns the CLSID of the DLL that implements the proxy and stub for the specified interface.</para>
    </summary>
    <param name="riid">
      <para>The interface whose proxy/stub CLSID is to be returned.</para>
    </param>
    <param name="pClsid">
      <para>Specifies where to store the proxy/stub CLSID for the interface specified by <i>riid</i>.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The proxy/stub CLSID was successfully returned.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_OUTOFMEMORY</b>
            </para>
          </description>
          <description>
            <para>There is insufficient memory to complete this operation.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CoGetPSClsid</b> function looks at the <b>HKEY_CLASSES_ROOT</b>\<b>Interfaces</b>\<i>{string form of riid}</i>\<b>ProxyStubClsid32</b> key in the registry to determine the CLSID of the DLL to load in order to create the proxy and stub for the interface specified by <i>riid</i>. This function also returns the CLSID for any interface IID registered by <see cref="CoRegisterPSClsid" /> within the current process.</para>
    </remarks>
    <seealso cref="CoRegisterPSClsid" />
  </member>
  <member name="Windows.CoGetStandardMarshal">
    <summary>
      <para>Creates a default, or standard, marshaling object in either the client process or the server process, depending on the caller, and returns a pointer to that object's <see cref="IMarshal" /> implementation.</para>
    </summary>
    <param name="riid">
      <para>A reference to the identifier of the interface whose pointer is to be marshaled. This interface must be derived from the <see cref="IUnknown" /> interface.</para>
    </param>
    <param name="pUnk">
      <para>A pointer to the interface to be marshaled.</para>
    </param>
    <param name="dwDestContext">
      <para>The destination context where the specified interface is to be unmarshaled. Values come from the enumeration <see cref="MSHCTX" />. Unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL).</para>
    </param>
    <param name="pvDestContext">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <param name="mshlflags">
      <para>Indicates whether the data to be marshaled is to be transmitted back to the client process (the normal case) or written to a global table where it can be retrieved by multiple clients. Values come from the <see cref="MSHLFLAGS" /> enumeration.</para>
    </param>
    <param name="ppMarshal">
      <para>The address of <b>IMarshal*</b> pointer variable that receives the interface pointer to the standard marshaler.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The <see cref="IMarshal" /> instance was returned successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_NOTINITIALIZED</b>
            </para>
          </description>
          <description>
            <para>Before this function can be called, the <see cref="CoInitialize" /> or <see cref="OleInitialize" /> function must be called on the current thread.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CoGetStandardMarshal</b> function creates a default, or standard, marshaling object in either the client process or the server process, as may be necessary, and returns that object's <see cref="IMarshal" /> pointer to the caller. If you implement <b>IMarshal</b>, you may want your implementation to call <b>CoGetStandardMarshal</b> as a way of delegating to COM's default implementation any destination contexts that you do not fully understand or want to handle. Otherwise, you can ignore this function, which COM calls as part of its internal marshaling procedures.</para>
      <para>When the COM library in the client process receives a marshaled interface pointer, it looks for a CLSID to be used in creating a proxy for the purposes of unmarshaling the packet. If the packet does not contain a CLSID for the proxy, COM calls <b>CoGetStandardMarshal</b>, passing a <b>NULL</b><i>pUnk</i> value. This function creates a standard proxy in the client process and returns a pointer to that proxy's implementation of <see cref="IMarshal" />. COM uses this pointer to call <see cref="CoUnmarshalInterface" /> to retrieve the pointer to the requested interface.</para>
      <para>If your OLE server application's implementation of <see cref="IMarshal" /> calls <b>CoGetStandardMarshal</b>, you should pass both the IID of (<i>riid</i>), and a pointer to (<i>pUnk</i>), the interface being requested.</para>
      <para>This function performs the following tasks:</para>
      <list type="number">
        <item>
          <description>Determines whether pUnk is <b>NULL</b>.</description>
        </item>
        <item>
          <description>If <i>pUnk</i> is <b>NULL</b>, creates a standard interface proxy in the client process for the specified <i>riid</i> and returns the proxy's <see cref="IMarshal" /> pointer.
</description>
        </item>
        <item>
          <description>If <i>pUnk</i> is not <b>NULL</b>, checks to see if a marshaler for the object already exists, creates a new one if necessary, and returns the marshaler's <see cref="IMarshal" /> pointer.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="IMarshal" />
  </member>
  <member name="Windows.CoGetStdMarshalEx">
    <summary>
      <para>Creates an aggregated standard marshaler for use with lightweight client-side handlers.</para>
    </summary>
    <param name="pUnkOuter">
      <para>A pointer to the controlling <see cref="IUnknown" />.</para>
    </param>
    <param name="smexflags">
      <para>One of two values indicating whether the aggregated standard marshaler is on the client side or the server side. These flags are defined in the <b>STDMSHLFLAGS</b> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SMEXF_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x01</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates a server-side aggregated standard marshaler.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SMEXF_HANDLER</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates a client-side (handler) aggregated standard marshaler.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="ppUnkInner">
      <para>On successful return, address of pointer to the <a href="https://docs.microsoft.com//windows/desktop/com/iunknown-and-interface-inheritance">IUnknown</a> interface on the newly-created aggregated standard marshaler. If an error occurs, this value is <b>NULL</b>.</para>
    </param>
    <returns>
      <para>This function returns S_OK.</para>
    </returns>
    <remarks>
      <para>The server calls <b>CoGetStdMarshalEx</b> passing in the flag SMEXF_SERVER. This creates a server side standard marshaler (known as a stub manager). The handler calls <b>CoGetStdMarshalEx</b> passing in the flag SMEXF_HANDLER. This creates a client side standard marshaler (known as a proxy manager). Note that when calling this function, the handler must pass the original controlling unknown that was passed to the handler when the handler was created. This will be the system implemented controlling unknown. Failure to pass the correct <see cref="IUnknown" /> results in an error returned. On success, the ppUnkInner returned is the controlling unknown of the inner object. The server and handler must keep this pointer, and may use it to call <see cref="IUnknown.QueryInterface" /> for the <see cref="IMarshal" /> interface.</para>
    </remarks>
    <seealso cref="IMarshal" />
    <seealso cref="IStdMarshalInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/the-lightweight-client-side-handler">The Lightweight Client-Side Handler</seealso>
  </member>
  <member name="Windows.CoGetTreatAsClass">
    <summary>
      <para>Returns the CLSID of an object that can emulate the specified object.</para>
    </summary>
    <param name="clsidOld">
      <para>The CLSID of the object that can be emulated (treated as) an object with a different CLSID.</para>
    </param>
    <param name="pClsidNew">
      <para>A pointer to where the CLSID that can emulate <i>clsidOld</i> objects is retrieved. This parameter cannot be <b>NULL</b>. If there is no emulation information for <i>clsidOld</i> objects, the <i>clsidOld</i> parameter is supplied.</para>
    </param>
    <returns>
      <para>This function can return the following values, as well as any error values returned by the <see cref="CLSIDFromString" /> function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A new CLSID was successfully returned.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>There is no emulation information for the <i>clsidOld</i> parameter, so the <i>pClsidNew</i> parameter is set to <i>clsidOld</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_READREGDB </b>
            </para>
          </description>
          <description>
            <para>There was an error reading the registry.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>CoGetTreatAsClass</b> returns the <a href="https://docs.microsoft.com//windows/desktop/com/treatas">TreatAs</a> entry in the registry for the specified object. The <b>TreatAs</b> entry, if set, is the CLSID of a registered object (an application) that can emulate the object in question. The <b>TreatAs</b> entry is set through a call to the <see cref="CoTreatAsClass" /> function. Emulation allows an application to open and edit an object of a different format, while retaining the original format of the object. Objects of the original CLSID are activated and treated as objects of the second CLSID. When the object is saved, this may result in loss of edits not supported by the original format. If there is no <b>TreatAs</b> entry for the specified object, this function returns the CLSID of the original object (<i>clsidOld</i>).</para>
    </remarks>
    <seealso cref="CoTreatAsClass" />
  </member>
  <member name="Windows.CoImpersonateClient">
    <summary>
      <para>Enables the server to impersonate the client of the current call for the duration of the call.</para>
    </summary>
    <returns>
      <para>This function supports the standard return values, including S_OK.</para>
    </returns>
    <remarks>
      <para>This method allows the server to impersonate the client of the current call for the duration of the call. If you do not call CoRevertToSelf, COM reverts automatically for you. This function will fail unless the object is being called with RPC_C_AUTHN_LEVEL_CONNECT or higher authentication in effect (which is any authentication level except RPC_C_AUTHN_LEVEL_NONE). This function encapsulates the following sequence of common calls (error handling excluded):</para>
      <code>    CoGetCallContext(IID_IServerSecurity, (void**)&amp;amp;amp;amp;amp;amp;amp;pss);
    pss-&gt;ImpersonateClient();
    pss-&gt;Release();

</code>
      <para>
        <b>CoImpersonateClient</b> encapsulates the process of getting a pointer to an instance of <see cref="IServerSecurity" /> that contains data about the current call, calling its <see cref="ImpersonateClient" /> method, and then releasing the pointer. One call to <see cref="CoRevertToSelf" /> (or <see cref="IServerSecurity.RevertToSelf" />) will undo any number of  calls to impersonate the client.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/com/cloaking">Cloaking</seealso>
    <seealso cref="IServerSecurity.ImpersonateClient" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/impersonation">Impersonation</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/com/impersonation-and-asynchronous-calls">Impersonation and Asynchronous Calls</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/com/security-in-com">Security in COM</seealso>
  </member>
  <member name="Windows.CoIncrementMTAUsage">
    <summary>
      <para>Keeps MTA support active when no MTA threads are running.</para>
    </summary>
    <param name="pCookie">
      <para>Address of a <b>PVOID</b> variable that receives the cookie for the <see cref="CoDecrementMTAUsage" /> function, or <b>NULL</b> if the call fails.</para>
    </param>
    <returns>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>The <b>CoIncrementMTAUsage</b> function enables clients to create MTA workers and wait on them for completion before exiting the process.</para>
      <para>The <b>CoIncrementMTAUsage</b> function ensures that the system doesn't free resources related to MTA support., even if the MTA thread count goes to 0.</para>
      <para>On success, call the <see cref="CoDecrementMTAUsage" /> once only. On failure, don't call the <b>CoDecrementMTAUsage</b> function.</para>
      <para>Don't call <b>CoIncrementMTAUsage</b> during process shutdown or inside dllmain. You can call <b>CoIncrementMTAUsage</b> before the call to start the shutdown process.</para>
      <para>You can call <b>CoIncrementMTAUsage</b> from one thread and <see cref="CoDecrementMTAUsage" /> from another as long as a cookie previously returned by <b>CoIncrementMTAUsage</b> is passed to <b>CoDecrementMTAUsage</b>.</para>
      <para>
        <b>CoIncrementMTAUsage</b> creates the MTA, if the MTA does not already exist. <b>CoIncrementMTAUsage</b> puts the current thread into the MTA, if the current thread is not already in an apartment</para>
      <para>You can use <b>CoIncrementMTAUsage</b> when:</para>
      <list type="bullet">
        <item>
          <description>You want a server to keep the MTA alive even when all worker threads are idle.</description>
        </item>
        <item>
          <description> Your API implementation requires COM to be initialized, but has no information about whether the current thread is already in an apartment, and does not need the current thread to go into a particular apartment. </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CoDecrementMTAUsage" />
  </member>
  <member name="Windows.CoInitializeEx">
    <summary>
      <para>Initializes the COM library for use by the calling thread, sets the thread's concurrency model, and creates a new apartment for the thread if one is required.</para>
      <para>You should call Windows.Foundation.Initialize to initialize the thread instead of <b>CoInitializeEx</b> if you want to use the Windows Runtime APIs or if you want to use both COM and Windows Runtime components. Windows.Foundation.Initialize is sufficient to use for COM components.</para>
    </summary>
    <param name="pvReserved">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <param name="dwCoInit">
      <para>The concurrency model and initialization options for the thread. Values for this parameter are taken from the <see cref="COINIT" /> enumeration. Any combination of values from <b>COINIT</b> can be used, except that the COINIT_APARTMENTTHREADED and COINIT_MULTITHREADED flags cannot both be set. The default is COINIT_MULTITHREADED.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The COM library was initialized successfully on this thread.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>The COM library is already initialized on this thread.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_E_CHANGED_MODE</b>
            </para>
          </description>
          <description>
            <para>A previous call to <see cref="CoInitializeEx" /> specified the concurrency model for this thread as multithread apartment (MTA). This could also indicate that a change from neutral-threaded apartment to single-threaded apartment has occurred.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>CoInitializeEx</b> must be called at least once, and is usually called only once, for each thread that uses the COM library. Multiple calls to <b>CoInitializeEx</b> by the same thread are allowed as long as they pass the same concurrency flag, but subsequent valid calls return S_FALSE. To close the COM library gracefully on a thread, each successful call to <see cref="CoInitialize" /> or <b>CoInitializeEx</b>, including any call that returns S_FALSE, must be balanced by a corresponding call to <see cref="CoUninitialize" />.</para>
      <para>You need to initialize the COM library on a thread before you call any of the library functions except <see cref="CoGetMalloc" />, to get a pointer to the standard allocator, and the memory allocation functions.</para>
      <para>Otherwise, the COM function will return CO_E_NOTINITIALIZED.</para>
      <para>After the concurrency model for a thread is set, it cannot be changed. A call to <see cref="CoInitialize" /> on an apartment that was previously initialized as multithreaded will fail and return RPC_E_CHANGED_MODE.</para>
      <para>Objects created in a single-threaded apartment (STA) receive method calls only from their apartment's thread, so calls are serialized and arrive only at message-queue boundaries (when the <see cref="PeekMessage" /> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function is called).</para>
      <para>Objects created on a COM thread in a multithread apartment (MTA) must be able to receive method calls from other threads at any time. You would typically implement some form of concurrency control in a multithreaded object's code using synchronization primitives such as critical sections, semaphores, or mutexes to help protect the object's data.</para>
      <para>When an object that is configured to run in the neutral threaded apartment (NTA) is called by a thread that is in either an STA or the MTA, that thread transfers to the NTA. If this thread subsequently calls <b>CoInitializeEx</b>, the call fails and returns RPC_E_CHANGED_MODE.</para>
      <para>Because OLE technologies are not thread-safe, the <see cref="OleInitialize" /> function calls <b>CoInitializeEx</b> with the COINIT_APARTMENTTHREADED flag. As a result, an apartment that is initialized for multithreaded object concurrency cannot use the features enabled by <b>OleInitialize</b>.</para>
      <para>Because there is no way to control the order in which in-process servers are loaded or unloaded, do not call <see cref="CoInitialize" />, <b>CoInitializeEx</b>, or <see cref="CoUninitialize" /> from the <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/com/processes--threads--and-apartments">Processes, Threads, and Apartments</seealso>
  </member>
  <member name="Windows.CoInitializeSecurity">
    <summary>
      <para>Registers security and sets the default security values for the process.</para>
    </summary>
    <param name="pSecDesc">
      <para>The access permissions that a server will use to receive calls. This parameter is used by COM only when a server calls <b>CoInitializeSecurity</b>. Its value is a pointer to one of three types: an AppID, an <see cref="IAccessControl" /> object, or a <see cref="SECURITY_DESCRIPTOR" />, in absolute format. See the Remarks section for more information.</para>
    </param>
    <param name="cAuthSvc">
      <para>The count of entries in the <i>asAuthSvc</i> parameter. This parameter is used by COM only when a server calls <b>CoInitializeSecurity</b>. If this parameter is 0, no authentication services will be registered and the server cannot receive secure calls. A value of -1 tells COM to choose which authentication services to register, and if this is the case, the <i>asAuthSvc</i> parameter must be <b>NULL</b>. However, Schannel will never be chosen as an authentication service by the server if this parameter is -1.</para>
    </param>
    <param name="asAuthSvc">
      <para>An array of authentication services that a server is willing to use to receive a call. This parameter is used by COM only when a server calls <b>CoInitializeSecurity</b>. For more information, see <see cref="SOLE_AUTHENTICATION_SERVICE" />.</para>
    </param>
    <param name="pReserved1">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <param name="dwAuthnLevel">
      <para>The default authentication level for the process. Both servers and clients use this parameter when they call <b>CoInitializeSecurity</b>. COM will fail calls that arrive with a lower authentication level. By default, all proxies will use at least this authentication level. This value should contain one of the <a href="https://docs.microsoft.com//windows/desktop/com/com-authentication-level-constants">authentication level constants</a>. By default, all calls to <see cref="IUnknown" /> are made at this level.</para>
    </param>
    <param name="dwImpLevel">
      <para>The default impersonation level for proxies. The value of this parameter is used only when the process is a client. It should be a value from the <a href="https://docs.microsoft.com//windows/desktop/com/com-impersonation-level-constants">impersonation level constants</a>, except for RPC_C_IMP_LEVEL_DEFAULT, which is not for use with <b>CoInitializeSecurity</b>.</para>
      <para>Outgoing calls from the client always use the impersonation level as specified. (It is not negotiated.) Incoming calls to the client can be at any impersonation level. By default, all <see cref="IUnknown" /> calls are made with this impersonation level, so even security-aware applications should set this level carefully. To determine which impersonation levels each authentication service supports, see the description of the authentication services in <a href="https://docs.microsoft.com//windows/desktop/com/com-and-security-packages">COM and Security Packages</a>. For more information about impersonation levels, see <a href="https://docs.microsoft.com//windows/desktop/com/impersonation">Impersonation</a>.</para>
    </param>
    <param name="pAuthList">
      <para>A pointer to <see cref="SOLE_AUTHENTICATION_LIST" />, which is an array of <see cref="SOLE_AUTHENTICATION_INFO" /> structures. This list indicates the information for each authentication service that a client can use to call a server. This parameter is used by COM only when a client calls <b>CoInitializeSecurity</b>.</para>
    </param>
    <param name="dwCapabilities">
      <para>Additional capabilities of the client or server, specified by setting one or more <see cref="EOLE_AUTHENTICATION_CAPABILITIES" /> values. Some of these value cannot be used simultaneously, and some cannot be set when particular authentication services are being used. For more information about these flags, see the Remarks section.</para>
    </param>
    <param name="pReserved3">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Indicates success.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_E_TOO_LATE</b>
            </para>
          </description>
          <description>
            <para>
              <see cref="CoInitializeSecurity" /> has already been called.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_E_NO_GOOD_SECURITY_PACKAGES</b>
            </para>
          </description>
          <description>
            <para>The <i>asAuthSvc</i> parameter was not <b>NULL</b>, and none of the authentication services in the list could be registered. Check the results saved in <i>asAuthSvc</i> for authentication service–specific error codes.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_OUT_OF_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Out of memory.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CoInitializeSecurity</b> function initializes the security layer and sets the specified values as the security default. If a process does not call <b>CoInitializeSecurity</b>, COM calls it automatically the first time an interface is marshaled or unmarshaled, registering the system default security. No default security packages are registered until then.</para>
      <para>This function is called exactly once per process, either explicitly or implicitly. It can be called by the client, server, or both. For legacy applications and other applications that do not explicitly call <b>CoInitializeSecurity</b>, COM calls this function implicitly with values from the registry. If you set processwide security using the registry and then call <b>CoInitializeSecurity</b>, the <a href="https://docs.microsoft.com//windows/desktop/com/appid-key">AppID</a> registry values will be ignored and the <b>CoInitializeSecurity</b> values will be used.</para>
      <para>
        <b>CoInitializeSecurity</b> can be used to override both computer-wide access permissions and application-specific access permissions, but not to override the computer-wide restriction policy.</para>
      <para>If <i>pSecDesc</i> points to an AppID, the EOAC_APPID flag must be set in <i>dwCapabilities</i> and, when the EOAC_APPID flag is set, all other parameters to <b>CoInitializeSecurity</b> are ignored. <b>CoInitializeSecurity</b> looks for the authentication level under the <b>AppID</b> key in the registry and uses it to determine the default security. For more information about how the <b>AppID</b> key is used to set security, see <a href="https://docs.microsoft.com//windows/desktop/com/setting-processwide-security-through-the-registry">Setting Process-Wide Security Through the Registry</a>.</para>
      <para>If <i>pSecDesc</i> is a pointer to an <see cref="IAccessControl" /> object, the EOAC_ACCESS_CONTROL flag must be set and <i>dwAuthnLevel</i> cannot be none. The <b>IAccessControl</b> object is used to determine who can call the process. DCOM will <see cref="AddRef" /> the <b>IAccessControl</b> and will <see cref="Release" /> it when <see cref="CoUninitialize" /> is called. The state of the <b>IAccessControl</b> object should not be changed.</para>
      <para>If <i>pSecDesc</i> is a pointer to a <see cref="SECURITY_DESCRIPTOR" />, neither the EOAC_APPID nor the EOAC_ACCESS_CONTROL flag can be set in <i>dwCapabilities</i>. The owner and group of the <b>SECURITY_DESCRIPTOR</b> must be set, and until DCOM supports auditing, the system ACL must be <b>NULL</b>. The access-control entries (ACEs) in the discretionary ACL (DACL) of the <b>SECURITY_DESCRIPTOR</b> are used to find out which callers are permitted to connect to the process's objects. A DACL with no ACEs allows no access, while a <b>NULL</b> DACL will allow calls from anyone. For more information on ACLs and ACEs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control-model">Access Control Model</a>. Applications should call <see cref="AccessCheck" /> (not <see cref="IsValidSecurityDescriptor" />) to ensure that their <b>SECURITY_DESCRIPTOR</b> is correctly formed prior to calling <b>CoInitializeSecurity</b>.</para>
      <para>Passing <i>pSecDesc</i> as <b>NULL</b> is strongly discouraged. An appropriate alternative might be to use a <see cref="SECURITY_DESCRIPTOR" /> that allows Everyone. If <i>pSecDesc</i> is <b>NULL</b>, the flags in <i>dwCapabilities</i> determine how <b>CoInitializeSecurity</b> defines the access permissions that a server will use, as follows:</para>
      <list type="bullet">
        <item>
          <description>If the EOAC_APPID flag is set, <b>CoInitializeSecurity</b> will look up the application's .exe name in the registry and use the AppID stored there.</description>
        </item>
        <item>
          <description>If the EOAC_ACCESS_CONTROL flag is set, <b>CoInitializeSecurity</b> will return an error.
</description>
        </item>
        <item>
          <description>If neither the EOAC_APPID flag nor the EOAC_ACCESS_CONTROL flag is set, <b>CoInitializeSecurity</b> allows all callers including Local and Remote Anonymous Users.
</description>
        </item>
      </list>
      <para>The <b>CoInitializeSecurity</b> function returns an error if both the EOAC_APPID and EOAC_ACCESS_CONTROL flags are set in <i>dwCapabilities</i>.</para>
    </remarks>
    <seealso cref="CoSetProxyBlanket" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/security-in-com">Security in COM</seealso>
  </member>
  <member name="Windows.CoInvalidateRemoteMachineBindings">
    <summary>
      <para>Tells the <a href="https://docs.microsoft.com//windows/desktop/Services/service-control-manager">service control manager</a> to flush any cached RPC binding handles for the specified computer.</para>
      <para>Only administrators may call this function.</para>
    </summary>
    <param name="pszMachineName">
      <para>The computer name for which binding handles should be flushed, or an empty string to signify that all handles in the cache should be flushed.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Indicates success.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_S_MACHINENAMENOTFOUND</b>
            </para>
          </description>
          <description>
            <para>Indicates that the specified computer name was not found or that the binding handle cache was empty, indicating that an empty string was passed instead of a specific computer name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>Indicates the caller was not an administrator for this computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Indicates that a <b>NULL</b> value was passed for <i>pszMachineName</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The OLE Service Control Manager is used by COM to send component activation requests to other machines. To do this, the OLE Service Control Manager maintains a cache of RPC binding handles to send activation requests to computer, keyed by computer name. Under normal circumstances, this works well, but in some scenarios, such as Web farms and load-balancing situations, the ability to purge this cache of specific handles might be needed in order to facilitate rebinding to a different physical server by the same name. <b>CoInvalidateRemoteMachineBindings</b> is used for this purpose.</para>
      <para>The OLE Service Control Manager will flush unused binding handles over time. It is not necessary to call <b>CoInvalidateRemoteMachineBindings</b> to do this.</para>
    </remarks>
  </member>
  <member name="Windows.CoIsHandlerConnected">
    <summary>
      <para>Determines whether a remote object is connected to the corresponding in-process object.</para>
    </summary>
    <param name="pUnk">
      <para>A pointer to the controlling <see cref="IUnknown" /> interface on the remote object.</para>
    </param>
    <returns>
      <para>If the object is not remote or if it is remote and still connected, the return value is <b>TRUE</b>; otherwise, it is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The <b>CoIsHandlerConnected</b> function determines the status of a remote object. You can use it to determine when to release a remote object. You specify the remote object by giving the function a pointer to its controlling <see cref="IUnknown" /> interface (the <i>pUnk</i> parameter). A value of <b>TRUE</b> returned from the function indicates either that the specified object is not remote, or that it is remote and is still connected to its remote handler. A value of <b>FALSE</b> returned from the function indicates that the object is remote but is no longer connected to its remote handler; in this case, the caller should respond by releasing the object.</para>
    </remarks>
  </member>
  <member name="Windows.CoLockObjectExternal">
    <summary>
      <para>Called either to lock an object to ensure that it stays in memory, or to release such a lock.</para>
    </summary>
    <param name="pUnk">
      <para>A pointer to the <see cref="IUnknown" /> interface on the object to be locked or unlocked.</para>
    </param>
    <param name="fLock">
      <para>Indicates whether the object is to be locked or released. If this parameter is <b>TRUE</b>, the object is kept in memory, independent of <b>AddRef</b>/<b>Release</b> operations, registrations, or revocations. If this parameter is <b>FALSE</b>, the lock previously set with a call to this function is released.</para>
    </param>
    <param name="fLastUnlockReleases">
      <para>If the lock is the last reference that is supposed to keep an object alive, specify <b>TRUE</b> to release all pointers to the object (there may be other references that are not supposed to keep it alive).
Otherwise, specify <b>FALSE</b>.</para>
      <para>If <i>fLock</i> is <b>TRUE</b>, this parameter is ignored.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.</para>
    </returns>
    <remarks>
      <para>The <b>CoLockObjectExternal</b> function must be called in the process in which the object actually resides (the EXE process, not the process in which handlers may be loaded).</para>
      <para>The <b>CoLockObjectExternal</b> function prevents the reference count of an object from going to zero, thereby "locking" it into existence until the lock is released. The same function (with different parameters) releases the lock. The lock is implemented by having the system call <see cref="IUnknown.AddRef" /> on the object. The system then waits to call <see cref="IUnknown.Release" /> on the object until a later call to <b>CoLockObjectExternal</b> with <i>fLock</i> set to <b>FALSE</b>. This function can be used to maintain a reference count on the object on behalf of the end user, because it acts outside of the object, as does the user.</para>
      <para>The end user has explicit control over the lifetime of an application, even if there are external locks on it. That is, if a user decides to close the application, it must shut down. In the presence of external locks (such as the lock set by <b>CoLockObjectExternal</b>), the application can call the <see cref="CoDisconnectObject" /> function to force these connections to close prior to shutdown.</para>
      <para>Calling <b>CoLockObjectExternal</b> sets a strong lock on an object. A strong lock keeps an object in memory, while a weak lock does not. Strong locks are required, for example, during a silent update to an OLE embedding. The embedded object's container must remain in memory until the update process is complete. There must also be a strong lock on an application object to ensure that the application stays alive until it has finished providing services to its clients. All external references place a strong reference lock on an object.</para>
      <para>The <b>CoLockObjectExternal</b> function is typically called in the following situations:</para>
      <list type="bullet">
        <item>
          <description>
            <para>Object servers should call <b>CoLockObjectExternal</b> with both <i>fLock</i> and <i>fLastLockReleases</i> set to <b>TRUE</b> when they become visible. This call creates a strong lock on behalf of the user. When the application is closing, free the lock with a call to <b>CoLockObjectExternal</b>, setting <i>fLock</i> to <b>FALSE</b> and <i>fLastLockReleases</i> to <b>TRUE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>A call to <b>CoLockObjectExternal</b> on the server can also be used in the implementation of <see cref="IOleContainer.LockContainer" />.</para>
          </description>
        </item>
      </list>
      <para>There are several things to be aware of when you use <b>CoLockObjectExternal</b> in the implementation of <see cref="LockContainer" />. An embedded object would call <b>LockContainer</b> on its container to keep it running (to lock it) in the absence of other reasons to keep it running. When the embedded object becomes visible, the container must weaken its connection to the embedded object with a call to the <see cref="OleSetContainedObject" /> function, so other connections can affect the object.</para>
      <para>Unless an application manages all aspects of its application and document shutdown completely with calls to <b>CoLockObjectExternal</b>, the container must keep a private lock count in <see cref="LockContainer" /> so that it exits when the lock count reaches zero and the container is invisible. Maintaining all aspects of shutdown, and thereby avoiding keeping a private lock count, means that <b>CoLockObjectExternal</b> should be called whenever one of the following conditions occur:</para>
      <list type="bullet">
        <item>
          <description>
            <para>A document is created and destroyed or made visible or invisible.</para>
          </description>
        </item>
        <item>
          <description>
            <para>An application is started and shut down by the user.</para>
          </description>
        </item>
        <item>
          <description>
            <para>A pseudo-object is created and destroyed.</para>
          </description>
        </item>
      </list>
      <para>For debugging purposes, it may be useful to keep a count of the number of external locks (and unlocks) set on the application.</para>
    </remarks>
    <seealso cref="IOleContainer.LockContainer" />
    <seealso cref="OleSetContainedObject" />
  </member>
  <member name="Windows.CoMarshalHresult">
    <summary>
      <para>Marshals an <b>HRESULT</b> to the specified stream, from which it can be unmarshaled using the <see cref="CoUnmarshalHresult" /> function.</para>
    </summary>
    <param name="pstm">
      <para>A pointer to the marshaling stream. See <see cref="IStream" />.</para>
    </param>
    <param name="hresult">
      <para>The <b>HRESULT</b> in the originating process.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The <b>HRESULT</b> was marshaled successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>STG_E_INVALIDPOINTER</b>
            </para>
          </description>
          <description>
            <para>A bad pointer was specified for <i>pstm</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>STG_E_MEDIUMFULL</b>
            </para>
          </description>
          <description>
            <para>The medium is full.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>An <b>HRESULT</b> is process-specific, so an <b>HRESULT</b> that is valid in one process might not be valid in another. If you are writing your own implementation of <see cref="IMarshal" /> and need to marshal an <b>HRESULT</b> from one process to another, either as a parameter or a return code, you must call this function. In other circumstances, you will have no need to call this function.</para>
      <para>This function performs the following tasks:</para>
      <list type="number">
        <item>
          <description>Writes an <b>HRESULT</b> to a stream.</description>
        </item>
        <item>
          <description>Returns an <see cref="IStream" /> pointer to that stream.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="CoUnmarshalHresult" />
    <seealso cref="IStream" />
  </member>
  <member name="Windows.CoMarshalInterface">
    <summary>
      <para>Writes into a stream the data required to initialize a proxy object in some client process.</para>
    </summary>
    <param name="pStm">
      <para>A pointer to the stream to be used during marshaling. See <see cref="IStream" />.</para>
    </param>
    <param name="riid">
      <para>A reference to the identifier of the interface to be marshaled. This interface must be derived from the <see cref="IUnknown" /> interface.</para>
    </param>
    <param name="pUnk">
      <para>A pointer to the interface to be marshaled. This interface must be derived from the <see cref="IUnknown" /> interface.</para>
    </param>
    <param name="dwDestContext">
      <para>The destination context where the specified interface is to be unmarshaled. The possible values come from the enumeration <see cref="MSHCTX" />. Currently, unmarshaling can occur in another apartment of the current process (MSHCTX_INPROC), in another process on the same computer as the current process (MSHCTX_LOCAL), or in a process on a different computer (MSHCTX_DIFFERENTMACHINE).</para>
    </param>
    <param name="pvDestContext">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <param name="mshlflags">
      <para>The flags that specify whether the data to be marshaled is to be transmitted back to the client process (the typical  case) or written to a global table, where it can be retrieved by multiple clients. The possible values come from the <see cref="MSHLFLAGS" /> enumeration.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, the stream-access error values returned by <see cref="IStream" />, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The <b>HRESULT</b> was marshaled successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CO_E_NOTINITIALIZED</b>
            </para>
          </description>
          <description>
            <para>The <see cref="CoInitialize" /> or <see cref="OleInitialize" /> function was not called on the current thread before this function was called.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CoMarshalInterface</b> function marshals the interface referred to by riid on the object whose <see cref="IUnknown" /> implementation is pointed to by <i>pUnk</i>. To do so, the <b>CoMarshalInterface</b> function performs the following tasks:</para>
      <list type="number">
        <item>
          <description>
            <para>Queries the object for a pointer to the <see cref="IMarshal" /> interface. If the object does not implement <b>IMarshal</b>, meaning that it relies on COM to provide marshaling support, <b>CoMarshalInterface</b> gets a pointer to COM's default implementation of <b>IMarshal</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>Gets the CLSID of the object's proxy by calling <see cref="IMarshal.GetUnmarshalClass" />, using whichever <see cref="IMarshal" /> interface pointer has been returned.</para>
          </description>
        </item>
        <item>
          <description>
            <para>Writes the CLSID of the proxy to the stream to be used for marshaling.</para>
          </description>
        </item>
        <item>
          <description>
            <para>Marshals the interface pointer by calling <see cref="IMarshal.MarshalInterface" />.</para>
          </description>
        </item>
      </list>
      <para>The COM library in the client process calls the <see cref="CoUnmarshalInterface" /> function to extract the data and initialize the proxy. Before calling <b>CoUnmarshalInterface</b>, seek back to the original position in the stream.</para>
      <para>If you are implementing existing COM interfaces or defining your own interfaces using the Microsoft Interface Definition Language (MIDL), the MIDL-generated proxies and stubs call <b>CoMarshalInterface</b> for you. If you are writing your own proxies and stubs, your proxy code and stub code should each call <b>CoMarshalInterface</b> to correctly marshal interface pointers. Calling <see cref="IMarshal" /> directly from your proxy and stub code is not recommended.</para>
      <para>If you are writing your own implementation of <see cref="IMarshal" />, and your proxy needs access to a private object, you can include an interface pointer to that object as part of the data you write to the stream. In such situations, if you want to use COM's default marshaling implementation when passing the interface pointer, you can call <b>CoMarshalInterface</b> on the object to do so.</para>
    </remarks>
    <seealso cref="CoUnmarshalInterface" />
    <seealso cref="IMarshal.MarshalInterface" />
  </member>
  <member name="Windows.CoMarshalInterThreadInterfaceInStream">
    <summary>
      <para>Marshals an interface pointer from one thread to another thread in the same process.</para>
    </summary>
    <param name="riid">
      <para>A reference to the identifier of the interface to be marshaled.</para>
    </param>
    <param name="pUnk">
      <para>A pointer to the interface to be marshaled, which must be derived from <see cref="IUnknown" />. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="ppStm">
      <para>The address of the <see cref="IStream" />* pointer variable that receives the interface pointer to the stream that contains the marshaled interface.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_OUTOFMEMORY and S_OK.</para>
    </returns>
    <remarks>
      <para>The <b>CoMarshalInterThreadInterfaceInStream</b> function enables an object to easily and reliably marshal an interface pointer to another thread in the same process. The stream returned in the <i>ppStm</i> parameter is guaranteed to behave correctly when a client running in the receiving thread attempts to unmarshal the pointer. The client can then call the <see cref="CoGetInterfaceAndReleaseStream" /> to unmarshal the interface pointer and release the stream object.</para>
      <para>The <b>CoMarshalInterThreadInterfaceInStream</b> function performs the following tasks:</para>
      <list type="number">
        <item>
          <description>
            <para>Creates a stream object.</para>
          </description>
        </item>
        <item>
          <description>
            <para>Passes the stream object's IStream pointer to <see cref="CoMarshalInterface" />.</para>
          </description>
        </item>
        <item>
          <description>
            <para>Returns the <see cref="IStream" /> pointer to the caller.</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CoGetInterfaceAndReleaseStream" />
  </member>
  <member name="Windows.CoQueryAuthenticationServices">
    <summary>
      <para>Retrieves a list of the authentication services registered when the process called <see cref="CoInitializeSecurity" />.</para>
    </summary>
    <param name="pcAuthSvc">
      <para>A pointer to a variable that receives the number of entries returned in the <i>asAuthSvc</i> array.</para>
    </param>
    <param name="asAuthSvc">
      <para>A pointer to an array of <see cref="SOLE_AUTHENTICATION_SERVICE" /> structures. The list is allocated through a call to the <see cref="CoTaskMemAlloc" /> function. The caller must free the list when finished with it by calling the <see cref="CoTaskMemFree" /> function.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</para>
    </returns>
    <remarks>
      <para>
        <b>CoQueryAuthenticationServices</b> retrieves a list of the authentication services currently registered. If the process calls <see cref="CoInitializeSecurity" />, these are the services registered through that call. If the application does not call it, <b>CoInitializeSecurity</b> is called automatically by COM, registering the default security package, the first time an interface is marshaled or unmarshaled.</para>
      <para>This function returns only the authentication services registered with <see cref="CoInitializeSecurity" />. It does not return all of the authentication services installed on the computer, but <see cref="EnumerateSecurityPackages" /> does. <b>CoQueryAuthenticationServices</b> is primarily useful for custom marshalers, to determine which principal names an application can use.</para>
      <para>Different authentication services support different levels of security. For example, NTLMSSP does not support delegation or mutual authentication while Kerberos does. The application is responsible only for registering authentication services that provide the features the application needs. This function provides a way to find out which services have been registered with <see cref="CoInitializeSecurity" />.</para>
    </remarks>
    <seealso cref="CoInitializeSecurity" />
    <seealso cref="SOLE_AUTHENTICATION_SERVICE" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/security-in-com">Security in COM</seealso>
  </member>
  <member name="Windows.CoQueryClientBlanket">
    <summary>
      <para>Called by the server to find out about the client that invoked the method executing on the current thread. This is a helper function for <see cref="IServerSecurity.QueryBlanket" />.</para>
    </summary>
    <param name="pAuthnSvc">
      <para>A pointer to a variable that receives the current authentication service. This will be a single value taken from the <a href="https://docs.microsoft.com//windows/desktop/com/com-authentication-service-constants">authentication service constants</a>. If the caller specifies <b>NULL</b>, the current authentication service is not retrieved.</para>
    </param>
    <param name="pAuthzSvc">
      <para>A pointer to a variable that receives the current authorization service. This will be a single value taken from the <a href="https://docs.microsoft.com//windows/desktop/com/com-authorization-constants">authorization constants</a>. If the caller specifies <b>NULL</b>, the current authorization service is not retrieved.</para>
    </param>
    <param name="pServerPrincName">
      <para>The current principal name. The string will be allocated by the callee using <see cref="CoTaskMemAlloc" />, and must be freed by the caller using <see cref="CoTaskMemFree" />. By default, Schannel principal names will be in the msstd form. The fullsic form will be returned if EOAC_MAKE_FULLSIC is specified in the <i>pCapabilities</i> parameter. For more information about the msstd and fullsic forms, see <a href="https://docs.microsoft.com//windows/desktop/Rpc/principal-names">Principal Names</a>. If the caller specifies <b>NULL</b>, the current principal name is not retrieved.</para>
    </param>
    <param name="pAuthnLevel">
      <para>A pointer to a variable that receives the current authentication level. This will be a single value taken from the <a href="https://docs.microsoft.com//windows/desktop/com/com-authentication-level-constants">authentication level constants</a>. If the caller specifies <b>NULL</b>, the current authentication level is not retrieved.</para>
    </param>
    <param name="pImpLevel">
      <para>This parameter must be <b>NULL</b>.</para>
    </param>
    <param name="pPrivs">
      <para>A pointer to a handle that receives the privilege information for the client application. The format of the structure that the handle refers to depends on the authentication service. The application should not write or free the memory. The information is valid only for the duration of the current call. For NTLMSSP and Kerberos, this is a string identifying the client principal. For Schannel, this is a <see cref="CERT_CONTEXT" /> structure that represents the client's certificate. If the client has no certificate, <b>NULL</b> is returned. If the caller specifies <b>NULL</b>, the current privilege information is not retrieved. See <a href="https://docs.microsoft.com//windows/desktop/Rpc/rpc-authz-handle">RPC_AUTHZ_HANDLE</a>.</para>
    </param>
    <param name="pCapabilities">
      <para>A pointer to return flags indicating capabilities of the call. To request that the principal name be returned in fullsic form if Schannel is the authentication service, the caller can set the EOAC_MAKE_FULLSIC flag in this parameter. If the caller specifies <b>NULL</b>, the current capabilities are not retrieved.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</para>
    </returns>
    <remarks>
      <para>
        <b>CoQueryClientBlanket</b> is called by the server to get security information about the client that invoked the method executing on the current thread. This function encapsulates the following sequence of common calls (error handling excluded):</para>
      <code>    CoGetCallContext(IID_IServerSecurity, (void**)&amp;amp;amp;amp;amp;amp;amp;pss);
    pss-&gt;QueryBlanket(pAuthnSvc, pAuthzSvc, pServerPrincName,
                pAuthnLevel, pImpLevel, pPrivs, pCapabilities);
    pss-&gt;Release();

</code>
      <para>This sequence calls <see cref="CoGetCallContext" /> to get a pointer to <see cref="IServerSecurity" /> and, with the resulting pointer, calls <see cref="IServerSecurity.QueryBlanket" /> and then releases the pointer.</para>
    </remarks>
    <seealso cref="CoGetCallContext" />
    <seealso cref="CoQueryProxyBlanket" />
    <seealso cref="IServerSecurity.QueryBlanket" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/security-in-com">Security in COM</seealso>
  </member>
  <member name="Windows.CoQueryProxyBlanket">
    <summary>
      <para>Retrieves the authentication information the client uses to make calls on the specified proxy. This is a helper function for <see cref="IClientSecurity.QueryBlanket" />.</para>
    </summary>
    <param name="pProxy">
      <para>A pointer indicating the proxy to query. This parameter cannot be <b>NULL</b>. For more information, see the Remarks section.</para>
    </param>
    <param name="pwAuthnSvc">
      <para>A pointer to a variable that receives the current authentication service. This will be a single value taken from the <a href="https://docs.microsoft.com//windows/desktop/com/com-authentication-service-constants">authentication service constants</a>. This parameter cannot be <b>NULL</b>.</para>
    </param>
    <param name="pAuthzSvc">
      <para>A pointer to a variable that receives the current authorization service. This will be a single value taken from the <a href="https://docs.microsoft.com//windows/desktop/com/com-authorization-constants">authorization constants</a>. If the caller specifies <b>NULL</b>, the current authorization service is not retrieved.</para>
    </param>
    <param name="pServerPrincName">
      <para>The current principal name. The string will be allocated by the callee using <see cref="CoTaskMemAlloc" />, and must be freed by the caller using <see cref="CoTaskMemFree" />. The EOAC_MAKE_FULLSIC flag is not accepted in the <i>pCapabilities</i> parameter. For more information about the msstd and fullsic forms, see <a href="https://docs.microsoft.com//windows/desktop/Rpc/principal-names">Principal Names</a>. If the caller specifies <b>NULL</b>, the current principal name is not retrieved.</para>
    </param>
    <param name="pAuthnLevel">
      <para>A pointer to a variable that receives the current authentication level. This will be a single value taken from the <a href="https://docs.microsoft.com//windows/desktop/com/com-authentication-level-constants">authentication level constants</a>. If the caller specifies <b>NULL</b>, the current authentication level is not retrieved.</para>
    </param>
    <param name="pImpLevel">
      <para>A pointer to a variable that receives the current impersonation level. This will be a single value taken from the <a href="https://docs.microsoft.com//windows/desktop/com/com-impersonation-level-constants">impersonation level constants</a>. If the caller specifies <b>NULL</b>, the current impersonation level is not retrieved.</para>
    </param>
    <param name="pAuthInfo">
      <para>A pointer to a handle that receives the identity of the client that was passed to the last <see cref="IClientSecurity.SetBlanket" /> call (or the default value). Default values are only valid until the proxy is released. If the caller specifies <b>NULL</b>, the client identity is not retrieved. The format of the structure that the handle refers to depends on the authentication service. The application should not write or free the memory. For NTLMSSP and Kerberos, if the client specified a structure in the <i>pAuthInfo</i> parameter to <see cref="CoInitializeSecurity" />, that value is returned. For Schannel, if a certificate for the client could be retrieved from the certificate manager, that value is returned here. Otherwise, <b>NULL</b> is returned. See <a href="https://docs.microsoft.com//windows/desktop/Rpc/rpc-auth-identity-handle">RPC_AUTH_IDENTITY_HANDLE</a>.</para>
    </param>
    <param name="pCapabilites">
      <para>A pointer to a variable that receives the capabilities of the proxy. If the caller specifies <b>NULL</b>, the current capability flags are not retrieved.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</para>
    </returns>
    <remarks>
      <para>
        <b>CoQueryProxyBlanket</b> is called by the client to retrieve the authentication information COM will use on calls made from the specified proxy. This function encapsulates the following sequence of common calls (error handling excluded):</para>
      <code>pProxy-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;amp;amp;amp;amp;amp;amp;pcs);
pcs-&gt;QueryBlanket(
    pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName, pAuthnLevel, pImpLevel, ppAuthInfo, pCapabilities
  );
pcs-&gt;Release();

</code>
      <para>This sequence calls <see cref="QueryInterface" /> on the proxy to get a pointer to <see cref="IClientSecurity" />, and with the resulting pointer, calls <see cref="IClientSecurity.QueryBlanket" /> and then releases the pointer.</para>
      <para>In <i>pProxy</i>, you can pass any proxy, such as a proxy you get through a call to <see cref="CoCreateInstance" /> or <see cref="CoUnmarshalInterface" />, or you can pass an interface pointer. It can be any interface. You cannot pass a pointer to something that is not a proxy. Therefore, you can't pass a pointer to an interface that has the local keyword in its interface definition because no proxy is created for such an interface. <see cref="IUnknown" /> is the exception to this rule.</para>
    </remarks>
    <seealso cref="CoQueryClientBlanket" />
    <seealso cref="CoSetProxyBlanket" />
    <seealso cref="IClientSecurity.QueryBlanket" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/security-in-com">Security in COM</seealso>
  </member>
  <member name="Windows.CoRegisterActivationFilter">
    <summary>
      <para>Registers a process-wide filter to process activation requests.</para>
    </summary>
    <param name="pActivationFilter">
      <para>Pointer to the filter to register.</para>
    </param>
    <returns>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This registers one and only one process-wide filter.</para>
    </remarks>
  </member>
  <member name="Windows.CoRegisterClassObject">
    <summary>
      <para>Registers an EXE class object with OLE so other applications can connect to it.</para>
    </summary>
    <param name="rclsid">
      <para>The CLSID to be registered.</para>
    </param>
    <param name="pUnk">
      <para>A pointer to the <see cref="IUnknown" /> interface on the class object whose availability is being published.</para>
    </param>
    <param name="dwClsContext">
      <para>The context in which the executable code is to be run. For information on these context values, see the <see cref="CLSCTX" /> enumeration.</para>
    </param>
    <param name="flags">
      <para>Indicates how connections are made to the class object. For information on these flags, see the <see cref="REGCLS" /> enumeration.</para>
    </param>
    <param name="lpdwRegister">
      <para>A pointer to a value that identifies the class object registered; later used by the <see cref="CoRevokeClassObject" /> function to revoke the registration.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The class object was registered successfully.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>EXE object applications should call <b>CoRegisterClassObject</b> on startup. It can also be used to register internal objects for use by the same EXE or other code (such as DLLs) that the EXE uses.
Only EXE object applications call <b>CoRegisterClassObject</b>. Object handlers or DLL object applications do not call this function — instead, they must implement and export the <see cref="DllGetClassObject" /> function.</para>
      <para>At startup, a multiple-use EXE object application must create a class object (with the <see cref="IClassFactory" /> interface on it), and call <b>CoRegisterClassObject</b> to register the class object. Object applications that support several different classes (such as multiple types of embeddable objects) must allocate and register a different class object for each.</para>
      <para>Multiple registrations of the same class object are independent and do not produce an error. Each subsequent registration yields a unique key in <i>lpdwRegister</i>.</para>
      <para>Multiple document interface (MDI) applications must register their class objects. Single document interface (SDI) applications must register their class objects only if they can be started by means of the <b>/Embedding</b> switch.</para>
      <para>The server for a class object should call <see cref="CoRevokeClassObject" /> to revoke the class object (remove its registration) when all of the following are true:</para>
      <list type="bullet">
        <item>
          <description>
            <para>There are no existing instances of the object definition.</para>
          </description>
        </item>
        <item>
          <description>
            <para>There are no locks on the class object.</para>
          </description>
        </item>
        <item>
          <description>
            <para>The application providing services to the class object is not under user control (not visible to the user on the display).</para>
          </description>
        </item>
      </list>
      <para>After the class object is revoked, when its reference count reaches zero, the class object can be released, allowing the application to exit. Note that <b>CoRegisterClassObject</b> calls <see cref="IUnknown.AddRef" /> and <see cref="CoRevokeClassObject" /> calls <see cref="IUnknown.Release" />, so the two functions form an <b>AddRef</b>/<b>Release</b> pair.</para>
      <para>As of Windows Server 2003, if a COM object application is registered as a service, COM verifies the registration. COM makes sure the process ID of the service, in the service control manager (SCM), matches the process ID of the registering process. If not, COM fails the registration. If the COM object application runs in the system account with no registry key, COM treats the objects application identity as <a href="https://docs.microsoft.com//windows/desktop/com/launching-user">Launching User</a>.</para>
    </remarks>
    <seealso cref="CLSCTX" />
    <seealso cref="CoGetClassObject" />
    <seealso cref="CoRevokeClassObject" />
    <seealso cref="DllGetClassObject" />
    <seealso cref="REGCLS" />
  </member>
  <member name="Windows.CoRegisterPSClsid">
    <summary>
      <para>Enables a downloaded DLL to register its custom interfaces within its running process so that the marshaling code will be able to marshal those interfaces.</para>
    </summary>
    <param name="riid">
      <para>A pointer to the IID of the interface to be registered.</para>
    </param>
    <param name="rclsid">
      <para>A pointer to the CLSID of the DLL that contains the proxy/stub code for the custom interface specified by <i>riid</i>.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</para>
    </returns>
    <remarks>
      <para>Typically, the code responsible for marshaling an interface pointer into the current running process reads the <b>HKEY_CLASSES_ROOT\Interfaces</b> section of the registry to obtain the CLSID of the DLL containing the ProxyStub code to be loaded. To obtain the ProxyStub CLSIDs for an existing interface, the code calls the <see cref="CoGetPSClsid" /> function.</para>
      <para>In some cases, however, it may be desirable or necessary for an in-process handler or in-process server to make its custom interfaces available without writing to the registry. A DLL downloaded across a network may not even have permission to access the local registry, and because the code originated on another computer, the user, for security purposes, may want to run it in a restricted environment. Or a DLL may have custom interfaces that it uses to talk to a remote server and may also include the ProxyStub code for those interfaces. In such cases, a DLL needs an alternative way to register its interfaces. <b>CoRegisterPSClsid</b>, used in conjunction with <see cref="CoRegisterClassObject" />, provides that alternative.</para>
      <h4>Examples</h4>
      <para>A DLL would typically call <b>CoRegisterPSClsid</b> as shown in the following code fragment.</para>
      <code>HRESULT RegisterMyCustomInterface(DWORD *pdwRegistrationKey)
{
    HRESULT hr = CoRegisterClassObject(CLSID_MyProxyStubClsid,
        pIPSFactoryBuffer,
        CLSCTX_INPROC_SERVER,
        REGCLS_MULTIPLEUSE
        pdwRegistrationKey);
    if(SUCCEEDED)(hr))
    {
        hr = CoRegisterPSClsid(IID_MyCustomInterface, CLSID_MyProxyStubClsid);
    }

    return hr;
}

</code>
    </remarks>
    <seealso cref="CoGetPSClsid" />
    <seealso cref="CoRegisterClassObject" />
  </member>
  <member name="Windows.CoRegisterSurrogate">
    <summary>
      <para>Registers the surrogate process through its <see cref="ISurrogate" /> interface pointer.</para>
    </summary>
    <param name="pSurrogate">
      <para>A pointer to the <see cref="ISurrogate" /> interface on the surrogate process to be registered.</para>
    </param>
    <returns>
      <para>This function returns S_OK to indicate that the surrogate process was registered successfully.</para>
    </returns>
    <remarks>
      <para>The <b>CoRegisterSurrogate</b> function sets a global interface pointer to the <see cref="ISurrogate" /> interface implemented on the surrogate process. This pointer is set in the ole32 DLL loaded in the surrogate process. COM uses this global pointer in ole32 to call the methods of <b>ISurrogate</b>. This function is usually called by the surrogate implementation when it is launched.</para>
      <para>As of Windows Server 2003, if a COM object application is registered as a service, COM verifies the registration. COM makes sure the process ID of the service, in the service control manager (SCM), matches the process ID of the registering process. If not, COM fails the registration.</para>
    </remarks>
    <seealso cref="ISurrogate" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/writing-a-custom-surrogate">Writing a Custom Surrogate</seealso>
  </member>
  <member name="Windows.CoReleaseServerProcess">
    <summary>
      <para>Decrements the global per-process reference count.</para>
    </summary>
    <returns>
      <para>If the server application should initiate its cleanup, the function returns 0; otherwise, the function returns a nonzero value.</para>
    </returns>
    <remarks>
      <para>Servers can call <b>CoReleaseServerProcess</b> to decrement a global per-process reference count incremented through a call to <see cref="CoAddRefServerProcess" />.</para>
      <para>When that count reaches zero, OLE automatically calls <see cref="CoSuspendClassObjects" />, which prevents new activation requests from coming in. This permits the server to deregister its class objects from its various threads without worry that another activation request may come in. New activation requests result in launching a new instance of the local server process.</para>
      <para>The simplest way for a local server application to make use of these functions is to call <see cref="CoAddRefServerProcess" /> in the constructor for each of its instance objects, and in each of its <see cref="IClassFactory.LockServer" /> methods when the <i>fLock</i> parameter is <b>TRUE</b>. The server application should also call <b>CoReleaseServerProcess</b> in the destructor of each of its instance objects, and in each of its <b>IClassFactory.LockServer</b> methods when the <i>fLock</i> parameter is <b>FALSE</b>. Finally, the server application must check the return code from <b>CoReleaseServerProcess</b>; if it returns 0, the server application should initiate its cleanup. This typically means that a server with multiple threads should signal its various threads to exit their message loops and call <see cref="CoRevokeClassObject" /> and <see cref="CoUninitialize" />.</para>
      <para>If these APIs are used at all, they must be called in both the object instances and the <see cref="LockServer" /> method, otherwise the server application may be shutdown prematurely. In-process Servers typically should not call <see cref="CoAddRefServerProcess" /> or <b>CoReleaseServerProcess</b>.</para>
    </remarks>
    <seealso cref="CoAddRefServerProcess" />
    <seealso cref="CoSuspendClassObjects" />
    <seealso cref="IClassFactory.LockServer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/out-of-process-server-implementation-helpers">Out-of-Process Server Implementation Helpers</seealso>
  </member>
  <member name="Windows.CoResumeClassObjects">
    <summary>
      <para>Called by a server that can register multiple class objects to inform the SCM about all registered classes, and permits activation requests for those class objects.</para>
    </summary>
    <returns>
      <para>This function returns S_OK to indicate that the CLSID was retrieved successfully.</para>
    </returns>
    <remarks>
      <para>Servers that can register multiple class objects call <b>CoResumeClassObjects</b> once, after having first called <see cref="CoRegisterClassObject" />, specifying REGCLS_LOCAL_SERVER | REGCLS_SUSPENDED for each CLSID the server supports. This function causes OLE to inform the SCM about all the registered classes, and begins letting activation requests into the server process.</para>
      <para>This reduces the overall registration time, and thus the server application startup time, by making a single call to the SCM, no matter how many CLSIDs are registered for the server. Another advantage is that if the server has multiple apartments with different CLSIDs registered in different apartments, or is a free-threaded server, no activation requests will come in until the server calls <b>CoResumeClassObjects</b>. This gives the server a chance to register all of its CLSIDs and get properly set up before having to deal with activation requests, and possibly shutdown requests.</para>
    </remarks>
    <seealso cref="CoRegisterClassObject" />
    <seealso cref="CoSuspendClassObjects" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/out-of-process-server-implementation-helpers">Out-of-Process Server Implementation Helpers</seealso>
  </member>
  <member name="Windows.CoRevertToSelf">
    <summary>
      <para>Restores the authentication information on a thread of execution.</para>
    </summary>
    <returns>
      <para>This function supports the standard return values, including S_OK to indicate success.</para>
    </returns>
    <remarks>
      <para>
        <b>CoRevertToSelf</b>, which is a helper function that calls <see cref="IServerSecurity.RevertToSelf" />, restores the authentication information on a thread to the authentication information on the thread before impersonation began.</para>
      <para>
        <b>CoRevertToSelf</b> encapsulates the following common sequence of calls (error handling excluded):</para>
      <code>    CoGetCallContext(IID_IServerSecurity, (void**)&amp;amp;amp;amp;amp;amp;amp;pss);
    pss-&gt;RevertToSelf();
    pss-&gt;Release();

</code>
    </remarks>
    <seealso cref="CoGetCallContext" />
    <seealso cref="IServerSecurity.RevertToSelf" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/security-in-com">Security in COM</seealso>
  </member>
  <member name="Windows.CoRevokeClassObject">
    <summary>
      <para>Informs OLE that a class object, previously registered with the <see cref="CoRegisterClassObject" /> function, is no longer available for use.</para>
    </summary>
    <param name="dwRegister">
      <para>A token previously returned from the <see cref="CoRegisterClassObject" /> function.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The class object was revoked successfully.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>A successful call to <b>CoRevokeClassObject</b> means that the class object has been removed from the global class object table (although it does not release the class object). If other clients still have pointers to the class object and have caused the reference count to be incremented by calls to <see cref="IUnknown.AddRef" />, the reference count will not be zero. When this occurs, applications may benefit if subsequent calls (with the obvious exceptions of <b>AddRef</b> and <see cref="IUnknown.Release" />) to the class object fail. Note that <see cref="CoRegisterClassObject" /> calls <b>AddRef</b> and <b>CoRevokeClassObject</b> calls <b>Release</b>, so the two functions form an <b>AddRef</b>/<b>Release</b> pair.</para>
      <para>An object application must call <b>CoRevokeClassObject</b> to revoke registered class objects before exiting the program. Class object implementers should call <b>CoRevokeClassObject</b> as part of the release sequence. You must specifically revoke the class object even when you have specified the flags value REGCLS_SINGLEUSE in a call to <see cref="CoRegisterClassObject" />, indicating that only one application can connect to the class object.</para>
    </remarks>
    <seealso cref="CoGetClassObject" />
    <seealso cref="CoRegisterClassObject" />
  </member>
  <member name="Windows.CoSetCancelObject">
    <summary>
      <para>Sets (registers) or resets (unregisters) a cancel object for use during subsequent cancel operations on the current thread.</para>
    </summary>
    <param name="pUnk">
      <para>Pointer to the <see cref="IUnknown" /> interface on the cancel object to be set or reset on the current thread. If this parameter is <b>NULL</b>, the topmost cancel object is reset.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The cancel object was successfully set or reset.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>The cancel object cannot be set or reset at this time because of a block on cancel operations.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>For objects that support standard marshaling, the proxy object begins marshaling a method call by calling <b>CoSetCancelObject</b> to register a cancel object for the current thread.</para>
      <para>
        <b>CoSetCancelObject</b> calls <see cref="QueryInterface" /> for <see cref="ICancelMethodCalls" /> on the cancel object. If the cancel object does not implement <b>ICancelMethodCalls</b>, <b>CoSetCancelObject</b> fails with E_NOINTERFACE. To disable cancel operations on a custom-marshaled interface, the implementation of <see cref="ICancelMethodCalls.Cancel" /> should do nothing but return E_NOTIMPL, E_FAIL, or some other appropriate value.</para>
      <para>
        <b>CoSetCancelObject</b> calls <see cref="AddRef" /> on objects that it registers and <see cref="Release" /> on objects that it unregisters.</para>
      <para>
        <b>CoSetCancelObject</b> does not set or reset cancel objects for asynchronous methods.</para>
    </remarks>
    <seealso cref="ICancelMethodCalls" />
  </member>
  <member name="Windows.CoSetProxyBlanket">
    <summary>
      <para>Sets the authentication information that will be used to make calls on the specified proxy. This is a helper function for <see cref="IClientSecurity.SetBlanket" />.</para>
    </summary>
    <param name="pProxy">
      <para>The proxy to be set.</para>
    </param>
    <param name="dwAuthnSvc">
      <para>The authentication service to be used. For a list of possible values, see <a href="https://docs.microsoft.com//windows/desktop/com/com-authentication-service-constants">Authentication Service Constants</a>. Use RPC_C_AUTHN_NONE if no authentication is required. If RPC_C_AUTHN_DEFAULT is specified, DCOM will pick an authentication service following its normal security blanket negotiation algorithm.</para>
    </param>
    <param name="dwAuthzSvc">
      <para>The authorization service to be used. For a list of possible values, see <a href="https://docs.microsoft.com//windows/desktop/com/com-authorization-constants">Authorization Constants</a>. If RPC_C_AUTHZ_DEFAULT is specified, DCOM will pick an authorization service following its normal security blanket negotiation algorithm. RPC_C_AUTHZ_NONE should be used as the authorization service if NTLMSSP, Kerberos, or Schannel is used as the authentication service.</para>
    </param>
    <param name="pServerPrincName">
      <para>The server principal name to be used with the authentication service. If COLE_DEFAULT_PRINCIPAL is specified, DCOM will pick a principal name using its security blanket negotiation algorithm. If Kerberos is used as the authentication service, this value must not be <b>NULL</b>. It must be the correct principal name of the server or the call will fail.</para>
      <para>If Schannel is used as the authentication service, this value must be one of the msstd or fullsic forms described in <a href="https://docs.microsoft.com//windows/desktop/Rpc/principal-names">Principal Names</a>, or <b>NULL</b> if you do not want mutual authentication.</para>
      <para>Generally, specifying <b>NULL</b> will not reset the server principal name on the proxy; rather, the previous setting will be retained. You must be careful when using <b>NULL</b> as <i>pServerPrincName</i> when selecting a different authentication service for the proxy, because there is no guarantee that the previously set principal name would be valid for the newly selected authentication service.</para>
    </param>
    <param name="dwAuthnLevel">
      <para>The authentication level to be used. For a list of possible values, see <a href="https://docs.microsoft.com//windows/desktop/com/com-authentication-level-constants">Authentication Level Constants</a>. If RPC_C_AUTHN_LEVEL_DEFAULT is specified, DCOM will pick an authentication level following its normal security blanket negotiation algorithm. If this value is none, the authentication service must also be none.</para>
    </param>
    <param name="dwImpLevel">
      <para>The impersonation level to be used. For a list of possible values, see <a href="https://docs.microsoft.com//windows/desktop/com/com-impersonation-level-constants">Impersonation Level Constants</a>. If RPC_C_IMP_LEVEL_DEFAULT is specified, DCOM will pick an impersonation level following its normal security blanket negotiation algorithm. If NTLMSSP is the authentication service, this value must be RPC_C_IMP_LEVEL_IMPERSONATE or RPC_C_IMP_LEVEL_IDENTIFY. NTLMSSP also supports delegate-level impersonation (RPC_C_IMP_LEVEL_DELEGATE) on the same computer. If Schannel is the authentication service, this parameter must be RPC_C_IMP_LEVEL_IMPERSONATE.</para>
    </param>
    <param name="pAuthInfo">
      <para>A pointer to an <b>RPC_AUTH_IDENTITY_HANDLE</b> value that establishes the identity of the client. The format of the structure referred to by the handle depends on the provider of the authentication service.</para>
      <para>For calls on the same computer, RPC logs on the user with the supplied credentials and uses the resulting token for the method call.</para>
      <para>For NTLMSSP or Kerberos, the structure is a <see cref="SEC_WINNT_AUTH_IDENTITY" /> or <see cref="SEC_WINNT_AUTH_IDENTITY_EX" /> structure.  The client can discard  <i>pAuthInfo</i> after calling the API. RPC does not keep a copy of the <i>pAuthInfo</i> pointer, and the client cannot retrieve it later in the <see cref="CoQueryProxyBlanket" /> method.</para>
      <para>If this parameter is <b>NULL</b>, DCOM uses the current proxy identity (which is either the process token or the impersonation token). If the handle refers to a structure, that identity is used.</para>
      <para>For Schannel, this parameter must be either a pointer to a <see cref="CERT_CONTEXT" /> structure that contains the client's X.509 certificate or is <b>NULL</b> if the client wishes to make an anonymous connection to the server. If a certificate is specified, the caller must not free it as long as any proxy to the object exists in the current apartment.</para>
      <para>For Snego, this member is either <b>NULL</b>, points to a <see cref="SEC_WINNT_AUTH_IDENTITY" /> structure, or points to a <see cref="SEC_WINNT_AUTH_IDENTITY_EX" /> structure. If it is <b>NULL</b>, Snego will pick a list of authentication services based on those available on the client computer. If it points to a <b>SEC_WINNT_AUTH_IDENTITY_EX</b> structure, the structure's <b>PackageList</b> member must point to a string containing a comma-separated list of authentication service names and the <b>PackageListLength</b> member must give the number of bytes in the <b>PackageList</b> string. If <b>PackageList</b> is <b>NULL</b>, all calls using Snego will fail.</para>
      <para>If COLE_DEFAULT_AUTHINFO is specified for this parameter, DCOM will pick the authentication information following its normal security blanket negotiation algorithm.</para>
      <para>
        <b>CoSetProxyBlanket</b> will fail if <i>pAuthInfo</i> is set and one of the cloaking flags is set in the <i>dwCapabilities</i> parameter.</para>
    </param>
    <param name="dwCapabilities">
      <para>The capabilities of this proxy. For a list of possible values, see the <see cref="EOLE_AUTHENTICATION_CAPABILITIES" /> enumeration. The only flags that can be set through this function are EOAC_MUTUAL_AUTH, EOAC_STATIC_CLOAKING, EOAC_DYNAMIC_CLOAKING, EOAC_ANY_AUTHORITY (this flag is deprecated), EOAC_MAKE_FULLSIC, and EOAC_DEFAULT. Either EOAC_STATIC_CLOAKING or EOAC_DYNAMIC_CLOAKING can be set if <i>pAuthInfo</i> is not set and Schannel is not the authentication service. (See <a href="https://docs.microsoft.com//windows/desktop/com/cloaking">Cloaking</a> for more information.) If any capability flags other than those mentioned here are set, <b>CoSetProxyBlanket</b> will fail.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The function was successful.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>One or more arguments is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>CoSetProxyBlanket</b> sets the authentication information that will be used to make calls on the specified proxy. This function encapsulates the following sequence of common calls (error handling excluded).</para>
      <code>    pProxy-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;amp;amp;amp;amp;amp;amp;pcs);
    pcs-&gt;SetBlanket(pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
        dwAuthnLevel, dwImpLevel, pAuthInfo, dwCapabilities);
    pcs-&gt;Release();

</code>
      <para>This sequence calls <see cref="QueryInterface" /> on the proxy to get a pointer to <see cref="IClientSecurity" />, and with the resulting pointer, calls <see cref="IClientSecurity.SetBlanket" /> and then releases the pointer.</para>
    </remarks>
    <seealso cref="CoQueryProxyBlanket" />
    <seealso cref="IClientSecurity.SetBlanket" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/security-in-com">Security in COM</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/com/setting-security-at-the-interface-proxy-level">Setting Security at the Interface Proxy Level</seealso>
  </member>
  <member name="Windows.CoSuspendClassObjects">
    <summary>
      <para>Prevents any new activation requests from the SCM on all class objects registered within the process.</para>
    </summary>
    <returns>
      <para>This function returns S_OK to indicate that the activation of class objects was successfully suspended.</para>
    </returns>
    <remarks>
      <para>
        <b>CoSuspendClassObjects</b> prevents any new activation requests from the SCM on all class objects registered within the process. Even though a process may call this function, the process still must call the <see cref="CoRevokeClassObject" /> function for each CLSID it has registered, in the apartment it registered in. Applications typically do not need to call this function, which is generally only called internally by OLE when used in conjunction with the <see cref="CoReleaseServerProcess" /> function.</para>
    </remarks>
    <seealso cref="CoReleaseServerProcess" />
    <seealso cref="CoRevokeClassObject" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/out-of-process-server-implementation-helpers">Out-of-Process Server Implementation Helpers</seealso>
  </member>
  <member name="Windows.CoSwitchCallContext">
    <summary>
      <para>Switches the call context object used by <see cref="CoGetCallContext" />.</para>
    </summary>
    <param name="pNewObject">
      <para>A pointer to an interface on the new call context object. COM stores this pointer without adding a reference to the pointer until <b>CoSwitchCallContext</b> is called with another object. This parameter may be <b>NULL</b> if you are calling <b>CoSwitchCallContext</b> to switch back to the original call context but there was no original call context.</para>
    </param>
    <param name="ppOldObject">
      <para>The address of pointer variable that receives a pointer to the call context object of the call currently in progress. This value is returned so that the original call context can be restored by the custom marshaller. The returned pointer will be <b>NULL</b> if there was no call in progress.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The function was successful.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_OUT_OF_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Out of memory.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Custom marshallers call <b>CoSwitchCallContext</b> to change the call context object used by the <see cref="CoGetCallContext" /> function. Before dispatching an arriving call, custom marshallers call <b>CoSwitchCallContext</b>, specifying the new context object. After sending a reply, they must restore the original call context by calling <b>CoSwitchCallContext</b> again, this time passing a pointer to the original context object.</para>
      <para>
        <b>CoSwitchCallContext</b> does not add a reference to the new context object. Custom marshallers must ensure that the lifetime of their context object continues throughout their call and until the call to restore the original context.  Custom marshallers should not release the value that they placed into the <i>ppOldObject</i> parameter when they set their context.</para>
      <para>Call context objects provided by custom marshallers should support the <see cref="IServerSecurity" /> interface.</para>
    </remarks>
    <seealso cref="CoGetCallContext" />
    <seealso cref="IServerSecurity" />
    <seealso href="https://docs.microsoft.com//windows/desktop/com/security-in-com">Security in COM</seealso>
  </member>
  <member name="Windows.CoTaskMemAlloc">
    <summary>
      <para>Allocates a block of task memory in the same way that <see cref="IMalloc.Alloc" /> does.</para>
    </summary>
    <param name="cb">
      <para>The size of the memory block to be allocated, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns the allocated memory block. Otherwise, it returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>CoTaskMemAlloc</b> uses the default allocator to allocate a memory block in the same way that <see cref="IMalloc.Alloc" /> does. It is not necessary to call the <see cref="CoGetMalloc" /> function before calling <b>CoTaskMemAlloc</b>.</para>
      <para>The initial contents of the returned memory block are undefined – there is no guarantee that the block has been initialized. The allocated block may be larger than <i>cb</i> bytes because of the space required for alignment and for maintenance information.</para>
      <para>If <i>cb</i> is 0, <b>CoTaskMemAlloc</b> allocates a zero-length item and returns a valid pointer to that item. If there is insufficient memory available, <b>CoTaskMemAlloc</b> returns <b>NULL</b>. Applications should always check the return value from this function, even when requesting small amounts of memory, because there is no guarantee that the memory will be allocated.</para>
    </remarks>
    <seealso cref="CoTaskMemFree" />
    <seealso cref="CoTaskMemRealloc" />
    <seealso cref="IMalloc.Alloc" />
  </member>
  <member name="Windows.CoTaskMemFree">
    <summary>
      <para>Frees a block of task memory previously allocated through a call to the <see cref="CoTaskMemAlloc" /> or <see cref="CoTaskMemRealloc" /> function.</para>
    </summary>
    <param name="pv">
      <para>A pointer to the memory block to be freed. If this parameter is <b>NULL</b>, the function has no effect.</para>
    </param>
    <remarks>
      <para>The <b>CoTaskMemFree</b> function uses the default OLE allocator.</para>
      <para>The number of bytes freed equals the number of bytes that were originally allocated or reallocated. After the call, the memory block pointed to by pv is invalid and can no longer be used.</para>
    </remarks>
    <seealso cref="CoTaskMemAlloc" />
    <seealso cref="CoTaskMemRealloc" />
    <seealso cref="IMalloc.Free" />
  </member>
  <member name="Windows.CoTaskMemRealloc">
    <summary>
      <para>Changes the size of a previously allocated block of task memory.</para>
    </summary>
    <param name="pv">
      <para>A pointer to the memory block to be reallocated. This parameter can be <b>NULL</b>, as discussed in Remarks.</para>
    </param>
    <param name="cb">
      <para>The size of the memory block to be reallocated, in bytes. This parameter can be 0, as discussed in Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns the reallocated memory block. Otherwise, it returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>This function changes the size of a previously allocated memory block in the same way that <see cref="IMalloc.Realloc" /> does. It is not necessary to call the <see cref="CoGetMalloc" /> function to get a pointer to the OLE allocator before calling <b>CoTaskMemRealloc</b>.</para>
      <para>The <i>pv</i> parameter points to the beginning of the memory block. If <i>pv</i> is <b>NULL</b>, <b>CoTaskMemRealloc</b> allocates a new memory block in the same way as the <see cref="CoTaskMemAlloc" /> function. If <i>pv</i> is not <b>NULL</b>, it should be a pointer returned by a prior call to <b>CoTaskMemAlloc</b>.</para>
      <para>The <i>cb</i> parameter specifies the size of the new block. The contents of the block are unchanged up to the shorter of the new and old sizes, although the new block can be in a different location. Because the new block can be in a different memory location, the pointer returned by <b>CoTaskMemRealloc</b> is not guaranteed to be the pointer passed through the <i>pv</i> argument. If <i>pv</i> is not <b>NULL</b> and <i>cb</i> is 0, then the memory pointed to by <i>pv</i> is freed.</para>
      <para>
        <b>CoTaskMemRealloc</b> returns a void pointer to the reallocated (and possibly moved) memory block. The return value is <b>NULL</b> if the size is 0 and the buffer argument is not <b>NULL</b>, or if there is not enough memory available to expand the block to the specified size. In the first case, the original block is freed; in the second case, the original block is unchanged.</para>
      <para>The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. To get a pointer to a type other than <b>void</b>, use a type cast on the return value.</para>
    </remarks>
    <seealso cref="CoTaskMemAlloc" />
    <seealso cref="CoTaskMemFree" />
    <seealso cref="IMalloc.Realloc" />
  </member>
  <member name="Windows.CoTestCancel">
    <summary>
      <para>Determines whether the call being executed on the server has been canceled by the client.</para>
    </summary>
    <returns>
      <para>This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>RPC_S_CALLPENDING</b>
            </para>
          </description>
          <description>
            <para>The call is still pending and has not yet been canceled by the client.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_E_CALL_CANCELED</b>
            </para>
          </description>
          <description>
            <para>The call has been canceled by the client.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Server objects should call <b>CoTestCancel</b> at least once before returning to detect client cancellation requests. Doing so can save the server unnecessary work if the client has issued a cancellation request, and it can reduce the client's wait time if it has set the cancel timeout as RPC_C_CANCEL_INFINITE_TIMEOUT. Furthermore, if the server object detects a cancellation request before returning from a pending call, it can clean up any memory, marshaled interfaces, or handles it has created or obtained.</para>
      <para>
        <b>CoTestCancel</b> calls <see cref="CoGetCallContext" /> to obtain the <see cref="ICancelMethodCalls" /> interface on the current cancel object and then calls <see cref="ICancelMethodCalls.TestCancel" />. Objects that implement custom marshaling should first call <see cref="CoSwitchCallContext" /> to install the appropriate call context object.</para>
      <para>This function does not test cancellation for asynchronous calls.</para>
    </remarks>
    <seealso cref="ICancelMethodCalls" />
  </member>
  <member name="Windows.CoUninitialize">
    <summary>
      <para>Closes the COM library on the current thread, unloads all DLLs loaded by the thread, frees any other resources that the thread maintains, and forces all RPC connections on the thread to close.</para>
    </summary>
    <remarks>
      <para>A thread must call <b>CoUninitialize</b> once for each successful call it has made to the <see cref="CoInitialize" /> or <see cref="CoInitializeEx" /> function, including any call that returns S_FALSE. Only the <b>CoUninitialize</b> call corresponding to the <b>CoInitialize</b> or <b>CoInitializeEx</b> call that initialized the library can close it.</para>
      <para>Calls to <see cref="OleInitialize" /> must be balanced by calls to <see cref="OleUninitialize" />. The <b>OleUninitialize</b> function calls <b>CoUninitialize</b> internally, so applications that call <b>OleUninitialize</b> do not also need to call <b>CoUninitialize</b>.</para>
      <para>
        <b>CoUninitialize</b> should be called on application shutdown, as the last call made to the COM library after the application hides its main windows and falls through its main message loop. If there are open conversations remaining, <b>CoUninitialize</b> starts a modal message loop and dispatches any pending messages from the containers or server for this COM application. By dispatching the messages, <b>CoUninitialize</b> ensures that the application does not quit before receiving all of its pending messages. Non-COM messages are discarded.</para>
      <para>Because there is no way to control the order in which in-process servers are loaded or unloaded, do not call <see cref="CoInitialize" />, <see cref="CoInitializeEx" />, or <b>CoUninitialize</b> from the <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function.</para>
    </remarks>
    <seealso cref="CoInitialize" />
    <seealso cref="CoInitializeEx" />
    <seealso cref="OleUninitialize" />
  </member>
  <member name="Windows.CoUnmarshalHresult">
    <summary>
      <para>Unmarshals an <b>HRESULT</b> type from the specified stream.</para>
    </summary>
    <param name="pstm">
      <para>A pointer to the stream from which the <b>HRESULT</b> is to be unmarshaled.</para>
    </param>
    <param name="phresult">
      <para>A pointer to the unmarshaled <b>HRESULT</b>.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The <b>HRESULT</b> was unmarshaled successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>STG_E_INVALIDPOINTER</b>
            </para>
          </description>
          <description>
            <i>pStm</i> is an invalid pointer.
</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You do not explicitly call this function unless you are performing custom marshaling (that is, writing your own implementation of <see cref="IMarshal" />), and your implementation needs to unmarshal an <b>HRESULT</b>.</para>
      <para>You must use <b>CoUnmarshalHresult</b> to unmarshal <b>HRESULT</b> values previously marshaled by a call to the <see cref="CoMarshalHresult" /> function.</para>
      <para>This function performs the following tasks:</para>
      <list type="number">
        <item>
          <description>
            <para>an <b>HRESULT</b> from a stream.</para>
          </description>
        </item>
        <item>
          <description>Returns the <b>HRESULT</b>.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="CoMarshalHresult" />
    <seealso cref="IStream" />
  </member>
  <member name="Windows.CoWaitForMultipleHandles">
    <summary>
      <para>Waits for specified handles to be signaled or for a specified timeout period to elapse.</para>
    </summary>
    <param name="dwFlags">
      <para>The wait options. Possible values are taken from the <see cref="COWAIT_FLAGS" /> enumeration.</para>
    </param>
    <param name="dwTimeout">
      <para>The timeout period, in milliseconds.</para>
    </param>
    <param name="cHandles">
      <para>The number of elements in the <i>pHandles</i> array.</para>
    </param>
    <param name="pHandles">
      <para>An array of handles.</para>
    </param>
    <param name="lpdwindex">
      <para>A pointer to a variable that, when the returned status is S_OK, receives a value indicating the event that caused the function to return. This value is usually the index into <i>pHandles</i> for the handle that was signaled.</para>
      <para>If <i>pHandles</i> includes one or more handles to mutex objects, a value between WAIT_ABANDONED_0 and (WAIT_ABANDONED_0 + nCount - 1) indicates the index into <i>pHandles</i> for the mutex that was abandoned.</para>
      <para>If the <see cref="COWAIT_ALERTABLE" /> flag is set in <i>dwFlags</i>, a value of WAIT_IO_COMPLETION indicates the wait was ended by one or more user-mode asynchronous procedure calls (APC) queued to the thread.</para>
      <para>See <see cref="WaitForMultipleObjectsEx" /> for more information.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <para>
        <b>Note</b>  The return value of <b>CoWaitForMultipleHandles</b> can be nondeterministic if the <see cref="COWAIT_ALERTABLE" /> flag is set in <i>dwFlags</i>, or if <i>pHandles</i> includes one or more handles to mutex objects. The recommended workaround is to call <see cref="SetLastError(ERROR_SUCCESS)" /> before <b>CoWaitForMultipleHandles</b>.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The required handle or handles were signaled.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <i>pHandles</i> was <b>NULL</b>, <i>lpdwindex</i> was <b>NULL</b>, or <i>dwFlags</i> was not a value from the <see cref="COWAIT_FLAGS" /> enumeration.
</description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_E_NO_SYNC</b>
            </para>
          </description>
          <description>
            <para>The value of <i>pHandles</i> was 0.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_S_CALLPENDING</b>
            </para>
          </description>
          <description>
            <para>The timeout period elapsed before the required handle or handles were signaled.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Depending on which flags are set in the dwFlags parameter, <b>CoWaitForMultipleHandles</b> blocks the calling thread until one of the following events occurs:</para>
      <list type="bullet">
        <item>
          <description>One or all of the handles is signaled. In the case of mutex objects, this condition is also satisfied by a mutex being abandoned.</description>
        </item>
        <item>
          <description>An asynchronous procedure call (APC) has been queued to the calling thread with a call to the <see cref="QueueUserAPC" /> function.</description>
        </item>
        <item>
          <description>The timeout period expires.</description>
        </item>
      </list>
      <para>If the caller resides in a single-thread apartment, <b>CoWaitForMultipleHandles</b> enters the COM modal loop, and the thread's message loop will continue to dispatch messages using the thread's message filter. If no message filter is registered for the thread, the default COM message processing is used.</para>
      <para>If the calling thread resides in a multithread apartment (MTA), <b>CoWaitForMultipleHandles</b> calls the  <see cref="WaitForMultipleObjectsEx" /> function.</para>
    </remarks>
    <seealso cref="COWAIT_FLAGS" />
  </member>
  <member name="Windows.CoWaitForMultipleObjects">
    <summary>
      <para>A replacement for <see cref="CoWaitForMultipleHandles" />. This replacement API hides the options for <b>CoWaitForMultipleHandles</b> that are not supported in ASTA.</para>
    </summary>
    <param name="dwFlags">
      <para>
        <see cref="CWMO_FLAGS" /> flag controlling whether call/window message reentrancy is enabled from this wait. By default, neither COM calls nor window messages are dispatched from <b>CoWaitForMultipleObjects</b> in ASTA.</para>
    </param>
    <param name="dwTimeout">
      <para>The timeout in milliseconds of the wait.</para>
    </param>
    <param name="cHandles">
      <para>The length of the <i>pHandles</i> array. Must be &lt;= 56.</para>
    </param>
    <param name="pHandles">
      <para>An array of handles to waitable kernel objects.</para>
    </param>
    <param name="lpdwindex">
      <para>Receives the index of the handle that satisfied the wait.</para>
    </param>
    <returns>
      <para>Same return values as <see cref="CoWaitForMultipleHandles" />, except the ASTA-specific CO_E_NOTSUPPORTED cases instead return E_INVALIDARG from all apartment types.</para>
    </returns>
  </member>
  <member name="Windows.CreateStreamOnHGlobal">
    <summary>
      <para>The <b>CreateStreamOnHGlobal</b> function creates a stream object that uses an HGLOBAL memory handle to store the stream contents. This object is the OLE-provided implementation of the <see cref="IStream" /> interface.</para>
      <para>The returned stream object supports both reading and writing, is not transacted, and does not support region locking. The object calls the <see cref="GlobalReAlloc" /> function to grow the memory block as required.</para>
      <para>
        <b>Tip</b>  Consider using the <see cref="SHCreateMemStream" /> function, which produces better performance, or for Windows Store apps, consider using <a href="https://docs.microsoft.com//uwp/api/windows.storage.streams.inmemoryrandomaccessstream">InMemoryRandomAccessStream</a>.</para>
    </summary>
    <param name="hGlobal">
      <para>A memory handle allocated by the <see cref="GlobalAlloc" /> function, or if <b>NULL</b> a new handle is to be allocated instead. The handle must be allocated as moveable and nondiscardable.</para>
    </param>
    <param name="fDeleteOnRelease">
      <para>A value that indicates whether the underlying handle for this stream object should be automatically freed when the stream object is released. If set to <b>FALSE</b>, the caller must free the <i>hGlobal</i> after the final release. If set to <b>TRUE</b>, the final release will automatically free the underlying handle. See the Remarks for further discussion of the case where <i>fDeleteOnRelease</i> is <b>FALSE</b>.</para>
    </param>
    <param name="ppstm">
      <para>The address of
<see cref="IStream" />* pointer variable that receives the interface pointer to the new stream object. Its value cannot be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>This function supports the standard return values E_INVALIDARG and E_OUTOFMEMORY, as well as the following.</para>
    </returns>
    <remarks>
      <para>If <i>hGlobal</i> is <b>NULL</b>, the function allocates a new memory handle and the stream is initially empty.</para>
      <para>If <i>hGlobal</i> is not <b>NULL</b>, the initial contents of the stream are the current contents of the memory block. Thus, <b>CreateStreamOnHGlobal</b> can be used to open an existing stream in memory. The memory handle and its contents are undisturbed by the creation of the new stream object.</para>
      <para>The initial size of the stream is the size of <i>hGlobal</i> as returned by the <see cref="GlobalSize" /> function. Because of rounding, this is not necessarily the same size that was originally allocated for the handle. If the logical size of the stream is important, follow the call to this function with a call to the
<see cref="IStream.SetSize" /> method.</para>
      <para>The new stream object’s initial seek position is the beginning of the stream.</para>
      <para>After creating the stream object with
<b>CreateStreamOnHGlobal</b>, call
<see cref="GetHGlobalFromStream" /> to retrieve the memory handle associated with the stream object.</para>
      <para>If a memory handle is passed to  <b>CreateStreamOnHGlobal</b> or if <see cref="GetHGlobalFromStream" /> is called, the memory handle of this function can be directly accessed by the caller while it is still in use by the stream object. Appropriate caution should be exercised in the use of this capability and its implications:</para>
      <list type="bullet">
        <item>
          <description>Do not free the <i>hGlobal</i> memory handle during the lifetime of the stream object. <see cref="IStream.Release" /> must be called before freeing the memory handle.</description>
        </item>
        <item>
          <description>Do not call <see cref="GlobalReAlloc" /> to change the size of the memory handle during the lifetime of the stream object or its clones.  This may cause application crashes or memory corruption. Avoid creating multiple stream objects separately on the same memory handle, because the <see cref="IStream.Write" /> and <see cref="IStream.SetSize" /> methods may internally call <b>GlobalReAlloc</b>.  The <see cref="IStream.Clone" /> method can be used to create a new stream object based on the same memory handle that will properly coordinate its access with the original stream object.</description>
        </item>
        <item>
          <description>If possible, avoid accessing the memory block during the lifetime of the stream object, because the object may internally call <see cref="GlobalReAlloc" /> and do not make assumptions about its size and location.  If the memory block must be accessed, the memory access calls should be surrounded by calls to <see cref="GlobalLock" /> and <see cref="GlobalUnLock" />.</description>
        </item>
        <item>
          <description>Avoid calling the object’s methods while you have the memory handle locked with <see cref="GlobalLock" />.  This can cause method calls to fail unpredictably.</description>
        </item>
      </list>
      <para>If the <i>fDeleteOnRelease</i> parameter is <b>FALSE</b>, the caller is responsible for freeing the underlying memory handle, even if the <i>hGlobal</i> parameter is <b>NULL</b>. Use the <b>GetHGlobalFromStream</b> function to obtain the underlying memory handle and <b>GlobalFree</b> that memory after the last reference to the stream is released. If the caller sets the <i>fDeleteOnRelease</i> parameter to <b>TRUE</b>, the final release will automatically free the underlying memory handle.</para>
      <para>The memory handle passed as the <i>hGlobal</i> parameter must be allocated as movable and nondiscardable, as shown in the following example:</para>
      <code>HGLOBAL    hMem = .GlobalAlloc(GMEM_MOVEABLE,iSize);
if (!hMem)
    AfxThrowMemoryException();

LPVOID pImage = .GlobalLock(hMem);
... // Fill memory
.GlobalUnlock(hMem);

CComPtr&lt;IStream&gt; spStream;
HRESULT hr = .CreateStreamOnHGlobal(hMem,FALSE,&amp;amp;amp;amp;amp;amp;spStream);
</code>
      <para>
        <b>CreateStreamOnHGlobal</b> will accept a memory handle allocated with <see cref="GMEM_FIXED" />, but this usage is not recommended. HGLOBALs allocated with <b>GMEM_FIXED</b> are not really handles and their value can change when they are reallocated. If the memory handle was allocated with <b>GMEM_FIXED</b> and <i>fDeleteOnRelease</i> is <b>FALSE</b>,  the caller must call <see cref="GetHGlobalFromStream" /> to get the correct handle in order to free it.</para>
      <para>Prior to Windows 7 and Windows Server 2008 R2, this implementation did not zero memory when calling <see cref="GlobalReAlloc" /> to grow the memory block. Increasing the size of the stream with <see cref="IStream.SetSize" /> or by writing to a location past the current end of the stream may leave portions of the newly allocated memory uninitialized.</para>
    </remarks>
    <seealso cref="GetHGlobalFromStream" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Stg/istream-compound-file-implementation">IStream - Compound File Implementation</seealso>
    <seealso cref="IStream.SetSize" />
    <seealso href="https://docs.microsoft.com//uwp/api/windows.storage.streams.inmemoryrandomaccessstream">InMemoryRandomAccessStream</seealso>
  </member>
  <member name="Windows.DllCanUnloadNow">
    <summary>
      <para>Determines whether the DLL that implements this function is in use. If not, the caller can unload the DLL from memory.</para>
      <para>OLE does not provide this function. DLLs that support the OLE Component Object Model (COM) should implement and export <b>DllCanUnloadNow</b>.</para>
    </summary>
    <returns>
      <para>If the function succeeds, the return value is S_OK. Otherwise, it is S_FALSE.</para>
    </returns>
    <remarks>
      <para>A call to <b>DllCanUnloadNow</b> determines whether the DLL from which it is exported is still in use. A DLL is no longer in use when it is not managing any existing objects (the reference count on all of its objects is 0).</para>
      <h3>Notes to Callers</h3>
      <para>You should not have to call <b>DllCanUnloadNow</b> directly. OLE calls it only through a call to the <see cref="CoFreeUnusedLibraries" /> function. When it returns S_OK, <b>CoFreeUnusedLibraries</b> frees the DLL.</para>
      <h3>Notes to Implementers</h3>
      <para>You must implement <b>DllCanUnloadNow</b> in, and export it from, DLLs that are to be dynamically loaded through a call to the <see cref="CoGetClassObject" /> function. (You also need to implement and export the <see cref="DllGetClassObject" /> function in the same DLL).</para>
      <para>If a DLL loaded through a call to <see cref="CoGetClassObject" /> fails to export <b>DllCanUnloadNow</b>, the DLL will not be unloaded until the application calls the <see cref="CoUninitialize" /> function to release the OLE libraries.</para>
      <para>
        <b>DllCanUnloadNow</b> should return S_FALSE if there are any existing references to objects that the DLL manages.</para>
    </remarks>
    <seealso cref="DllGetClassObject" />
  </member>
  <member name="Windows.DllGetClassObject">
    <summary>
      <para>Retrieves the class object from a DLL object handler or object application.</para>
      <para>OLE does not provide this function. DLLs that support the OLE Component Object Model (COM) must implement <b>DllGetClassObject</b> in OLE object handlers or DLL applications.</para>
    </summary>
    <param name="rclsid">
      <para>The CLSID that will associate the correct data and code.</para>
    </param>
    <param name="riid">
      <para>A reference to the identifier of the interface that the caller is to use to communicate with the class object. Usually, this is IID_IClassFactory (defined in the OLE headers as the interface identifier for <see cref="IClassFactory" />).</para>
    </param>
    <param name="ppv">
      <para>The address of a pointer variable that receives the interface pointer requested in riid. Upon successful return, *<i>ppv</i> contains the requested interface pointer. If an error occurs, the interface pointer is <b>NULL</b>.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The object was retrieved successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CLASS_E_CLASSNOTAVAILABLE</b>
            </para>
          </description>
          <description>
            <para>The DLL does not support the class (object definition).</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If a call to the <see cref="CoGetClassObject" /> function finds the class object that is to be loaded in a DLL, <b>CoGetClassObject</b> uses the DLL's exported <b>DllGetClassObject</b> function.</para>
      <h3>Notes to Callers</h3>
      <para>You should not call <b>DllGetClassObject</b> directly. When an object is defined in a DLL, <see cref="CoGetClassObject" /> calls the <see cref="CoLoadLibrary" /> function to load the DLL, which, in turn, calls <b>DllGetClassObject</b>.</para>
      <h3>Notes to Implementers</h3>
      <para>You need to implement <b>DllGetClassObject</b> in (and export it from) DLLs that support COM.</para>
      <h4>Examples</h4>
      <para>The following is an example (in C++) of an implementation of <b>DllGetClassObject</b>. In this example, <b>DllGetClassObject</b> creates a class object and calls its <see cref="QueryInterface" /> method to retrieve a pointer to the interface requested in riid. The implementation releases the reference it holds to the <see cref="IClassFactory" /> interface because it returns a reference-counted pointer to <b>IClassFactory</b> to the caller.</para>
      <code>HRESULT_export CALLBACK DllGetClassObject
    (REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppvObj = NULL;

    CClassFactory *pClassFactory = new CClassFactory(rclsid);
    if (pClassFactory != NULL)   {
        hr = pClassFactory-&gt;QueryInterface(riid, ppvObj);
        pClassFactory-&gt;Release();
    }
    return hr;
}

</code>
    </remarks>
    <seealso cref="CoGetClassObject" />
    <seealso cref="DllCanUnloadNow" />
  </member>
  <member name="Windows.FreePropVariantArray">
    <summary>
      <para>The <b>FreePropVariantArray</b> function calls
<see cref="PropVariantClear" /> on each of the
<see cref="PROPVARIANT" /> structures in the <i>rgvars</i> array to make the value zero for each of the members of the array.</para>
    </summary>
    <param name="cVariants">
      <para>Count of elements in the
<see cref="PROPVARIANT" /> array (<i>rgvars</i>).</para>
    </param>
    <param name="rgvars">
      <para>Pointer to an initialized array of
<see cref="PROPVARIANT" /> structures for which any deallocatable elements are to be freed. On exit, all zeroes are written to the
<b>PROPVARIANT</b> structure (thus tagging them as VT_EMPTY).</para>
    </param>
    <returns>
      <para>This function returns HRESULT.</para>
    </returns>
    <remarks>
      <para>
        <b>FreePropVariantArray</b> calls
<see cref="PropVariantClear" /> on an array of
<see cref="PROPVARIANT" /> structures to clear all the valid members. All valid
<b>PROPVARIANT</b> structures are freed. If any of the
<b>PROPVARIANT</b> structures contain illegal VT types, valid members are freed and the function returns STG_E_INVALIDPARAMETER.</para>
      <para>Passing <b>NULL</b> for <i>rgvars</i> is legal, and produces a return code of S_OK.</para>
    </remarks>
    <seealso cref="PropVariantClear" />
  </member>
  <member name="Windows.GetHGlobalFromStream">
    <summary>
      <para>The <b>GetHGlobalFromStream</b> function retrieves the global memory handle to a stream that was created through a call to the
<see cref="CreateStreamOnHGlobal" /> function.</para>
    </summary>
    <param name="pstm">
      <para>
        <see cref="IStream" /> pointer to the stream object previously created by a call to the
<see cref="CreateStreamOnHGlobal" /> function.</para>
    </param>
    <param name="phglobal">
      <para>Pointer to the current memory handle used by the specified stream object.</para>
    </param>
    <returns>
      <para>This function returns HRESULT.</para>
    </returns>
    <remarks>
      <para>The handle <b>GetHGlobalFromStream</b> returns may be different from the original handle due to intervening <see cref="GlobalReAlloc" /> calls.</para>
      <para>This function can be called only from within the same process from which the byte array was created.</para>
    </remarks>
    <seealso cref="CreateStreamOnHGlobal" />
    <seealso cref="GlobalReAlloc" />
  </member>
  <member name="Windows.IIDFromString">
    <summary>
      <para>Converts a string generated by the <see cref="StringFromIID" /> function back into the original interface identifier (IID).</para>
    </summary>
    <param name="lpsz">
      <para>A pointer to the string representation of the IID.</para>
    </param>
    <param name="lpiid">
      <para>A pointer to the requested IID on return.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</para>
    </returns>
    <remarks>
      <para>The function converts the interface identifier in a way that guarantees different interface identifiers will always be converted to different strings.</para>
    </remarks>
    <seealso cref="StringFromIID" />
  </member>
  <member name="Windows.IID_PPV_ARGS">
    <summary>
      <para>Used to retrieve an interface pointer, supplying the IID value of the requested interface automatically based on the type of the interface pointer used. This avoids a common coding error by checking the type of the value passed at compile time.</para>
    </summary>
    <param name="ppType">
      <para>An address of an interface pointer whose type <b>T</b> is used to determine the type of object being requested. The macro returns the interface pointer through this parameter.</para>
    </param>
    <remarks>
      <para>A common syntax in methods that retrieve an interface pointer (most notably <see cref="QueryInterface" /> and <see cref="CoCreateInstance" />) includes two parameters:</para>
      <list type="bullet">
        <item>
          <description>An [in] parameter, normally of type <b>REFIID</b>, to specify the IID of the interface to retrieve.</description>
        </item>
        <item>
          <description>An [out] parameter, normally of type <b>void**</b>, to receive the interface pointer.</description>
        </item>
      </list>
      <para>This macro computes the IID based on the type of interface pointer, which prevents coding errors in which the IID and interface pointer type do not match. Windows developers should always use this macro with any method that requires separate IID and interface pointer parameters.</para>
      <para>While Windows 7 is the first inclusion of this macro in a public header, it can be used on older systems by defining it manually in your project headers or source code.</para>
      <para>The following example shows the use of <b>IID_PPV_ARGS</b> to create the memory property store object using <see cref="IPropertyStore" />.</para>
      <code>IPropertyStore *pPropertyStore;

CoCreateInstance(CLSID_PropertyStore, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;pPropertyStore));
</code>
    </remarks>
  </member>
  <member name="Windows.ProgIDFromCLSID">
    <summary>
      <para>Retrieves the ProgID for a given CLSID.</para>
    </summary>
    <param name="clsid">
      <para>The CLSID for which the ProgID is to be requested.</para>
    </param>
    <param name="lplpszProgID">
      <para>The address of a pointer variable that receives the ProgID string. The string that represents <i>clsid</i> includes enclosing braces.</para>
    </param>
    <returns>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The ProgID was returned successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_CLASSNOTREG</b>
            </para>
          </description>
          <description>
            <para>Class not registered in the registry.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>REGDB_E_READREGDB</b>
            </para>
          </description>
          <description>
            <para>There was an error reading from the registry.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Every OLE object class listed in the <b>Insert Object</b> dialog box must have a programmatic identifier (ProgID), a string that uniquely identifies a given class, stored in the registry. In addition to determining the eligibility for the <b>Insert Object</b> dialog box, the ProgID can be used as an identifier in a macro programming language to identify a class. Finally, the ProgID is also the class name used for an object of an OLE class that is placed in an OLE 1 container.</para>
      <para>
        <b>ProgIDFromCLSID</b> uses entries in the registry to do the conversion. OLE application authors are responsible for ensuring that the registry is configured correctly in the application's setup program.</para>
      <para>The ProgID string must be different than the class name of any OLE 1 application, including the OLE 1 version of the same application, if there is one. In addition, a ProgID string must not contain more than 39 characters, start with a digit, or, except for a single period, contain any punctuation (including underscores).</para>
      <para>The ProgID must never be shown to the user in the user interface. If you need a short displayable string for an object, call <see cref="IOleObject.GetUserType" />.</para>
      <para>Call the <see cref="CLSIDFromProgID" /> function to find the CLSID associated with a given ProgID. Be sure to free the returned ProgID  when you are finished with it by calling the <see cref="CoTaskMemFree" /> function.</para>
    </remarks>
    <seealso cref="CLSIDFromProgID" />
  </member>
  <member name="Windows.PropVariantClear">
    <summary>
      <para>The <b>PropVariantClear</b> function
frees all elements that can be freed in a given
<see cref="PROPVARIANT" /> structure.   For complex elements with known element pointers, the underlying elements are freed prior to freeing the containing element.</para>
    </summary>
    <param name="pvar">
      <para>A pointer to an initialized
<see cref="PROPVARIANT" /> structure for which any deallocatable elements are to be freed. On return, all zeroes are written to the
<b>PROPVARIANT</b> structure.</para>
    </param>
    <returns>
      <para>This function returns HRESULT.</para>
    </returns>
    <remarks>
      <para>At any level of indirection, <b>NULL</b> pointers are ignored. For example, the <i>pvar</i> parameter  points to a <see cref="PROPVARIANT" /> structure of type <b>VT_CF</b>. The  <b>pclipdata</b> member of the <b>PROPVARIANT</b> structure points to a <b>CLIPDATA</b> structure. The <i>pClipData</i> pointer in the <b>CLIPDATA</b> structure is  <b>NULL</b>.  In this example, the <i>pClipData</i> pointer is ignored.  However, the <b>CLIPDATA</b> structure pointed to by the <b>pclipdata</b> member of the <b>PROPVARIANT</b> structure is freed.</para>
      <para>On return, this function writes zeroes to the specified
<see cref="PROPVARIANT" /> structure, so the VT-type is <b>VT_EMPTY</b>.</para>
      <para>Passing <b>NULL</b> as the <i>pvar</i> parameter produces a return code of S_OK.</para>
      <para>
        <b>Note</b>  Do not use this function to initialize
<see cref="PROPVARIANT" /> structures. Instead, initialize these structures using the
<see cref="PropVariantInit" /> macro (defined in Propidl.h).</para>
    </remarks>
    <seealso cref="FreePropVariantArray" />
  </member>
  <member name="Windows.PropVariantCopy">
    <summary>
      <para>The
<b>PropVariantCopy</b> function
copies the contents of one
<see cref="PROPVARIANT" /> structure to another.</para>
    </summary>
    <param name="pvarDest">
      <para>Pointer to an uninitialized
<see cref="PROPVARIANT" /> structure that receives the copy.</para>
    </param>
    <param name="pvarSrc">
      <para>Pointer to the
<see cref="PROPVARIANT" /> structure to be copied.</para>
    </param>
    <returns>
      <para>This function returns HRESULT.</para>
    </returns>
    <remarks>
      <para>Copies a
<see cref="PROPVARIANT" /> structure by value so the original <i>pvarSrc</i> and new <i>pvarDest</i> parameters may be freed independently with calls to
<see cref="PropVariantClear" />.
<b>PropVariantCopy</b> does not free the destination as the <see cref="VariantCopy" /> function does. For nonsimple
<b>PROPVARIANT</b> types such as VT_STREAM, VT_STORAGE, and so forth, which require a subobject, the copy is made by reference. The pointer is copied, and <see cref="IUnknown.AddRef" /> is called on it. It is illegal to pass <b>NULL</b> for either <i>pvarDest</i> or <i>pvarSrc</i>.</para>
    </remarks>
    <seealso cref="PROPVARIANT" />
    <seealso cref="PropVariantClear" />
  </member>
  <member name="Windows.RoGetAgileReference">
    <summary>
      <para>Creates an agile reference for an object specified by the given interface.</para>
    </summary>
    <param name="options">
      <para>The registration options.</para>
    </param>
    <param name="riid">
      <para>The interface ID of the object for which an agile reference is being obtained.</para>
    </param>
    <param name="pUnk">
      <para>Pointer to the interface to be encapsulated in an agile reference. It must be the same type as <i>riid</i>. It may be a pointer to an in-process object or a pointer to a proxy of an object.</para>
    </param>
    <param name="ppAgileReference">
      <para>The agile reference for the object. Call the <a href="https://docs.microsoft.com//windows/desktop/WinRT/iagilereference-resolve">Resolve</a> method to localize the object into the apartment in which <b>Resolve</b> is called.</para>
    </param>
    <returns>
      <para>This function can return one of these values.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>S_OK</para>
          </description>
          <description>
            <para>The function completed successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>E_INVALIDARG</para>
          </description>
          <description>
            <para>The <i>options</i> parameter in invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>E_OUTOFMEMORY</para>
          </description>
          <description>
            <para>The agile reference couldn't be constructed due to an out-of-memory condition.</para>
          </description>
        </item>
        <item>
          <description>
            <para>E_NOINTERFACE</para>
          </description>
          <description>
            <para>The <i>pUnk</i> parameter doesn't support the interface ID specified by the <i>riid</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>CO_E_NOT_SUPPORTED</para>
          </description>
          <description>
            <para>The object implements the <see cref="INoMarshal" /> interface.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Call the <b>RoGetAgileReference</b> function on an existing object to request an agile reference to the object. The object may or may not be agile, but the returned <see cref="IAgileReference" /> is agile. The agile reference can be passed to another apartment within the same process, where the original object is retrieved by using the <b>IAgileReference</b> interface.</para>
      <para>This is conceptually similar to the existing Global Interface Table (GIT). Rather than interacting with the GIT, an <see cref="IAgileReference" /> is obtained and used to retrieve the object directly. Just as the GIT is per-process only, agile references are per-process and can't be marshaled.</para>
      <para>The agile reference feature provides a performance improvement over the GIT. The agile reference performs eager marshaling by default, which saves a cross-apartment call in cases where the object is retrieved from the agile reference in an apartment that's different from where the agile reference was created. For additional performance improvement, users of the <b>RoGetAgileReference</b> function can use the same interface to create an <see cref="IAgileReference" /> and resolve the original object. This saves an additional <see cref="QueryInterface" /> call to obtain the desired interface from the resolved object.</para>
      <para>For example, you have a non-agile object named CDemoExample, which implements the IDemo and IExample interfaces. Call the <b>RoGetAgileReference</b> function and pass the object, with IID_IDemo. You get back an <see cref="IAgileReference" /> interface pointer, which is agile, so you can pass it to a different apartment. In the other apartment, call the <a href="https://docs.microsoft.com//windows/desktop/WinRT/iagilereference-resolve">Resolve</a> method, with IID_IExample. You get back an IExample pointer that you can use within this apartment. This IExample pointer is an IExample proxy that's connected to the original CDemoExample object. The agile reference handles the complexity of operations like manually marshaling to a stream and unmarshaling on the other side of the apartment boundary.</para>
    </remarks>
    <seealso cref="AgileReferenceOptions" />
    <seealso cref="IAgileReference" />
  </member>
  <member name="Windows.StringFromCLSID">
    <summary>
      <para>Converts a CLSID into a string of printable characters. Different CLSIDs always convert to different strings.</para>
    </summary>
    <param name="rclsid">
      <para>The CLSID to be converted.</para>
    </param>
    <param name="lplpsz">
      <para>The address of a pointer variable that receives a pointer to the resulting string. The string that represents <i>rclsid</i> includes enclosing braces.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_OUTOFMEMORY and S_OK.</para>
    </returns>
    <remarks>
      <para>
        <b>StringFromCLSID</b> calls the <see cref="StringFromGUID2" /> function to convert a globally unique identifier (GUID) into a string of printable characters.</para>
      <para>The caller is responsible for freeing the memory allocated for the string by calling the <see cref="CoTaskMemFree" /> function.</para>
    </remarks>
    <seealso cref="CLSIDFromString" />
    <seealso cref="StringFromGUID2" />
  </member>
  <member name="Windows.StringFromGUID2">
    <summary>
      <para>Converts a globally unique identifier (GUID) into a string of printable characters.</para>
    </summary>
    <param name="rguid">
      <para>The GUID to be converted.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a caller-allocated string variable to receive the resulting string. The string that represents <i>rguid</i> includes enclosing braces.</para>
    </param>
    <param name="cchMax">
      <para>The number of characters available in the <i>lpsz</i> buffer.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters in the returned string, including the null terminator. If the buffer is too small to contain the string, the return value is 0.</para>
    </returns>
    <seealso cref="StringFromCLSID" />
  </member>
  <member name="Windows.StringFromIID">
    <summary>
      <para>Converts an interface identifier into a string of printable characters.</para>
    </summary>
    <param name="rclsid">
      <para>The interface identifier to be converted.</para>
    </param>
    <param name="lplpsz">
      <para>The address of a pointer variable that receives a pointer to the resulting string. The string that represents <i>rclsid</i> includes enclosing braces.</para>
    </param>
    <returns>
      <para>This function can return the standard return values E_OUTOFMEMORY and S_OK.</para>
    </returns>
    <remarks>
      <para>The caller is responsible for freeing the memory allocated for the string by calling the <see cref="CoTaskMemFree" /> function.</para>
    </remarks>
    <seealso cref="IIDFromString" />
  </member>
</doc>