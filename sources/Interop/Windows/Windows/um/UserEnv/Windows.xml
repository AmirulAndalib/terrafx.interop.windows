<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.CreateAppContainerProfile">
    <summary>
      <para>Creates a per-user, per-app profile for Windows Store apps.</para>
    </summary>
    <param name="pszAppContainerName">
      <para>The name of the app container. To ensure uniqueness, it is recommended that this string contains the app name as well as the publisher. This string can be up to 64 characters in length.  Further, it must fit into the pattern described by the regular expression "[-_. A-Za-z0-9]+".</para>
    </param>
    <param name="pszDisplayName">
      <para>The display name. This string can be up to 512 characters in length.</para>
    </param>
    <param name="pszDescription">
      <para>A description for the app container. This string can be up to 2048 characters in length.</para>
    </param>
    <param name="pCapabilities">
      <para>The SIDs that define the requested capabilities.</para>
    </param>
    <param name="dwCapabilityCount">
      <para>The number of SIDs in <i>pCapabilities</i>.</para>
    </param>
    <param name="ppSidAppContainerSid">
      <para>The SID for the profile. This buffer must be freed using the <see cref="FreeSid" /> function.</para>
    </param>
    <returns>
      <para>If this function succeeds, it returns a standard HRESULT code, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The data store was created successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>The caller does not have permission to create the profile.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)</b>
            </para>
          </description>
          <description>
            <para>The application data store already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>The container name   is <b>NULL</b>,  or the container name,   the display name, or the description strings exceed their specified respective limits for length.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>A profile contains folders and registry storage that are per-user and per-app. The folders have ACLs that prevent them from being accessed by other users and apps. These folders can be accessed by calling <see cref="SHGetKnownFolderPath" />.</para>
      <para>The function creates a profile for the current user. To create a profile on behalf of another user, you must impersonate that user. To create profiles for multiple users of the same app, you must call <b>CreateAppContainerProfile</b> for each user.</para>
    </remarks>
    <seealso cref="DeleteAppContainerProfile" />
  </member>
  <member name="Windows.CreateEnvironmentBlock">
    <summary>
      <para>Retrieves the environment variables for the specified user. This block can then be passed to the <see cref="CreateProcessAsUser" /> function.</para>
    </summary>
    <param name="lpEnvironment">
      <para>Type: <b>LPVOID*</b></para>
      <para>When this function returns, receives a pointer to the new environment block. The environment block is an array of null-terminated Unicode strings. The list ends with two nulls (\0\0).</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, returned from the
<see cref="LogonUser" /> function. If this is a primary token, the token must have <b>TOKEN_QUERY</b> and <b>TOKEN_DUPLICATE</b> access. If the token is an impersonation token, it must have <b>TOKEN_QUERY</b> access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
      <para>If this parameter is <b>NULL</b>, the returned environment block contains system variables only.</para>
    </param>
    <param name="bInherit">
      <para>Type: <b>BOOL</b></para>
      <para>Specifies whether to inherit from the current process' environment. If this value is <b>TRUE</b>, the process inherits the current process' environment. If this value is <b>FALSE</b>, the process does not inherit the current process' environment.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To free the buffer when you have finished with the environment block, call the
<see cref="DestroyEnvironmentBlock" /> function.</para>
      <para>If the environment block is passed to
<see cref="CreateProcessAsUser" />, you must also specify the <b>CREATE_UNICODE_ENVIRONMENT</b> flag. After <b>CreateProcessAsUser</b> has returned, the new process has a copy of the environment block, and <see cref="DestroyEnvironmentBlock" /> can be safely called.</para>
      <para>User-specific environment variables such as %USERPROFILE% are set only when the user's profile is loaded. To load a user's profile, call the
<see cref="LoadUserProfile" /> function.</para>
    </remarks>
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DestroyEnvironmentBlock" />
    <seealso cref="LogonUser" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.CreateProfile">
    <summary>
      <para>Creates a new user profile.</para>
    </summary>
    <param name="pszUserSid">
      <para>Type: <b>LPCWSTR</b></para>
      <para>Pointer to the SID of the user as a string.</para>
    </param>
    <param name="pszUserName">
      <para>Type: <b>LPCWSTR</b></para>
      <para>The user name of the new user. This name is used as the base name for the profile directory.</para>
    </param>
    <param name="pszProfilePath">
      <para>Type: <b>LPWSTR</b></para>
      <para>When this function returns, contains a pointer to the full path of the profile.</para>
    </param>
    <param name="cchProfilePath">
      <para>Type: <b>DWORD</b></para>
      <para>Size of the buffer pointed to by <i>pszProfilePath</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or an error value otherwise, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>The caller does not have a sufficient permission level to create the profile.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)</b>
            </para>
          </description>
          <description>
            <para>A profile already exists for the specified user.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The caller must have administrator privileges to call this function.</para>
    </remarks>
  </member>
  <member name="Windows.DeleteAppContainerProfile">
    <summary>
      <para>Deletes the specified per-user, per-app profile.<b>Note</b>  Deleting a non-existent profile returns success.</para>
    </summary>
    <param name="pszAppContainerName">
      <para>The name given to the profile in the call to the <see cref="CreateAppContainerProfile" /> function. This string is at most 64 characters in length, and  fits into the pattern described by the regular expression "[-_. A-Za-z0-9]+".</para>
    </param>
    <returns>
      <para>If this function succeeds, it returns a standard HRESULT code, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED)</b>
            </para>
          </description>
          <description>
            <para>If the method is called from within an app container.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The profile was deleted successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>If the container name   is <b>NULL</b>, or if it exceeds its specified limit for length.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>To ensure the best results, close all file handles in the profile storage locations before calling the <b>DeleteAppContainerProfile</b> function. Otherwise, this function may not be able to completely remove the storage locations for the profile.</para>
      <para>This function deletes the profile for the current user. To delete the profile for another user, you must impersonate that user.</para>
      <para>If the function fails, the status of the profile is undetermined, and you should call <b>DeleteAppContainerProfile</b> again to complete the operation.</para>
    </remarks>
    <seealso cref="CreateAppContainerProfile" />
  </member>
  <member name="Windows.DeleteProfile">
    <summary>
      <para>Deletes the user profile and all user-related settings from the specified computer. The caller must have administrative privileges to delete a user's profile.</para>
    </summary>
    <param name="lpSidString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the user
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">SID</a>.</para>
    </param>
    <param name="lpProfilePath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the function obtains the path from the registry.</para>
    </param>
    <param name="lpComputerName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the name of the computer from which the profile is to be deleted. If this parameter is <b>NULL</b>, the local computer name is used.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>DeleteProfile</b> might fail when passed the security identifier (SID) of the local system account (S-1-5-18). For more information, see <a href="https://support.microsoft.com/kb/890212">KB890212</a>.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines DeleteProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.DeleteProfileA">
    <summary>
      <para>Deletes the user profile and all user-related settings from the specified computer. The caller must have administrative privileges to delete a user's profile.</para>
    </summary>
    <param name="lpSidString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the user
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">SID</a>.</para>
    </param>
    <param name="lpProfilePath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the function obtains the path from the registry.</para>
    </param>
    <param name="lpComputerName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the name of the computer from which the profile is to be deleted. If this parameter is <b>NULL</b>, the local computer name is used.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>DeleteProfile</b> might fail when passed the security identifier (SID) of the local system account (S-1-5-18). For more information, see <a href="https://support.microsoft.com/kb/890212">KB890212</a>.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines DeleteProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.DeleteProfileW">
    <summary>
      <para>Deletes the user profile and all user-related settings from the specified computer. The caller must have administrative privileges to delete a user's profile.</para>
    </summary>
    <param name="lpSidString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the user
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">SID</a>.</para>
    </param>
    <param name="lpProfilePath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the function obtains the path from the registry.</para>
    </param>
    <param name="lpComputerName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the name of the computer from which the profile is to be deleted. If this parameter is <b>NULL</b>, the local computer name is used.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>DeleteProfile</b> might fail when passed the security identifier (SID) of the local system account (S-1-5-18). For more information, see <a href="https://support.microsoft.com/kb/890212">KB890212</a>.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines DeleteProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.DeleteProfile">
    <summary>
      <para>Deletes the user profile and all user-related settings from the specified computer. The caller must have administrative privileges to delete a user's profile.</para>
    </summary>
    <param name="lpSidString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the user
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">SID</a>.</para>
    </param>
    <param name="lpProfilePath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the function obtains the path from the registry.</para>
    </param>
    <param name="lpComputerName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the name of the computer from which the profile is to be deleted. If this parameter is <b>NULL</b>, the local computer name is used.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>DeleteProfile</b> might fail when passed the security identifier (SID) of the local system account (S-1-5-18). For more information, see <a href="https://support.microsoft.com/kb/890212">KB890212</a>.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines DeleteProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.DeleteProfileA">
    <summary>
      <para>Deletes the user profile and all user-related settings from the specified computer. The caller must have administrative privileges to delete a user's profile.</para>
    </summary>
    <param name="lpSidString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the user
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">SID</a>.</para>
    </param>
    <param name="lpProfilePath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the function obtains the path from the registry.</para>
    </param>
    <param name="lpComputerName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the name of the computer from which the profile is to be deleted. If this parameter is <b>NULL</b>, the local computer name is used.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>DeleteProfile</b> might fail when passed the security identifier (SID) of the local system account (S-1-5-18). For more information, see <a href="https://support.microsoft.com/kb/890212">KB890212</a>.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines DeleteProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.DeleteProfileW">
    <summary>
      <para>Deletes the user profile and all user-related settings from the specified computer. The caller must have administrative privileges to delete a user's profile.</para>
    </summary>
    <param name="lpSidString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the user
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">SID</a>.</para>
    </param>
    <param name="lpProfilePath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the function obtains the path from the registry.</para>
    </param>
    <param name="lpComputerName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a string that specifies the name of the computer from which the profile is to be deleted. If this parameter is <b>NULL</b>, the local computer name is used.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>DeleteProfile</b> might fail when passed the security identifier (SID) of the local system account (S-1-5-18). For more information, see <a href="https://support.microsoft.com/kb/890212">KB890212</a>.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines DeleteProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.DeriveAppContainerSidFromAppContainerName">
    <summary>
      <para>Gets the SID of the specified profile.</para>
    </summary>
    <param name="pszAppContainerName">
      <para>The name of the profile.</para>
    </param>
    <param name="ppsidAppContainerSid">
      <para>The SID for the profile. This buffer must be freed using the <see cref="FreeSid" /> function.</para>
    </param>
    <returns>
      <para>This function can return one of these values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The operation completed successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>The <i>pszAppContainerName</i> parameter, or the  <i>ppsidAppContainerSid</i> parameter is either <b>NULL</b> or not valid.</para>
          </description>
        </item>
      </list>
    </returns>
  </member>
  <member name="Windows.DestroyEnvironmentBlock">
    <summary>
      <para>Frees environment variables created by the <see cref="CreateEnvironmentBlock" /> function.</para>
    </summary>
    <param name="lpEnvironment">
      <para>Type: <b>LPVOID</b></para>
      <para>Pointer to the environment block created by
<see cref="CreateEnvironmentBlock" />. The environment block is an array of null-terminated Unicode strings. The list ends with two nulls (\0\0).</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="CreateEnvironmentBlock" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.EnterCriticalPolicySection">
    <summary>
      <para>The
<b>EnterCriticalPolicySection</b> function pauses the application of policy to allow applications to safely read policy settings. Applications  call this function if they read multiple policy entries and must ensure that the settings are not changed while they are being read. This mutex protects Group Policy processing for all client-side extensions stored in a Group Policy Object (GPO).</para>
    </summary>
    <param name="bMachine">
      <para>A value that specifies whether to stop the application of computer policy or user policy. If this value is <b>TRUE</b>, the system stops applying computer policy. If this value is <b>FALSE</b>, the system stops applying user policy.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a policy section.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>The maximum amount of time an application can hold a critical section is 10 minutes. After 10 minutes, the system releases the critical section and policy can be applied again.</para>
      <para>To acquire both the computer and user critical section objects, acquire the user critical section object before acquiring the computer critical section object. This will help prevent a deadlock situation.</para>
      <para>To close the handle, call the
<see cref="LeaveCriticalPolicySection" /> function. The policy section handle cannot be used in any other Windows functions.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
    <seealso cref="LeaveCriticalPolicySection" />
  </member>
  <member name="Windows.ExpandEnvironmentStringsForUser">
    <summary>
      <para>Expands the source string by using the environment block established for the specified user.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, returned from the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have TOKEN_IMPERSONATE and TOKEN_QUERY access. In addition, as of Windows 7 the token must also have TOKEN_DUPLICATE access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
      <para>If <i>hToken</i> is <b>NULL</b>, the environment block contains system variables only.</para>
    </param>
    <param name="lpSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to the null-terminated source string to be expanded.</para>
    </param>
    <param name="lpDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a buffer that receives the expanded strings.</para>
    </param>
    <param name="dwSize">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies the size of the <i>lpDest</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example source string:</para>
      <code>%USERPROFILE%\ntuser.dat
</code>
      <para>When <b>ExpandEnvironmentStringsForUser</b> returns, the destination string expands as follows:</para>
      <code>C:\Documents and Settings\UserName\ntuser.dat
</code>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines ExpandEnvironmentStringsForUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.ExpandEnvironmentStringsForUserA">
    <summary>
      <para>Expands the source string by using the environment block established for the specified user.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, returned from the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have TOKEN_IMPERSONATE and TOKEN_QUERY access. In addition, as of Windows 7 the token must also have TOKEN_DUPLICATE access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
      <para>If <i>hToken</i> is <b>NULL</b>, the environment block contains system variables only.</para>
    </param>
    <param name="lpSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to the null-terminated source string to be expanded.</para>
    </param>
    <param name="lpDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a buffer that receives the expanded strings.</para>
    </param>
    <param name="dwSize">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies the size of the <i>lpDest</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example source string:</para>
      <code>%USERPROFILE%\ntuser.dat
</code>
      <para>When <b>ExpandEnvironmentStringsForUser</b> returns, the destination string expands as follows:</para>
      <code>C:\Documents and Settings\UserName\ntuser.dat
</code>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines ExpandEnvironmentStringsForUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.ExpandEnvironmentStringsForUserW">
    <summary>
      <para>Expands the source string by using the environment block established for the specified user.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, returned from the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have TOKEN_IMPERSONATE and TOKEN_QUERY access. In addition, as of Windows 7 the token must also have TOKEN_DUPLICATE access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
      <para>If <i>hToken</i> is <b>NULL</b>, the environment block contains system variables only.</para>
    </param>
    <param name="lpSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to the null-terminated source string to be expanded.</para>
    </param>
    <param name="lpDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a buffer that receives the expanded strings.</para>
    </param>
    <param name="dwSize">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies the size of the <i>lpDest</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example source string:</para>
      <code>%USERPROFILE%\ntuser.dat
</code>
      <para>When <b>ExpandEnvironmentStringsForUser</b> returns, the destination string expands as follows:</para>
      <code>C:\Documents and Settings\UserName\ntuser.dat
</code>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines ExpandEnvironmentStringsForUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.ExpandEnvironmentStringsForUser">
    <summary>
      <para>Expands the source string by using the environment block established for the specified user.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, returned from the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have TOKEN_IMPERSONATE and TOKEN_QUERY access. In addition, as of Windows 7 the token must also have TOKEN_DUPLICATE access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
      <para>If <i>hToken</i> is <b>NULL</b>, the environment block contains system variables only.</para>
    </param>
    <param name="lpSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to the null-terminated source string to be expanded.</para>
    </param>
    <param name="lpDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a buffer that receives the expanded strings.</para>
    </param>
    <param name="dwSize">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies the size of the <i>lpDest</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example source string:</para>
      <code>%USERPROFILE%\ntuser.dat
</code>
      <para>When <b>ExpandEnvironmentStringsForUser</b> returns, the destination string expands as follows:</para>
      <code>C:\Documents and Settings\UserName\ntuser.dat
</code>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines ExpandEnvironmentStringsForUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.ExpandEnvironmentStringsForUserA">
    <summary>
      <para>Expands the source string by using the environment block established for the specified user.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, returned from the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have TOKEN_IMPERSONATE and TOKEN_QUERY access. In addition, as of Windows 7 the token must also have TOKEN_DUPLICATE access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
      <para>If <i>hToken</i> is <b>NULL</b>, the environment block contains system variables only.</para>
    </param>
    <param name="lpSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to the null-terminated source string to be expanded.</para>
    </param>
    <param name="lpDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a buffer that receives the expanded strings.</para>
    </param>
    <param name="dwSize">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies the size of the <i>lpDest</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example source string:</para>
      <code>%USERPROFILE%\ntuser.dat
</code>
      <para>When <b>ExpandEnvironmentStringsForUser</b> returns, the destination string expands as follows:</para>
      <code>C:\Documents and Settings\UserName\ntuser.dat
</code>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines ExpandEnvironmentStringsForUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.ExpandEnvironmentStringsForUserW">
    <summary>
      <para>Expands the source string by using the environment block established for the specified user.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, returned from the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have TOKEN_IMPERSONATE and TOKEN_QUERY access. In addition, as of Windows 7 the token must also have TOKEN_DUPLICATE access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
      <para>If <i>hToken</i> is <b>NULL</b>, the environment block contains system variables only.</para>
    </param>
    <param name="lpSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to the null-terminated source string to be expanded.</para>
    </param>
    <param name="lpDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a buffer that receives the expanded strings.</para>
    </param>
    <param name="dwSize">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies the size of the <i>lpDest</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example source string:</para>
      <code>%USERPROFILE%\ntuser.dat
</code>
      <para>When <b>ExpandEnvironmentStringsForUser</b> returns, the destination string expands as follows:</para>
      <code>C:\Documents and Settings\UserName\ntuser.dat
</code>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines ExpandEnvironmentStringsForUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.FreeGPOList">
    <summary>
      <para>The
<b>FreeGPOList</b> function frees the specified list of GPOs.</para>
    </summary>
    <param name="pGPOList">
      <para>A pointer to the list of GPO structures. This list is returned by the
<see cref="GetGPOList" /> or
<see cref="GetAppliedGPOList" /> function. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines FreeGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetAppliedGPOList" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.FreeGPOListA">
    <summary>
      <para>The
<b>FreeGPOList</b> function frees the specified list of GPOs.</para>
    </summary>
    <param name="pGPOList">
      <para>A pointer to the list of GPO structures. This list is returned by the
<see cref="GetGPOList" /> or
<see cref="GetAppliedGPOList" /> function. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines FreeGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetAppliedGPOList" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.FreeGPOListW">
    <summary>
      <para>The
<b>FreeGPOList</b> function frees the specified list of GPOs.</para>
    </summary>
    <param name="pGPOList">
      <para>A pointer to the list of GPO structures. This list is returned by the
<see cref="GetGPOList" /> or
<see cref="GetAppliedGPOList" /> function. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines FreeGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetAppliedGPOList" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.FreeGPOList">
    <summary>
      <para>The
<b>FreeGPOList</b> function frees the specified list of GPOs.</para>
    </summary>
    <param name="pGPOList">
      <para>A pointer to the list of GPO structures. This list is returned by the
<see cref="GetGPOList" /> or
<see cref="GetAppliedGPOList" /> function. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines FreeGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetAppliedGPOList" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.FreeGPOListA">
    <summary>
      <para>The
<b>FreeGPOList</b> function frees the specified list of GPOs.</para>
    </summary>
    <param name="pGPOList">
      <para>A pointer to the list of GPO structures. This list is returned by the
<see cref="GetGPOList" /> or
<see cref="GetAppliedGPOList" /> function. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines FreeGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetAppliedGPOList" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.FreeGPOListW">
    <summary>
      <para>The
<b>FreeGPOList</b> function frees the specified list of GPOs.</para>
    </summary>
    <param name="pGPOList">
      <para>A pointer to the list of GPO structures. This list is returned by the
<see cref="GetGPOList" /> or
<see cref="GetAppliedGPOList" /> function. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines FreeGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetAppliedGPOList" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetAllUsersProfileDirectory">
    <summary>
      <para>Retrieves the path to the root of the directory that contains program data shared by all users.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path. Set this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\All Users
</code>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows 7:</para>
      <code>C:\ProgramData
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAllUsersProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetAllUsersProfileDirectoryA">
    <summary>
      <para>Retrieves the path to the root of the directory that contains program data shared by all users.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path. Set this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\All Users
</code>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows 7:</para>
      <code>C:\ProgramData
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAllUsersProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetAllUsersProfileDirectoryW">
    <summary>
      <para>Retrieves the path to the root of the directory that contains program data shared by all users.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path. Set this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\All Users
</code>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows 7:</para>
      <code>C:\ProgramData
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAllUsersProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetAllUsersProfileDirectory">
    <summary>
      <para>Retrieves the path to the root of the directory that contains program data shared by all users.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path. Set this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\All Users
</code>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows 7:</para>
      <code>C:\ProgramData
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAllUsersProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetAllUsersProfileDirectoryA">
    <summary>
      <para>Retrieves the path to the root of the directory that contains program data shared by all users.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path. Set this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\All Users
</code>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows 7:</para>
      <code>C:\ProgramData
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAllUsersProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetAllUsersProfileDirectoryW">
    <summary>
      <para>Retrieves the path to the root of the directory that contains program data shared by all users.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path. Set this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\All Users
</code>
      <para>The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows 7:</para>
      <code>C:\ProgramData
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAllUsersProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetAppContainerFolderPath">
    <summary>
      <para>Gets the path of the local app data folder for the specified app container.</para>
    </summary>
    <param name="pszAppContainerSid">
      <para>A pointer to the SID of the app container.</para>
    </param>
    <param name="ppszPath">
      <para>The address of a pointer to a string that, when this function returns successfully, receives the path of the local folder. It is the responsibility of the caller to free this string when it is no longer needed by calling the <see cref="CoTaskMemFree" /> function.</para>
    </param>
    <returns>
      <para>This function returns an <b>HRESULT</b> code, including but not limited to the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The operation completed successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>The <i>pszAppContainerSid</i> or <i>ppszPath</i> parameter is <b>NULL</b>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The path retrieved through this function is the same path that you would get by calling the <see cref="SHGetKnownFolderPath" /> function with <b>FOLDERID_LocalAppData</b>.</para>
      <para>If a thread token is set, this function uses the app container for the current user. If no thread token is set, this function uses the app container associated with the process identity.</para>
    </remarks>
    <seealso cref="GetAppContainerRegistryLocation" />
  </member>
  <member name="Windows.GetAppContainerRegistryLocation">
    <summary>
      <para>Gets the location of the registry storage associated with an app container.</para>
    </summary>
    <param name="desiredAccess">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired registry access.</para>
    </param>
    <param name="phAppContainerKey">
      <para>Type: <b>PHKEY</b></para>
      <para>A pointer to an HKEY that, when this function returns successfully, receives the registry storage location for the current profile.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>This function returns an <b>HRESULT</b> code, including but not limited to the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The operation completed successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>The caller is not running as or impersonating a user who can access this profile.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The function gets the registry storage for the current user. To get the registry storage for another user, you must impersonate that user.</para>
    </remarks>
    <seealso cref="GetAppContainerFolderPath" />
  </member>
  <member name="Windows.GetAppliedGPOList">
    <summary>
      <para>The
<b>GetAppliedGPOList</b> function retrieves the list of GPOs applied for the specified user or computer.</para>
    </summary>
    <param name="dwFlags">
      <para>A value that specifies the policy type. This parameter can be the following value.</para>
      <h4>GPO_LIST_FLAG_MACHINE</h4>
      <para>Retrieves information  about the computer policy.</para>
      <para>If this value is not specified, the function retrieves only user policy information.</para>
    </param>
    <param name="pMachineName">
      <para>A pointer to the name of the remote computer. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="pSidUser">
      <para>A value that specifies the SID of the user. If <i>pMachineName</i> is not <b>NULL</b> and <i>dwFlags</i> specifies user policy, then <i>pSidUser</i> cannot be <b>NULL</b>.</para>
      <para>If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is <b>NULL</b>, the user is the currently logged-on user. If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is not <b>NULL</b>, the user is represented by <i>pSidUser</i> on the local computer. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">Security Identifiers</a>.</para>
    </param>
    <param name="pGuidExtension">
      <para>A value that specifies the <b>GUID</b> of the extension.</para>
    </param>
    <param name="ppGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. Otherwise, the function returns a system error code. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.</para>
    </returns>
    <remarks>
      <para>To free the GPO list when you have finished processing it, call the
<see cref="FreeGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAppliedGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetAppliedGPOListA">
    <summary>
      <para>The
<b>GetAppliedGPOList</b> function retrieves the list of GPOs applied for the specified user or computer.</para>
    </summary>
    <param name="dwFlags">
      <para>A value that specifies the policy type. This parameter can be the following value.</para>
      <h4>GPO_LIST_FLAG_MACHINE</h4>
      <para>Retrieves information  about the computer policy.</para>
      <para>If this value is not specified, the function retrieves only user policy information.</para>
    </param>
    <param name="pMachineName">
      <para>A pointer to the name of the remote computer. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="pSidUser">
      <para>A value that specifies the SID of the user. If <i>pMachineName</i> is not <b>NULL</b> and <i>dwFlags</i> specifies user policy, then <i>pSidUser</i> cannot be <b>NULL</b>.</para>
      <para>If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is <b>NULL</b>, the user is the currently logged-on user. If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is not <b>NULL</b>, the user is represented by <i>pSidUser</i> on the local computer. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">Security Identifiers</a>.</para>
    </param>
    <param name="pGuidExtension">
      <para>A value that specifies the <b>GUID</b> of the extension.</para>
    </param>
    <param name="ppGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. Otherwise, the function returns a system error code. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.</para>
    </returns>
    <remarks>
      <para>To free the GPO list when you have finished processing it, call the
<see cref="FreeGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAppliedGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetAppliedGPOListW">
    <summary>
      <para>The
<b>GetAppliedGPOList</b> function retrieves the list of GPOs applied for the specified user or computer.</para>
    </summary>
    <param name="dwFlags">
      <para>A value that specifies the policy type. This parameter can be the following value.</para>
      <h4>GPO_LIST_FLAG_MACHINE</h4>
      <para>Retrieves information  about the computer policy.</para>
      <para>If this value is not specified, the function retrieves only user policy information.</para>
    </param>
    <param name="pMachineName">
      <para>A pointer to the name of the remote computer. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="pSidUser">
      <para>A value that specifies the SID of the user. If <i>pMachineName</i> is not <b>NULL</b> and <i>dwFlags</i> specifies user policy, then <i>pSidUser</i> cannot be <b>NULL</b>.</para>
      <para>If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is <b>NULL</b>, the user is the currently logged-on user. If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is not <b>NULL</b>, the user is represented by <i>pSidUser</i> on the local computer. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">Security Identifiers</a>.</para>
    </param>
    <param name="pGuidExtension">
      <para>A value that specifies the <b>GUID</b> of the extension.</para>
    </param>
    <param name="ppGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. Otherwise, the function returns a system error code. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.</para>
    </returns>
    <remarks>
      <para>To free the GPO list when you have finished processing it, call the
<see cref="FreeGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAppliedGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetAppliedGPOList">
    <summary>
      <para>The
<b>GetAppliedGPOList</b> function retrieves the list of GPOs applied for the specified user or computer.</para>
    </summary>
    <param name="dwFlags">
      <para>A value that specifies the policy type. This parameter can be the following value.</para>
      <h4>GPO_LIST_FLAG_MACHINE</h4>
      <para>Retrieves information  about the computer policy.</para>
      <para>If this value is not specified, the function retrieves only user policy information.</para>
    </param>
    <param name="pMachineName">
      <para>A pointer to the name of the remote computer. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="pSidUser">
      <para>A value that specifies the SID of the user. If <i>pMachineName</i> is not <b>NULL</b> and <i>dwFlags</i> specifies user policy, then <i>pSidUser</i> cannot be <b>NULL</b>.</para>
      <para>If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is <b>NULL</b>, the user is the currently logged-on user. If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is not <b>NULL</b>, the user is represented by <i>pSidUser</i> on the local computer. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">Security Identifiers</a>.</para>
    </param>
    <param name="pGuidExtension">
      <para>A value that specifies the <b>GUID</b> of the extension.</para>
    </param>
    <param name="ppGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
      <h5>- dwFlags.GPO_LIST_FLAG_MACHINE</h5>
      <para>Retrieves information  about the computer policy.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. Otherwise, the function returns a system error code. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.</para>
    </returns>
    <remarks>
      <para>To free the GPO list when you have finished processing it, call the
<see cref="FreeGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAppliedGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetAppliedGPOListA">
    <summary>
      <para>The
<b>GetAppliedGPOList</b> function retrieves the list of GPOs applied for the specified user or computer.</para>
    </summary>
    <param name="dwFlags">
      <para>A value that specifies the policy type. This parameter can be the following value.</para>
      <h4>GPO_LIST_FLAG_MACHINE</h4>
      <para>Retrieves information  about the computer policy.</para>
      <para>If this value is not specified, the function retrieves only user policy information.</para>
    </param>
    <param name="pMachineName">
      <para>A pointer to the name of the remote computer. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="pSidUser">
      <para>A value that specifies the SID of the user. If <i>pMachineName</i> is not <b>NULL</b> and <i>dwFlags</i> specifies user policy, then <i>pSidUser</i> cannot be <b>NULL</b>.</para>
      <para>If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is <b>NULL</b>, the user is the currently logged-on user. If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is not <b>NULL</b>, the user is represented by <i>pSidUser</i> on the local computer. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">Security Identifiers</a>.</para>
    </param>
    <param name="pGuidExtension">
      <para>A value that specifies the <b>GUID</b> of the extension.</para>
    </param>
    <param name="ppGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
      <h5>- dwFlags.GPO_LIST_FLAG_MACHINE</h5>
      <para>Retrieves information  about the computer policy.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. Otherwise, the function returns a system error code. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.</para>
    </returns>
    <remarks>
      <para>To free the GPO list when you have finished processing it, call the
<see cref="FreeGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAppliedGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetAppliedGPOListW">
    <summary>
      <para>The
<b>GetAppliedGPOList</b> function retrieves the list of GPOs applied for the specified user or computer.</para>
    </summary>
    <param name="dwFlags">
      <para>A value that specifies the policy type. This parameter can be the following value.</para>
      <h4>GPO_LIST_FLAG_MACHINE</h4>
      <para>Retrieves information  about the computer policy.</para>
      <para>If this value is not specified, the function retrieves only user policy information.</para>
    </param>
    <param name="pMachineName">
      <para>A pointer to the name of the remote computer. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="pSidUser">
      <para>A value that specifies the SID of the user. If <i>pMachineName</i> is not <b>NULL</b> and <i>dwFlags</i> specifies user policy, then <i>pSidUser</i> cannot be <b>NULL</b>.</para>
      <para>If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is <b>NULL</b>, the user is the currently logged-on user. If <i>pMachineName</i> is <b>NULL</b> and <i>pSidUser</i> is not <b>NULL</b>, the user is represented by <i>pSidUser</i> on the local computer. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">Security Identifiers</a>.</para>
    </param>
    <param name="pGuidExtension">
      <para>A value that specifies the <b>GUID</b> of the extension.</para>
    </param>
    <param name="ppGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
      <h5>- dwFlags.GPO_LIST_FLAG_MACHINE</h5>
      <para>Retrieves information  about the computer policy.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. Otherwise, the function returns a system error code. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.</para>
    </returns>
    <remarks>
      <para>To free the GPO list when you have finished processing it, call the
<see cref="FreeGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetAppliedGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso cref="GetGPOList" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetDefaultUserProfileDirectory">
    <summary>
      <para>Retrieves the path to the root of the default user's profile.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Default User
</code>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Default
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetDefaultUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetDefaultUserProfileDirectoryA">
    <summary>
      <para>Retrieves the path to the root of the default user's profile.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Default User
</code>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Default
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetDefaultUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetDefaultUserProfileDirectoryW">
    <summary>
      <para>Retrieves the path to the root of the default user's profile.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Default User
</code>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Default
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetDefaultUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetDefaultUserProfileDirectory">
    <summary>
      <para>Retrieves the path to the root of the default user's profile.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Default User
</code>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Default
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetDefaultUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetDefaultUserProfileDirectoryA">
    <summary>
      <para>Retrieves the path to the root of the default user's profile.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Default User
</code>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Default
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetDefaultUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetDefaultUserProfileDirectoryW">
    <summary>
      <para>Retrieves the path to the root of the default user's profile.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Default User
</code>
      <para>The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Default
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetDefaultUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetGPOList">
    <summary>
      <para>The
<b>GetGPOList</b> function retrieves the list of GPOs for the specified user or computer. This function can be called in two ways: first, you can use the token for the user or computer, or, second, you can use the name of the user or computer and the name of the domain controller.</para>
    </summary>
    <param name="hToken">
      <para>A token for the user or computer, returned from the
<see cref="LogonUser" />,
<see cref="CreateRestrictedToken" />,
<see cref="DuplicateToken" />,
<see cref="OpenProcessToken" />, or
<see cref="OpenThreadToken" /> function. This token must have <b>TOKEN_IMPERSONATE</b> and <b>TOKEN_QUERY</b> access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a> and the following Remarks section.</para>
      <para>If this parameter is <b>NULL</b>, you must supply values for the <i>lpName</i> and <i>lpHostName</i> parameters.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the user or computer name, in the fully qualified distinguished name format (for example,  "CN=<i>user</i>, OU=<i>users</i>, DC=<i>contoso</i>, DC=<i>com</i>").</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpHostName">
      <para>A DNS domain name or domain controller name. Domain controller name can be retrieved using the
<see cref="DsGetDcName" /> function, specifying <b>DS_DIRECTORY_SERVICE_REQUIRED</b> in the <i>flags</i> parameter.</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpComputerName">
      <para>A pointer to the name of the computer used to determine the site location. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="dwFlags">
      <para>A value that specifies additional flags that are used to control information retrieval. If you specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the computer. If you do not specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the user.</para>
      <para>If you specify <b>GPO_LIST_FLAG_SITEONLY</b> the function returns only site information for the computer or user.</para>
    </param>
    <param name="pGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetGPOList</b> function is intended for use by services acting on behalf of a user or computer. The service calls this function to obtain a list of GPOs, then checks each GPO for service-specific policy.</para>
      <para>Calling this function with a token provides the most accurate list. The system can perform access checking for the user or computer. Calling this function with the user or computer name and the domain controller name is faster than calling it with a token. However, if the token is not specified, the system uses the security access of the caller, which means that the list may not be completely correct for the intended user or computer.</para>
      <para>To obtain the most accurate list of GPOs for a computer when calling <b>GetGPOList</b>, the caller must have read access to each OU and site in the computer domain, and also read and apply Group Policy access to all GPOs that are linked to the sites, domain or OUs of that domain. An example of a caller would be a service running on the computer whose name is specified in the <i>lpName</i> parameter. An alternate method of obtaining a list of GPOs would be to call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsopplanningmodeprovider-rsopcreatesession">RsopCreateSession</a> method of the <b>RsopPlanningModeProvider</b> WMI class. The method can generate resultant policy data for a computer or user account in a hypothetical scenario.</para>
      <para>Call the
<see cref="FreeGPOList" /> function to free the GPO list when you have finished processing it.</para>
      <para>Generally, you should call
<b>GetGPOList</b> with a token when retrieving a list of GPOs for a user as shown in the following code example.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (hToken, NULL, NULL, NULL, 0, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>Typically, to retrieve a list of GPOs for a computer, you can call
<b>GetGPOList</b> with the computer name and domain controller name as demonstrated in the following code snippet.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (NULL, lpMachineName, lpHostName, lpMachineName, GPO_LIST_FLAG_MACHINE, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>To retrieve the list of GPOs applied for a specific user or computer and extension, call the
<see cref="GetAppliedGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DsGetDcName" />
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetGPOListA">
    <summary>
      <para>The
<b>GetGPOList</b> function retrieves the list of GPOs for the specified user or computer. This function can be called in two ways: first, you can use the token for the user or computer, or, second, you can use the name of the user or computer and the name of the domain controller.</para>
    </summary>
    <param name="hToken">
      <para>A token for the user or computer, returned from the
<see cref="LogonUser" />,
<see cref="CreateRestrictedToken" />,
<see cref="DuplicateToken" />,
<see cref="OpenProcessToken" />, or
<see cref="OpenThreadToken" /> function. This token must have <b>TOKEN_IMPERSONATE</b> and <b>TOKEN_QUERY</b> access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a> and the following Remarks section.</para>
      <para>If this parameter is <b>NULL</b>, you must supply values for the <i>lpName</i> and <i>lpHostName</i> parameters.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the user or computer name, in the fully qualified distinguished name format (for example,  "CN=<i>user</i>, OU=<i>users</i>, DC=<i>contoso</i>, DC=<i>com</i>").</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpHostName">
      <para>A DNS domain name or domain controller name. Domain controller name can be retrieved using the
<see cref="DsGetDcName" /> function, specifying <b>DS_DIRECTORY_SERVICE_REQUIRED</b> in the <i>flags</i> parameter.</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpComputerName">
      <para>A pointer to the name of the computer used to determine the site location. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="dwFlags">
      <para>A value that specifies additional flags that are used to control information retrieval. If you specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the computer. If you do not specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the user.</para>
      <para>If you specify <b>GPO_LIST_FLAG_SITEONLY</b> the function returns only site information for the computer or user.</para>
    </param>
    <param name="pGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetGPOList</b> function is intended for use by services acting on behalf of a user or computer. The service calls this function to obtain a list of GPOs, then checks each GPO for service-specific policy.</para>
      <para>Calling this function with a token provides the most accurate list. The system can perform access checking for the user or computer. Calling this function with the user or computer name and the domain controller name is faster than calling it with a token. However, if the token is not specified, the system uses the security access of the caller, which means that the list may not be completely correct for the intended user or computer.</para>
      <para>To obtain the most accurate list of GPOs for a computer when calling <b>GetGPOList</b>, the caller must have read access to each OU and site in the computer domain, and also read and apply Group Policy access to all GPOs that are linked to the sites, domain or OUs of that domain. An example of a caller would be a service running on the computer whose name is specified in the <i>lpName</i> parameter. An alternate method of obtaining a list of GPOs would be to call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsopplanningmodeprovider-rsopcreatesession">RsopCreateSession</a> method of the <b>RsopPlanningModeProvider</b> WMI class. The method can generate resultant policy data for a computer or user account in a hypothetical scenario.</para>
      <para>Call the
<see cref="FreeGPOList" /> function to free the GPO list when you have finished processing it.</para>
      <para>Generally, you should call
<b>GetGPOList</b> with a token when retrieving a list of GPOs for a user as shown in the following code example.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (hToken, NULL, NULL, NULL, 0, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>Typically, to retrieve a list of GPOs for a computer, you can call
<b>GetGPOList</b> with the computer name and domain controller name as demonstrated in the following code snippet.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (NULL, lpMachineName, lpHostName, lpMachineName, GPO_LIST_FLAG_MACHINE, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>To retrieve the list of GPOs applied for a specific user or computer and extension, call the
<see cref="GetAppliedGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DsGetDcName" />
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetGPOListW">
    <summary>
      <para>The
<b>GetGPOList</b> function retrieves the list of GPOs for the specified user or computer. This function can be called in two ways: first, you can use the token for the user or computer, or, second, you can use the name of the user or computer and the name of the domain controller.</para>
    </summary>
    <param name="hToken">
      <para>A token for the user or computer, returned from the
<see cref="LogonUser" />,
<see cref="CreateRestrictedToken" />,
<see cref="DuplicateToken" />,
<see cref="OpenProcessToken" />, or
<see cref="OpenThreadToken" /> function. This token must have <b>TOKEN_IMPERSONATE</b> and <b>TOKEN_QUERY</b> access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a> and the following Remarks section.</para>
      <para>If this parameter is <b>NULL</b>, you must supply values for the <i>lpName</i> and <i>lpHostName</i> parameters.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the user or computer name, in the fully qualified distinguished name format (for example,  "CN=<i>user</i>, OU=<i>users</i>, DC=<i>contoso</i>, DC=<i>com</i>").</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpHostName">
      <para>A DNS domain name or domain controller name. Domain controller name can be retrieved using the
<see cref="DsGetDcName" /> function, specifying <b>DS_DIRECTORY_SERVICE_REQUIRED</b> in the <i>flags</i> parameter.</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpComputerName">
      <para>A pointer to the name of the computer used to determine the site location. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="dwFlags">
      <para>A value that specifies additional flags that are used to control information retrieval. If you specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the computer. If you do not specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the user.</para>
      <para>If you specify <b>GPO_LIST_FLAG_SITEONLY</b> the function returns only site information for the computer or user.</para>
    </param>
    <param name="pGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetGPOList</b> function is intended for use by services acting on behalf of a user or computer. The service calls this function to obtain a list of GPOs, then checks each GPO for service-specific policy.</para>
      <para>Calling this function with a token provides the most accurate list. The system can perform access checking for the user or computer. Calling this function with the user or computer name and the domain controller name is faster than calling it with a token. However, if the token is not specified, the system uses the security access of the caller, which means that the list may not be completely correct for the intended user or computer.</para>
      <para>To obtain the most accurate list of GPOs for a computer when calling <b>GetGPOList</b>, the caller must have read access to each OU and site in the computer domain, and also read and apply Group Policy access to all GPOs that are linked to the sites, domain or OUs of that domain. An example of a caller would be a service running on the computer whose name is specified in the <i>lpName</i> parameter. An alternate method of obtaining a list of GPOs would be to call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsopplanningmodeprovider-rsopcreatesession">RsopCreateSession</a> method of the <b>RsopPlanningModeProvider</b> WMI class. The method can generate resultant policy data for a computer or user account in a hypothetical scenario.</para>
      <para>Call the
<see cref="FreeGPOList" /> function to free the GPO list when you have finished processing it.</para>
      <para>Generally, you should call
<b>GetGPOList</b> with a token when retrieving a list of GPOs for a user as shown in the following code example.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (hToken, NULL, NULL, NULL, 0, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>Typically, to retrieve a list of GPOs for a computer, you can call
<b>GetGPOList</b> with the computer name and domain controller name as demonstrated in the following code snippet.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (NULL, lpMachineName, lpHostName, lpMachineName, GPO_LIST_FLAG_MACHINE, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>To retrieve the list of GPOs applied for a specific user or computer and extension, call the
<see cref="GetAppliedGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DsGetDcName" />
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetGPOList">
    <summary>
      <para>The
<b>GetGPOList</b> function retrieves the list of GPOs for the specified user or computer. This function can be called in two ways: first, you can use the token for the user or computer, or, second, you can use the name of the user or computer and the name of the domain controller.</para>
    </summary>
    <param name="hToken">
      <para>A token for the user or computer, returned from the
<see cref="LogonUser" />,
<see cref="CreateRestrictedToken" />,
<see cref="DuplicateToken" />,
<see cref="OpenProcessToken" />, or
<see cref="OpenThreadToken" /> function. This token must have <b>TOKEN_IMPERSONATE</b> and <b>TOKEN_QUERY</b> access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a> and the following Remarks section.</para>
      <para>If this parameter is <b>NULL</b>, you must supply values for the <i>lpName</i> and <i>lpHostName</i> parameters.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the user or computer name, in the fully qualified distinguished name format (for example,  "CN=<i>user</i>, OU=<i>users</i>, DC=<i>contoso</i>, DC=<i>com</i>").</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpHostName">
      <para>A DNS domain name or domain controller name. Domain controller name can be retrieved using the
<see cref="DsGetDcName" /> function, specifying <b>DS_DIRECTORY_SERVICE_REQUIRED</b> in the <i>flags</i> parameter.</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpComputerName">
      <para>A pointer to the name of the computer used to determine the site location. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="dwFlags">
      <para>A value that specifies additional flags that are used to control information retrieval. If you specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the computer. If you do not specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the user.</para>
      <para>If you specify <b>GPO_LIST_FLAG_SITEONLY</b> the function returns only site information for the computer or user.</para>
    </param>
    <param name="pGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetGPOList</b> function is intended for use by services acting on behalf of a user or computer. The service calls this function to obtain a list of GPOs, then checks each GPO for service-specific policy.</para>
      <para>Calling this function with a token provides the most accurate list. The system can perform access checking for the user or computer. Calling this function with the user or computer name and the domain controller name is faster than calling it with a token. However, if the token is not specified, the system uses the security access of the caller, which means that the list may not be completely correct for the intended user or computer.</para>
      <para>To obtain the most accurate list of GPOs for a computer when calling <b>GetGPOList</b>, the caller must have read access to each OU and site in the computer domain, and also read and apply Group Policy access to all GPOs that are linked to the sites, domain or OUs of that domain. An example of a caller would be a service running on the computer whose name is specified in the <i>lpName</i> parameter. An alternate method of obtaining a list of GPOs would be to call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsopplanningmodeprovider-rsopcreatesession">RsopCreateSession</a> method of the <b>RsopPlanningModeProvider</b> WMI class. The method can generate resultant policy data for a computer or user account in a hypothetical scenario.</para>
      <para>Call the
<see cref="FreeGPOList" /> function to free the GPO list when you have finished processing it.</para>
      <para>Generally, you should call
<b>GetGPOList</b> with a token when retrieving a list of GPOs for a user as shown in the following code example.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (hToken, NULL, NULL, NULL, 0, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>Typically, to retrieve a list of GPOs for a computer, you can call
<b>GetGPOList</b> with the computer name and domain controller name as demonstrated in the following code snippet.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (NULL, lpMachineName, lpHostName, lpMachineName, GPO_LIST_FLAG_MACHINE, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>To retrieve the list of GPOs applied for a specific user or computer and extension, call the
<see cref="GetAppliedGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DsGetDcName" />
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetGPOListA">
    <summary>
      <para>The
<b>GetGPOList</b> function retrieves the list of GPOs for the specified user or computer. This function can be called in two ways: first, you can use the token for the user or computer, or, second, you can use the name of the user or computer and the name of the domain controller.</para>
    </summary>
    <param name="hToken">
      <para>A token for the user or computer, returned from the
<see cref="LogonUser" />,
<see cref="CreateRestrictedToken" />,
<see cref="DuplicateToken" />,
<see cref="OpenProcessToken" />, or
<see cref="OpenThreadToken" /> function. This token must have <b>TOKEN_IMPERSONATE</b> and <b>TOKEN_QUERY</b> access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a> and the following Remarks section.</para>
      <para>If this parameter is <b>NULL</b>, you must supply values for the <i>lpName</i> and <i>lpHostName</i> parameters.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the user or computer name, in the fully qualified distinguished name format (for example,  "CN=<i>user</i>, OU=<i>users</i>, DC=<i>contoso</i>, DC=<i>com</i>").</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpHostName">
      <para>A DNS domain name or domain controller name. Domain controller name can be retrieved using the
<see cref="DsGetDcName" /> function, specifying <b>DS_DIRECTORY_SERVICE_REQUIRED</b> in the <i>flags</i> parameter.</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpComputerName">
      <para>A pointer to the name of the computer used to determine the site location. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="dwFlags">
      <para>A value that specifies additional flags that are used to control information retrieval. If you specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the computer. If you do not specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the user.</para>
      <para>If you specify <b>GPO_LIST_FLAG_SITEONLY</b> the function returns only site information for the computer or user.</para>
    </param>
    <param name="pGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetGPOList</b> function is intended for use by services acting on behalf of a user or computer. The service calls this function to obtain a list of GPOs, then checks each GPO for service-specific policy.</para>
      <para>Calling this function with a token provides the most accurate list. The system can perform access checking for the user or computer. Calling this function with the user or computer name and the domain controller name is faster than calling it with a token. However, if the token is not specified, the system uses the security access of the caller, which means that the list may not be completely correct for the intended user or computer.</para>
      <para>To obtain the most accurate list of GPOs for a computer when calling <b>GetGPOList</b>, the caller must have read access to each OU and site in the computer domain, and also read and apply Group Policy access to all GPOs that are linked to the sites, domain or OUs of that domain. An example of a caller would be a service running on the computer whose name is specified in the <i>lpName</i> parameter. An alternate method of obtaining a list of GPOs would be to call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsopplanningmodeprovider-rsopcreatesession">RsopCreateSession</a> method of the <b>RsopPlanningModeProvider</b> WMI class. The method can generate resultant policy data for a computer or user account in a hypothetical scenario.</para>
      <para>Call the
<see cref="FreeGPOList" /> function to free the GPO list when you have finished processing it.</para>
      <para>Generally, you should call
<b>GetGPOList</b> with a token when retrieving a list of GPOs for a user as shown in the following code example.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (hToken, NULL, NULL, NULL, 0, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>Typically, to retrieve a list of GPOs for a computer, you can call
<b>GetGPOList</b> with the computer name and domain controller name as demonstrated in the following code snippet.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (NULL, lpMachineName, lpHostName, lpMachineName, GPO_LIST_FLAG_MACHINE, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>To retrieve the list of GPOs applied for a specific user or computer and extension, call the
<see cref="GetAppliedGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DsGetDcName" />
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetGPOListW">
    <summary>
      <para>The
<b>GetGPOList</b> function retrieves the list of GPOs for the specified user or computer. This function can be called in two ways: first, you can use the token for the user or computer, or, second, you can use the name of the user or computer and the name of the domain controller.</para>
    </summary>
    <param name="hToken">
      <para>A token for the user or computer, returned from the
<see cref="LogonUser" />,
<see cref="CreateRestrictedToken" />,
<see cref="DuplicateToken" />,
<see cref="OpenProcessToken" />, or
<see cref="OpenThreadToken" /> function. This token must have <b>TOKEN_IMPERSONATE</b> and <b>TOKEN_QUERY</b> access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a> and the following Remarks section.</para>
      <para>If this parameter is <b>NULL</b>, you must supply values for the <i>lpName</i> and <i>lpHostName</i> parameters.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the user or computer name, in the fully qualified distinguished name format (for example,  "CN=<i>user</i>, OU=<i>users</i>, DC=<i>contoso</i>, DC=<i>com</i>").</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpHostName">
      <para>A DNS domain name or domain controller name. Domain controller name can be retrieved using the
<see cref="DsGetDcName" /> function, specifying <b>DS_DIRECTORY_SERVICE_REQUIRED</b> in the <i>flags</i> parameter.</para>
      <para>If the <i>hToken</i> parameter is not <b>NULL</b>, this parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpComputerName">
      <para>A pointer to the name of the computer used to determine the site location. The format of the name is "\\<i>computer_name</i>". If this parameter is <b>NULL</b>, the local computer name is used.</para>
    </param>
    <param name="dwFlags">
      <para>A value that specifies additional flags that are used to control information retrieval. If you specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the computer. If you do not specify <b>GPO_LIST_FLAG_MACHINE</b>, the function retrieves policy information for the user.</para>
      <para>If you specify <b>GPO_LIST_FLAG_SITEONLY</b> the function returns only site information for the computer or user.</para>
    </param>
    <param name="pGPOList">
      <para>A pointer that receives the list of GPO structures. For more information, see
<see cref="GROUP_POLICY_OBJECT" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetGPOList</b> function is intended for use by services acting on behalf of a user or computer. The service calls this function to obtain a list of GPOs, then checks each GPO for service-specific policy.</para>
      <para>Calling this function with a token provides the most accurate list. The system can perform access checking for the user or computer. Calling this function with the user or computer name and the domain controller name is faster than calling it with a token. However, if the token is not specified, the system uses the security access of the caller, which means that the list may not be completely correct for the intended user or computer.</para>
      <para>To obtain the most accurate list of GPOs for a computer when calling <b>GetGPOList</b>, the caller must have read access to each OU and site in the computer domain, and also read and apply Group Policy access to all GPOs that are linked to the sites, domain or OUs of that domain. An example of a caller would be a service running on the computer whose name is specified in the <i>lpName</i> parameter. An alternate method of obtaining a list of GPOs would be to call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsopplanningmodeprovider-rsopcreatesession">RsopCreateSession</a> method of the <b>RsopPlanningModeProvider</b> WMI class. The method can generate resultant policy data for a computer or user account in a hypothetical scenario.</para>
      <para>Call the
<see cref="FreeGPOList" /> function to free the GPO list when you have finished processing it.</para>
      <para>Generally, you should call
<b>GetGPOList</b> with a token when retrieving a list of GPOs for a user as shown in the following code example.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (hToken, NULL, NULL, NULL, 0, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>Typically, to retrieve a list of GPOs for a computer, you can call
<b>GetGPOList</b> with the computer name and domain controller name as demonstrated in the following code snippet.</para>
      <code>LPGROUP_POLICY_OBJECT  pGPOList;
      if (GetGPOList (NULL, lpMachineName, lpHostName, lpMachineName, GPO_LIST_FLAG_MACHINE, &amp;amp;amp;amp;amp;amp;pGPOList))
      {
//        Perform processing here.
//
//        Free the GPO list when you finish processing.
          FreeGPOList (pGPOList);
      }
</code>
      <para>To retrieve the list of GPOs applied for a specific user or computer and extension, call the
<see cref="GetAppliedGPOList" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetGPOList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DsGetDcName" />
    <seealso cref="FreeGPOList" />
    <seealso cref="GROUP_POLICY_OBJECT" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.GetProfilesDirectory">
    <summary>
      <para>Retrieves the path to the root directory where user profiles are stored.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings
</code>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows 7:</para>
      <code>C:\Users
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetProfilesDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetProfilesDirectoryA">
    <summary>
      <para>Retrieves the path to the root directory where user profiles are stored.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings
</code>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows 7:</para>
      <code>C:\Users
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetProfilesDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetProfilesDirectoryW">
    <summary>
      <para>Retrieves the path to the root directory where user profiles are stored.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings
</code>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows 7:</para>
      <code>C:\Users
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetProfilesDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetProfilesDirectory">
    <summary>
      <para>Retrieves the path to the root directory where user profiles are stored.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings
</code>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows 7:</para>
      <code>C:\Users
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetProfilesDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetProfilesDirectoryA">
    <summary>
      <para>Retrieves the path to the root directory where user profiles are stored.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings
</code>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows 7:</para>
      <code>C:\Users
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetProfilesDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetProfilesDirectoryW">
    <summary>
      <para>Retrieves the path to the root directory where user profiles are stored.</para>
    </summary>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings
</code>
      <para>The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows 7:</para>
      <code>C:\Users
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetProfilesDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetUserProfileDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetProfileType">
    <summary>
      <para>Retrieves the type of profile loaded for the current user.</para>
    </summary>
    <param name="dwFlags">
      <para>Type: <b>DWORD*</b></para>
      <para>Pointer to a variable that receives the profile type. If the function succeeds, it sets one or more of the following values:</para>
      <h4>PT_MANDATORY</h4>
      <para>The user has a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776895(v=vs.85)">Mandatory User Profiles</a>.</para>
      <h4>PT_ROAMING</h4>
      <para>The user has a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776897(v=vs.85)">Roaming User Profiles</a>.</para>
      <h4>PT_ROAMING_PREEXISTING</h4>
      <para>The user has a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776897(v=vs.85)">Roaming User Profile</a> that was created on another PC and is being downloaded.
This profile type implies <b>PT_ROAMING</b>.</para>
      <h4>PT_TEMPORARY</h4>
      <para>The user has a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776898(v=vs.85)">Temporary User Profiles</a>; it will be deleted at logoff.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the user profile is not already loaded, the function fails.</para>
      <para>Note that the caller must have <b>KEY_READ</b> access to <b>HKEY_LOCAL_MACHINE</b>. This access right is granted by default. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>If the profile type is <b>PT_ROAMING_PREEXISTING</b>, Explorer will not reinitialize default programs associations when a profile is loaded on a machine for the first time.</para>
    </remarks>
    <seealso cref="LoadUserProfile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetUserProfileDirectory">
    <summary>
      <para>Retrieves the path to the root directory of the specified user's profile.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>A token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or  <see cref="OpenThreadToken" /> function. The token must have TOKEN_QUERY access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the specified user's profile directory.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Joe
</code>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Joe
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetUserProfileDirectoryA">
    <summary>
      <para>Retrieves the path to the root directory of the specified user's profile.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>A token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or  <see cref="OpenThreadToken" /> function. The token must have TOKEN_QUERY access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the specified user's profile directory.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Joe
</code>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Joe
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetUserProfileDirectoryW">
    <summary>
      <para>Retrieves the path to the root directory of the specified user's profile.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>A token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or  <see cref="OpenThreadToken" /> function. The token must have TOKEN_QUERY access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the specified user's profile directory.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Joe
</code>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Joe
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetUserProfileDirectory">
    <summary>
      <para>Retrieves the path to the root directory of the specified user's profile.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>A token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or  <see cref="OpenThreadToken" /> function. The token must have TOKEN_QUERY access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the specified user's profile directory.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Joe
</code>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Joe
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetUserProfileDirectoryA">
    <summary>
      <para>Retrieves the path to the root directory of the specified user's profile.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>A token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or  <see cref="OpenThreadToken" /> function. The token must have TOKEN_QUERY access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the specified user's profile directory.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Joe
</code>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Joe
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.GetUserProfileDirectoryW">
    <summary>
      <para>Retrieves the path to the root directory of the specified user's profile.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>A token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or  <see cref="OpenThreadToken" /> function. The token must have TOKEN_QUERY access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileDir">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the path to the specified user's profile directory.</para>
    </param>
    <param name="lpcchSize">
      <para>Type: <b>LPDWORD</b></para>
      <para>Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.</para>
      <para>If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows XP:</para>
      <code>C:\Documents and Settings\Joe
</code>
      <para>The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows 7:</para>
      <code>C:\Users\Joe
</code>
      <para>To obtain the paths of subdirectories of this directory, use the <see cref="SHGetFolderPath" /> (Windows XP and earlier) or <see cref="SHGetKnownFolderPath" /> (Windows Vista) function.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines GetUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetAllUsersProfileDirectory" />
    <seealso cref="GetDefaultUserProfileDirectory" />
    <seealso cref="GetProfilesDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.LeaveCriticalPolicySection">
    <summary>
      <para>The
<b>LeaveCriticalPolicySection</b> function resumes the background application of policy. This function closes the handle to the policy section.</para>
    </summary>
    <param name="hSection">
      <para>Handle to a policy section, which is returned by the
<see cref="EnterCriticalPolicySection" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="EnterCriticalPolicySection" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
  </member>
  <member name="Windows.LoadUserProfile">
    <summary>
      <para>Loads the specified user's profile. The profile can be a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776894(v=vs.85)">local user profile</a> or a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776897(v=vs.85)">roaming user profile</a>.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have <b>TOKEN_QUERY</b>, <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileInfo">
      <para>Type: <b>LPPROFILEINFO</b></para>
      <para>Pointer to a <see cref="PROFILEINFO" /> structure. <b>LoadUserProfile</b> fails and returns <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure at <i>lpProfileInfo</i> is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When a user logs on interactively, the system automatically loads the user's profile. If a service or an application impersonates a user, the system does not load the user's profile. Therefore, the service or application should load the user's profile with <b>LoadUserProfile</b>.</para>
      <para>Services and applications that call <b>LoadUserProfile</b> should check to see if the user has a roaming profile. If the user has a roaming profile, specify its path as the <b>lpProfilePath</b> member of
<see cref="PROFILEINFO" />. To retrieve the user's roaming profile path, you can call the
<see cref="NetUserGetInfo" /> function, specifying information level 3 or 4.</para>
      <para>Upon successful return, the <b>hProfile</b> member of <see cref="PROFILEINFO" /> is a registry key handle opened to the root of the user's hive. It has been opened with full access (KEY_ALL_ACCESS). If a service that is impersonating a user needs to read or write to the user's registry file, use this handle instead of <b>HKEY_CURRENT_USER</b>. Do not close the <b>hProfile</b> handle. Instead, pass it to the
<see cref="UnloadUserProfile" /> function. This function closes the handle. You should ensure that all handles to keys in the user's registry hive are closed. If you do not close all open registry handles, the user's profile fails to unload. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a> and <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-hives">Registry Hives</a>.</para>
      <para>Note that it is your responsibility to load the user's registry hive into the <b>HKEY_USERS</b> registry key with the <b>LoadUserProfile</b> function before you call <see cref="CreateProcessAsUser" />. This is because <b>CreateProcessAsUser</b> does not load the specified user's profile into <b>HKEY_USERS</b>. This means that access to information in the <b>HKEY_CURRENT_USER</b> registry key may not produce results consistent with a normal interactive logon.</para>
      <para>The calling process must have the <b>SE_RESTORE_NAME</b> and <b>SE_BACKUP_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>Starting with Windows XP Service Pack 2 (SP2) and Windows Server 2003, the caller must be an administrator or the LocalSystem account. It is not sufficient for the caller to merely impersonate the administrator or LocalSystem account.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines LoadUserProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PROFILEINFO" />
    <seealso cref="UnloadUserProfile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.LoadUserProfileA">
    <summary>
      <para>Loads the specified user's profile. The profile can be a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776894(v=vs.85)">local user profile</a> or a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776897(v=vs.85)">roaming user profile</a>.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have <b>TOKEN_QUERY</b>, <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileInfo">
      <para>Type: <b>LPPROFILEINFO</b></para>
      <para>Pointer to a <see cref="PROFILEINFO" /> structure. <b>LoadUserProfile</b> fails and returns <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure at <i>lpProfileInfo</i> is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When a user logs on interactively, the system automatically loads the user's profile. If a service or an application impersonates a user, the system does not load the user's profile. Therefore, the service or application should load the user's profile with <b>LoadUserProfile</b>.</para>
      <para>Services and applications that call <b>LoadUserProfile</b> should check to see if the user has a roaming profile. If the user has a roaming profile, specify its path as the <b>lpProfilePath</b> member of
<see cref="PROFILEINFO" />. To retrieve the user's roaming profile path, you can call the
<see cref="NetUserGetInfo" /> function, specifying information level 3 or 4.</para>
      <para>Upon successful return, the <b>hProfile</b> member of <see cref="PROFILEINFO" /> is a registry key handle opened to the root of the user's hive. It has been opened with full access (KEY_ALL_ACCESS). If a service that is impersonating a user needs to read or write to the user's registry file, use this handle instead of <b>HKEY_CURRENT_USER</b>. Do not close the <b>hProfile</b> handle. Instead, pass it to the
<see cref="UnloadUserProfile" /> function. This function closes the handle. You should ensure that all handles to keys in the user's registry hive are closed. If you do not close all open registry handles, the user's profile fails to unload. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a> and <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-hives">Registry Hives</a>.</para>
      <para>Note that it is your responsibility to load the user's registry hive into the <b>HKEY_USERS</b> registry key with the <b>LoadUserProfile</b> function before you call <see cref="CreateProcessAsUser" />. This is because <b>CreateProcessAsUser</b> does not load the specified user's profile into <b>HKEY_USERS</b>. This means that access to information in the <b>HKEY_CURRENT_USER</b> registry key may not produce results consistent with a normal interactive logon.</para>
      <para>The calling process must have the <b>SE_RESTORE_NAME</b> and <b>SE_BACKUP_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>Starting with Windows XP Service Pack 2 (SP2) and Windows Server 2003, the caller must be an administrator or the LocalSystem account. It is not sufficient for the caller to merely impersonate the administrator or LocalSystem account.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines LoadUserProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PROFILEINFO" />
    <seealso cref="UnloadUserProfile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.LoadUserProfileW">
    <summary>
      <para>Loads the specified user's profile. The profile can be a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776894(v=vs.85)">local user profile</a> or a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776897(v=vs.85)">roaming user profile</a>.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have <b>TOKEN_QUERY</b>, <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileInfo">
      <para>Type: <b>LPPROFILEINFO</b></para>
      <para>Pointer to a <see cref="PROFILEINFO" /> structure. <b>LoadUserProfile</b> fails and returns <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure at <i>lpProfileInfo</i> is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When a user logs on interactively, the system automatically loads the user's profile. If a service or an application impersonates a user, the system does not load the user's profile. Therefore, the service or application should load the user's profile with <b>LoadUserProfile</b>.</para>
      <para>Services and applications that call <b>LoadUserProfile</b> should check to see if the user has a roaming profile. If the user has a roaming profile, specify its path as the <b>lpProfilePath</b> member of
<see cref="PROFILEINFO" />. To retrieve the user's roaming profile path, you can call the
<see cref="NetUserGetInfo" /> function, specifying information level 3 or 4.</para>
      <para>Upon successful return, the <b>hProfile</b> member of <see cref="PROFILEINFO" /> is a registry key handle opened to the root of the user's hive. It has been opened with full access (KEY_ALL_ACCESS). If a service that is impersonating a user needs to read or write to the user's registry file, use this handle instead of <b>HKEY_CURRENT_USER</b>. Do not close the <b>hProfile</b> handle. Instead, pass it to the
<see cref="UnloadUserProfile" /> function. This function closes the handle. You should ensure that all handles to keys in the user's registry hive are closed. If you do not close all open registry handles, the user's profile fails to unload. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a> and <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-hives">Registry Hives</a>.</para>
      <para>Note that it is your responsibility to load the user's registry hive into the <b>HKEY_USERS</b> registry key with the <b>LoadUserProfile</b> function before you call <see cref="CreateProcessAsUser" />. This is because <b>CreateProcessAsUser</b> does not load the specified user's profile into <b>HKEY_USERS</b>. This means that access to information in the <b>HKEY_CURRENT_USER</b> registry key may not produce results consistent with a normal interactive logon.</para>
      <para>The calling process must have the <b>SE_RESTORE_NAME</b> and <b>SE_BACKUP_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>Starting with Windows XP Service Pack 2 (SP2) and Windows Server 2003, the caller must be an administrator or the LocalSystem account. It is not sufficient for the caller to merely impersonate the administrator or LocalSystem account.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines LoadUserProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PROFILEINFO" />
    <seealso cref="UnloadUserProfile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.LoadUserProfile">
    <summary>
      <para>Loads the specified user's profile. The profile can be a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776894(v=vs.85)">local user profile</a> or a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776897(v=vs.85)">roaming user profile</a>.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have <b>TOKEN_QUERY</b>, <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileInfo">
      <para>Type: <b>LPPROFILEINFO</b></para>
      <para>Pointer to a <see cref="PROFILEINFO" /> structure. <b>LoadUserProfile</b> fails and returns <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure at <i>lpProfileInfo</i> is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When a user logs on interactively, the system automatically loads the user's profile. If a service or an application impersonates a user, the system does not load the user's profile. Therefore, the service or application should load the user's profile with <b>LoadUserProfile</b>.</para>
      <para>Services and applications that call <b>LoadUserProfile</b> should check to see if the user has a roaming profile. If the user has a roaming profile, specify its path as the <b>lpProfilePath</b> member of
<see cref="PROFILEINFO" />. To retrieve the user's roaming profile path, you can call the
<see cref="NetUserGetInfo" /> function, specifying information level 3 or 4.</para>
      <para>Upon successful return, the <b>hProfile</b> member of <see cref="PROFILEINFO" /> is a registry key handle opened to the root of the user's hive. It has been opened with full access (KEY_ALL_ACCESS). If a service that is impersonating a user needs to read or write to the user's registry file, use this handle instead of <b>HKEY_CURRENT_USER</b>. Do not close the <b>hProfile</b> handle. Instead, pass it to the
<see cref="UnloadUserProfile" /> function. This function closes the handle. You should ensure that all handles to keys in the user's registry hive are closed. If you do not close all open registry handles, the user's profile fails to unload. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a> and <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-hives">Registry Hives</a>.</para>
      <para>Note that it is your responsibility to load the user's registry hive into the <b>HKEY_USERS</b> registry key with the <b>LoadUserProfile</b> function before you call <see cref="CreateProcessAsUser" />. This is because <b>CreateProcessAsUser</b> does not load the specified user's profile into <b>HKEY_USERS</b>. This means that access to information in the <b>HKEY_CURRENT_USER</b> registry key may not produce results consistent with a normal interactive logon.</para>
      <para>The calling process must have the <b>SE_RESTORE_NAME</b> and <b>SE_BACKUP_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>Starting with Windows XP Service Pack 2 (SP2) and Windows Server 2003, the caller must be an administrator or the LocalSystem account. It is not sufficient for the caller to merely impersonate the administrator or LocalSystem account.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines LoadUserProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PROFILEINFO" />
    <seealso cref="UnloadUserProfile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.LoadUserProfileA">
    <summary>
      <para>Loads the specified user's profile. The profile can be a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776894(v=vs.85)">local user profile</a> or a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776897(v=vs.85)">roaming user profile</a>.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have <b>TOKEN_QUERY</b>, <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileInfo">
      <para>Type: <b>LPPROFILEINFO</b></para>
      <para>Pointer to a <see cref="PROFILEINFO" /> structure. <b>LoadUserProfile</b> fails and returns <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure at <i>lpProfileInfo</i> is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When a user logs on interactively, the system automatically loads the user's profile. If a service or an application impersonates a user, the system does not load the user's profile. Therefore, the service or application should load the user's profile with <b>LoadUserProfile</b>.</para>
      <para>Services and applications that call <b>LoadUserProfile</b> should check to see if the user has a roaming profile. If the user has a roaming profile, specify its path as the <b>lpProfilePath</b> member of
<see cref="PROFILEINFO" />. To retrieve the user's roaming profile path, you can call the
<see cref="NetUserGetInfo" /> function, specifying information level 3 or 4.</para>
      <para>Upon successful return, the <b>hProfile</b> member of <see cref="PROFILEINFO" /> is a registry key handle opened to the root of the user's hive. It has been opened with full access (KEY_ALL_ACCESS). If a service that is impersonating a user needs to read or write to the user's registry file, use this handle instead of <b>HKEY_CURRENT_USER</b>. Do not close the <b>hProfile</b> handle. Instead, pass it to the
<see cref="UnloadUserProfile" /> function. This function closes the handle. You should ensure that all handles to keys in the user's registry hive are closed. If you do not close all open registry handles, the user's profile fails to unload. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a> and <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-hives">Registry Hives</a>.</para>
      <para>Note that it is your responsibility to load the user's registry hive into the <b>HKEY_USERS</b> registry key with the <b>LoadUserProfile</b> function before you call <see cref="CreateProcessAsUser" />. This is because <b>CreateProcessAsUser</b> does not load the specified user's profile into <b>HKEY_USERS</b>. This means that access to information in the <b>HKEY_CURRENT_USER</b> registry key may not produce results consistent with a normal interactive logon.</para>
      <para>The calling process must have the <b>SE_RESTORE_NAME</b> and <b>SE_BACKUP_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>Starting with Windows XP Service Pack 2 (SP2) and Windows Server 2003, the caller must be an administrator or the LocalSystem account. It is not sufficient for the caller to merely impersonate the administrator or LocalSystem account.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines LoadUserProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PROFILEINFO" />
    <seealso cref="UnloadUserProfile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.LoadUserProfileW">
    <summary>
      <para>Loads the specified user's profile. The profile can be a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776894(v=vs.85)">local user profile</a> or a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776897(v=vs.85)">roaming user profile</a>.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, which is returned by the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have <b>TOKEN_QUERY</b>, <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="lpProfileInfo">
      <para>Type: <b>LPPROFILEINFO</b></para>
      <para>Pointer to a <see cref="PROFILEINFO" /> structure. <b>LoadUserProfile</b> fails and returns <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure at <i>lpProfileInfo</i> is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When a user logs on interactively, the system automatically loads the user's profile. If a service or an application impersonates a user, the system does not load the user's profile. Therefore, the service or application should load the user's profile with <b>LoadUserProfile</b>.</para>
      <para>Services and applications that call <b>LoadUserProfile</b> should check to see if the user has a roaming profile. If the user has a roaming profile, specify its path as the <b>lpProfilePath</b> member of
<see cref="PROFILEINFO" />. To retrieve the user's roaming profile path, you can call the
<see cref="NetUserGetInfo" /> function, specifying information level 3 or 4.</para>
      <para>Upon successful return, the <b>hProfile</b> member of <see cref="PROFILEINFO" /> is a registry key handle opened to the root of the user's hive. It has been opened with full access (KEY_ALL_ACCESS). If a service that is impersonating a user needs to read or write to the user's registry file, use this handle instead of <b>HKEY_CURRENT_USER</b>. Do not close the <b>hProfile</b> handle. Instead, pass it to the
<see cref="UnloadUserProfile" /> function. This function closes the handle. You should ensure that all handles to keys in the user's registry hive are closed. If you do not close all open registry handles, the user's profile fails to unload. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a> and <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-hives">Registry Hives</a>.</para>
      <para>Note that it is your responsibility to load the user's registry hive into the <b>HKEY_USERS</b> registry key with the <b>LoadUserProfile</b> function before you call <see cref="CreateProcessAsUser" />. This is because <b>CreateProcessAsUser</b> does not load the specified user's profile into <b>HKEY_USERS</b>. This means that access to information in the <b>HKEY_CURRENT_USER</b> registry key may not produce results consistent with a normal interactive logon.</para>
      <para>The calling process must have the <b>SE_RESTORE_NAME</b> and <b>SE_BACKUP_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>Starting with Windows XP Service Pack 2 (SP2) and Windows Server 2003, the caller must be an administrator or the LocalSystem account. It is not sufficient for the caller to merely impersonate the administrator or LocalSystem account.</para>
      <blockquote>
        <para>[!NOTE]
The userenv.h header defines LoadUserProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PROFILEINFO" />
    <seealso cref="UnloadUserProfile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.ProcessGroupPolicyCompleted">
    <summary>
      <para>The
<b>ProcessGroupPolicyCompleted</b> function notifies the system that the specified extension has finished applying policy.</para>
    </summary>
    <param name="extensionId">
      <para>Specifies the unique <b>GUID</b> that identifies the extension.</para>
    </param>
    <param name="pAsyncHandle">
      <para>Asynchronous completion handle. This handle is passed to the
<a href="https://docs.microsoft.com//windows/desktop/api/userenv/nc-userenv-pfnprocessgrouppolicy">ProcessGroupPolicy</a> function.</para>
    </param>
    <param name="dwStatus">
      <para>Specifies the completion status of asynchronous processing.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. Otherwise, the function returns one of the system error codes. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/userenv/nc-userenv-pfnprocessgrouppolicy">ProcessGroupPolicy</seealso>
  </member>
  <member name="Windows.ProcessGroupPolicyCompletedEx">
    <summary>
      <para>The
<b>ProcessGroupPolicyCompletedEx</b> function notifies the system that the specified policy extension has finished applying policy. The function also reports the status of Resultant Set of Policy (RSoP) logging.</para>
    </summary>
    <param name="extensionId">
      <para>Specifies the unique <b>GUID</b> that identifies the policy extension.</para>
    </param>
    <param name="pAsyncHandle">
      <para>Asynchronous completion handle. This handle is passed to the
<a href="https://docs.microsoft.com//windows/desktop/api/userenv/nc-userenv-pfnprocessgrouppolicyex">ProcessGroupPolicyEx</a> callback function.</para>
    </param>
    <param name="dwStatus">
      <para>Specifies the completion status of asynchronous processing of policy.</para>
    </param>
    <param name="RsopStatus">
      <para>Specifies an <b>HRESULT</b> return code that indicates the status of RSoP logging.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. Otherwise, the function returns one of the system error codes. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/userenv/nc-userenv-pfnprocessgrouppolicy">ProcessGroupPolicy</seealso>
    <seealso cref="ProcessGroupPolicyCompleted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/userenv/nc-userenv-pfnprocessgrouppolicyex">ProcessGroupPolicyEx</seealso>
  </member>
  <member name="Windows.RefreshPolicy">
    <summary>
      <para>The
<b>RefreshPolicy</b> function causes policy to be applied immediately on the client computer. To apply policy and specify the type of refresh that should occur, you can call the extended function
<see cref="RefreshPolicyEx" />.</para>
    </summary>
    <param name="bMachine">
      <para>Specifies whether to refresh the computer policy or user policy. If this value is <b>TRUE</b>, the system refreshes the computer policy. If this value is <b>FALSE</b>, the system refreshes the user policy.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>By default, policy is reapplied every 90 minutes.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/userenv/nc-userenv-pfnprocessgrouppolicy">ProcessGroupPolicy</seealso>
  </member>
  <member name="Windows.RefreshPolicyEx">
    <summary>
      <para>The
<b>RefreshPolicyEx</b> function causes policy to be applied immediately on the computer. The extended function allows you to specify the type of policy refresh to apply.</para>
    </summary>
    <param name="bMachine">
      <para>Specifies whether to refresh the computer policy or user policy. If this value is <b>TRUE</b>, the system refreshes the computer policy. If this value is <b>FALSE</b>, the system refreshes the user policy.</para>
    </param>
    <param name="dwOptions">
      <para>Specifies the type of policy refresh to apply. This parameter can be the following value.</para>
      <h4>RP_FORCE</h4>
      <para>Reapply all policies even if no policy change was detected.</para>
      <para>Note that if there are any client-side extensions that can be applied at boot or logon time, (for example, an application installation extension), the extensions are re-applied at the next boot or logon, even if no policy change is detected.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If you do not need to specify the <i>dwOptions</i> parameter, you can call the
<see cref="RefreshPolicy" /> function instead.</para>
      <para>By default, policy is reapplied every 90 minutes.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/userenv/nc-userenv-pfnprocessgrouppolicy">ProcessGroupPolicy</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/userenv/nc-userenv-pfnprocessgrouppolicyex">ProcessGroupPolicyEx</seealso>
    <seealso cref="RefreshPolicy" />
  </member>
  <member name="Windows.RegisterGPNotification">
    <summary>
      <para>The
<b>RegisterGPNotification</b> function enables an application to receive notification when there is a change in policy. When a policy change occurs, the specified event object is set to the signaled state.</para>
    </summary>
    <param name="hEvent">
      <para>Handle to an event object. Use the
<see cref="CreateEvent" /> function to create the event object.</para>
    </param>
    <param name="bMachine">
      <para>Specifies the policy change type. If <b>TRUE</b>, computer policy changes are reported. If <b>FALSE</b>, user policy changes are reported.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Call the
<see cref="UnregisterGPNotification" /> function to unregister the handle from receiving policy change notifications. Call the
<see cref="CloseHandle" /> function to close the handle when it is no longer required.</para>
      <para>An application can also receive notifications about policy changes when a
<a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message is broadcast. In this instance, the <i>wParam</i> parameter value is 1 if computer policy was applied; it is zero if user policy was applied. The <i>lParam</i> parameter points to the string "Policy".</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
    <seealso cref="UnregisterGPNotification" />
  </member>
  <member name="Windows.RSoPAccessCheckByType">
    <summary>
      <para>The
<b>RSoPAccessCheckByType</b> function determines whether a security descriptor grants a specified set of access rights to the client identified by an <b>RSOPTOKEN</b>.</para>
    </summary>
    <param name="pSecurityDescriptor">
      <para>Pointer to a
<see cref="SECURITY_DESCRIPTOR" /> against which access on the object is checked.</para>
    </param>
    <param name="pPrincipalSelfSid">
      <para>Pointer to a SID. If the security descriptor is associated with an object that represents a principal (for example, a user object), this parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known <b>PRINCIPAL_SELF</b> SID ("S-1-5-10"). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-identifiers">Security Identifiers</a> and
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-Known SIDs</a>.</para>
      <para>This parameter should be <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="pRsopToken">
      <para>Pointer to a valid <b>RSOPTOKEN</b> representing the client attempting to gain access to the object.</para>
    </param>
    <param name="dwDesiredAccessMask">
      <para>Specifies an access mask that indicates the access rights to check. This mask can contain a combination of
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/generic-access-rights">generic</a>,
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">standard</a> and specific access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-and-access-masks">Access Rights and Access Masks</a>.</para>
    </param>
    <param name="pObjectTypeList">
      <para>Pointer to an array of
<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a <b>GUID</b> that identifies the object type and a value indicating the level of the object type in the hierarchy of object types. The array should not have two elements with the same <b>GUID</b>.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order,
<b>RSoPAccessCheckByType</b> fails and
<see cref="GetLastError" /> returns <b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="ObjectTypeListLength">
      <para>Specifies the number of elements in the <i>pObjectTypeList</i> array.</para>
    </param>
    <param name="pGenericMapping">
      <para>Pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="pPrivilegeSet">
      <para>This parameter is currently unused.</para>
    </param>
    <param name="pdwPrivilegeSetLength">
      <para>This parameter is currently unused.</para>
    </param>
    <param name="pdwGrantedAccessMask">
      <para>Pointer to an
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-and-access-masks">access mask</a> that receives the granted access rights.</para>
      <para>If the function succeeds, the <i>pbAccessStatus</i> parameter is set to <b>TRUE</b>, and the mask is updated to contain the standard and specific rights granted. If <i>pbAccessStatus</i> is set to <b>FALSE</b>, this parameter is set to zero. If the function fails, the mask is not modified.</para>
    </param>
    <param name="pbAccessStatus">
      <para>Pointer to a variable that receives the results of the access check.</para>
      <para>If the function succeeds, and the requested set of access rights are granted, this parameter is set to <b>TRUE</b>. Otherwise, this parameter is set to <b>FALSE</b>. If the function fails, the status is not modified.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>S_OK</b>. Otherwise, the function returns one of the COM error codes defined in the Platform SDK header file WinError.h.</para>
    </returns>
    <remarks>
      <para>The
<b>RSoPAccessCheckByType</b> function compares the specified security descriptor with the specified <b>RSOPTOKEN</b> and indicates, in the <i>pbAccessStatus</i> parameter, whether access is granted or denied.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
    <seealso cref="RSoPFileAccessCheck" />
  </member>
  <member name="Windows.RSoPFileAccessCheck">
    <summary>
      <para>The
<b>RSoPFileAccessCheck</b> function determines whether a file's security descriptor grants a specified set of file access rights to the client identified by an <b>RSOPTOKEN</b>.</para>
    </summary>
    <param name="pszFileName">
      <para>Pointer to the name of the relevant file. The file must already exist.</para>
    </param>
    <param name="pRsopToken">
      <para>Pointer to a valid <b>RSOPTOKEN</b> representing the client attempting to gain access to the file.</para>
    </param>
    <param name="dwDesiredAccessMask">
      <para>Specifies an access mask that indicates the access rights to check. This mask can contain a combination of
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/generic-access-rights">generic</a>,
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">standard</a>, and specific access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-and-access-masks">Access Rights and Access Masks</a>.</para>
    </param>
    <param name="pdwGrantedAccessMask">
      <para>Pointer to an access mask that receives the granted access rights.</para>
      <para>If the function succeeds, the <i>pbAccessStatus</i> parameter is set to <b>TRUE</b>, and the mask is updated to contain the standard and specific rights granted. If <i>pbAccessStatus</i> is set to <b>FALSE</b>, this parameter is set to zero. If the function fails, the mask is not modified.</para>
    </param>
    <param name="pbAccessStatus">
      <para>Pointer to a variable that receives the results of the access check.</para>
      <para>If the function succeeds, and the requested set of access rights are granted, this parameter is set to <b>TRUE</b>. Otherwise, this parameter is set to <b>FALSE</b>. If the function fails, the status is not modified.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>S_OK</b>. Otherwise, the function returns one of the COM error codes defined in the Platform SDK header file WinError.h.</para>
    </returns>
    <remarks>
      <para>The
<b>RSoPFileAccessCheck</b> function indicates, in the <i>pbAccessStatus</i> parameter, whether access is granted or denied to the client identified by the <b>RSOPTOKEN</b>. If access is granted, the requested access mask becomes the object's granted access mask.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
    <seealso cref="RSoPAccessCheckByType" />
  </member>
  <member name="Windows.RSoPResetPolicySettingStatus">
    <summary>
      <para>The
<b>RSoPResetPolicySettingStatus</b> function unlinks the
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysettingstatus">RSOP_PolicySettingStatus</a> instance from its
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysetting">RSOP_PolicySetting</a> instance. The function deletes the instances of
<b>RSOP_PolicySettingStatus</b> and
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysettinglink">RSOP_PolicySettingLink</a>. Optionally, you can also specify that the function delete the instance of
<b>RSOP_PolicySetting</b>.</para>
    </summary>
    <param name="dwFlags">
      <para>This parameter is currently unused.</para>
    </param>
    <param name="pServices">
      <para>Specifies a WMI services pointer to the RSoP namespace to which the policy data is to be written. This parameter is required.</para>
    </param>
    <param name="pSettingInstance">
      <para>Pointer to an instance of
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysetting">RSOP_PolicySetting</a> containing the policy setting. This parameter is required and can also point to the instance's children.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>S_OK</b>. Otherwise, the function returns one of the COM error codes defined in the Platform SDK header file WinError.h.</para>
    </returns>
    <remarks>
      <para>To link (associate) the
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysettingstatus">RSOP_PolicySettingStatus</a> instance to its
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysetting">RSOP_PolicySetting</a> instance, you can call the
<see cref="RSoPSetPolicySettingStatus" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
    <seealso cref="RSoPSetPolicySettingStatus" />
  </member>
  <member name="Windows.RSoPSetPolicySettingStatus">
    <summary>
      <para>The
<b>RSoPSetPolicySettingStatus</b> function creates an instance of
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysettingstatus">RSOP_PolicySettingStatus</a> and an instance of
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysettinglink">RSOP_PolicySettingLink</a>. The function links (associates)
<b>RSOP_PolicySettingStatus</b> to its
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysetting">RSOP_PolicySetting</a> instance.</para>
    </summary>
    <param name="dwFlags">
      <para>This parameter is currently unused.</para>
    </param>
    <param name="pServices">
      <para>Specifies a WMI services pointer to the RSoP namespace to which the policy data is to be written. This parameter is required.</para>
    </param>
    <param name="pSettingInstance">
      <para>Pointer to an instance of
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysetting">RSOP_PolicySetting</a> containing the policy setting. This parameter is required and can point to the instance's children.</para>
    </param>
    <param name="nInfo">
      <para>Specifies the number of elements in the <i>pStatus</i> array.</para>
    </param>
    <param name="pStatus">
      <para>Pointer to an array of
<see cref="POLICYSETTINGSTATUSINFO" /> structures.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>S_OK</b>. Otherwise, the function returns one of the COM error codes defined in the Platform SDK header file WinError.h.</para>
    </returns>
    <remarks>
      <para>To unlink an
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysettingstatus">RSOP_PolicySettingStatus</a> instance from its
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/rsop-policysetting">RSOP_PolicySetting</a> instance, you can call the
<see cref="RSoPResetPolicySettingStatus" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
    <seealso cref="IWbemClassObject" />
    <seealso cref="IWbemServices" />
    <seealso cref="RSoPResetPolicySettingStatus" />
  </member>
  <member name="Windows.UnloadUserProfile">
    <summary>
      <para>Unloads a user's profile that was loaded by the <see cref="LoadUserProfile" /> function. The caller must have administrative privileges on the computer. For more information, see the Remarks section of the <b>LoadUserProfile</b> function.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>Token for the user, returned from the <see cref="LogonUser" />, <see cref="CreateRestrictedToken" />, <see cref="DuplicateToken" />, <see cref="OpenProcessToken" />, or <see cref="OpenThreadToken" /> function. The token must have <b>TOKEN_IMPERSONATE</b> and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="hProfile">
      <para>Type: <b>HANDLE</b></para>
      <para>Handle to the registry key. This value is the <b>hProfile</b> member of the <see cref="PROFILEINFO" /> structure. For more information see the Remarks section of <see cref="LoadUserProfile" /> and <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Before calling <b>UnloadUserProfile</b> you should ensure that all handles to keys that you have opened in the user's registry hive are closed. If you do not close all open registry handles, the user's profile fails to unload. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a> and <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-hives">Registry Hives</a>.</para>
      <para>For more information about calling functions that require administrator privileges, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
    </remarks>
    <seealso cref="LoadUserProfile" />
    <seealso cref="PROFILEINFO" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776900(v=vs.85)">User Profiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776901(v=vs.85)">User Profiles Reference</seealso>
  </member>
  <member name="Windows.UnregisterGPNotification">
    <summary>
      <para>The
<b>UnregisterGPNotification</b> function unregisters the specified policy-notification handle from receiving policy change notifications.</para>
    </summary>
    <param name="hEvent">
      <para>Policy-notification handle passed to the
<see cref="RegisterGPNotification" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The caller must call the
<see cref="CloseHandle" /> function to close the handle when it is no longer needed.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/group-policy-functions">Group Policy
Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/Policy/about-group-policy">Group Policy
Overview</seealso>
    <seealso cref="RegisterGPNotification" />
  </member>
</doc>