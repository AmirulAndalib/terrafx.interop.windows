<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="IMarshal.DisconnectObject">
    <summary>
      <para>Releases all connections to an object. The object's server calls the object's implementation of this method prior to shutting down.</para>
    </summary>
    <param name="dwReserved">
      <para>This parameter is reserved and must be 0.</para>
    </param>
    <returns>
      <para>If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.</para>
    </returns>
    <remarks>
      <para>This method is implemented on the object, not the proxy.</para>
      <h3>Notes to Callers</h3>
      <para>The usual case in which this method is called occurs when an end user forcibly closes a COM server that has one or more running objects that implement <see cref="IMarshal" />. Prior to shutting down, the server calls the <see cref="CoDisconnectObject" /> function to release external connections to all its running objects. For each object that implements <b>IMarshal</b>, however, this function calls <b>DisconnectObject</b> so that each object that manages its own marshaling can take steps to notify its proxy that it is about to shut down.</para>
      <h3>Notes to Implementers</h3>
      <para>As part of its normal shutdown code, a server should call <see cref="CoDisconnectObject" />, which in turn calls <b>DisconnectObject</b>, on each of its running objects that implements <see cref="IMarshal" />.</para>
      <para>The outcome of any implementation of this method should be to enable a proxy to respond to all subsequent calls from its client by returning RPC_E_DISCONNECTED or CO_E_OBJNOTCONNECTED rather than attempting to forward the calls on to the original object. It is up to the client to destroy the proxy.</para>
      <para>If you are implementing this method for an immutable object, such as a moniker, your implementation does not need to do anything because such objects are typically copied whole into the client's address space. Therefore, they have neither a proxy nor a connection to the original object. For more information on marshaling immutable objects, see the "When to Implement" section of the <see cref="IMarshal" /> topic.</para>
    </remarks>
    <seealso cref="CoDisconnectObject" />
    <seealso cref="IMarshal" />
  </member>
  <member name="IMarshal.GetMarshalSizeMax">
    <summary>
      <para>Retrieves the maximum size of the buffer that will be needed during marshaling.</para>
    </summary>
    <param name="riid">
      <para>A reference to the identifier of the interface to be marshaled.</para>
    </param>
    <param name="pv">
      <para>The interface pointer to be marshaled. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="dwDestContext">
      <para>The destination context where the specified interface is to be unmarshaled. Possible values come from the enumeration <see cref="MSHCTX" />. Unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL).</para>
    </param>
    <param name="pvDestContext">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <param name="mshlflags">
      <para>Indicates whether the data to be marshaled is to be transmitted back to the client process (the typical case) or written to a global table, where it can be retrieved by multiple clients. Possible values come from the <see cref="MSHLFLAGS" /> enumeration.</para>
    </param>
    <param name="pSize">
      <para>A pointer to a variable that receives the maximum size of the buffer.</para>
    </param>
    <returns>
      <para>This method can return the standard return values E_FAIL and S_OK, as well as the following value.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_NOINTERFACE</b>
            </para>
          </description>
          <description>
            <para>The specified interface is not supported.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This method is called indirectly, in a call to <see cref="CoGetMarshalSizeMax" />, by whatever code in the server process is responsible for marshaling a pointer to an interface on an object. This marshaling code is usually a stub generated by COM for one of several interfaces that can marshal a pointer to an interface implemented on an entirely different object. Examples include the <see cref="IClassFactory" /> and <see cref="IOleItemContainer" /> interfaces. For purposes of discussion, the code responsible for marshaling a pointer is called the <i>marshaling stub</i>.</para>
      <para>To create a proxy for an object, COM requires two pieces of information from the original object: the amount of data to be written to the marshaling stream and the proxy's CLSID.</para>
      <para>The marshaling stub obtains these two pieces of information with successive calls to <see cref="CoGetMarshalSizeMax" /> and <see cref="CoMarshalInterface" />.</para>
      <h3>Notes to Callers</h3>
      <para>The marshaling stub, through a call to <see cref="CoGetMarshalSizeMax" />, calls the object's implementation of this method to preallocate the stream buffer that will be passed to <see cref="MarshalInterface" />.</para>
      <para>You do not explicitly call this method if you are implementing existing COM interfaces or using the Microsoft Interface Definition Language (MIDL) to define your own custom interfaces. In either case, the MIDL-generated stub automatically makes the call.</para>
      <para>If you are not using MIDL to define your own interface (see <a href="https://docs.microsoft.com//windows/desktop/com/defining-com-interfaces">Defining COM Interfaces</a>), your marshaling stub does not have to call <b>GetMarshalSizeMax</b>, although doing so is highly recommended. An object knows better than an interface stub what the maximum size of a marshaling data packet is likely to be. Therefore, unless you are providing an automatically growing stream that is so efficient that the overhead of expanding it is insignificant, you should call this method even when implementing your own interfaces.</para>
      <para>The value returned by this method is guaranteed to be valid only as long as the internal state of the object being marshaled does not change. Therefore, the actual marshaling should be done immediately after this function returns, or the stub runs the risk that the object, because of some change in state, might require more memory to marshal than it originally indicated.</para>
      <h3>Notes to Implementers</h3>
      <para>Your implementation of <see cref="MarshalInterface" /> will use the preallocated buffer to write marshaling data into the stream. If the buffer is too small, the marshaling operation will fail. Therefore, the value returned by this method must be a conservative estimate of the amount of data that will be needed to marshal the interface. Violation of this requirement should be treated as a catastrophic error.</para>
      <para>In a subsequent call to <see cref="MarshalInterface" />, your <see cref="IMarshal" /> implementation cannot rely on the caller actually having called <b>GetMarshalSizeMax</b> beforehand. It must still be wary of STG_E_MEDIUMFULL errors returned by the stream and be prepared to handle them gracefully.</para>
      <para>To ensure that your implementation of <b>GetMarshalSizeMax</b> will continue to work properly as new destination contexts are supported in the future, delegate marshaling to the COM default implementation for all <i>dwDestContext</i> values that your implementation does not understand. To delegate marshaling to the COM default implementation, call the <see cref="CoGetStandardMarshal" /> function.</para>
    </remarks>
    <seealso cref="CoGetMarshalSizeMax" />
    <seealso cref="IMarshal" />
  </member>
  <member name="IMarshal.GetUnmarshalClass">
    <summary>
      <para>Retrieves the CLSID of the unmarshaling code.</para>
    </summary>
    <param name="riid">
      <para>A reference to the identifier of the interface to be marshaled.</para>
    </param>
    <param name="pv">
      <para>A pointer to the interface to be marshaled; can be <b>NULL</b> if the caller does not have a pointer to the desired interface.</para>
    </param>
    <param name="dwDestContext">
      <para>The destination context where the specified interface is to be unmarshaled. Possible values come from the enumeration <see cref="MSHCTX" />. Unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL).</para>
    </param>
    <param name="pvDestContext">
      <para>This parameter is reserved and must be <b>NULL</b>.</para>
    </param>
    <param name="mshlflags">
      <para>Indicates whether the data to be marshaled is to be transmitted back to the client process (the typical case) or written to a global table, where it can be retrieved by multiple clients. Possible values come from the <see cref="MSHLFLAGS" /> enumeration.</para>
    </param>
    <param name="pCid">
      <para>A pointer that receives the CLSID to be used to create a proxy in the client process.</para>
    </param>
    <returns>
      <para>If the method succeeds, the return value is S_OK. Otherwise, it is S_FALSE.</para>
    </returns>
    <remarks>
      <para>This method is called indirectly, in  a call to <see cref="CoMarshalInterface" />, by whatever code in the server process is responsible for marshaling a pointer to an interface on an object. This marshaling code is usually a stub generated by COM for one of several interfaces that can marshal a pointer to an interface implemented on an entirely different object. Examples include the <see cref="IClassFactory" /> and <see cref="IOleItemContainer" /> interfaces. For purposes of discussion, the code responsible for marshaling a pointer is called the <i>marshaling stub</i>.</para>
      <para>To create a proxy for an object, COM requires two pieces of information from the original object: the amount of data to be written to the marshaling stream and the proxy's CLSID.</para>
      <para>The marshaling stub obtains these two pieces of information with successive calls to <see cref="CoGetMarshalSizeMax" /> and <see cref="CoMarshalInterface" />.</para>
      <h3>Notes to Callers</h3>
      <para>The marshaling stub calls the object's implementation of this method to obtain the CLSID to be used in creating an instance of the proxy. The client, upon receiving the CLSID, loads the DLL listed for it in the system registry.</para>
      <para>You do not explicitly call this method if you are implementing existing COM interfaces or using the Microsoft Interface Definition Language (MIDL) to define your own interfaces. In either case, the stub automatically makes the call. See <a href="https://docs.microsoft.com//windows/desktop/com/defining-com-interfaces">Defining COM Interfaces</a>.</para>
      <para>If you are not using MIDL to define your own interface, your stub must call this method, either directly or indirectly, to get the CLSID that the client-side COM library needs to create a proxy for the object implementing the interface.</para>
      <para>If the caller has a pointer to the interface to be marshaled, it should, as a matter of efficiency, use the <i>pv</i> parameter to pass that pointer. In this way, an implementation that may use such a pointer to determine the appropriate CLSID for the proxy does not have to call <see cref="QueryInterface" /> on itself. If a caller does not have a pointer to the interface to be marshaled, it can pass <b>NULL</b>.</para>
      <h3>Notes to Implementers</h3>
      <para>COM calls <b>GetUnmarshalClass</b> to obtain the CLSID to be used for creating a proxy in the client process. The CLSID to be used for a proxy is normally not that of the original object, but one you will have generated (using the Guidgen.exe tool) specifically for your proxy object.</para>
      <para>Implement this method for each object that provides marshaling for one or more of its interfaces. The code responsible for marshaling the object writes the CLSID, along with the marshaling data, to a stream; COM extracts the CLSID and data from the stream on the receiving side.</para>
      <para>If your proxy implementation consists simply of copying the entire original object into the client process, thereby eliminating the need to forward calls to the original object, the CLSID returned would be the same as that of the original object. This strategy, of course, is advisable only for objects that are not expected to change.</para>
      <para>If the <i>pv</i> parameter is <b>NULL</b> and your implementation needs an interface pointer, it can call <see cref="QueryInterface" /> on the current object to get it. The <i>pv</i> parameter exists merely to improve efficiency.</para>
      <para>To ensure that your implementation of <b>GetUnmarshalClass</b> continues to work properly as new destination contexts are supported in the future, delegate marshaling to the COM default implementation for all <i>dwDestContext</i> values that your implementation does not handle. To delegate marshaling to the COM default implementation, call the <see cref="CoGetStandardMarshal" /> function.</para>
      <para>
        <b>Note</b>  The <b>ThreadingModel</b> registry value must be <b>Both</b> for an in-process server that implements the CLSID returned from the <b>GetUnmarshalClass</b> method.
For more information, see <a href="https://docs.microsoft.com//windows/desktop/com/inprocserver32">InprocServer32</a>.</para>
    </remarks>
    <seealso cref="CoMarshalInterface" />
    <seealso cref="IMarshal" />
  </member>
  <member name="IMarshal.MarshalInterface">
    <summary>
      <para>Marshals an interface pointer.</para>
    </summary>
    <param name="pStm">
      <para>A pointer to the stream to be used during marshaling.</para>
    </param>
    <param name="riid">
      <para>A reference to the identifier of the interface to be marshaled. This interface must be derived from the <see cref="IUnknown" /> interface.</para>
    </param>
    <param name="pv">
      <para>A pointer to the interface pointer to be marshaled. This parameter can be <b>NULL</b> if the caller does not have a pointer to the desired interface.</para>
    </param>
    <param name="dwDestContext">
      <para>The destination context where the specified interface is to be unmarshaled. Possible values for <i>dwDestContext</i> come from the enumeration <see cref="MSHCTX" />. Currently, unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL).</para>
    </param>
    <param name="pvDestContext">
      <para>This parameter is reserved and must be 0.</para>
    </param>
    <param name="mshlflags">
      <para>Indicates whether the data to be marshaled is to be transmitted back to the client process—the typical case—or written to a global table, where it can be retrieved by multiple clients. Possible values come from the <see cref="MSHLFLAGS" /> enumeration.</para>
    </param>
    <returns>
      <para>This method can return the standard return value E_FAIL, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The interface pointer was marshaled successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_NOINTERFACE</b>
            </para>
          </description>
          <description>
            <para>The specified interface is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>STG_E_MEDIUMFULL</b>
            </para>
          </description>
          <description>
            <para>The stream is full.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This method is called indirectly, in  a call to <see cref="CoMarshalInterface" />, by whatever code in the server process is responsible for marshaling a pointer to an interface on an object. This marshaling code is usually a stub generated by COM for one of several interfaces that can marshal a pointer to an interface implemented on an entirely different object. Examples include the <see cref="IClassFactory" /> and <see cref="IOleItemContainer" /> interfaces. For purposes of discussion, the code responsible for marshaling a pointer is called the <i>marshaling stub</i>.</para>
      <h3>Notes to Callers</h3>
      <para>Typically, rather than calling <b>MarshalInterface</b> directly, your marshaling stub instead should call the <see cref="CoMarshalInterface" /> function, which contains a call to this method. The stub makes this call to command an object to write its marshaling data into a stream. The stub then either passes the marshaling data back to the client process or writes it to a global table, where it can be unmarshaled by multiple clients. The stub's call to <b>CoMarshalInterface</b> is normally preceded by a call to <see cref="CoGetMarshalSizeMax" /> to get the maximum size of the stream buffer into which the marshaling data will be written.</para>
      <para>You do not explicitly call this method if you are implementing existing COM interfaces or defining your own interfaces using the Microsoft Interface Definition Language (MIDL). In either case, the MIDL-generated stub automatically makes the call.</para>
      <para>If you are not using MIDL to define your own interface, your marshaling stub must call this method, either directly or indirectly. Your stub implementation should call <b>MarshalInterface</b> immediately after its previous call to <see cref="IMarshal.GetMarshalSizeMax" /> returns. Because the value returned by <b>GetMarshalSizeMax</b> is guaranteed to be valid only as long as the internal state of the object being marshaled does not change, a delay in calling <b>MarshalInterface</b> runs the risk that the object will require a larger stream buffer than originally indicated.</para>
      <para>If the caller has a pointer to the interface to be marshaled, it should, as a matter of efficiency, use the <i>pv</i> parameter to pass that pointer. In this way, an implementation that may use such a pointer to determine the appropriate CLSID for the proxy does not have to call <see cref="QueryInterface" /> on itself. If a caller does not have a pointer to the interface to be marshaled, it can pass <b>NULL</b>.</para>
      <h3>Notes to Implementers</h3>
      <para>Your implementation of <b>MarshalInterface</b> must write to the stream whatever data is needed to initialize the proxy on the receiving side. Such data would include a reference to the interface to be marshaled, a <see cref="MSHLFLAGS" /> value specifying whether the data should be returned to the client process or written to a global table, and whatever is needed to connect to the object, such as a named pipe, handle to a window, or pointer to an RPC channel.</para>
      <para>Your implementation should not assume that the stream is large enough to hold all the data. Rather, it should gracefully handle a STG_E_MEDIUMFULL error. Just before exiting, your implementation should position the seek pointer in the stream immediately after the last byte of data written.</para>
      <para>If the pv parameter is <b>NULL</b> and your implementation needs an interface pointer, it can call <see cref="QueryInterface" /> on the current object to get it. The <i>pv</i> parameter exists merely to improve efficiency.</para>
      <para>To ensure that your implementation of <b>MarshalInterface</b> continues to work properly as new destination contexts are supported in the future, delegate marshaling to the COM default implementation for all <i>dwDestContext</i> values that your implementation does not handle. To delegate marshaling to the COM default implementation, call the <see cref="CoGetStandardMarshal" /> helper function.</para>
      <para>Using the <see cref="MSHLFLAGS" /> enumeration, callers can specify whether an interface pointer is to be marshaled back to a single client or written to a global table, where it can be unmarshaled by multiple clients. You must make sure that your object can handle calls from the multiple proxies that might be created from the same initialization data.</para>
    </remarks>
    <seealso cref="CoMarshalInterface" />
    <seealso cref="IMarshal" />
  </member>
  <member name="IMarshal.ReleaseMarshalData">
    <summary>
      <para>Destroys a marshaled data packet.</para>
    </summary>
    <param name="pStm">
      <para>A pointer to a stream that contains the data packet to be destroyed.</para>
    </param>
    <returns>
      <para>This method can return the standard return values S_OK and E_FAIL, as well as any of the stream-access errors for the <see cref="IStream" /> interface.</para>
    </returns>
    <remarks>
      <para>If an object's marshaled data packet does not get unmarshaled in the client process space and the packet is no longer needed, the client calls <b>ReleaseMarshalData</b> on the proxy's <see cref="IMarshal" /> implementation to instruct the object to destroy the data packet. The call occurs within the <see cref="CoReleaseMarshalData" /> function. The data packet serves as an additional reference on the object, and releasing the data is like releasing an interface pointer by calling <see cref="Release" />.</para>
      <para>If the marshaled data packet somehow does not arrive in the client process or if <b>ReleaseMarshalData</b> is not successfully re-created in the proxy, COM can call this method on the object itself.</para>
      <h3>Notes to Callers</h3>
      <para>You will rarely if ever have occasion to call this method yourself. A possible exception would be if you were to implement <see cref="IMarshal" /> on a class factory for a class object on which you are also implementing <b>IMarshal</b>. In this case, if you were marshaling the object to a table where it could be retrieved by multiple clients, you might, as part of your unmarshaling routine, call <b>ReleaseMarshalData</b> to release the data packet for each proxy.</para>
      <h3>Notes to Implementers</h3>
      <para>If your implementation stores state information about marshaled data packets, you can use this method to release the state information associated with the data packet represented by <i>pStm</i>. Your implementation should also position the seek pointer in the stream past the last byte of data.</para>
    </remarks>
    <seealso cref="CoReleaseMarshalData" />
    <seealso cref="IMarshal" />
  </member>
  <member name="IMarshal.UnmarshalInterface">
    <summary>
      <para>Unmarshals an interface pointer.</para>
    </summary>
    <param name="pStm">
      <para>A pointer to the stream from which the interface pointer is to be unmarshaled.</para>
    </param>
    <param name="riid">
      <para>A reference to the identifier of the interface to be unmarshaled.</para>
    </param>
    <param name="ppv">
      <para>The address of pointer variable that receives the interface pointer. Upon successful return, *<i>ppv</i> contains the requested interface pointer of the interface to be unmarshaled.</para>
    </param>
    <returns>
      <para>This method can return the standard return value E_FAIL, as well as the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The interface pointer was unmarshaled successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_NOINTERFACE</b>
            </para>
          </description>
          <description>
            <para>The specified interface is not supported.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The COM library in the process where unmarshaling is to occur calls the proxy's implementation of this method.</para>
      <h3>Notes to Callers</h3>
      <para>You do not call this method directly. There are, however, some situations in which you might call it indirectly through a call to <see cref="CoUnmarshalInterface" />. For example, if you are implementing a stub, your implementation would call <b>CoUnmarshalInterface</b> when the stub receives an interface pointer as a parameter in a method call.</para>
      <h3>Notes to Implementers</h3>
      <para>The proxy's implementation should read the data written to the stream by the original object's implementation of <see cref="IMarshal.MarshalInterface" /> and use that data to initialize the proxy object whose CLSID was returned by the marshaling stub's call to the original object's implementation of <see cref="IMarshal.GetUnmarshalClass" />.</para>
      <para>To return the appropriate interface pointer, the proxy implementation can simply call <see cref="QueryInterface" /> on itself, passing the <i>riid</i> and <i>ppv</i> parameters. However, your implementation of <b>UnmarshalInterface</b> is free to create a different object and, if necessary, return a pointer to it.</para>
      <para>Just before exiting, even if exiting with an error, your implementation should reposition the seek pointer in the stream immediately after the last byte of data read.</para>
    </remarks>
    <seealso cref="CoUnmarshalInterface" />
    <seealso cref="IMarshal" />
  </member>
  <member name="IMarshal">
    <summary>
      <para>Enables a COM object to define and manage the marshaling of its interface pointers.</para>
    </summary>
    <remarks>
      <para>
        <i>Marshaling</i> is the process of packaging data into packets for transmission to a different process
or computer. Unmarshaling is the process of recovering that data at the receiving end. In any given call, method
arguments are marshaled and unmarshaled in one direction, while return values are marshaled and unmarshaled in
the other.</para>
      <para>Although marshaling applies to all data types, interface pointers require special handling. The fundamental
problem is how client code running in one address space can correctly dereference a pointer to an interface on an
object residing in a different address space. The COM solution is for a client application to communicate with
the original object through a surrogate object, or proxy, which lives in the client's process. The proxy holds a
reference to an interface on the original object and hands the client a pointer to an interface on itself. When
the client calls an interface method on the original object, its call is actually going to the proxy. Therefore,
from the client's point of view, all calls are in-process.</para>
      <para>On receiving a call, the proxy marshals the method arguments and through some means of interprocess
communication, such as RPC, passes them along to code in the server process, which unmarshals the arguments and
passes them to the original object. This same code marshals return values for transmission back to the proxy,
which unmarshals the values and passes them to the client application.</para>
      <para>
        <b>IMarshal</b> provides methods for creating, initializing, and
managing a proxy in a client process; it does not dictate how the proxy should communicate with the original
object. The COM default implementation of <b>IMarshal</b> uses RPC.
When you implement this interface yourself, you are free to choose any method of interprocess communication you
deem to be appropriate for your application—shared memory, named pipe, window handle,
RPC—in short, whatever works.</para>
      <h3>IMarshal Default Implementation</h3>
      <para>COM uses its own internal implementation of the <b>IMarshal</b></para>
      <para>interface to marshal any object that does not provide its own implementation. COM makes this determination by
querying the object for <b>IMarshal</b>. If the interface is
missing, COM defaults to its internal implementation.</para>
      <para>The COM default implementation of <b>IMarshal</b> uses a generic
proxy for each object and creates individual stubs and proxies, as they are needed, for each interface
implemented on the object. This mechanism is necessary because COM cannot know in advance what particular
interfaces a given object may implement. Developers who do not use COM default marshaling, electing instead to
write their own proxy and marshaling routines, know at compile time all the interfaces to be found on their
objects and therefore understand exactly what marshaling code is required. COM, in providing marshaling support
for all objects, must do so at run time.</para>
      <para>The <i>interface proxy</i> resides in the client process; the <i>interface stub</i> resides in the
server. Together, each pair handles all marshaling for the interface. The job of each interface proxy is to
marshal arguments and unmarshal return values and out parameters that are passed back and forth in subsequent
calls to its interface. The job of each interface stub is to unmarshal function arguments and pass them along to
the original object and then marshal the return values and out parameters that the object returns.</para>
      <para>Proxy and stub communicate by means of an RPC (remote procedure call) channel, which utilizes the system's RPC
infrastructure for interprocess communication. The RPC channel implements a single interface,
<see cref="IRpcChannelBuffer" />, to which both interface proxies and
stubs hold a pointer. The proxy and stub call the interface to obtain a marshaling packet, send the data to
their counterpart, and destroy the packet when they are done. The interface stub also holds a pointer to the
original object.</para>
      <para>For any given interface, the proxy and stub are both implemented as instances of the same class, which is
listed for each interface in the system registry under the label
<b>ProxyStubClsid32</b>. This entry maps the interface's IID to the
<b>CLSID</b> of its proxy and stub objects. When COM needs to marshal an interface, it
looks in the system registry to obtain the appropriate <b>CLSID</b>. The server
identified by this <b>CLSID</b> implements both the interface proxy and interface stub.</para>
      <para>Most often, the class to which this <b>CLSID</b> refers is automatically generated by a
tool whose input is a description of the function signatures and semantics of a given interface, written in some
interface description language. While using such a language is highly recommended and encouraged for accuracy's
sake, doing so is not required. Proxies and stubs are merely COM components used by the RPC infrastructure and,
as such, can be written in any manner desired, as long as the correct external contracts are upheld. The
programmer who designs a new interface is responsible for ensuring that all interface proxies and stubs that
ever exist agree on the representation of their marshaled data.</para>
      <para>When created, interface proxies are always aggregated into a larger proxy, which represents the object as a
whole. This object proxy also aggregates the COM generic proxy object, which is known as the
<i>proxy manager</i>. The proxy manager implements two interfaces:
<see cref="IUnknown" /> and
<b>IMarshal</b>. All of the other interfaces that may be implemented
on an object are exposed in its object proxy through the aggregation of individual interface proxies. A client
holding a pointer to the object proxy "believes" it holds a pointer to the actual object.</para>
      <para>A proxy representing the object as a whole is required in the client process so that a client can distinguish
calls to the same interfaces implemented on entirely different objects. Such a requirement does not exist in the
server process, however, where the object itself resides, because all interface stubs communicate only with the
objects for which they were created. No other connection is possible.</para>
      <para>Interface stubs, by contrast with interface proxies, are not aggregated because there is no need that they
appear to some external client to be part of a larger whole. When connected, an interface stub is given a
pointer to the server object to which it should forward method invocations that it receives. Although it is
useful to refer conceptually to a stub manager, meaning whatever pieces of code and state in the server-side RPC
infrastructure that service the remoting of a given object, there is no direct requirement that the code and
state take any particular, well-specified form.</para>
      <para>The first time a client requests a pointer to an interface on a particular object, COM loads an
<see cref="IClassFactory" /> stub in the server process and uses it to
marshal the first pointer back to the client. In the client process, COM loads the generic proxy for the class
factory object and calls its implementation of <b>IMarshal</b> to
unmarshal that first pointer. COM then creates the first interface proxy and hands it a pointer to the RPC
channel. Finally, COM returns the <b>IClassFactory</b> pointer
to the client, which uses it to call
<see cref="IClassFactory.CreateInstance" />, passing it
a reference to the interface.</para>
      <para>Back in the server process, COM now creates a new instance of the object, along with a stub for the requested
interface. This stub marshals the interface pointer back to the client process, where another object proxy is
created, this time for the object itself. Also created is a proxy for the requested interface, a pointer to
which is returned to the client. With subsequent calls to other interfaces on the object, COM will load the
appropriate interface stubs and proxies as needed.</para>
      <para>When a new interface proxy is created, COM hands it a pointer to the proxy manager's implementation of
<see cref="IUnknown" />, to which it delegates all
<see cref="QueryInterface" /> calls. Each interface proxy
implements two interfaces of its own: the interface it represents and
<see cref="IRpcProxyBuffer" />. The interface proxy exposes its own
interface directly to clients, which can obtain its pointer by calling
<b>QueryInterface</b> on the proxy manager. Only COM,
however, can call <b>IRpcProxyBuffer</b>, which is used to
connect and disconnect the proxy to the RPC channel. A client cannot query an interface proxy to obtain a
pointer to the <b>IRpcProxyBuffer</b> interface.</para>
      <para>On the server side, each interface stub implements
<see cref="IRpcStubBuffer" />. The server code acting as a stub manager
calls <see cref="IRpcStubBuffer.Connect" /> and passes the
interface stub the <see cref="IUnknown" /> pointer of its object.</para>
      <para>When an interface proxy receives a method invocation, it obtains a marshaling packet from its RPC channel
through a call to
<see cref="IRpcChannelBuffer.GetBuffer" />. The process
of marshaling the arguments will copy data into the buffer. When marshaling is complete, the interface proxy
invokes <see cref="IRpcChannelBuffer.SendReceive" /> to
send the marshaled packet to the corresponding interface stub. When
<b>IRpcChannelBuffer.SendReceive</b> returns,
the buffer into which the arguments were marshaled will have been replaced by a new buffer containing the return
values marshaled from the interface stub. The interface proxy unmarshals the return values, invokes
<see cref="IRpcChannelBuffer.FreeBuffer" /> to free the
buffer, and then returns the return values to the original caller of the method.</para>
      <para>It is the implementation of
<see cref="IRpcChannelBuffer.SendReceive" /> that
actually sends the request to the server process and that knows how to identify the server process and, within
that process, the object to which the request should be sent. The channel implementation also knows how to
forward the request on to the appropriate stub manager in that process. The interface stub unmarshals the
arguments from the provided buffer, invokes the indicated method on the server object, and marshals the return
values back into a new buffer allocated by a call to
<see cref="IRpcChannelBuffer.GetBuffer" />. The channel
then transmits the return data packet back to the interface proxy, which is still in the middle of
<b>IRpcChannelBuffer.SendReceive</b>, which
returns to the interface proxy.</para>
      <para>A particular instance of an interface proxy can be used to service more than one interface, as long as the
following conditions are met:</para>
      <list type="bullet">
        <item>
          <description>The IIDs of the affected interfaces must be mapped to the appropriate
<a href="https://docs.microsoft.com//windows/desktop/com/proxystubclsid">ProxyStubClsid</a> in the system registry.</description>
        </item>
        <item>
          <description>The interface proxy must support calls to
<see cref="QueryInterface" /> from one supported interface to
the other interfaces, as usual, as well as from <see cref="IUnknown" /> and
<see cref="IRpcProxyBuffer" />.</description>
        </item>
      </list>
      <para>A single instance of an interface stub can also service more than one interface, but only if that set of
interfaces has a strict single-inheritance relationship. This restriction exists because the stub can direct
method invocations to multiple interfaces only where it knows in advance which methods are implemented on which
interfaces.</para>
      <para>At various times, proxies and stubs will have need to allocate or free memory. Interface proxies, for example,
will need to allocate memory in which to return out parameters to their caller. In this respect, interface
proxies and interface stubs are just normal COM components, in that they should use the standard task allocator.
(See <see cref="CoGetMalloc" />.)</para>
    </remarks>
    <seealso cref="IStdMarshalInfo" />
  </member>
</doc>