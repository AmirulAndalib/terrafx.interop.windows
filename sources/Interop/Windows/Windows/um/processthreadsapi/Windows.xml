<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.CreateProcess">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the
<see cref="CreateProcessAsUser" /> or
<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>,  the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by  <i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" />  contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The name of the executable in the command line that the operating system provides to a process is not necessarily identical to that in the command line that the calling process gives to the
<b>CreateProcess</b> function. The operating system may prepend a fully qualified path to an executable name that is provided without a fully qualified path.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcess</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>A  parent process can directly alter the environment variables of a child process during process creation.  This is the only  situation when a process can directly change the environment settings of another process. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
      <para>If an application provides an environment block, the current directory information of the system drives is not automatically propagated to the new process. For example, there is an environment variable named =C: whose value is the current directory on drive C. An application must manually pass the current directory information to the new process. To do so, the application must explicitly create these environment variable strings, sort them alphabetically (because the system uses a sorted environment), and put them into the environment block. Typically, they will go at the front of the environment block, due to the environment block sort order.</para>
      <para>One way to obtain the current directory information for a drive X is to make the following call:
<code>GetFullPathName("X:", ...)</code>. That avoids an application having to scan the environment block. If the full path returned is X:, there is no need to pass that value on as environment data, since the root directory is the default current directory for drive X of a new process.</para>
      <para>When a process is created with <b>CREATE_NEW_PROCESS_GROUP</b> specified, an implicit call to
<a href="https://docs.microsoft.com//windows/console/setconsolectrlhandler">SetConsoleCtrlHandler</a>(<b>NULL</b>,<b>TRUE</b>) is made on behalf of the new process; this means that the new process has CTRL+C disabled. This lets shells handle CTRL+C themselves, and selectively pass that signal on to sub-processes. CTRL+BREAK is not disabled, and may be used to interrupt the process/process group.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The first parameter, <i>lpApplicationName</i>, can be <b>NULL</b>, in which case the executable name must be in the  white space–delimited string pointed to by <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline = _tcsdup(TEXT("C:\\Program Files\\MyApp -L -S"));
    CreateProcess(NULL, szCmdline, /* ... */);
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcess</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass <b>NULL</b> for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\" -L -S"));
    CreateProcess(NULL, szCmdline, /*...*/);
</code>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/creating-processes">Creating Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcess as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetCommandLine" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="OpenProcess" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="TerminateProcess" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateProcessA">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the
<see cref="CreateProcessAsUser" /> or
<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>,  the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by  <i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" />  contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The name of the executable in the command line that the operating system provides to a process is not necessarily identical to that in the command line that the calling process gives to the
<b>CreateProcess</b> function. The operating system may prepend a fully qualified path to an executable name that is provided without a fully qualified path.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcess</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>A  parent process can directly alter the environment variables of a child process during process creation.  This is the only  situation when a process can directly change the environment settings of another process. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
      <para>If an application provides an environment block, the current directory information of the system drives is not automatically propagated to the new process. For example, there is an environment variable named =C: whose value is the current directory on drive C. An application must manually pass the current directory information to the new process. To do so, the application must explicitly create these environment variable strings, sort them alphabetically (because the system uses a sorted environment), and put them into the environment block. Typically, they will go at the front of the environment block, due to the environment block sort order.</para>
      <para>One way to obtain the current directory information for a drive X is to make the following call:
<code>GetFullPathName("X:", ...)</code>. That avoids an application having to scan the environment block. If the full path returned is X:, there is no need to pass that value on as environment data, since the root directory is the default current directory for drive X of a new process.</para>
      <para>When a process is created with <b>CREATE_NEW_PROCESS_GROUP</b> specified, an implicit call to
<a href="https://docs.microsoft.com//windows/console/setconsolectrlhandler">SetConsoleCtrlHandler</a>(<b>NULL</b>,<b>TRUE</b>) is made on behalf of the new process; this means that the new process has CTRL+C disabled. This lets shells handle CTRL+C themselves, and selectively pass that signal on to sub-processes. CTRL+BREAK is not disabled, and may be used to interrupt the process/process group.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The first parameter, <i>lpApplicationName</i>, can be <b>NULL</b>, in which case the executable name must be in the  white space–delimited string pointed to by <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline = _tcsdup(TEXT("C:\\Program Files\\MyApp -L -S"));
    CreateProcess(NULL, szCmdline, /* ... */);
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcess</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass <b>NULL</b> for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\" -L -S"));
    CreateProcess(NULL, szCmdline, /*...*/);
</code>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/creating-processes">Creating Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcess as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetCommandLine" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="OpenProcess" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="TerminateProcess" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateProcessW">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the
<see cref="CreateProcessAsUser" /> or
<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>,  the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by  <i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" />  contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The name of the executable in the command line that the operating system provides to a process is not necessarily identical to that in the command line that the calling process gives to the
<b>CreateProcess</b> function. The operating system may prepend a fully qualified path to an executable name that is provided without a fully qualified path.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcess</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>A  parent process can directly alter the environment variables of a child process during process creation.  This is the only  situation when a process can directly change the environment settings of another process. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
      <para>If an application provides an environment block, the current directory information of the system drives is not automatically propagated to the new process. For example, there is an environment variable named =C: whose value is the current directory on drive C. An application must manually pass the current directory information to the new process. To do so, the application must explicitly create these environment variable strings, sort them alphabetically (because the system uses a sorted environment), and put them into the environment block. Typically, they will go at the front of the environment block, due to the environment block sort order.</para>
      <para>One way to obtain the current directory information for a drive X is to make the following call:
<code>GetFullPathName("X:", ...)</code>. That avoids an application having to scan the environment block. If the full path returned is X:, there is no need to pass that value on as environment data, since the root directory is the default current directory for drive X of a new process.</para>
      <para>When a process is created with <b>CREATE_NEW_PROCESS_GROUP</b> specified, an implicit call to
<a href="https://docs.microsoft.com//windows/console/setconsolectrlhandler">SetConsoleCtrlHandler</a>(<b>NULL</b>,<b>TRUE</b>) is made on behalf of the new process; this means that the new process has CTRL+C disabled. This lets shells handle CTRL+C themselves, and selectively pass that signal on to sub-processes. CTRL+BREAK is not disabled, and may be used to interrupt the process/process group.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The first parameter, <i>lpApplicationName</i>, can be <b>NULL</b>, in which case the executable name must be in the  white space–delimited string pointed to by <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline = _tcsdup(TEXT("C:\\Program Files\\MyApp -L -S"));
    CreateProcess(NULL, szCmdline, /* ... */);
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcess</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass <b>NULL</b> for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\" -L -S"));
    CreateProcess(NULL, szCmdline, /*...*/);
</code>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/creating-processes">Creating Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcess as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetCommandLine" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="OpenProcess" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="TerminateProcess" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateProcessAsUser">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the
<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is  not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the
<see cref="LogonUser" /> function. Alternatively, you can call the
<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,
<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the
<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>
      </para>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by
<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in
<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory. </description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. </description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.  If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the
<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process.
If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>
        <b>CreateProcessAsUser</b> must be able to open the primary token of the calling process with the <b>TOKEN_DUPLICATE</b> and <b>TOKEN_IMPERSONATE</b> access rights.</para>
      <para>By default,
<b>CreateProcessAsUser</b> creates the new process on a noninteractive window station with a desktop that is not visible and cannot receive user input. To enable user interaction with the new process, you must specify the name of the default interactive window station and desktop, "winsta0\default", in the <b>lpDesktop</b> member of the
<see cref="STARTUPINFO" /> structure. In addition, before calling
<b>CreateProcessAsUser</b>, you must change the discretionary access control list (DACL) of both the default interactive window station and the default desktop. The DACLs for the window station and desktop must grant access to the user or the logon session represented by the <i>hToken</i> parameter.</para>
      <para>
        <b>CreateProcessAsUser</b> does not load the specified user's profile into the <b>HKEY_USERS</b> registry key. Therefore, to access the information in the <b>HKEY_CURRENT_USER</b> registry key, you must load the user's profile information into <b>HKEY_USERS</b> with the
<see cref="LoadUserProfile" /> function before calling
<b>CreateProcessAsUser</b>. Be sure to call <see cref="UnloadUserProfile" /> after the new process exits.</para>
      <para>If the <i>lpEnvironment</i> parameter is NULL, the new process inherits the environment of the calling process.
<b>CreateProcessAsUser</b> does not automatically modify the environment block to include environment variables specific to the user represented by <i>hToken</i>. For example, the USERNAME and USERDOMAIN variables are inherited from the calling process if <i>lpEnvironment</i> is NULL. It is your responsibility to prepare the environment block for the new process and specify it in <i>lpEnvironment</i>.</para>
      <para>The
<see cref="CreateProcessWithLogonW" />    and <see cref="CreateProcessWithTokenW" /> functions are similar to
<b>CreateProcessAsUser</b>, except that the caller does not need to call the
<see cref="LogonUser" /> function to authenticate the user and get a token.</para>
      <para>
        <b>CreateProcessAsUser</b> allows you to access the specified directory and executable image in the security context of the caller or the target user. By default,
<b>CreateProcessAsUser</b> accesses the directory and executable image in the security context of the caller. In this case, if the caller does not have access to the directory and executable image, the function fails. To access the directory and executable image using the security context of the target user, specify <i>hToken</i> in a call to the
<see cref="ImpersonateLoggedOnUser" /> function before calling
<b>CreateProcessAsUser</b>.</para>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcessAsUser</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The <i>lpApplicationName</i> parameter can be NULL, in which case the executable name must be the first white space–delimited string in <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("C:\\Program Files\\MyApp"));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/ );
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcessAsUser</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass NULL for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\""));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/);
</code>
      <para>
        <b>PowerShell:  </b>When the <b>CreateProcessAsUser</b> function is used to implement a cmdlet in PowerShell version 2.0, the cmdlet operates correctly for both fan-in and fan-out remote sessions. Because of certain security scenarios, however, a cmdlet implemented with <b>CreateProcessAsUser</b> only operates correctly in PowerShell version 3.0 for fan-in remote sessions; fan-out remote sessions will fail because of insufficient client security privileges. To implement a cmdlet that works for both fan-in and fan-out remote sessions in PowerShell version 3.0, use the <see cref="CreateProcess" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//previous-versions/aa379608(v=vs.85)">Starting an Interactive Client Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcessAsUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEnvironmentBlock" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="LoadUserProfile" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SHCreateProcessAsUserW" />
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateProcessAsUserA">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the
<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is  not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the
<see cref="LogonUser" /> function. Alternatively, you can call the
<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,
<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the
<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>
      </para>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by
<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in
<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory. </description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. </description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.  If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the
<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process.
If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>
        <b>CreateProcessAsUser</b> must be able to open the primary token of the calling process with the <b>TOKEN_DUPLICATE</b> and <b>TOKEN_IMPERSONATE</b> access rights.</para>
      <para>By default,
<b>CreateProcessAsUser</b> creates the new process on a noninteractive window station with a desktop that is not visible and cannot receive user input. To enable user interaction with the new process, you must specify the name of the default interactive window station and desktop, "winsta0\default", in the <b>lpDesktop</b> member of the
<see cref="STARTUPINFO" /> structure. In addition, before calling
<b>CreateProcessAsUser</b>, you must change the discretionary access control list (DACL) of both the default interactive window station and the default desktop. The DACLs for the window station and desktop must grant access to the user or the logon session represented by the <i>hToken</i> parameter.</para>
      <para>
        <b>CreateProcessAsUser</b> does not load the specified user's profile into the <b>HKEY_USERS</b> registry key. Therefore, to access the information in the <b>HKEY_CURRENT_USER</b> registry key, you must load the user's profile information into <b>HKEY_USERS</b> with the
<see cref="LoadUserProfile" /> function before calling
<b>CreateProcessAsUser</b>. Be sure to call <see cref="UnloadUserProfile" /> after the new process exits.</para>
      <para>If the <i>lpEnvironment</i> parameter is NULL, the new process inherits the environment of the calling process.
<b>CreateProcessAsUser</b> does not automatically modify the environment block to include environment variables specific to the user represented by <i>hToken</i>. For example, the USERNAME and USERDOMAIN variables are inherited from the calling process if <i>lpEnvironment</i> is NULL. It is your responsibility to prepare the environment block for the new process and specify it in <i>lpEnvironment</i>.</para>
      <para>The
<see cref="CreateProcessWithLogonW" />    and <see cref="CreateProcessWithTokenW" /> functions are similar to
<b>CreateProcessAsUser</b>, except that the caller does not need to call the
<see cref="LogonUser" /> function to authenticate the user and get a token.</para>
      <para>
        <b>CreateProcessAsUser</b> allows you to access the specified directory and executable image in the security context of the caller or the target user. By default,
<b>CreateProcessAsUser</b> accesses the directory and executable image in the security context of the caller. In this case, if the caller does not have access to the directory and executable image, the function fails. To access the directory and executable image using the security context of the target user, specify <i>hToken</i> in a call to the
<see cref="ImpersonateLoggedOnUser" /> function before calling
<b>CreateProcessAsUser</b>.</para>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcessAsUser</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The <i>lpApplicationName</i> parameter can be NULL, in which case the executable name must be the first white space–delimited string in <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("C:\\Program Files\\MyApp"));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/ );
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcessAsUser</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass NULL for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\""));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/);
</code>
      <para>
        <b>PowerShell:  </b>When the <b>CreateProcessAsUser</b> function is used to implement a cmdlet in PowerShell version 2.0, the cmdlet operates correctly for both fan-in and fan-out remote sessions. Because of certain security scenarios, however, a cmdlet implemented with <b>CreateProcessAsUser</b> only operates correctly in PowerShell version 3.0 for fan-in remote sessions; fan-out remote sessions will fail because of insufficient client security privileges. To implement a cmdlet that works for both fan-in and fan-out remote sessions in PowerShell version 3.0, use the <see cref="CreateProcess" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//previous-versions/aa379608(v=vs.85)">Starting an Interactive Client Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcessAsUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEnvironmentBlock" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="LoadUserProfile" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SHCreateProcessAsUserW" />
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateProcessAsUserW">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the
<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is  not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the
<see cref="LogonUser" /> function. Alternatively, you can call the
<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,
<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the
<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>
      </para>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by
<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in
<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory. </description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. </description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.  If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the
<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process.
If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>
        <b>CreateProcessAsUser</b> must be able to open the primary token of the calling process with the <b>TOKEN_DUPLICATE</b> and <b>TOKEN_IMPERSONATE</b> access rights.</para>
      <para>By default,
<b>CreateProcessAsUser</b> creates the new process on a noninteractive window station with a desktop that is not visible and cannot receive user input. To enable user interaction with the new process, you must specify the name of the default interactive window station and desktop, "winsta0\default", in the <b>lpDesktop</b> member of the
<see cref="STARTUPINFO" /> structure. In addition, before calling
<b>CreateProcessAsUser</b>, you must change the discretionary access control list (DACL) of both the default interactive window station and the default desktop. The DACLs for the window station and desktop must grant access to the user or the logon session represented by the <i>hToken</i> parameter.</para>
      <para>
        <b>CreateProcessAsUser</b> does not load the specified user's profile into the <b>HKEY_USERS</b> registry key. Therefore, to access the information in the <b>HKEY_CURRENT_USER</b> registry key, you must load the user's profile information into <b>HKEY_USERS</b> with the
<see cref="LoadUserProfile" /> function before calling
<b>CreateProcessAsUser</b>. Be sure to call <see cref="UnloadUserProfile" /> after the new process exits.</para>
      <para>If the <i>lpEnvironment</i> parameter is NULL, the new process inherits the environment of the calling process.
<b>CreateProcessAsUser</b> does not automatically modify the environment block to include environment variables specific to the user represented by <i>hToken</i>. For example, the USERNAME and USERDOMAIN variables are inherited from the calling process if <i>lpEnvironment</i> is NULL. It is your responsibility to prepare the environment block for the new process and specify it in <i>lpEnvironment</i>.</para>
      <para>The
<see cref="CreateProcessWithLogonW" />    and <see cref="CreateProcessWithTokenW" /> functions are similar to
<b>CreateProcessAsUser</b>, except that the caller does not need to call the
<see cref="LogonUser" /> function to authenticate the user and get a token.</para>
      <para>
        <b>CreateProcessAsUser</b> allows you to access the specified directory and executable image in the security context of the caller or the target user. By default,
<b>CreateProcessAsUser</b> accesses the directory and executable image in the security context of the caller. In this case, if the caller does not have access to the directory and executable image, the function fails. To access the directory and executable image using the security context of the target user, specify <i>hToken</i> in a call to the
<see cref="ImpersonateLoggedOnUser" /> function before calling
<b>CreateProcessAsUser</b>.</para>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcessAsUser</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The <i>lpApplicationName</i> parameter can be NULL, in which case the executable name must be the first white space–delimited string in <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("C:\\Program Files\\MyApp"));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/ );
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcessAsUser</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass NULL for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\""));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/);
</code>
      <para>
        <b>PowerShell:  </b>When the <b>CreateProcessAsUser</b> function is used to implement a cmdlet in PowerShell version 2.0, the cmdlet operates correctly for both fan-in and fan-out remote sessions. Because of certain security scenarios, however, a cmdlet implemented with <b>CreateProcessAsUser</b> only operates correctly in PowerShell version 3.0 for fan-in remote sessions; fan-out remote sessions will fail because of insufficient client security privileges. To implement a cmdlet that works for both fan-in and fan-out remote sessions in PowerShell version 3.0, use the <see cref="CreateProcess" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//previous-versions/aa379608(v=vs.85)">Starting an Interactive Client Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcessAsUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEnvironmentBlock" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="LoadUserProfile" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SHCreateProcessAsUserW" />
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateProcessAsUser">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the
<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is  not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the
<see cref="LogonUser" /> function. Alternatively, you can call the
<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,
<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the
<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>
      </para>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by
<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in
<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory. </description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. </description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.  If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the
<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process.
If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>
        <b>CreateProcessAsUser</b> must be able to open the primary token of the calling process with the <b>TOKEN_DUPLICATE</b> and <b>TOKEN_IMPERSONATE</b> access rights.</para>
      <para>By default,
<b>CreateProcessAsUser</b> creates the new process on a noninteractive window station with a desktop that is not visible and cannot receive user input. To enable user interaction with the new process, you must specify the name of the default interactive window station and desktop, "winsta0\default", in the <b>lpDesktop</b> member of the
<see cref="STARTUPINFO" /> structure. In addition, before calling
<b>CreateProcessAsUser</b>, you must change the discretionary access control list (DACL) of both the default interactive window station and the default desktop. The DACLs for the window station and desktop must grant access to the user or the logon session represented by the <i>hToken</i> parameter.</para>
      <para>
        <b>CreateProcessAsUser</b> does not load the specified user's profile into the <b>HKEY_USERS</b> registry key. Therefore, to access the information in the <b>HKEY_CURRENT_USER</b> registry key, you must load the user's profile information into <b>HKEY_USERS</b> with the
<see cref="LoadUserProfile" /> function before calling
<b>CreateProcessAsUser</b>. Be sure to call <see cref="UnloadUserProfile" /> after the new process exits.</para>
      <para>If the <i>lpEnvironment</i> parameter is NULL, the new process inherits the environment of the calling process.
<b>CreateProcessAsUser</b> does not automatically modify the environment block to include environment variables specific to the user represented by <i>hToken</i>. For example, the USERNAME and USERDOMAIN variables are inherited from the calling process if <i>lpEnvironment</i> is NULL. It is your responsibility to prepare the environment block for the new process and specify it in <i>lpEnvironment</i>.</para>
      <para>The
<see cref="CreateProcessWithLogonW" />    and <see cref="CreateProcessWithTokenW" /> functions are similar to
<b>CreateProcessAsUser</b>, except that the caller does not need to call the
<see cref="LogonUser" /> function to authenticate the user and get a token.</para>
      <para>
        <b>CreateProcessAsUser</b> allows you to access the specified directory and executable image in the security context of the caller or the target user. By default,
<b>CreateProcessAsUser</b> accesses the directory and executable image in the security context of the caller. In this case, if the caller does not have access to the directory and executable image, the function fails. To access the directory and executable image using the security context of the target user, specify <i>hToken</i> in a call to the
<see cref="ImpersonateLoggedOnUser" /> function before calling
<b>CreateProcessAsUser</b>.</para>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcessAsUser</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The <i>lpApplicationName</i> parameter can be NULL, in which case the executable name must be the first white space–delimited string in <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("C:\\Program Files\\MyApp"));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/ );
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcessAsUser</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass NULL for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\""));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/);
</code>
      <para>
        <b>PowerShell:  </b>When the <b>CreateProcessAsUser</b> function is used to implement a cmdlet in PowerShell version 2.0, the cmdlet operates correctly for both fan-in and fan-out remote sessions. Because of certain security scenarios, however, a cmdlet implemented with <b>CreateProcessAsUser</b> only operates correctly in PowerShell version 3.0 for fan-in remote sessions; fan-out remote sessions will fail because of insufficient client security privileges. To implement a cmdlet that works for both fan-in and fan-out remote sessions in PowerShell version 3.0, use the <see cref="CreateProcess" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//previous-versions/aa379608(v=vs.85)">Starting an Interactive Client Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcessAsUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEnvironmentBlock" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="LoadUserProfile" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SHCreateProcessAsUserW" />
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateProcessAsUserA">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the
<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is  not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the
<see cref="LogonUser" /> function. Alternatively, you can call the
<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,
<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the
<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>
      </para>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by
<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in
<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory. </description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. </description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.  If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the
<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process.
If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>
        <b>CreateProcessAsUser</b> must be able to open the primary token of the calling process with the <b>TOKEN_DUPLICATE</b> and <b>TOKEN_IMPERSONATE</b> access rights.</para>
      <para>By default,
<b>CreateProcessAsUser</b> creates the new process on a noninteractive window station with a desktop that is not visible and cannot receive user input. To enable user interaction with the new process, you must specify the name of the default interactive window station and desktop, "winsta0\default", in the <b>lpDesktop</b> member of the
<see cref="STARTUPINFO" /> structure. In addition, before calling
<b>CreateProcessAsUser</b>, you must change the discretionary access control list (DACL) of both the default interactive window station and the default desktop. The DACLs for the window station and desktop must grant access to the user or the logon session represented by the <i>hToken</i> parameter.</para>
      <para>
        <b>CreateProcessAsUser</b> does not load the specified user's profile into the <b>HKEY_USERS</b> registry key. Therefore, to access the information in the <b>HKEY_CURRENT_USER</b> registry key, you must load the user's profile information into <b>HKEY_USERS</b> with the
<see cref="LoadUserProfile" /> function before calling
<b>CreateProcessAsUser</b>. Be sure to call <see cref="UnloadUserProfile" /> after the new process exits.</para>
      <para>If the <i>lpEnvironment</i> parameter is NULL, the new process inherits the environment of the calling process.
<b>CreateProcessAsUser</b> does not automatically modify the environment block to include environment variables specific to the user represented by <i>hToken</i>. For example, the USERNAME and USERDOMAIN variables are inherited from the calling process if <i>lpEnvironment</i> is NULL. It is your responsibility to prepare the environment block for the new process and specify it in <i>lpEnvironment</i>.</para>
      <para>The
<see cref="CreateProcessWithLogonW" />    and <see cref="CreateProcessWithTokenW" /> functions are similar to
<b>CreateProcessAsUser</b>, except that the caller does not need to call the
<see cref="LogonUser" /> function to authenticate the user and get a token.</para>
      <para>
        <b>CreateProcessAsUser</b> allows you to access the specified directory and executable image in the security context of the caller or the target user. By default,
<b>CreateProcessAsUser</b> accesses the directory and executable image in the security context of the caller. In this case, if the caller does not have access to the directory and executable image, the function fails. To access the directory and executable image using the security context of the target user, specify <i>hToken</i> in a call to the
<see cref="ImpersonateLoggedOnUser" /> function before calling
<b>CreateProcessAsUser</b>.</para>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcessAsUser</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The <i>lpApplicationName</i> parameter can be NULL, in which case the executable name must be the first white space–delimited string in <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("C:\\Program Files\\MyApp"));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/ );
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcessAsUser</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass NULL for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\""));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/);
</code>
      <para>
        <b>PowerShell:  </b>When the <b>CreateProcessAsUser</b> function is used to implement a cmdlet in PowerShell version 2.0, the cmdlet operates correctly for both fan-in and fan-out remote sessions. Because of certain security scenarios, however, a cmdlet implemented with <b>CreateProcessAsUser</b> only operates correctly in PowerShell version 3.0 for fan-in remote sessions; fan-out remote sessions will fail because of insufficient client security privileges. To implement a cmdlet that works for both fan-in and fan-out remote sessions in PowerShell version 3.0, use the <see cref="CreateProcess" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//previous-versions/aa379608(v=vs.85)">Starting an Interactive Client Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcessAsUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEnvironmentBlock" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="LoadUserProfile" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SHCreateProcessAsUserW" />
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateProcessAsUserW">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the
<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is  not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the
<see cref="LogonUser" /> function. Alternatively, you can call the
<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,
<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the
<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>
      </para>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by
<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in
<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory. </description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. </description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.  If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the
<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process.
If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>
        <b>CreateProcessAsUser</b> must be able to open the primary token of the calling process with the <b>TOKEN_DUPLICATE</b> and <b>TOKEN_IMPERSONATE</b> access rights.</para>
      <para>By default,
<b>CreateProcessAsUser</b> creates the new process on a noninteractive window station with a desktop that is not visible and cannot receive user input. To enable user interaction with the new process, you must specify the name of the default interactive window station and desktop, "winsta0\default", in the <b>lpDesktop</b> member of the
<see cref="STARTUPINFO" /> structure. In addition, before calling
<b>CreateProcessAsUser</b>, you must change the discretionary access control list (DACL) of both the default interactive window station and the default desktop. The DACLs for the window station and desktop must grant access to the user or the logon session represented by the <i>hToken</i> parameter.</para>
      <para>
        <b>CreateProcessAsUser</b> does not load the specified user's profile into the <b>HKEY_USERS</b> registry key. Therefore, to access the information in the <b>HKEY_CURRENT_USER</b> registry key, you must load the user's profile information into <b>HKEY_USERS</b> with the
<see cref="LoadUserProfile" /> function before calling
<b>CreateProcessAsUser</b>. Be sure to call <see cref="UnloadUserProfile" /> after the new process exits.</para>
      <para>If the <i>lpEnvironment</i> parameter is NULL, the new process inherits the environment of the calling process.
<b>CreateProcessAsUser</b> does not automatically modify the environment block to include environment variables specific to the user represented by <i>hToken</i>. For example, the USERNAME and USERDOMAIN variables are inherited from the calling process if <i>lpEnvironment</i> is NULL. It is your responsibility to prepare the environment block for the new process and specify it in <i>lpEnvironment</i>.</para>
      <para>The
<see cref="CreateProcessWithLogonW" />    and <see cref="CreateProcessWithTokenW" /> functions are similar to
<b>CreateProcessAsUser</b>, except that the caller does not need to call the
<see cref="LogonUser" /> function to authenticate the user and get a token.</para>
      <para>
        <b>CreateProcessAsUser</b> allows you to access the specified directory and executable image in the security context of the caller or the target user. By default,
<b>CreateProcessAsUser</b> accesses the directory and executable image in the security context of the caller. In this case, if the caller does not have access to the directory and executable image, the function fails. To access the directory and executable image using the security context of the target user, specify <i>hToken</i> in a call to the
<see cref="ImpersonateLoggedOnUser" /> function before calling
<b>CreateProcessAsUser</b>.</para>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcessAsUser</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The <i>lpApplicationName</i> parameter can be NULL, in which case the executable name must be the first white space–delimited string in <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("C:\\Program Files\\MyApp"));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/ );
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcessAsUser</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass NULL for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\""));
    CreateProcessAsUser(hToken, NULL, szCmdline, /*...*/);
</code>
      <para>
        <b>PowerShell:  </b>When the <b>CreateProcessAsUser</b> function is used to implement a cmdlet in PowerShell version 2.0, the cmdlet operates correctly for both fan-in and fan-out remote sessions. Because of certain security scenarios, however, a cmdlet implemented with <b>CreateProcessAsUser</b> only operates correctly in PowerShell version 3.0 for fan-in remote sessions; fan-out remote sessions will fail because of insufficient client security privileges. To implement a cmdlet that works for both fan-in and fan-out remote sessions in PowerShell version 3.0, use the <see cref="CreateProcess" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//previous-versions/aa379608(v=vs.85)">Starting an Interactive Client Process</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcessAsUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEnvironmentBlock" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="LoadUserProfile" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SHCreateProcessAsUserW" />
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateProcess">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the
<see cref="CreateProcessAsUser" /> or
<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>,  the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by  <i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" />  contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The name of the executable in the command line that the operating system provides to a process is not necessarily identical to that in the command line that the calling process gives to the
<b>CreateProcess</b> function. The operating system may prepend a fully qualified path to an executable name that is provided without a fully qualified path.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcess</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>A  parent process can directly alter the environment variables of a child process during process creation.  This is the only  situation when a process can directly change the environment settings of another process. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
      <para>If an application provides an environment block, the current directory information of the system drives is not automatically propagated to the new process. For example, there is an environment variable named =C: whose value is the current directory on drive C. An application must manually pass the current directory information to the new process. To do so, the application must explicitly create these environment variable strings, sort them alphabetically (because the system uses a sorted environment), and put them into the environment block. Typically, they will go at the front of the environment block, due to the environment block sort order.</para>
      <para>One way to obtain the current directory information for a drive X is to make the following call:
<code>GetFullPathName("X:", ...)</code>. That avoids an application having to scan the environment block. If the full path returned is X:, there is no need to pass that value on as environment data, since the root directory is the default current directory for drive X of a new process.</para>
      <para>When a process is created with <b>CREATE_NEW_PROCESS_GROUP</b> specified, an implicit call to
<a href="https://docs.microsoft.com//windows/console/setconsolectrlhandler">SetConsoleCtrlHandler</a>(<b>NULL</b>,<b>TRUE</b>) is made on behalf of the new process; this means that the new process has CTRL+C disabled. This lets shells handle CTRL+C themselves, and selectively pass that signal on to sub-processes. CTRL+BREAK is not disabled, and may be used to interrupt the process/process group.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The first parameter, <i>lpApplicationName</i>, can be <b>NULL</b>, in which case the executable name must be in the  white space–delimited string pointed to by <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline = _tcsdup(TEXT("C:\\Program Files\\MyApp -L -S"));
    CreateProcess(NULL, szCmdline, /* ... */);
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcess</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass <b>NULL</b> for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\" -L -S"));
    CreateProcess(NULL, szCmdline, /*...*/);
</code>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/creating-processes">Creating Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcess as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetCommandLine" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="OpenProcess" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="TerminateProcess" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateProcessA">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the
<see cref="CreateProcessAsUser" /> or
<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>,  the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by  <i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" />  contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The name of the executable in the command line that the operating system provides to a process is not necessarily identical to that in the command line that the calling process gives to the
<b>CreateProcess</b> function. The operating system may prepend a fully qualified path to an executable name that is provided without a fully qualified path.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcess</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>A  parent process can directly alter the environment variables of a child process during process creation.  This is the only  situation when a process can directly change the environment settings of another process. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
      <para>If an application provides an environment block, the current directory information of the system drives is not automatically propagated to the new process. For example, there is an environment variable named =C: whose value is the current directory on drive C. An application must manually pass the current directory information to the new process. To do so, the application must explicitly create these environment variable strings, sort them alphabetically (because the system uses a sorted environment), and put them into the environment block. Typically, they will go at the front of the environment block, due to the environment block sort order.</para>
      <para>One way to obtain the current directory information for a drive X is to make the following call:
<code>GetFullPathName("X:", ...)</code>. That avoids an application having to scan the environment block. If the full path returned is X:, there is no need to pass that value on as environment data, since the root directory is the default current directory for drive X of a new process.</para>
      <para>When a process is created with <b>CREATE_NEW_PROCESS_GROUP</b> specified, an implicit call to
<a href="https://docs.microsoft.com//windows/console/setconsolectrlhandler">SetConsoleCtrlHandler</a>(<b>NULL</b>,<b>TRUE</b>) is made on behalf of the new process; this means that the new process has CTRL+C disabled. This lets shells handle CTRL+C themselves, and selectively pass that signal on to sub-processes. CTRL+BREAK is not disabled, and may be used to interrupt the process/process group.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The first parameter, <i>lpApplicationName</i>, can be <b>NULL</b>, in which case the executable name must be in the  white space–delimited string pointed to by <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline = _tcsdup(TEXT("C:\\Program Files\\MyApp -L -S"));
    CreateProcess(NULL, szCmdline, /* ... */);
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcess</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass <b>NULL</b> for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\" -L -S"));
    CreateProcess(NULL, szCmdline, /*...*/);
</code>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/creating-processes">Creating Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcess as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetCommandLine" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="OpenProcess" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="TerminateProcess" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateProcessW">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the
<see cref="CreateProcessAsUser" /> or
<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>,  the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by  <i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="lpProcessAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. If this parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" />  contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the
<see cref="PROCESS_INFORMATION" /> structure.</para>
      <para>The name of the executable in the command line that the operating system provides to a process is not necessarily identical to that in the command line that the calling process gives to the
<b>CreateProcess</b> function. The operating system may prepend a fully qualified path to an executable name that is provided without a fully qualified path.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcess</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>A  parent process can directly alter the environment variables of a child process during process creation.  This is the only  situation when a process can directly change the environment settings of another process. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
      <para>If an application provides an environment block, the current directory information of the system drives is not automatically propagated to the new process. For example, there is an environment variable named =C: whose value is the current directory on drive C. An application must manually pass the current directory information to the new process. To do so, the application must explicitly create these environment variable strings, sort them alphabetically (because the system uses a sorted environment), and put them into the environment block. Typically, they will go at the front of the environment block, due to the environment block sort order.</para>
      <para>One way to obtain the current directory information for a drive X is to make the following call:
<code>GetFullPathName("X:", ...)</code>. That avoids an application having to scan the environment block. If the full path returned is X:, there is no need to pass that value on as environment data, since the root directory is the default current directory for drive X of a new process.</para>
      <para>When a process is created with <b>CREATE_NEW_PROCESS_GROUP</b> specified, an implicit call to
<a href="https://docs.microsoft.com//windows/console/setconsolectrlhandler">SetConsoleCtrlHandler</a>(<b>NULL</b>,<b>TRUE</b>) is made on behalf of the new process; this means that the new process has CTRL+C disabled. This lets shells handle CTRL+C themselves, and selectively pass that signal on to sub-processes. CTRL+BREAK is not disabled, and may be used to interrupt the process/process group.</para>
      <para>By default, passing <b>TRUE</b> as the value of the <i>bInheritHandles</i> parameter causes all inheritable handles to be inherited by the new process.
This can be problematic for applications which create processes from multiple threads simultaneously
yet desire each process to inherit different handles.
Applications can use the
<see cref="UpdateProcThreadAttributeList" /> function
with the <b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b> parameter
to provide a list of handles to be inherited by a particular process.</para>
      <h3>Security Remarks</h3>
      <para>The first parameter, <i>lpApplicationName</i>, can be <b>NULL</b>, in which case the executable name must be in the  white space–delimited string pointed to by <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline = _tcsdup(TEXT("C:\\Program Files\\MyApp -L -S"));
    CreateProcess(NULL, szCmdline, /* ... */);
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcess</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass <b>NULL</b> for <i>lpApplicationName</i>. If you do pass <b>NULL</b> for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline[] = _tcsdup(TEXT("\"C:\\Program Files\\MyApp\" -L -S"));
    CreateProcess(NULL, szCmdline, /*...*/);
</code>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/creating-processes">Creating Processes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The processthreadsapi.h header defines CreateProcess as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="CreateProcessWithLogonW" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetCommandLine" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetStartupInfo" />
    <seealso cref="OpenProcess" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="STARTUPINFO" />
    <seealso cref="STARTUPINFOEX" />
    <seealso cref="SetErrorMode" />
    <seealso cref="TerminateProcess" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateRemoteThread">
    <summary>
      <para>Creates a thread that runs in the virtual address space of another process.</para>
      <para>Use the <see cref="CreateRemoteThreadEx" /> function to create a thread that runs in the virtual address space of another process and optionally specify extended attributes.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process in which the thread is to be created. The handle must have the <b>PROCESS_CREATE_THREAD</b>, <b>PROCESS_QUERY_INFORMATION</b>, <b>PROCESS_VM_OPERATION</b>, <b>PROCESS_VM_WRITE</b>, and <b>PROCESS_VM_READ</b> access rights, and may fail without these rights on certain platforms. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If <i>lpThreadAttributes</i> is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.</para>
      <para>
        <b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="dwStackSize">
      <para>The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</para>
    </param>
    <param name="lpStartAddress">
      <para>A pointer to the application-defined function of type <b>LPTHREAD_START_ROUTINE</b> to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. For more information, see
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>.</para>
    </param>
    <param name="lpParameter">
      <para>A pointer to a variable to be passed to the thread function.</para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the creation of the thread.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The thread runs immediately after creation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_SUSPENDED</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The thread is created in a suspended state, and does not run until the
<see cref="ResumeThread" /> function is called.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>STACK_SIZE_PARAM_IS_A_RESERVATION</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>dwStackSize</i> parameter specifies the initial reserve size of the stack. If this flag is not specified, <i>dwStackSize</i> specifies the commit size.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpThreadId">
      <para>A pointer to a variable that receives the thread identifier.</para>
      <para>If this parameter is <b>NULL</b>, the thread identifier is not returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the new thread.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that
<b>CreateRemoteThread</b> may succeed even if <i>lpStartAddress</i> points to data, code, or is not accessible. If the start address is invalid when the thread runs, an exception occurs, and the thread terminates. Thread termination due to a invalid start address is handled as an error exit for the thread's process. This behavior is similar to the asynchronous nature of
<see cref="CreateProcess" />, where the process is created even if it refers to invalid or missing dynamic-link libraries (DLL).</para>
    </returns>
    <remarks>
      <para>The
<b>CreateRemoteThread</b> function causes a new thread of execution to begin in the address space of the specified process. The thread has access to all objects that the process opens.</para>
      <para>Terminal Services isolates each terminal session by design. Therefore,
<b>CreateRemoteThread</b> fails if the target process is in a different session than the calling process.</para>
      <para>The new thread handle is created with full access to the new thread. If a security descriptor is not provided, the handle may be used in any function that requires a thread object handle. When a security descriptor is provided, an access check is performed on all subsequent uses of the handle before access is granted. If the access check denies access, the requesting process cannot use the handle to gain access to the thread.</para>
      <para>If the thread is created in a runnable state (that is, if the <b>CREATE_SUSPENDED</b> flag is not used), the thread can start running before <see cref="CreateThread" /> returns and, in particular, before  the caller receives the handle and identifier of the created thread.</para>
      <para>The thread is created with a thread priority of <b>THREAD_PRIORITY_NORMAL</b>. Use the
<see cref="GetThreadPriority" /> and
<see cref="SetThreadPriority" /> functions to get and set the priority value of a thread.</para>
      <para>When a thread terminates, the thread object attains a signaled state, which satisfies the threads that are waiting for the object.</para>
      <para>The thread object remains in the system until the thread has terminated and all handles to it are closed through a call to
<see cref="CloseHandle" />.</para>
      <para>The
<see cref="ExitProcess" />,
<see cref="ExitThread" />,
<see cref="CreateThread" />,
<b>CreateRemoteThread</b> functions, and a process that is starting (as the result of a
<see cref="CreateProcess" /> call) are serialized between each other within a process. Only one of these events occurs in an address space at a time. This means the following restrictions hold:</para>
      <list type="bullet">
        <item>
          <description>During process startup and DLL initialization routines, new threads can be created, but they do not begin execution until DLL initialization is done for the process.</description>
        </item>
        <item>
          <description>Only one thread in a process can be in a DLL initialization or detach routine at a time.</description>
        </item>
        <item>
          <description>
            <see cref="ExitProcess" /> returns after all threads have completed their DLL initialization or detach routines. </description>
        </item>
      </list>
      <para>A common use of this function is to inject a thread into a process that is being debugged to issue a break. However, this use is not recommended, because the extra thread is confusing to the person debugging the application and there are several side effects to using this technique:</para>
      <list type="bullet">
        <item>
          <description>It converts single-threaded applications into multithreaded applications.</description>
        </item>
        <item>
          <description>It changes the timing and memory layout of the process.</description>
        </item>
        <item>
          <description>It results in a call to the entry point of each DLL in the process.</description>
        </item>
      </list>
      <para>Another common use of this function is to inject a thread into a process to query heap or other process information. This can cause the same side effects mentioned in the previous paragraph. Also, the application can deadlock if the thread attempts to obtain ownership of locks that another thread is using.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateRemoteThreadEx" />
    <seealso cref="CreateThread" />
    <seealso cref="ExitProcess" />
    <seealso cref="ExitThread" />
    <seealso cref="GetThreadPriority" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="ResumeThread" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetThreadPriority" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.CreateRemoteThreadEx">
    <summary>
      <para>Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights. In Windows 10, version 1607, your code must obtain these access rights for the new handle. However, starting in Windows 10, version 1703, if the new handle is entitled to these access rights, the system obtains them for you. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If <i>lpThreadAttributes</i> is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.</para>
    </param>
    <param name="dwStackSize">
      <para>The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</para>
    </param>
    <param name="lpStartAddress">
      <para>A pointer to the application-defined function of type <b>LPTHREAD_START_ROUTINE</b> to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. For more information, see
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>.</para>
    </param>
    <param name="lpParameter">
      <para>A pointer to a variable to be passed to the thread function pointed to by <i>lpStartAddress</i>. This parameter can be NULL.</para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the creation of the thread.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The thread runs immediately after creation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_SUSPENDED</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The thread is created in a suspended state and does not run until the
<see cref="ResumeThread" /> function is called.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>STACK_SIZE_PARAM_IS_A_RESERVATION</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>dwStackSize</i> parameter specifies the initial reserve size of the stack. If this flag is not specified, <i>dwStackSize</i> specifies the commit size.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpAttributeList">
      <para>An attribute list that contains additional parameters for the new thread. This list is created by the <see cref="InitializeProcThreadAttributeList" /> function.</para>
    </param>
    <param name="lpThreadId">
      <para>A pointer to a variable that receives the thread identifier.</para>
      <para>If this parameter is NULL, the thread identifier is not returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the new thread.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>CreateRemoteThreadEx</b> function causes a new thread of execution to begin in the address space of the specified process. The thread has access to all objects that the process opens. The <i>lpAttribute</i> parameter can be used to specify extended attributes such as processor group affinity for the new thread. If <i>lpAttribute</i> is NULL, the function's behavior is the same as  <see cref="CreateRemoteThread" />.</para>
      <para>Prior to Windows 8, Terminal Services isolates each terminal session by design. Therefore,
<see cref="CreateRemoteThread" /> fails if the target process is in a different session than the calling process.</para>
      <para>The new thread handle is created with full access to the new thread. If a security descriptor is not provided, the handle may be used in any function that requires a thread object handle. When a security descriptor is provided, an access check is performed on all subsequent uses of the handle before access is granted. If the access check denies access, the requesting process cannot use the handle to gain access to the thread.</para>
      <para>If the thread is created in a runnable state (that is, if the CREATE_SUSPENDED flag is not used), the thread can start running before <see cref="CreateThread" /> returns and, in particular, before  the caller receives the handle and identifier of the created thread.</para>
      <para>The thread is created with a thread priority of THREAD_PRIORITY_NORMAL. To get and set the priority value of a thread, use the
<see cref="GetThreadPriority" /> and
<see cref="SetThreadPriority" /> functions.</para>
      <para>When a thread terminates, the thread object attains a signaled state, which satisfies the threads that are waiting for the object.</para>
      <para>The thread object remains in the system until the thread has terminated and all handles to it are closed through a call to
<see cref="CloseHandle" />.</para>
      <para>The
<see cref="ExitProcess" />,
<see cref="ExitThread" />,
<see cref="CreateThread" />,
<see cref="CreateRemoteThread" /> functions, and a process that is starting (as the result of a
<see cref="CreateProcess" /> call) are serialized between each other within a process. Only one of these events occurs in an address space at a time. This means the following restrictions hold:</para>
      <list type="bullet">
        <item>
          <description>During process startup and DLL initialization routines, new threads can be created, but they do not begin execution until DLL initialization is done for the process.</description>
        </item>
        <item>
          <description>Only one thread in a process can be in a DLL initialization or detach routine at a time.</description>
        </item>
        <item>
          <description>
            <see cref="ExitProcess" /> returns after all threads have completed their DLL initialization or detach routines. </description>
        </item>
      </list>
      <para>A common use of this function is to inject a thread into a process that is being debugged to issue a break. However, this use is not recommended, because the extra thread is confusing to the person debugging the application and there are several side effects to using this technique:</para>
      <list type="bullet">
        <item>
          <description>It converts single-threaded applications into multithreaded applications.</description>
        </item>
        <item>
          <description>It changes the timing and memory layout of the process.</description>
        </item>
        <item>
          <description>It results in a call to the entry point of each DLL in the process.</description>
        </item>
      </list>
      <para>Another common use of this function is to inject a thread into a process to query heap or other process information. This can cause the same side effects mentioned in the previous paragraph. Also, the application can deadlock if the thread attempts to obtain ownership of locks that another thread is using.</para>
    </remarks>
    <seealso cref="CreateRemoteThread" />
  </member>
  <member name="Windows.CreateThread">
    <summary>
      <para>Creates a thread to execute within the virtual address space of the calling process.</para>
      <para>To create a thread that runs in the virtual address space of another process, use the
<see cref="CreateRemoteThread" /> function.</para>
    </summary>
    <param name="lpThreadAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether the returned handle can be inherited by child processes. If
<i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new thread. If <i>lpThreadAttributes</i> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the primary token of the creator.</para>
    </param>
    <param name="dwStackSize">
      <para>The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is zero, the new thread uses the default size for the executable. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</para>
    </param>
    <param name="lpStartAddress">
      <para>A pointer to the application-defined function to be executed by the thread. This pointer represents the starting address of the thread. For more information on the thread function, see
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>.</para>
    </param>
    <param name="lpParameter">
      <para>A pointer to a variable to be passed to the thread.</para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the creation of the thread.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The thread runs immediately after creation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_SUSPENDED</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The thread is created in a suspended state, and does not run until the
<see cref="ResumeThread" /> function is called.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>STACK_SIZE_PARAM_IS_A_RESERVATION</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>dwStackSize</i> parameter specifies the initial reserve size of the stack. If this flag is not specified, <i>dwStackSize</i> specifies the commit size.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpThreadId">
      <para>A pointer to a variable that receives the  thread identifier. If this parameter is
<b>NULL</b>, the thread identifier is not returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the new thread.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that <b>CreateThread</b> may succeed even if
<i>lpStartAddress</i> points to data, code, or is not accessible. If the start address is
invalid when the thread runs, an exception occurs, and the thread terminates. Thread termination due to a
invalid start address is handled as an error exit for the thread's process. This behavior is similar to the
asynchronous nature of <see cref="CreateProcess" />, where the
process is created even if it refers to invalid or missing dynamic-link libraries (DLLs).</para>
    </returns>
    <remarks>
      <para>The number of threads a process can create is limited by the available virtual memory. By default, every thread has one megabyte of stack space. Therefore, you can create at most 2,048 threads. If you reduce the default stack size, you can create more threads. However, your application will have better performance if you create one thread per processor and build queues of requests for which the application maintains the context information. A thread would process all requests in a queue before processing requests in the next queue.</para>
      <para>The new thread handle is created with the <b>THREAD_ALL_ACCESS</b> access right. If a security descriptor is not provided when the thread is created, a default security descriptor is constructed for the new thread using the primary token of the   process that is creating the thread. When a caller attempts to access the thread  with the <see cref="OpenThread" /> function, the effective token of the caller is evaluated against this  security descriptor to grant or deny access.</para>
      <para>The newly created thread  has full access rights to itself when calling the <see cref="GetCurrentThread" />  function.</para>
      <para>
        <b>Windows Server 2003:  </b>The thread's access rights to itself are computed by evaluating the primary token of the process in which the thread was created  against the default security descriptor constructed for the thread. If the thread is created in a remote process, the primary token of the remote process is used. As a result, the newly created thread may have reduced access rights to itself when calling <see cref="GetCurrentThread" />. Some access rights including <b>THREAD_SET_THREAD_TOKEN</b> and <b>THREAD_GET_CONTEXT</b> may not be present, leading to unexpected failures. For this reason, creating a thread while impersonating another user is not recommended.</para>
      <para>If the thread is created in a runnable state (that is, if the <b>CREATE_SUSPENDED</b> flag is not used), the thread can start running before <b>CreateThread</b> returns and, in particular, before  the caller receives the handle and identifier of the created thread.</para>
      <para>The thread execution begins at the function specified by the <i>lpStartAddress</i> parameter. If this function returns, the <b>DWORD</b> return value is used to terminate the thread in an implicit call to the
<see cref="ExitThread" /> function. Use the
<see cref="GetExitCodeThread" /> function to get the thread's return value.</para>
      <para>The thread is created with a thread priority of <b>THREAD_PRIORITY_NORMAL</b>. Use the
<see cref="GetThreadPriority" /> and
<see cref="SetThreadPriority" /> functions to get and set the priority value of a thread.</para>
      <para>When a thread terminates, the thread object attains a signaled state, satisfying any threads that were waiting on the object.</para>
      <para>The thread object remains in the system until the thread has terminated and all handles to it have been closed through a call to
<see cref="CloseHandle" />.</para>
      <para>The
<see cref="ExitProcess" />,
<see cref="ExitThread" />,
<b>CreateThread</b>,
<see cref="CreateRemoteThread" /> functions, and a process that is starting (as the result of a call by
<see cref="CreateProcess" />) are serialized between each other within a process. Only one of these events can happen in an address space at a time. This means that the following restrictions hold:</para>
      <list type="bullet">
        <item>
          <description>During process startup and DLL initialization routines, new threads can be created, but they do not begin execution until DLL initialization is done for the process.</description>
        </item>
        <item>
          <description>Only one thread in a process can be in a DLL initialization or detach routine at a time.</description>
        </item>
        <item>
          <description>
            <see cref="ExitProcess" /> does not complete until there are no threads in their DLL initialization or detach routines.</description>
        </item>
      </list>
      <para>A thread in an executable that calls the C run-time library (CRT) should use the <a href="https://docs.microsoft.com//cpp/c-runtime-library/reference/beginthread-beginthreadex">_beginthreadex</a> and <a href="https://docs.microsoft.com//cpp/c-runtime-library/reference/endthread-endthreadex">_endthreadex</a> functions for thread management rather than
<b>CreateThread</b> and
<see cref="ExitThread" />; this requires the use of the multithreaded version of the CRT. If a thread created using <b>CreateThread</b> calls the CRT, the CRT may terminate the process in low-memory conditions.</para>
      <para>
        <b>Windows Phone 8.1:</b> This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later.</para>
      <para>
        <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/creating-threads">Creating Threads</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateRemoteThread" />
    <seealso cref="ExitProcess" />
    <seealso cref="ExitThread" />
    <seealso cref="GetExitCodeThread" />
    <seealso cref="GetThreadPriority" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="ResumeThread" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetThreadPriority" />
    <seealso cref="SuspendThread" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.DeleteProcThreadAttributeList">
    <summary>
      <para>Deletes the specified list of attributes for process and thread creation.</para>
    </summary>
    <param name="lpAttributeList">
      <para>The attribute list. This list is created by the <see cref="InitializeProcThreadAttributeList" /> function.</para>
    </param>
    <seealso cref="InitializeProcThreadAttributeList" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.ExitProcess">
    <summary>
      <para>Ends the calling process and all its threads.</para>
    </summary>
    <param name="uExitCode">
      <para>The exit code for the process and all threads.</para>
    </param>
    <remarks>
      <para>Use the
<see cref="GetExitCodeProcess" /> function to retrieve the process's exit value. Use the
<see cref="GetExitCodeThread" /> function to retrieve a thread's exit value.</para>
      <para>Exiting a process causes the following:</para>
      <list type="number">
        <item>
          <description>All of the threads in the process, except the calling thread, terminate their execution without receiving a DLL_THREAD_DETACH notification.</description>
        </item>
        <item>
          <description>The states of all of the threads terminated in step 1 become signaled.</description>
        </item>
        <item>
          <description>The entry-point functions of all loaded dynamic-link libraries (DLLs) are called with DLL_PROCESS_DETACH. </description>
        </item>
        <item>
          <description>After all attached DLLs have executed any process termination code, the <b>ExitProcess</b> function terminates the current process, including the calling thread.</description>
        </item>
        <item>
          <description>The state of the calling thread becomes signaled.</description>
        </item>
        <item>
          <description>All of the object handles opened by the process are closed.</description>
        </item>
        <item>
          <description>The termination status of the process changes from STILL_ACTIVE to the exit value of the process.</description>
        </item>
        <item>
          <description>The state of the process object becomes signaled, satisfying any threads that had been waiting for the process to terminate.</description>
        </item>
      </list>
      <para>If one of the terminated threads in the process holds a lock and the DLL detach code in one of the loaded DLLs attempts to acquire the same lock, then calling <b>ExitProcess</b> results in a deadlock. In contrast, if a process terminates by calling
<see cref="TerminateProcess" />, the DLLs that the process is attached to are not notified of the process termination. Therefore, if you do not know the state of all threads in your process, it is better to call <b>TerminateProcess</b> than  <b>ExitProcess</b>. Note that returning from the <b>main</b> function of an application results in a call to <b>ExitProcess</b>.</para>
      <para>Calling
<b>ExitProcess</b> in a DLL can lead to unexpected application or system errors. Be sure to call
<b>ExitProcess</b> from a DLL only if you know which applications or system components will load the DLL and that it is safe to call
<b>ExitProcess</b> in this context.</para>
      <para>Exiting a process does not cause child processes to be terminated.</para>
      <para>Exiting a process does not necessarily remove the process object from the operating system. A process object is deleted when the last handle to the process is closed.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/creating-a-child-process-with-redirected-input-and-output">Creating a Child Process with Redirected Input and Output</a>.</para>
    </remarks>
    <seealso cref="CreateProcess" />
    <seealso cref="CreateRemoteThread" />
    <seealso cref="CreateThread" />
    <seealso cref="ExitThread" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetExitCodeThread" />
    <seealso cref="OpenProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="TerminateProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</seealso>
  </member>
  <member name="Windows.ExitThread">
    <summary>
      <para>Ends the calling thread.</para>
    </summary>
    <param name="dwExitCode">
      <para>The exit code for the thread.</para>
    </param>
    <remarks>
      <para>
        <b>ExitThread</b> is the preferred method of exiting a thread in C code. However, in C++ code, the thread is exited before any destructors can be called or any other automatic cleanup can be performed. Therefore, in C++ code, you should return from your thread function.</para>
      <para>When this function is called (either explicitly or by returning from a thread procedure), the current thread's stack is deallocated, all pending I/O initiated by the thread is canceled, and the thread terminates. The entry-point function of all attached dynamic-link libraries (DLLs) is invoked with a value indicating that the thread is detaching from the DLL.</para>
      <para>If the thread is the last thread in the process when this function is called, the thread's process is also terminated.</para>
      <para>The state of the thread object becomes signaled, releasing any other threads that had been waiting for the thread to terminate. The thread's termination status changes from STILL_ACTIVE to the value of the <i>dwExitCode</i> parameter.</para>
      <para>Terminating a thread does not necessarily remove the thread object from the operating system. A thread object is deleted when the last handle to the thread is closed.</para>
      <para>The
<see cref="ExitProcess" />,
<b>ExitThread</b>,
<see cref="CreateThread" />,
<see cref="CreateRemoteThread" /> functions, and a process that is starting (as the result of a
<see cref="CreateProcess" /> call) are serialized between each other within a process. Only one of these events can happen in an address space at a time. This means the following restrictions hold:</para>
      <list type="bullet">
        <item>
          <description>During process startup and DLL initialization routines, new threads can be created, but they do not begin execution until DLL initialization is done for the process.</description>
        </item>
        <item>
          <description>Only one thread in a process can be in a DLL initialization or detach routine at a time.</description>
        </item>
        <item>
          <description>
            <see cref="ExitProcess" /> does not return until no threads are in their DLL initialization or detach routines.</description>
        </item>
      </list>
      <para>A thread in an executable that is linked to the static C run-time library (CRT) should use <b>_beginthread</b> and <b>_endthread</b> for thread management rather than
<b>CreateThread</b> and
<b>ExitThread</b>. Failure to do so results in small memory leaks when
the thread calls <b>ExitThread</b>. Another work around is to link the executable to the CRT in a DLL instead of the static CRT. Note that this memory leak only occurs from a DLL if the DLL is linked to the static CRT and a thread calls the <see cref="DisableThreadLibraryCalls" /> function. Otherwise, it is safe to call <b>CreateThread</b> and
<b>ExitThread</b> from a thread in a DLL that links to the static CRT.</para>
      <para>Use the
<see cref="GetExitCodeThread" /> function to retrieve a thread's exit code.</para>
      <para>
        <b>Windows Phone 8.1:</b> This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later.</para>
      <para>
        <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-event-objects">Using Event Objects</a>.</para>
    </remarks>
    <seealso cref="CreateProcess" />
    <seealso cref="CreateRemoteThread" />
    <seealso cref="CreateThread" />
    <seealso cref="ExitProcess" />
    <seealso cref="FreeLibraryAndExitThread" />
    <seealso cref="GetExitCodeThread" />
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="TerminateThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.FlushInstructionCache">
    <summary>
      <para>Flushes the instruction cache for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to a process whose instruction cache is to be flushed.</para>
    </param>
    <param name="lpBaseAddress">
      <para>A pointer to the base of the region to be flushed. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region to be flushed if the <i>lpBaseAddress</i> parameter is not <b>NULL</b>, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications should call
<b>FlushInstructionCache</b> if they generate or modify code in memory. The CPU cannot detect the change, and may execute the old code it cached.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/debugging-functions">Debugging Functions</seealso>
  </member>
  <member name="Windows.FlushProcessWriteBuffers">
    <summary>
      <para>Flushes the write queue of each processor that is running a thread of the current process.</para>
    </summary>
    <remarks>
      <para>The function generates an interprocessor interrupt (IPI) to all processors that are part of the current process affinity. It guarantees the visibility of write operations performed on one processor to the other processors.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.GetCurrentProcess">
    <summary>
      <para>Retrieves a pseudo handle for the current process.</para>
    </summary>
    <returns>
      <para>The return value is a pseudo handle to the current process.</para>
    </returns>
    <remarks>
      <para>A pseudo handle is a special constant, currently (<b>HANDLE</b>)-1, that is interpreted as the current process handle. For compatibility with future operating systems, it is best to call
<b>GetCurrentProcess</b> instead of hard-coding this constant value. The calling process can use a pseudo handle to specify its own process whenever a process handle is required. Pseudo handles are not inherited by child processes.</para>
      <para>This handle has the <b>PROCESS_ALL_ACCESS</b> access right to the process object. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>This handle has the maximum access allowed by the security descriptor of the process to the primary token of the process.</para>
      <para>A process can create a "real" handle to itself that is valid in the context of other processes, or that can be inherited by other processes, by specifying the pseudo handle as the source handle in a call to the <see cref="DuplicateHandle" /> function. A process can also use the
<see cref="OpenProcess" /> function to open a real handle to itself.</para>
      <para>The pseudo handle need not be closed when it is no longer needed. Calling the
<see cref="CloseHandle" /> function with a pseudo handle has no effect. If the pseudo handle is duplicated by
<see cref="DuplicateHandle" />, the duplicate handle must be closed.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/creating-a-child-process-with-redirected-input-and-output">Creating a Child Process with Redirected Input and Output</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="DuplicateHandle" />
    <seealso cref="GetCurrentProcessId" />
    <seealso cref="GetCurrentThread" />
    <seealso cref="OpenProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
  </member>
  <member name="Windows.GetCurrentProcessId">
    <summary>
      <para>Retrieves the process identifier of the calling process.</para>
    </summary>
    <returns>
      <para>The return value is the process identifier of the calling process.</para>
    </returns>
    <remarks>
      <para>Until the process terminates, the process identifier uniquely identifies the process throughout the system.</para>
    </remarks>
    <seealso cref="GetCurrentProcess" />
    <seealso cref="OpenProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
  </member>
  <member name="Windows.GetCurrentProcessorNumber">
    <summary>
      <para>Retrieves the number of the processor the current thread was running on during the call to this function.</para>
    </summary>
    <returns>
      <para>The function returns the current processor number.</para>
    </returns>
    <remarks>
      <para>This function is used to provide information for estimating process performance.</para>
      <para>On systems with more than 64 logical processors, the <b>GetCurrentProcessorNumber</b> function returns the processor number within the <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a> to which the logical processor is assigned. Use the <see cref="GetCurrentProcessorNumberEx" /> function to retrieve the processor group and number of the current processor.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-processors">Multiple Processors</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
  </member>
  <member name="Windows.RtlGetCurrentProcessorNumber">
    <summary>
      <para>Retrieves the number of the processor the current thread was running on during the call to this function.</para>
    </summary>
    <returns>
      <para>The function returns the current processor number.</para>
    </returns>
    <remarks>
      <para>This function is used to provide information for estimating process performance.</para>
      <para>On systems with more than 64 logical processors, the <b>GetCurrentProcessorNumber</b> function returns the processor number within the <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a> to which the logical processor is assigned. Use the <see cref="GetCurrentProcessorNumberEx" /> function to retrieve the processor group and number of the current processor.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-processors">Multiple Processors</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
  </member>
  <member name="Windows.GetCurrentProcessorNumberEx">
    <summary>
      <para>Retrieves the processor group and number of the logical processor in which the calling thread is running.</para>
    </summary>
    <param name="ProcNumber">
      <para>A pointer to a <see cref="PROCESSOR_NUMBER" /> structure that receives the processor group to which the logical processor is assigned and the number of the logical processor within its group.</para>
    </param>
    <returns>
      <para>If the function succeeds, the <i>ProcNumber</i> parameter contains the group and processor number of the processor on which the calling thread is running.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0601. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.GetCurrentProcessToken">
    <summary>
      <para>Retrieves a pseudo-handle that you can use as a shorthand way to refer to the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> associated with a process.</para>
    </summary>
    <returns>
      <para>A pseudo-handle that you can use as a shorthand way to refer to the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> associated with a process.</para>
    </returns>
    <remarks>
      <para>A pseudo-handle is a special constant that can function as the access token for the current process.  The calling process can use a pseudo-handle to specify the access token for that process whenever a token handle is required.  Child processes do not inherit pseudo-handles.</para>
      <para>Starting in Windows 8, this pseudo-handle has only TOKEN_QUERY and TOKEN_QUERY_SOURCE access rights.</para>
      <para>The pseudo-handle cannot be duplicated by the <see cref="DuplicateHandle" /> function or the <see cref="DuplicateToken" /> function.</para>
      <para>You do not need to close the pseudo-handle when you no longer need it. If you call the <see cref="CloseHandle" /> function with a pseudo-handle, the function has no effect.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</seealso>
    <seealso cref="OpenProcessToken" />
  </member>
  <member name="Windows.GetCurrentThread">
    <summary>
      <para>Retrieves a pseudo handle for the calling thread.</para>
    </summary>
    <returns>
      <para>The return value is a pseudo handle for the current thread.</para>
    </returns>
    <remarks>
      <para>A pseudo handle is a special constant that is interpreted as the current thread handle. The calling thread can use this handle to specify itself whenever a thread handle is required. Pseudo handles are not inherited by child processes.</para>
      <para>This handle has the <b>THREAD_ALL_ACCESS</b> access right to the thread object. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>This handle has the maximum access allowed by the security descriptor of the thread to the primary token of the process.</para>
      <para>The function cannot be used by one thread to create a handle that can be used by other threads to refer to the first thread. The handle is always interpreted as referring to the thread that is using it. A thread can create a "real" handle to itself that can be used by other threads, or inherited by other processes, by specifying the pseudo handle as the source handle in a call to the <see cref="DuplicateHandle" /> function.</para>
      <para>The pseudo handle need not be closed when it is no longer needed. Calling the
<see cref="CloseHandle" /> function with this handle has no effect. If the pseudo handle is duplicated by
<see cref="DuplicateHandle" />, the duplicate handle must be closed.</para>
      <para>Do not create a thread while impersonating a security context. The call will succeed, however the newly created thread will have reduced access rights to itself when calling <b>GetCurrentThread</b>. The access rights granted this thread will  be derived from the access rights the impersonated user has to the process.  Some access rights including <b>THREAD_SET_THREAD_TOKEN</b> and <b>THREAD_GET_CONTEXT</b> may not be present, leading to unexpected failures.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/verifying-client-access-with-acls-in-c--">Checking Client Access</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="DuplicateHandle" />
    <seealso cref="GetCurrentProcess" />
    <seealso cref="GetCurrentThreadId" />
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.GetCurrentThreadEffectiveToken">
    <summary>
      <para>Retrieves a pseudo-handle that you can use as a shorthand way to refer to the token that is currently in effect for the thread, which is the thread token if one exists and the process token otherwise.</para>
    </summary>
    <returns>
      <para>A pseudo-handle that you can use as a shorthand way to refer to the token that is currently in effect for the thread.</para>
    </returns>
    <remarks>
      <para>A pseudo-handle is a special constant that can function as the effective token for the current thread.  The calling thread can use a pseudo-handle to specify the effective token for that thread whenever a token handle is required.  Child processes do not inherit pseudo-handles.</para>
      <para>Starting in Windows 8, this pseudo-handle has only TOKEN_QUERY and TOKEN_QUERY_SOURCE access rights.</para>
      <para>The pseudo-handle cannot be duplicated by the <see cref="DuplicateHandle" /> function or the <see cref="DuplicateToken" /> function.</para>
      <para>You do not need to close the pseudo-handle when you no longer need it. If you call the <see cref="CloseHandle" /> function with a pseudo-handle, the function has no effect.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</seealso>
    <seealso cref="GetCurrentProcessToken" />
    <seealso cref="GetCurrentThreadToken" />
  </member>
  <member name="Windows.GetCurrentThreadId">
    <summary>
      <para>Retrieves the thread identifier of the calling thread.</para>
    </summary>
    <returns>
      <para>The return value is the thread identifier of the calling thread.</para>
    </returns>
    <remarks>
      <para>Until the thread terminates, the thread identifier uniquely identifies the thread throughout the system.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-thread-local-storage">Using Thread Local Storage</a>.</para>
    </remarks>
    <seealso cref="GetCurrentThread" />
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.GetCurrentThreadStackLimits">
    <summary>
      <para>Retrieves the boundaries of the stack that was allocated by the system for the current thread.</para>
    </summary>
    <param name="LowLimit">
      <para>A pointer variable that receives the lower boundary of the current thread stack.</para>
    </param>
    <param name="HighLimit">
      <para>A pointer variable that receives the upper boundary of the current thread stack.</para>
    </param>
    <remarks>
      <para>It is possible for user-mode code to execute in stack memory
that is outside the region allocated by the system when the thread was created. Callers
can use the <b>GetCurrentThreadStackLimits</b> function to verify that the current stack pointer is within the returned
limits.</para>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0602. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</seealso>
  </member>
  <member name="Windows.GetCurrentThreadToken">
    <summary>
      <para>Retrieves a pseudo-handle that you can use as a shorthand way to refer to the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that was assigned to the current thread.</para>
    </summary>
    <returns>
      <para>A pseudo-handle that you can use as a shorthand way to refer to the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that was assigned to the current thread.</para>
    </returns>
    <remarks>
      <para>A pseudo-handle is a special constant that can function as the impersonation token for the current thread.  The calling thread can use a pseudo-handle to specify the impersonation token for that thread whenever a token handle is required.  Child processes do not inherit pseudo-handles.</para>
      <para>Starting in Windows 8, this pseudo-handle has only TOKEN_QUERY and TOKEN_QUERY_SOURCE access rights.</para>
      <para>The pseudo-handle cannot be duplicated by the <see cref="DuplicateHandle" /> function or the <see cref="DuplicateToken" /> function.</para>
      <para>You do not need to close the pseudo-handle when you no longer need it. If you call the <see cref="CloseHandle" /> function with a pseudo-handle, the function has no effect.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</seealso>
    <seealso cref="OpenThreadToken" />
    <seealso cref="SetThreadToken" />
  </member>
  <member name="Windows.GetExitCodeProcess">
    <summary>
      <para>Retrieves the termination status of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpExitCode">
      <para>A pointer to a variable to receive the process termination status. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function returns immediately. If the process has not terminated and the function succeeds, the status returned is <b>STILL_ACTIVE</b> (a macro for <b>STATUS_PENDING</b> (minwinbase.h)). If the process has terminated and the function succeeds, the status returned is one of the following values:</para>
      <list type="bullet">
        <item>
          <description>The exit value specified in the
<see cref="ExitProcess" /> or
<see cref="TerminateProcess" /> function.</description>
        </item>
        <item>
          <description>The return value from the <a href="https://docs.microsoft.com//cpp/cpp/main-function-command-line-args">main</a> or <see cref="WinMain" /> function of the process.</description>
        </item>
        <item>
          <description>The exception value for an unhandled exception that caused the process to terminate.</description>
        </item>
      </list>
      <blockquote>
        <para>[!IMPORTANT]
The <b>GetExitCodeProcess</b> function returns a valid error code defined by the application only after the thread terminates. Therefore, an application should not use <b>STILL_ACTIVE</b> (259) as an error code (<b>STILL_ACTIVE</b> is a macro for <b>STATUS_PENDING</b> (minwinbase.h)). If a thread returns <b>STILL_ACTIVE</b> (259) as an error code, then applications that test for that value could interpret it to mean that the thread is still running, and continue to test for the completion of the thread after the thread has terminated, which could put the application into an infinite loop.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExitProcess" />
    <seealso cref="ExitThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="TerminateProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</seealso>
    <seealso cref="WinMain" />
  </member>
  <member name="Windows.GetExitCodeThread">
    <summary>
      <para>Retrieves the termination status of the specified thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread.</para>
      <para>The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpExitCode">
      <para>A pointer to a variable to receive the thread termination status. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function returns immediately. If the specified thread has not terminated and the function succeeds, the status returned is <b>STILL_ACTIVE</b>. If the thread has terminated and the function succeeds, the status returned is one of the following values:</para>
      <list type="bullet">
        <item>
          <description>The exit value specified in the
<see cref="ExitThread" /> or
<see cref="TerminateThread" /> function.</description>
        </item>
        <item>
          <description>The return value from the thread function.</description>
        </item>
        <item>
          <description>The exit value of the thread's process.</description>
        </item>
      </list>
      <b>Important</b>  The <b>GetExitCodeThread</b> function returns a valid error code defined by the application only after the thread terminates. Therefore, an application should not use <b>STILL_ACTIVE</b> (259) as an error code. If a thread returns <b>STILL_ACTIVE</b> (259) as an error code, applications that test for this value could interpret it to mean that the thread is still running and continue to test for the completion of the thread after the thread has terminated, which could put the application into an infinite loop. To avoid this problem, callers should call the <b>GetExitCodeThread</b> function only after the thread has been confirmed to have exited. Use the <see cref="WaitForSingleObject" /> function with a wait duration of zero to determine whether a thread has exited.
<para><b>Windows Phone 8.1:</b> This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later.</para><para><b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.</para></remarks>
    <seealso cref="ExitThread" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="TerminateThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-thread">Terminating a Thread</seealso>
  </member>
  <member name="Windows.GetMachineTypeAttributes">
    <summary>
      <para>Queries if the specified architecture is supported on the current system, either natively or by any form of compatibility or emulation layer.</para>
    </summary>
    <param name="Machine">
      <para>An IMAGE_FILE_MACHINE_* value corresponding to the architecture of code to be tested for supportability. See the list of architecture values in <a href="https://docs.microsoft.com//windows/win32/sysinfo/image-file-machine-constants">Image File Machine Constants</a>.</para>
    </param>
    <param name="MachineTypeAttributes">
      <para>Output parameter receives a pointer to a value from the <see cref="MACHINE_ATTRIBUTES" /> enumeration indicating if the specified code architecture can run in user mode, kernel mode, and/or under WOW64 on the host operating system.</para>
    </param>
    <returns>
      <para>If the function fails, the return value is a nonzero HRESULT value. If the function succeeds, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetPriorityClass">
    <summary>
      <para>Retrieves the priority class for the specified process. This value, together with the priority value of each thread of the process, determines each thread's base priority level.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the priority class of the specified process.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The process's priority class is one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ABOVE_NORMAL_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process that has priority above <b>NORMAL_PRIORITY_CLASS</b> but below <b>HIGH_PRIORITY_CLASS</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>BELOW_NORMAL_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00004000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process that has priority above <b>IDLE_PRIORITY_CLASS</b> but below <b>NORMAL_PRIORITY_CLASS</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>HIGH_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process that performs time-critical tasks that must be executed immediately for it to run correctly. The threads of a high-priority class process preempt the threads of normal or idle priority class processes. An example is the Task List, which must respond quickly when called by the user, regardless of the load on the operating system. Use extreme care when using the high-priority class, because a high-priority class CPU-bound application can use nearly all available cycles.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>IDLE_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process whose threads run only when the system is idle and are preempted by the threads of any process running in a higher priority class. An example is a screen saver. The idle priority class is inherited by child processes.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NORMAL_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process with no special scheduling needs.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>REALTIME_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process that has the highest possible priority. The threads of a real-time priority class process preempt the threads of all other processes, including operating system processes performing important tasks. For example, a real-time process that executes for more than a very brief interval can cause disk caches not to flush or cause the mouse to be unresponsive.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Every thread has a base priority level determined by the thread's priority value and the priority class of its process. The operating system uses the base priority level of all executable threads to determine which thread gets the next slice of CPU time. Threads are scheduled in a round-robin fashion at each priority level, and only when there are no executable threads at a higher level will scheduling of threads at a lower level take place.</para>
      <para>For a table that shows the base priority levels for each combination of priority class and thread priority value, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>.</para>
      <para>Priority class is maintained by the executive, so all processes have a priority class that can be queried.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ToolHelp/taking-a-snapshot-and-viewing-processes">Taking a Snapshot and Viewing Processes</a>.</para>
    </remarks>
    <seealso cref="GetThreadPriority" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</seealso>
    <seealso cref="SetPriorityClass" />
    <seealso cref="SetThreadPriority" />
  </member>
  <member name="Windows.GetProcessDefaultCpuSetMasks">
    <summary>
      <para>Retrieves the list of CPU Sets in the process default set that was set by <see cref="SetProcessDefaultCpuSetMasks" /> or <see cref="SetProcessDefaultCpuSets" />.</para>
    </summary>
    <param name="Process">
      <para>Specifies a process handle for the process to query. This handle must have the <a href="https://docs.microsoft.com//windows/win32/procthread/process-security-and-access-rights">PROCESS_QUERY_LIMITED_INFORMATION</a> access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</para>
    </param>
    <param name="CpuSetMasks">
      <para>Specifies an optional buffer to retrieve a list of <see cref="GROUP_AFFINITY" /> structures representing the process default CPU Sets.</para>
    </param>
    <param name="CpuSetMaskCount">
      <para>Specifies the size of the <i>CpuSetMasks</i> array, in elements.</para>
    </param>
    <param name="RequiredMaskCount">
      <para>On successful return, specifies the number of affinity structures written to the array. If the <i>CpuSetMasks</i> array is too small, the function fails with <b>ERROR_INSUFFICIENT_BUFFER</b> and sets the <i>RequiredMaskCount</i> parameter to the number of elements required. The number of required elements is always less than or equal to the maximum group count returned by <see cref="GetMaximumProcessorGroupCount" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero and extended error information can be retrieved by calling <see cref="GetLastError" />.</para>
      <para>If the array supplied is too small, the error value is <b>ERROR_INSUFFICIENT_BUFFER</b> and the <i>RequiredMaskCount</i> is set to the number of elements required.</para>
    </returns>
    <remarks>
      <para>If no default CPU Sets are set for a given process, then the <i>RequiredMaskCount</i> parameter is set to 0 and the function succeeds.</para>
      <para>This function is analogous to <see cref="GetProcessDefaultCpuSets" />, except that it uses group affinities as opposed to CPU Set IDs to represent a list of CPU sets. This means that the process default CPU Sets are mapped to their home processors, and those processors are retrieved in the resulting list of group affinities.</para>
    </remarks>
  </member>
  <member name="Windows.GetProcessDefaultCpuSets">
    <summary>
      <para>Retrieves the list of CPU Sets in the process default set that was set by . If no default CPU Sets are set for a given process, then the <b>RequiredIdCount</b> is set to 0 and the function succeeds.</para>
    </summary>
    <param name="Process">
      <para>Specifies a process handle for the process to query. This handle must have the PROCESS_QUERY_LIMITED_INFORMATION access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</para>
    </param>
    <param name="CpuSetIds">
      <para>Specifies an optional buffer to retrieve the list of CPU Set identifiers.</para>
    </param>
    <param name="CpuSetIdCount">
      <para>Specifies the capacity of the buffer specified in <b>CpuSetIds</b>. If the buffer is NULL, this must be 0.</para>
    </param>
    <param name="RequiredIdCount">
      <para>Specifies the required capacity of the buffer to hold the entire list of process default CPU Sets. On successful return, this specifies the number of IDs filled into the buffer.</para>
    </param>
    <returns>
      <para>This API returns TRUE on success. If the buffer is not large enough the API returns FALSE, and the <b>GetLastError</b> value is ERROR_INSUFFICIENT_BUFFER. This API cannot fail when passed valid parameters and the return buffer is large enough.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessHandleCount">
    <summary>
      <para>Retrieves the number of open handles  that belong to the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process whose handle count is being requested.  The
handle must have the PROCESS_QUERY_INFORMATION
or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the PROCESS_QUERY_INFORMATION access right.</para>
    </param>
    <param name="pdwHandleCount">
      <para>A pointer to a variable that receives the number of open handles that belong to the specified process.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error  information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function retrieves information about the executive objects for the process. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/kernel-objects">Kernel Objects</a>.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
  </member>
  <member name="Windows.GetProcessId">
    <summary>
      <para>Retrieves the process identifier of the specified process.</para>
    </summary>
    <param name="Process">
      <para>A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the PROCESS_QUERY_INFORMATION access right.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the process identifier.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Until a process terminates, its process identifier uniquely identifies it on the system. For more information about access rights, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </remarks>
    <seealso cref="GetCurrentProcessId" />
    <seealso cref="GetProcessIdOfThread" />
    <seealso cref="GetThreadId" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
  </member>
  <member name="Windows.GetProcessIdOfThread">
    <summary>
      <para>Retrieves the process identifier of the process associated with the specified thread.</para>
    </summary>
    <param name="Thread">
      <para>A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003:  </b>The handle must have the THREAD_QUERY_INFORMATION access right.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the process identifier of the process associated with the specified thread.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Until a process terminates, its process identifier uniquely identifies it on the system. For more information about access rights, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </remarks>
    <seealso cref="GetCurrentThreadId" />
    <seealso cref="GetProcessId" />
    <seealso cref="GetThreadId" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
  </member>
  <member name="Windows.GetProcessInformation">
    <summary>
      <para>Retrieves information about the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access
right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="ProcessInformationClass">
      <para>A member of the <see cref="PROCESS_INFORMATION_CLASS" /> enumeration specifying the kind of information to retrieve.</para>
    </param>
    <param name="ProcessInformation">
      <para>Pointer to an object to receive the type of information specified by the
<i>ProcessInformationClass</i> parameter.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessMemoryPriority</b>, this parameter must point to a
<see cref="MEMORY_PRIORITY_INFORMATION" /> structure.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessPowerThrottling</b>, this parameter must point to a
<see cref="PROCESS_POWER_THROTTLING_STATE" /> structure.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessProtectionLevelInfo</b>, this parameter must point to a
<see cref="PROCESS_PROTECTION_LEVEL_INFORMATION" /> structure.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessLeapSecondInfo</b>, this parameter must point to a
<see cref="PROCESS_LEAP_SECOND_INFO" /> structure.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessAppMemoryInfo</b>, this parameter must point to a
<see cref="APP_MEMORY_INFORMATION" /> structure.</para>
    </param>
    <param name="ProcessInformationSize">
      <para>The size in bytes of the structure specified by the <i>ProcessInformation</i> parameter.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessMemoryPriority</b>, this parameter must be
<code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessPowerThrottling</b>, this parameter must be
<code>sizeof(PROCESS_POWER_THROTTLING_STATE)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessProtectionLevelInfo</b>, this parameter must be
<code>sizeof(PROCESS_PROTECTION_LEVEL_INFORMATION)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessLeapSecondInfo</b>, this parameter must be
<code>sizeof(PROCESS_LEAP_SECOND_INFO)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessAppMemoryInfo</b>, this parameter must be
<code>sizeof(APP_MEMORY_INFORMATION)</code>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="GetThreadInformation" />
    <seealso cref="MEMORY_PRIORITY_INFORMATION" />
    <seealso href="https://docs.microsoft.com//previous-versions/mt767996(v=vs.85)">PROCESS_INFORMATION_CLASS</seealso>
    <seealso cref="SetProcessInformation" />
  </member>
  <member name="Windows.GetProcessMitigationPolicy">
    <summary>
      <para>Retrieves mitigation policy settings for the calling process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must have the PROCESS_QUERY_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="MitigationPolicy">
      <para>The mitigation policy to retrieve. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ProcessDEPPolicy</b>
          </description>
          <description>
            <para>The data execution prevention (DEP) policy of the process.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_DEP_POLICY" /> structure that specifies the DEP policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessASLRPolicy</b>
          </description>
          <description>
            <para>The Address Space Layout Randomization (ASLR) policy of the process.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_ASLR_POLICY" /> structure that specifies the ASLR policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessDynamicCodePolicy</b>
          </description>
          <description>
            <para>The dynamic code policy of the process. When turned on, the process cannot generate dynamic code or modify existing executable code.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_DYNAMIC_CODE_POLICY" /> structure that specifies the dynamic code policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessStrictHandleCheckPolicy</b>
          </description>
          <description>
            <para>The process will receive a fatal error if it manipulates a handle that is not valid.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY" /> structure that specifies the handle check policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessSystemCallDisablePolicy</b>
          </description>
          <description>
            <para>Disables the ability to use NTUser/GDI functions at the lowest layer.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY" /> structure that specifies the system call disable policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessMitigationOptionsMask</b>
          </description>
          <description>
            <para>Returns the mask of valid bits for all the mitigation options on the system.  An application can set many mitigation options without querying the operating system for mitigation options by combining bitwise with the mask to exclude all non-supported bits at once.</para>
            <para>The <i>lpBuffer</i> parameter points to a <b>ULONG64</b> bit vector for the mask, or a two-element array of <b>ULONG64</b> bit vectors.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessExtensionPointDisablePolicy</b>
          </description>
          <description>
            <para>Prevents certain built-in third party extension points from being enabled, preventing legacy extension point DLLs from being loaded into the process.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY" /> structure that specifies the extension point disable policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessControlFlowGuardPolicy</b>
          </description>
          <description>
            <para>The Control Flow Guard (CFG) policy of the process.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY" /> structure that specifies the CFG policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessSignaturePolicy</b>
          </description>
          <description>
            <para>The policy of a process that can restrict image loading to those images that are either signed by Microsoft, by the Windows Store, or by Microsoft, the Windows Store and the Windows Hardware Quality Labs (WHQL).</para>
            <para>he <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY" /> structure that specifies the signature policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessFontDisablePolicy</b>
          </description>
          <description>
            <para>The policy regarding font loading for the process. When turned on, the process cannot load non-system fonts.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_FONT_DISABLE_POLICY" /> structure that specifies the policy flags for font loading.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessImageLoadPolicy</b>
          </description>
          <description>
            <para>The policy regarding image loading for the process, which determines the types of executable images that are allowed to be mapped into the process. When turned on, images cannot be loaded from some locations, such a remote devices or files that have the low mandatory label.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_IMAGE_LOAD_POLICY" /> structure that specifies the policy flags for image loading.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessSideChannelIsolationPolicy</b>
          </description>
          <description>
            <para>Windows 10, version 1809 and above: The policy regarding isolation of side channels for the specified process.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY" /> structure that specifies the policy flags for side channel isolation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessUserShadowStackPolicy</b>
          </description>
          <description>
            <para>Windows 10, version 2004 and above: The policy regarding user-mode Hardware-enforced Stack Protection for the specified process.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY" /> structure that specifies the policy flags for user-mode Hardware-enforced Stack Protection.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessDEPPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_DEP_POLICY" /> structure that receives the DEP policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessASLRPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_ASLR_POLICY" /> structure that receives the ASLR policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessDynamicCodePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_DYNAMIC_CODE_POLICY" /> structure that receives the dynamic code policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessStrictHandleCheckPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY" /> structure that specifies the handle check policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSystemCallDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY" /> structure that specifies the system call disable policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessMitigationOptionsMask</b>, this parameter points to a <b>ULONG64</b> bit vector for the mask or a two-element array of <b>ULONG64</b> bit vectors.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessExtensionPointDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY" /> structure that specifies the extension point disable policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessControlFlowGuardPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY" /> structure that specifies the CFG policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSignaturePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY" /> structure that receives the signature policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessFontDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_FONT_DISABLE_POLICY" /> structure that receives the policy flags for font loading.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_IMAGE_LOAD_POLICY" /> structure that receives the policy flags for image loading.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessUserShadowStackPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY" /> structure that receives the policy flags for user-mode Hardware-enforced Stack Protection.</para>
    </param>
    <param name="dwLength">
      <para>The size of <i>lpBuffer</i>, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0602. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.GetProcessPriorityBoost">
    <summary>
      <para>Retrieves the priority boost control state of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="pDisablePriorityBoost">
      <para>A pointer to a variable that receives the priority boost control state. A value of TRUE indicates that dynamic boosting is disabled. A value of FALSE indicates normal behavior.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero. In that case, the variable pointed to by the <i>pDisablePriorityBoost</i> parameter receives the priority boost control state.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/priority-boosts">Priority Boosts</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</seealso>
    <seealso cref="SetProcessPriorityBoost" />
  </member>
  <member name="Windows.GetProcessShutdownParameters">
    <summary>
      <para>Retrieves the shutdown parameters for the currently calling process.</para>
    </summary>
    <param name="lpdwLevel">
      <para>A pointer to a variable that receives the shutdown priority level. Higher levels shut down first. System level shutdown orders are reserved for system components. Higher numbers shut down first. Following are the level conventions.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>000-0FF</para>
          </description>
          <description>
            <para>System reserved last shutdown range.</para>
          </description>
        </item>
        <item>
          <description>
            <para>100-1FF</para>
          </description>
          <description>
            <para>Application reserved last shutdown range.</para>
          </description>
        </item>
        <item>
          <description>
            <para>200-2FF</para>
          </description>
          <description>
            <para>Application reserved "in between" shutdown range.</para>
          </description>
        </item>
        <item>
          <description>
            <para>300-3FF</para>
          </description>
          <description>
            <para>Application reserved first shutdown range.</para>
          </description>
        </item>
        <item>
          <description>
            <para>400-4FF</para>
          </description>
          <description>
            <para>System reserved first shutdown range.</para>
          </description>
        </item>
      </list>
      <para>All processes start at shutdown level 0x280.</para>
    </param>
    <param name="lpdwFlags">
      <para>A pointer to a variable that receives the shutdown flags. This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SHUTDOWN_NORETRY</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this process takes longer than the specified timeout to shut down, do not display a retry dialog box for the user. Instead, just cause the process to directly exit.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="SetProcessShutdownParameters" />
  </member>
  <member name="Windows.GetProcessTimes">
    <summary>
      <para>Retrieves timing information for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process whose timing information is sought. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpCreationTime">
      <para>A pointer to a
<see cref="FILETIME" /> structure that receives the creation time of the process.</para>
    </param>
    <param name="lpExitTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that receives the exit time of the process. If the process has not exited, the content of this structure is undefined.</para>
    </param>
    <param name="lpKernelTime">
      <para>A pointer to a
<see cref="FILETIME" /> structure that receives the amount of time that the process has executed in kernel mode. The time that each of the threads of the process has executed in kernel mode is determined, and then all of those times are summed together to obtain this value.</para>
    </param>
    <param name="lpUserTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that receives the amount of time that the process has executed in user mode. The time that each of the threads of the process has executed in user mode is determined, and then all of those times are summed together to obtain this value. Note that this value can exceed the amount of real time elapsed (between <i>lpCreationTime</i> and <i>lpExitTime</i>) if the process executes across multiple CPU cores.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>All times are expressed using <see cref="FILETIME" /> data structures. Such a structure contains two 32-bit values that combine to form a 64-bit count of 100-nanosecond time units.</para>
      <para>Process creation and exit times are points in time expressed as the amount of time that has elapsed since midnight on January 1, 1601 at Greenwich, England. There are several functions that an application can use to convert such values to more generally useful forms.</para>
      <para>Process kernel mode and user mode times are amounts of time. For example, if a process has spent one second in kernel mode, this function will fill the
<see cref="FILETIME" /> structure specified by <i>lpKernelTime</i> with a 64-bit value of ten million. That is the number of 100-nanosecond units in one second.</para>
      <para>To retrieve the number of CPU clock cycles used by the threads of the process, use the <see cref="QueryProcessCycleTime" /> function.</para>
    </remarks>
    <seealso cref="FILETIME" />
    <seealso cref="FileTimeToDosDateTime" />
    <seealso cref="FileTimeToLocalFileTime" />
    <seealso cref="FileTimeToSystemTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
  </member>
  <member name="Windows.GetProcessVersion">
    <summary>
      <para>Retrieves the major and minor version numbers of the system on which the specified process expects to run.</para>
    </summary>
    <param name="ProcessId">
      <para>The process identifier of the process of interest. A value of zero specifies the calling process.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the version of the system on which the process expects to run. The high word of the return value contains the major version number. The low word of the return value contains the minor version number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. The function fails if <i>ProcessId</i> is an invalid value.</para>
    </returns>
    <remarks>
      <para>The
<b>GetProcessVersion</b> function performs less quickly when <i>ProcessId</i> is nonzero, specifying a process other than the calling process.</para>
      <para>The version number returned by this function is the version number stamped in the image header of the .exe file the process is running. Linker programs set this value.</para>
      <para>If this function is called from a 32-bit application running on WOW64, the specified process must be a 32-bit process or the function fails.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
  </member>
  <member name="Windows.GetStartupInfo">
    <summary>
      <para>Retrieves the contents of the
<see cref="STARTUPINFO" /> structure that was specified when the calling process was created.</para>
    </summary>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> structure that receives the startup information.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
      <para>If an error occurs, the ANSI version of this function (<b>GetStartupInfoA</b>) can raise an exception. The Unicode version (<b>GetStartupInfoW</b>) does not fail.</para>
    </returns>
    <remarks>
      <para>The
<see cref="STARTUPINFO" /> structure was specified by the process that created the calling process. It can be used to specify properties associated with the main window of the calling process.</para>
    </remarks>
    <seealso cref="CreateProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="STARTUPINFO" />
  </member>
  <member name="Windows.GetStartupInfoA">
    <summary>
      <para>Retrieves the contents of the
<see cref="STARTUPINFO" /> structure that was specified when the calling process was created.</para>
    </summary>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> structure that receives the startup information.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
      <para>If an error occurs, the ANSI version of this function (<b>GetStartupInfoA</b>) can raise an exception. The Unicode version (<b>GetStartupInfoW</b>) does not fail.</para>
    </returns>
    <remarks>
      <para>The
<see cref="STARTUPINFO" /> structure was specified by the process that created the calling process. It can be used to specify properties associated with the main window of the calling process.</para>
    </remarks>
    <seealso cref="CreateProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="STARTUPINFO" />
  </member>
  <member name="Windows.GetStartupInfoW">
    <summary>
      <para>Retrieves the contents of the
<see cref="STARTUPINFO" /> structure that was specified when the calling process was created.</para>
    </summary>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> structure that receives the startup information.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
      <para>If an error occurs, the ANSI version of this function (<b>GetStartupInfoA</b>) can raise an exception. The Unicode version (<b>GetStartupInfoW</b>) does not fail.</para>
    </returns>
    <remarks>
      <para>The
<see cref="STARTUPINFO" /> structure was specified by the process that created the calling process. It can be used to specify properties associated with the main window of the calling process.</para>
    </remarks>
    <seealso cref="CreateProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="STARTUPINFO" />
  </member>
  <member name="Windows.GetSystemCpuSetInformation">
    <summary>
      <para>Allows an application to query the available CPU Sets on the system, and their current state.</para>
    </summary>
    <param name="Information">
      <para>A pointer to a <see cref="SYSTEM_CPU_SET_INFORMATION" /> structure that receives the CPU Set data. Pass NULL with a buffer length of 0 to determine the required buffer size.</para>
    </param>
    <param name="BufferLength">
      <para>The length, in bytes, of the output buffer passed as the Information argument.</para>
    </param>
    <param name="ReturnedLength">
      <para>The length, in bytes, of the valid data in the output buffer if the buffer is large enough, or the required size of the output buffer. If no CPU Sets exist, this value will be 0.</para>
    </param>
    <param name="Process">
      <para>An optional handle to a process. This process is used to determine the value of the <b>AllocatedToTargetProcess</b> flag in the SYSTEM_CPU_SET_INFORMATION structure. If a CPU Set is allocated to the specified process, the flag is set. Otherwise, it is clear. This handle must have the PROCESS_QUERY_LIMITED_INFORMATION access right. The value returned by <see cref="GetCurrentProcess" /> may also be specified here.</para>
    </param>
    <param name="Flags">
      <para>Reserved, must be 0.</para>
    </param>
    <returns>
      <para>If the API succeeds it returns TRUE. If it fails, the error reason is available through <b>GetLastError</b>. If the Information buffer was NULL or not large enough, the error code ERROR_INSUFFICIENT_BUFFER is returned. This API cannot fail when passed valid parameters and a buffer that is large enough to hold all of the return data.</para>
    </returns>
  </member>
  <member name="Windows.GetSystemTimes">
    <summary>
      <para>Retrieves system timing information.  On a multiprocessor system, the values returned are the sum
of the designated times across all processors.</para>
    </summary>
    <param name="lpIdleTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that receives the amount of time that the system has been idle.</para>
    </param>
    <param name="lpKernelTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that receives the amount of time that the system has spent executing in Kernel mode (including all threads in all processes, on all processors). This time value also includes the amount of time the system has been idle.</para>
    </param>
    <param name="lpUserTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that receives the amount of time that the system has spent executing in User mode (including all threads in all processes, on all processors).</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error  information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="FILETIME" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-time">System Time</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.GetThreadContext">
    <summary>
      <para>Retrieves the context of the specified thread.</para>
      <para>A 64-bit application can retrieve the context of a WOW64 thread using the <see cref="Wow64GetThreadContext" />.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread whose context is to be retrieved. The handle must have <b>THREAD_GET_CONTEXT</b> access to the thread. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>WOW64:</b> The handle must also have <b>THREAD_QUERY_INFORMATION</b> access.</para>
    </param>
    <param name="lpContext">
      <para>A pointer to a <see cref="CONTEXT" /> structure (such as <see cref="ARM64_NT_CONTEXT" />) that receives the appropriate context of the specified thread. The value of the <b>ContextFlags</b> member of this structure specifies which portions of a thread's context are retrieved. The       <b>CONTEXT</b> structure is highly processor specific. Refer to the WinNT.h header file for processor-specific definitions of this structures and any alignment requirements.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is used to retrieve the thread context of the specified thread. The function retrieves a selective context based on the value of the <b>ContextFlags</b> member of the context structure. The thread identified by the <i>hThread</i> parameter is typically being debugged, but the function can also operate when the thread is not being debugged.</para>
      <para>You cannot get a valid context for a running thread. Use the <see cref="SuspendThread" /> function to suspend the thread before calling <b>GetThreadContext</b>.</para>
      <para>If you call <b>GetThreadContext</b> for the current thread, the function returns successfully; however, the context returned is not valid.</para>
    </remarks>
    <seealso cref="CONTEXT" />
    <seealso cref="ARM64_NT_CONTEXT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/debugging-functions">Debugging Functions</seealso>
    <seealso cref="GetXStateFeaturesMask" />
    <seealso cref="SetThreadContext" />
    <seealso cref="SuspendThread" />
    <seealso cref="Wow64GetThreadContext" />
  </member>
  <member name="Windows.GetThreadDescription">
    <summary>
      <para>Retrieves the description that was assigned to a thread by calling <see cref="SetThreadDescription" />.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread for which to retrieve the description. The handle must have THREAD_QUERY_LIMITED_INFORMATION access.</para>
    </param>
    <param name="ppszThreadDescription">
      <para>A Unicode string that contains the description of the thread.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the <b>HRESULT</b> that denotes a successful operation.
If the function fails, the return value is an <b>HRESULT</b> that denotes the error.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows Server 2016</b>, <b>Windows 10 LTSB 2016</b> and <b>Windows 10 version 1607</b>: GetThreadDescription is only available by <a href="https://docs.microsoft.com//windows/win32/dlls/using-run-time-dynamic-linking">Run Time Dynamic Linking</a> in KernelBase.dll.</para>
      <para>The description for a thread can change at any time. For example, a different thread can change the description of a thread of interest while you try to retrieve that description.</para>
      <para>Thread descriptions do not need to be unique.</para>
      <para>To free the memory for the thread description, call the <see cref="LocalFree" /> method.</para>
      <h4>Examples</h4>
      <para>The following example gets the description for a thread,  prints the description, and then frees the memory for the description.</para>
      <code>HRESULT hr = GetThreadDescription(ThreadHandle, &amp;amp;amp;amp;amp;amp;data);
if (SUCCEEDED(hr))
{
    wprintf(“%ls\n”, data);
    LocalFree(data);
}
</code>
    </remarks>
    <seealso cref="LocalFree" />
    <seealso cref="SetThreadDescription" />
  </member>
  <member name="Windows.GetThreadId">
    <summary>
      <para>Retrieves the thread identifier of the specified thread.</para>
    </summary>
    <param name="Thread">
      <para>A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information about access rights, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003:  </b>The handle must have the THREAD_QUERY_INFORMATION access right.</para>
    </param>
    <returns>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Until a thread terminates, its thread identifier uniquely identifies it on the system.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0502 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="GetCurrentThreadId" />
    <seealso cref="GetProcessId" />
    <seealso cref="GetProcessIdOfThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.GetThreadIdealProcessorEx">
    <summary>
      <para>Retrieves the processor number of the ideal processor for the specified thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread for which to retrieve the ideal processor. This handle must have been created with the THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="lpIdealProcessor">
      <para>Points to <see cref="PROCESSOR_NUMBER" /> structure to receive the number of the ideal processor.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, it returns zero. To get extended error information, use <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0601. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="SetThreadIdealProcessorEx" />
  </member>
  <member name="Windows.GetThreadInformation">
    <summary>
      <para>Retrieves information about the specified thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread. The handle must have THREAD_QUERY_INFORMATION access rights. For more information, see  <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="ThreadInformationClass">
      <para>The class of information to retrieve. The only supported values are <b>ThreadMemoryPriority</b> and <b>ThreadPowerThrottling</b>.</para>
    </param>
    <param name="ThreadInformation">
      <para>Pointer to a structure to receive the type of information specified by the <i>ThreadInformationClass</i> parameter.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must point to a <b>MEMORY_PRIORITY_INFORMATION</b> structure.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadPowerThrottling</b>, this parameter must point to a <b>THREAD_POWER_THROTTLING_STATE</b> structure.</para>
    </param>
    <param name="ThreadInformationSize">
      <para>The size in bytes of the structure specified by the <i>ThreadInformation</i> parameter.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must be <code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadPowerThrottling</b>, this parameter must be <code>sizeof(THREAD_POWER_THROTTLING_STATE)</code>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="GetProcessInformation" />
    <seealso cref="SetThreadInformation" />
  </member>
  <member name="Windows.GetThreadIOPendingFlag">
    <summary>
      <para>Determines whether a specified thread has any I/O requests pending.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread in question. This handle must have been created with the THREAD_QUERY_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="lpIOIsPending">
      <para>A pointer to a  variable which the function sets to TRUE if the specified thread has one or more I/O requests pending, or to FALSE otherwise.</para>
    </param>
    <returns>
      <para>If the  function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Keep in mind that the I/O status of the specified thread can change  rapidly, and may already have changed by the time the function returns. For example, a pending I/O operation could complete between the time the function sets  <i>lpIOIsPending</i> and the time it returns.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.GetThreadPriority">
    <summary>
      <para>Retrieves the priority value for the specified thread. This value, together with the priority class of the thread's process, determines the thread's base-priority level.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread.</para>
      <para>The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the thread's priority level.</para>
      <para>If the function fails, the return value is <b>THREAD_PRIORITY_ERROR_RETURN</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>
        <b>Windows Phone 8.1:  </b>This function will always return <b>THREAD_PRIORITY_NORMAL</b>.</para>
      <para>The thread's priority level is one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_ABOVE_NORMAL</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Priority 1 point above the priority class.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_BELOW_NORMAL</b>
                </description>
              </item>
              <item>
                <description>-1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Priority 1 point below the priority class.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_HIGHEST</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Priority 2 points above the priority class.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_IDLE</b>
                </description>
              </item>
              <item>
                <description>-15</description>
              </item>
            </list>
          </description>
          <description>
            <para>Base priority of 1 for <b>IDLE_PRIORITY_CLASS</b>, <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or <b>HIGH_PRIORITY_CLASS</b> processes, and a base priority of 16 for <b>REALTIME_PRIORITY_CLASS</b> processes.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_LOWEST</b>
                </description>
              </item>
              <item>
                <description>-2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Priority 2 points below the priority class.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_NORMAL</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Normal priority for the priority class.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_TIME_CRITICAL</b>
                </description>
              </item>
              <item>
                <description>15</description>
              </item>
            </list>
          </description>
          <description>
            <para>Base-priority level of 15 for <b>IDLE_PRIORITY_CLASS</b>, <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or <b>HIGH_PRIORITY_CLASS</b> processes, and a base-priority level of 31 for <b>REALTIME_PRIORITY_CLASS</b> processes.</para>
          </description>
        </item>
      </list>
      <para>If the thread has the <b>REALTIME_PRIORITY_CLASS</b> base class, this function can also return one of the following values: -7, -6, -5, -4, -3, 3, 4, 5, or 6. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>.</para>
    </returns>
    <remarks>
      <para>Every thread has a base-priority level determined by the thread's priority value and the priority class of its process. The operating system uses the base-priority level of all executable threads to determine which thread gets the next slice of CPU time. Threads are scheduled in a round-robin fashion at each priority level, and only when there are no executable threads at a higher level will scheduling of threads at a lower level take place.</para>
      <para>For a table that shows the base-priority levels for each combination of priority class and thread priority value, refer to the
<see cref="SetPriorityClass" /> function.</para>
      <para>
        <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps.</para>
      <para>
        <b>Windows Phone 8.1:</b>Windows Phone Store apps may call this function but it has no effect.</para>
    </remarks>
    <seealso cref="GetPriorityClass" />
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</seealso>
    <seealso cref="SetPriorityClass" />
    <seealso cref="SetThreadPriority" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.GetThreadPriorityBoost">
    <summary>
      <para>Retrieves the priority boost control state of the specified thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread. The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="pDisablePriorityBoost">
      <para>A pointer to a variable that receives the priority boost control state. A value of TRUE indicates that dynamic boosting is disabled. A value of FALSE indicates normal behavior.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero. In that case, the variable pointed to by the <i>pDisablePriorityBoost</i> parameter receives the priority boost control state.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/priority-boosts">Priority Boosts</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</seealso>
    <seealso cref="SetThreadPriorityBoost" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.GetThreadSelectedCpuSetMasks">
    <summary>
      <para>Returns the explicit CPU Set assignment of the specified thread, if any assignment was set using <see cref="SetThreadSelectedCpuSetMasks" /> or <see cref="SetThreadSelectedCpuSets" />.</para>
    </summary>
    <param name="Thread">
      <para>Specifies the thread for which to query the selected CPU Sets. This handle must have the <a href="https://docs.microsoft.com//windows/win32/procthread/process-security-and-access-rights">PROCESS_QUERY_LIMITED_INFORMATION</a> access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</para>
    </param>
    <param name="CpuSetMasks">
      <para>Specifies an optional buffer to retrieve a list of <see cref="GROUP_AFFINITY" /> structures representing the thread selected CPU Sets.</para>
    </param>
    <param name="CpuSetMaskCount">
      <para>Specifies the size of the <i>CpuSetMasks</i> array, in elements.</para>
    </param>
    <param name="RequiredMaskCount">
      <para>On successful return, specifies the number of affinity structures written to the array.
If the array is too small, the function fails with <b>ERROR_INSUFFICIENT_BUFFER</b> and sets the <i>RequiredMaskCount</i> parameter to the number of elements required.
The number of required elements is always less than or equal to the maximum group count returned by <see cref="GetMaximumProcessorGroupCount" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero and extended error information can be retrieved by calling <see cref="GetLastError" />.</para>
      <para>If the array supplied is too small, the error value is <b>ERROR_INSUFFICIENT_BUFFER</b> and the RequiredMaskCount is set to the number of elements required.</para>
    </returns>
    <remarks>
      <para>If no explicit assignment is set, <i>RequiredMaskCount</i> is set to 0 and the function succeeds.</para>
      <para>This function is analogous to <see cref="GetThreadSelectedCpuSets" />, except that it uses group affinities as opposed to CPU Set IDs to represent a list of CPU sets. This means that the thread selected CPU Sets are mapped to their home processors, and those processors are retrieved in the resulting list of group affinities.</para>
    </remarks>
  </member>
  <member name="Windows.GetThreadSelectedCpuSets">
    <summary>
      <para>Returns the explicit CPU Set assignment of the specified thread, if any assignment was set using the  API. If no explicit assignment is set, <b>RequiredIdCount</b> is set to 0 and the function returns TRUE.</para>
    </summary>
    <param name="Thread">
      <para>Specifies the thread for which to query the selected CPU Sets. This handle must have the THREAD_QUERY_LIMITED_INFORMATION access right. The value returned by <see cref="GetCurrentThread" /> can also be specified here.</para>
    </param>
    <param name="CpuSetIds">
      <para>Specifies an optional buffer to retrieve the list of CPU Set identifiers.</para>
    </param>
    <param name="CpuSetIdCount">
      <para>Specifies the capacity of the buffer specified in <b>CpuSetIds</b>. If the buffer is NULL, this must be 0.</para>
    </param>
    <param name="RequiredIdCount">
      <para>Specifies the required capacity of the buffer to hold the entire list of thread selected CPU Sets. On successful return, this specifies the number of IDs filled into the buffer.</para>
    </param>
    <returns>
      <para>This API returns TRUE on success. If the buffer is not large enough, the <b>GetLastError</b> value is ERROR_INSUFFICIENT_BUFFER. This API cannot fail when passed valid parameters and the return buffer is large enough.</para>
    </returns>
  </member>
  <member name="Windows.GetThreadTimes">
    <summary>
      <para>Retrieves timing information for the specified thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread whose timing information is sought. The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpCreationTime">
      <para>A pointer to a
<see cref="FILETIME" /> structure that receives the creation time of the thread.</para>
    </param>
    <param name="lpExitTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that receives the exit time of the thread. If the thread has not exited, the content of this structure is undefined.</para>
    </param>
    <param name="lpKernelTime">
      <para>A pointer to a
<see cref="FILETIME" /> structure that receives the amount of time that the thread has executed in kernel mode.</para>
    </param>
    <param name="lpUserTime">
      <para>A pointer to a <see cref="FILETIME" /> structure that receives the amount of time that the thread has executed in user mode.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>All times are expressed using
<see cref="FILETIME" /> data structures. Such a structure contains two 32-bit values that combine to form a 64-bit count of 100-nanosecond time units.</para>
      <para>Thread creation and exit times are points in time expressed as the amount of time that has elapsed since midnight on January 1, 1601 at Greenwich, England. There are several functions that an application can use to convert such values to more generally useful forms; see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</a>.</para>
      <para>Thread kernel mode and user mode times are amounts of time. For example, if a thread has spent one second in kernel mode, this function will fill the <see cref="FILETIME" /> structure specified by <i>lpKernelTime</i> with a 64-bit value of ten million. That is the number of 100-nanosecond units in one second.</para>
      <para>To retrieve the number of CPU clock cycles used by the threads, use the <see cref="QueryThreadCycleTime" /> function.</para>
    </remarks>
    <seealso cref="FILETIME" />
    <seealso cref="FileTimeToDosDateTime" />
    <seealso cref="FileTimeToLocalFileTime" />
    <seealso cref="FileTimeToSystemTime" />
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.InitializeProcThreadAttributeList">
    <summary>
      <para>Initializes the specified list of attributes for process and thread creation.</para>
    </summary>
    <param name="lpAttributeList">
      <para>The attribute list. This parameter can be NULL to determine the buffer size required to support the specified number of attributes.</para>
    </param>
    <param name="dwAttributeCount">
      <para>The count of attributes to be added to the list.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter is reserved and must be zero.</para>
    </param>
    <param name="lpSize">
      <para>If <i>lpAttributeList</i> is not NULL, this parameter specifies the size in bytes of the <i>lpAttributeList</i> buffer on input. On output, this parameter receives the size in bytes of the initialized attribute list.</para>
      <para>If <i>lpAttributeList</i> is NULL, this parameter receives the required buffer size in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>First, call this function with the <i>dwAttributeCount</i> parameter set to the maximum number of attributes you will be using and the <i>lpAttributeList</i> to NULL. The function returns the required buffer size in bytes in the <i>lpSize</i> parameter.</para>
      <para>
        <b>Note</b>  This initial call will return an error by design. This is expected behavior.</para>
      <para>Allocate enough space for the data in the <i>lpAttributeList</i> buffer and call the function again to initialize the buffer.</para>
      <para>To add attributes to the list, call the <see cref="UpdateProcThreadAttribute" /> function. To specify these attributes when creating a process, specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlag</i> parameter and a <see cref="STARTUPINFOEX" /> structure in the <i>lpStartupInfo</i> parameter. Note that you can specify the same <b>STARTUPINFOEX</b> structure to multiple child processes.</para>
      <para>When you have finished using the list, call the <see cref="DeleteProcThreadAttributeList" /> function.</para>
    </remarks>
    <seealso cref="DeleteProcThreadAttributeList" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="UpdateProcThreadAttribute" />
  </member>
  <member name="Windows.IsProcessCritical">
    <summary>
      <para>Determines whether the specified process is considered critical.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process to query. The process must have been          opened with <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access.</para>
    </param>
    <param name="Critical">
      <para>A pointer to the <b>BOOL</b> value this function will use to indicate whether the process          is considered critical.</para>
    </param>
    <returns>
      <para>This routine returns FALSE on failure. Any other value indicates success.      Call <see cref="GetLastError" /> to query for the specific error reason on failure.</para>
    </returns>
    <seealso cref="HRESULT_FROM_WIN32" />
  </member>
  <member name="Windows.IsProcessorFeaturePresent">
    <summary>
      <para>Determines whether the specified processor feature is supported by the current computer.</para>
    </summary>
    <param name="ProcessorFeature">
      <para>The processor feature to be tested. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_ARM_64BIT_LOADSTORE_ATOMIC</b>
                </description>
              </item>
              <item>
                <description>25</description>
              </item>
            </list>
          </description>
          <description>
            <para>The 64-bit load/store atomic instructions are available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>24</description>
              </item>
            </list>
          </description>
          <description>
            <para>The divide instructions are available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_ARM_EXTERNAL_CACHE_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>26</description>
              </item>
            </list>
          </description>
          <description>
            <para>The external cache is available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>27</description>
              </item>
            </list>
          </description>
          <description>
            <para>The floating-point multiply-accumulate instruction is available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_ARM_VFP_32_REGISTERS_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>18</description>
              </item>
            </list>
          </description>
          <description>
            <para>The VFP/Neon: 32 x 64bit register bank is present. This flag has the same meaning as <b>PF_ARM_VFP_EXTENDED_REGISTERS</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_3DNOW_INSTRUCTIONS_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>7</description>
              </item>
            </list>
          </description>
          <description>
            <para>The 3D-Now instruction set is available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_CHANNELS_ENABLED</b>
                </description>
              </item>
              <item>
                <description>16</description>
              </item>
            </list>
          </description>
          <description>
            <para>The processor channels are enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_COMPARE_EXCHANGE_DOUBLE</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The atomic compare and exchange operation (cmpxchg) is available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_COMPARE_EXCHANGE128</b>
                </description>
              </item>
              <item>
                <description>14</description>
              </item>
            </list>
          </description>
          <description>
            <para>The  atomic compare and exchange 128-bit operation (cmpxchg16b) is available.</para>
            <para>
              <b>Windows Server 2003 and Windows XP/2000:  </b>This feature is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_COMPARE64_EXCHANGE128</b>
                </description>
              </item>
              <item>
                <description>15</description>
              </item>
            </list>
          </description>
          <description>
            <para>The atomic compare 64 and exchange 128-bit operation (cmp8xchg16) is available.</para>
            <para>
              <b>Windows Server 2003 and Windows XP/2000:  </b>This feature is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_FASTFAIL_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>23</description>
              </item>
            </list>
          </description>
          <description>
            <para>_fastfail() is available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_FLOATING_POINT_EMULATED</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Floating-point operations are emulated using a software emulator.</para>
            <para>This function returns a nonzero value if floating-point operations are emulated; otherwise, it returns zero.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_FLOATING_POINT_PRECISION_ERRATA</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>On a Pentium, a floating-point precision error can occur in rare circumstances.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_MMX_INSTRUCTIONS_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The MMX instruction set is available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_NX_ENABLED</b>
                </description>
              </item>
              <item>
                <description>12</description>
              </item>
            </list>
          </description>
          <description>
            <para>
              <a href="https://docs.microsoft.com//windows/desktop/Memory/data-execution-prevention">Data execution prevention</a> is enabled.</para>
            <para>
              <b>Windows XP/2000:  </b>This feature is not supported until Windows XP with SP2 and Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_PAE_ENABLED</b>
                </description>
              </item>
              <item>
                <description>9</description>
              </item>
            </list>
          </description>
          <description>
            <para>The processor is PAE-enabled. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/physical-address-extension">Physical Address Extension</a>.</para>
            <para>All x64 processors always return a nonzero value for this feature.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_RDTSC_INSTRUCTION_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The RDTSC instruction is available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_RDWRFSGSBASE_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>22</description>
              </item>
            </list>
          </description>
          <description>
            <para>RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE instructions are available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_SECOND_LEVEL_ADDRESS_TRANSLATION</b>
                </description>
              </item>
              <item>
                <description>20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Second Level Address Translation is supported by the hardware.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_SSE3_INSTRUCTIONS_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>13</description>
              </item>
            </list>
          </description>
          <description>
            <para>The SSE3 instruction set is available.</para>
            <para>
              <b>Windows Server 2003 and Windows XP/2000:  </b>This feature is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_VIRT_FIRMWARE_ENABLED</b>
                </description>
              </item>
              <item>
                <description>21</description>
              </item>
            </list>
          </description>
          <description>
            <para>Virtualization is enabled in the firmware and made available by the operating system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_XMMI_INSTRUCTIONS_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The SSE instruction set is available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_XMMI64_INSTRUCTIONS_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>10</description>
              </item>
            </list>
          </description>
          <description>
            <para>The SSE2 instruction set is available.</para>
            <para>
              <b>Windows 2000:  </b>This feature is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_XSAVE_ENABLED</b>
                </description>
              </item>
              <item>
                <description>17</description>
              </item>
            </list>
          </description>
          <description>
            <para>The processor implements the XSAVE and XRSTOR instructions.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:  </b>This feature is not supported until Windows 7 and Windows Server 2008 R2.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_ARM_V8_INSTRUCTIONS_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>29</description>
              </item>
            </list>
          </description>
          <description>
            <para>This ARM processor implements the the ARM v8 instructions set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>30</description>
              </item>
            </list>
          </description>
          <description>
            <para>This ARM processor implements the ARM v8 extra cryptographic instructions (i.e. AES, SHA1 and SHA2).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>31</description>
              </item>
            </list>
          </description>
          <description>
            <para>This ARM processor implements the ARM v8 extra CRC32 instructions.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE</b>
                </description>
              </item>
              <item>
                <description>34</description>
              </item>
            </list>
          </description>
          <description>
            <para>This ARM processor implements the ARM v8.1 atomic instructions (e.g. CAS, SWP).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the feature is supported, the return value is a nonzero value.</para>
      <para>If the feature is not supported, the return value is zero.</para>
      <para>If the HAL does not support detection of the feature, whether or not the hardware supports the feature, the return value is also zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.OpenProcess">
    <summary>
      <para>Opens an existing local process object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the process object. This access right is checked against the  security descriptor for the process. This parameter can be one or more of the
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">process access rights</a>.</para>
      <para>If the caller has enabled the SeDebugPrivilege privilege, the requested access is  granted regardless of the contents of the security descriptor.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="dwProcessId">
      <para>The identifier of the local process to be opened.</para>
      <para>If the specified process is the System Idle Process (0x00000000), the function fails and the last error code is <code>ERROR_INVALID_PARAMETER</code>. If the specified process is the System process or one of the Client Server Run-Time Subsystem (CSRSS) processes, this function fails and the last error code is <code>ERROR_ACCESS_DENIED</code> because their access restrictions prevent user-level code from opening them.</para>
      <para>If you are using <see cref="GetCurrentProcessId" /> as an argument to this function, consider using <see cref="GetCurrentProcess" /> instead of OpenProcess, for improved performance.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified process.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To open a handle to another local process and obtain full access rights, you must enable the SeDebugPrivilege privilege. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.</para>
      <para>The handle returned by the
<b>OpenProcess</b> function can be used in any function that requires a handle to a process, such as the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, provided the appropriate access rights were requested.</para>
      <para>When you are finished with the handle, be sure to close it using the <see cref="CloseHandle" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ToolHelp/taking-a-snapshot-and-viewing-processes">Taking a Snapshot and Viewing Processes</a>.</para>
    </remarks>
    <seealso cref="AssignProcessToJobObject" />
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateRemoteThread" />
    <seealso cref="DuplicateHandle" />
    <seealso cref="GetCurrentProcess" />
    <seealso cref="GetCurrentProcessId" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetPriorityClass" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="ReadProcessMemory" />
    <seealso cref="SetPriorityClass" />
    <seealso cref="SetProcessWorkingSetSize" />
    <seealso cref="TerminateProcess" />
    <seealso cref="VirtualProtectEx" />
    <seealso cref="WriteProcessMemory" />
  </member>
  <member name="Windows.OpenProcessToken">
    <summary>
      <para>The <b>OpenProcessToken</b> function opens the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> associated with a process.</para>
    </summary>
    <param name="ProcessHandle">
      <para>A handle to the process whose access token is opened. The process must have the PROCESS_QUERY_INFORMATION access permission.</para>
    </param>
    <param name="DesiredAccess">
      <para>Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the requested types of access to the access token. These requested access types are compared with the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/d-gly">discretionary access control list</a> (DACL) of the token to determine which accesses are granted or denied.</para>
      <para>For a list of access rights for access tokens, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="TokenHandle">
      <para>A pointer to a handle that identifies the newly opened access token when the function returns.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Close the access token handle returned through the <i>TokenHandle</i> parameter by calling
<see cref="CloseHandle" />.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso cref="AccessCheck" />
    <seealso cref="AdjustTokenGroups" />
    <seealso cref="AdjustTokenPrivileges" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="GetCurrentProcessToken" />
    <seealso cref="GetCurrentThreadEffectiveToken" />
    <seealso cref="GetCurrentThreadToken" />
    <seealso cref="GetTokenInformation" />
    <seealso cref="OpenThreadToken" />
    <seealso cref="SetTokenInformation" />
  </member>
  <member name="Windows.OpenThread">
    <summary>
      <para>Opens an existing thread object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the thread object. This access right is checked against the security descriptor for the thread. This parameter can be one or more of the
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">thread access rights</a>.</para>
      <para>If the caller has enabled the SeDebugPrivilege privilege, the requested access is  granted regardless of the contents of the security descriptor.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="dwThreadId">
      <para>The identifier of the thread to be opened.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified thread.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by
<b>OpenThread</b> can be used in any function that requires a handle to a thread, such as the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>, provided you requested the appropriate access rights. The handle is granted access to the thread object only to the extent it was specified in the <i>dwDesiredAccess</i> parameter.</para>
      <para>When you are finished with the handle, be sure to close it by using the
<see cref="CloseHandle" /> function.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="GetExitCodeThread" />
    <seealso cref="GetThreadContext" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="ResumeThread" />
    <seealso cref="SetThreadContext" />
    <seealso cref="SetTokenInformation" />
    <seealso cref="SuspendThread" />
    <seealso cref="TerminateThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.OpenThreadToken">
    <summary>
      <para>The <b>OpenThreadToken</b> function opens the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> associated with a thread.</para>
    </summary>
    <param name="ThreadHandle">
      <para>A handle to the thread whose access token is opened.</para>
    </param>
    <param name="DesiredAccess">
      <para>Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the requested types of access to the access token. These requested access types are reconciled against the token's <a href="https://docs.microsoft.com//windows/desktop/SecGloss/d-gly">discretionary access control list</a> (DACL) to determine which accesses are granted or denied.</para>
      <para>For a list of access rights for access tokens, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="OpenAsSelf">
      <para>TRUE if the access check is to be made against the  process-level <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security context</a>.</para>
      <para>
        <b>FALSE</b> if the access check is to be made against the current security context of the thread calling the <b>OpenThreadToken</b> function.</para>
      <para>The <i>OpenAsSelf</i> parameter allows the caller of this function to open the access token of a specified thread when the caller is impersonating a token at <b>SecurityIdentification</b> level. Without this parameter, the calling thread cannot open the access token on the specified thread because it is impossible to open executive-level objects by using the <b>SecurityIdentification</b> impersonation level.</para>
    </param>
    <param name="TokenHandle">
      <para>A pointer to a variable that receives the handle to the newly opened access token.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If the token has the anonymous impersonation level, the token will not be opened and <b>OpenThreadToken</b> sets  ERROR_CANT_OPEN_ANONYMOUS as the error.</para>
    </returns>
    <remarks>
      <para>Tokens with the anonymous impersonation level cannot be opened.</para>
      <para>Close the access token handle returned through the <i>TokenHandle</i> parameter by calling
<see cref="CloseHandle" />.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso cref="AccessCheck" />
    <seealso cref="AdjustTokenGroups" />
    <seealso cref="AdjustTokenPrivileges" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="GetCurrentThreadToken" />
    <seealso cref="GetTokenInformation" />
    <seealso cref="OpenProcessToken" />
    <seealso cref="SECURITY_IMPERSONATION_LEVEL" />
    <seealso cref="SetThreadToken" />
    <seealso cref="SetTokenInformation" />
  </member>
  <member name="Windows.ProcessIdToSessionId">
    <summary>
      <para>Retrieves the Remote Desktop Services session
associated with a specified process.</para>
    </summary>
    <param name="dwProcessId">
      <para>Specifies a process identifier. Use the
<see cref="GetCurrentProcessId" /> function to retrieve the
process identifier for the current process.</para>
    </param>
    <param name="pSessionId">
      <para>Pointer to a variable that receives the identifier of the Remote Desktop Services session under which the
specified process is running. To retrieve the identifier of the session currently attached to the console, use
the <see cref="WTSGetActiveConsoleSessionId" /></para>
      <para>function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Callers must hold the <b>PROCESS_QUERY_INFORMATION</b> access right for the specified
process. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </remarks>
    <seealso cref="OSVERSIONINFOEX" />
    <seealso cref="WTSQuerySessionInformation" />
  </member>
  <member name="Windows.QueryProcessAffinityUpdateMode">
    <summary>
      <para>Retrieves the affinity update mode of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpdwFlags">
      <para>The affinity update mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Dynamic update of the process affinity by the system is disabled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_AFFINITY_ENABLE_AUTO_UPDATE</b>
                </description>
              </item>
              <item>
                <description>0x00000001UL</description>
              </item>
            </list>
          </description>
          <description>
            <para>Dynamic update of the process affinity by the system is enabled.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that calls this function, define _WIN32_WINNT as 0x0600 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="SetProcessAffinityUpdateMode" />
  </member>
  <member name="Windows.QueryProtectedPolicy">
    <summary>
      <para>Queries the value associated with a protected policy.</para>
    </summary>
    <param name="PolicyGuid">
      <para>The globally-unique identifier of the policy to query.</para>
    </param>
    <param name="PolicyValue">
      <para>Receives the value that the supplied policy is set to.</para>
    </param>
    <returns>
      <para>True if the function succeeds; otherwise, false.</para>
    </returns>
    <remarks>
      <para>Protected policies are process-wide configuration settings that are stored in read-only memory. This is intended to help protect the policy from being corrupted or altered in an unintended way while an application is executing.</para>
      <para>To compile an application that calls this function, define _WIN32_WINNT as 0x0603 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers.</a></para>
      <para>This function became available in Windows 8.1 and  Windows Server 2012 R2 update 3 (the November 2014 update).</para>
    </remarks>
  </member>
  <member name="Windows.QueueUserAPC">
    <summary>
      <para>Adds a user-mode <a href="https://docs.microsoft.com//windows/win32/sync/asynchronous-procedure-calls">asynchronous procedure call</a> (APC) object to the APC queue of the specified thread.</para>
    </summary>
    <param name="pfnAPC">
      <para>A pointer to the application-supplied APC function to be called when the specified thread performs an alertable wait operation. For more information, see <a href="https://docs.microsoft.com/../winnt/nc-winnt-papcfunc.md">PAPCFUNC callback function</a>.</para>
    </param>
    <param name="hThread">
      <para>A handle to the thread. The handle must have the <b>THREAD_SET_CONTEXT</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="dwData">
      <para>A single value that is passed to the APC function pointed to by the <i>pfnAPC</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. <b>Windows Server 2003 and Windows XP:</b> There are no error values defined for this function that can be retrieved by calling <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>See <see cref="QueueUserAPC2 function" /> for information on special user-mode APCs.</para>
      <para>The APC support provided in the operating system allows an application to queue an APC object to a thread. To ensure successful execution of  functions used by the APC, APCs  should be queued only to   threads in the caller's process.</para>
      <blockquote>
        <para>[!NOTE]
Queuing APCs to threads outside the caller's process is not recommended for a number of reasons. DLL rebasing can cause the addresses of functions used by the APC to be incorrect when the functions are executed outside the caller's process. Similarly, if a 64-bit process queues an APC to a 32-bit process or vice versa, addresses will be incorrect and the application will crash. Other factors can prevent successful function execution, even if the address is known.</para>
      </blockquote>
      <para>Each thread has its own APC queue. The queuing of an APC is a request for the thread to call the APC function. The operating system issues a software interrupt to direct the thread to call the APC function.</para>
      <para>When a user-mode APC is queued, the thread is not directed to call the APC function unless it is in an alertable state. After the thread is in an alertable state, the thread handles all pending APCs in first in, first out (FIFO) order, and the wait operation returns <b>WAIT_IO_COMPLETION</b>. A thread enters an alertable state by using <see cref="SleepEx function" />, <see cref="SignalObjectAndWait function" />, <see cref="WaitForSingleObjectEx function" />, <see cref="WaitForMultipleObjectsEx function" />, or <see cref="MsgWaitForMultipleObjectsEx function" />.</para>
      <para>If an application queues an APC before the thread begins running, the thread begins by calling the APC function. After the thread calls an APC function, it calls the APC functions for all APCs in its APC queue.</para>
      <para>It is possible to sleep or wait for an object within the APC. If you perform an alertable wait inside an APC, it will recursively dispatch the APCs. This can cause a stack overflow.</para>
      <para>When the thread is terminated using the <see cref="ExitThread function" /> or <see cref="TerminateThread function" /> function, the APCs in its APC queue are lost. The APC functions are not called.</para>
      <para>When the thread is in the process of being terminated, calling QueueUserAPC to add to the thread's APC queue will fail with <b>(31) ERROR_GEN_FAILURE</b>.</para>
      <para>Note that the <see cref="ReadFileEx function" />, <see cref="SetWaitableTimer function" />, and <see cref="WriteFileEx function" /> functions are implemented using an APC as the completion notification callback mechanism.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com/../winnt/nc-winnt-papcfunc.md">PAPCFUNC callback function</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/asynchronous-procedure-calls">Asynchronous Procedure Calls</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.QueueUserAPC2">
    <summary>
      <para>Adds a user-mode <a href="https://docs.microsoft.com//windows/win32/sync/asynchronous-procedure-calls">asynchronous procedure call</a> (APC) object to the APC queue of the specified thread.</para>
    </summary>
    <param name="ApcRoutine">
      <para>A pointer to the application-supplied APC function to be called when the specified thread performs an alertable wait operation. For more information, see <a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-papcfunc">APCProc</a>.</para>
      <para>For special user-mode APCs, an alertable wait is not required. See <a href="https://docs.microsoft.com/#-remarks">Remarks</a> for more information about special user-mode APCs.</para>
    </param>
    <param name="Thread">
      <para>A handle to the thread. The handle must have <b>THREAD_SET_CONTEXT</b> access permission. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="Data">
      <para>A single value that is passed to the APC function pointed to by the <i>ApcRoutine</i> parameter.</para>
    </param>
    <param name="Flags">
      <para>A value from <see cref="QUEUE_USER_APC_FLAGS" /> to modify the behavior of the user-mode APC.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. <b>Windows Server 2003 and Windows XP:</b> There are no error values defined for this function that can be retrieved by calling <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Regular user-mode APCs are only executed if the target thread is in an alertable state. See <see cref="QueueUserAPC function" /> for additional remarks on regular user-mode APCs.</para>
      <para>Special user-mode APCs always execute, even if the target thread is not in an alertable state. For example, if the target thread is currently executing user-mode code, or if the target thread is currently performing an alertable wait, the target thread will be interrupted immediately for APC execution. If the target thread is executing a system call, or performing a non-alertable wait, the APC will be executed after the system call or non-alertable wait finishes (the wait is not interrupted).</para>
      <para>Since the execution of the special user-mode APC is not synchronized with the target thread, particular care must be taken (beyond the normal requirements for multithreading and synchronization). For example, when acquiring any locks, the interrupted target thread may already own the lock or be in the process of acquiring or releasing the lock. In addition, because there are no facilities to block a thread from receiving special user-mode APCs, a special user-mode APC can be executed on a target thread that is already executing a special user-mode APC.</para>
      <para>Currently, special user-mode APCs are only supported on native architectures, and not when running under WoW.</para>
    </remarks>
  </member>
  <member name="Windows.ResumeThread">
    <summary>
      <para>Decrements a thread's suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread to be restarted.</para>
      <para>This handle must have the THREAD_SUSPEND_RESUME access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the thread's previous suspend count.</para>
      <para>If the function fails, the return value is (DWORD) -1. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>ResumeThread</b> function checks the suspend count of the subject thread. If the suspend count is zero, the thread is not currently suspended. Otherwise, the subject thread's suspend count is decremented. If the resulting value is zero, then the execution of the subject thread is resumed.</para>
      <para>If the return value is zero, the specified thread was not suspended. If the return value is 1, the specified thread was suspended but was restarted. If the return value is greater than 1, the specified thread is still suspended.</para>
      <para>Note that while reporting debug events, all threads within the reporting process are frozen. Debuggers are expected to use the
<see cref="SuspendThread" /> and
<b>ResumeThread</b> functions to limit the set of threads that can execute within a process. By suspending all threads in a process except for the one reporting a debug event, it is possible to "single step" a single thread. The other threads are not released by a continue operation if they are suspended.</para>
      <para>
        <b>Windows Phone 8.1:  </b>This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later.</para>
      <para>
        <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.</para>
    </remarks>
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="SuspendThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/suspending-thread-execution">Suspending Thread Execution</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.SetPriorityClass">
    <summary>
      <para>Sets the priority class for the specified process. This value together with the priority value of each thread of the process determines each thread's base priority level.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process.</para>
      <para>The handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwPriorityClass">
      <para>The priority class for the process. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Priority</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ABOVE_NORMAL_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process that has priority above <b>NORMAL_PRIORITY_CLASS</b> but below <b>HIGH_PRIORITY_CLASS</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>BELOW_NORMAL_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00004000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process that has priority above <b>IDLE_PRIORITY_CLASS</b> but below <b>NORMAL_PRIORITY_CLASS</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>HIGH_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process that performs time-critical tasks that must be executed immediately. The threads of the process preempt the threads of normal or idle priority class processes. An example is the Task List, which must respond quickly when called by the user, regardless of the load on the operating system. Use extreme care when using the high-priority class, because a high-priority class application can use nearly all available CPU time.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>IDLE_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process whose threads run only when the system is idle. The threads of the process are preempted by the threads of any process running in a higher priority class. An example is a screen saver. The idle-priority class is inherited by child processes.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NORMAL_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process with no special scheduling needs.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_MODE_BACKGROUND_BEGIN</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Begin background processing mode. The system lowers the resource scheduling priorities of the process (and its threads) so that it can perform background work without significantly affecting activity in the foreground.</para>
            <para>This value can be specified only if <i>hProcess</i> is a handle to the current process. The function fails if the process is already in background processing mode.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_MODE_BACKGROUND_END</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>End background processing mode. The system restores the resource scheduling priorities of the process (and its threads) as they were before the process entered background processing mode.</para>
            <para>This value can be specified only if <i>hProcess</i> is a handle to the current process. The function fails if the process is not in background processing mode.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>REALTIME_PRIORITY_CLASS</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>Process that has the highest possible priority. The threads of the process preempt the threads of all other processes, including operating system processes performing important tasks. For example, a real-time process that executes for more than a very brief interval can cause disk caches not to flush or cause the mouse to be unresponsive.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Every thread has a base priority level determined by the thread's priority value and the priority class of its process. The system uses the base priority level of all executable threads to determine which thread gets the next slice of CPU time. The
<see cref="SetThreadPriority" /> function enables setting the base priority level of a thread relative to the priority class of its process. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>.</para>
      <para>The <b>*_PRIORITY_CLASS</b> values affect the CPU scheduling priority of the process. For processes that perform background work such as file I/O, network I/O, or data processing, it is not sufficient to adjust the CPU scheduling priority; even an idle CPU priority process can easily interfere with system responsiveness when it uses the disk and memory. Processes that perform background work should use the <b>PROCESS_MODE_BACKGROUND_BEGIN</b> and <b>PROCESS_MODE_BACKGROUND_END</b> values to adjust their resource scheduling priorities; processes that interact with the user should not use <b>PROCESS_MODE_BACKGROUND_BEGIN</b>.</para>
      <para>If a process is in background processing mode, the new threads it creates will also be in background processing mode. When a thread is in background processing mode, it should minimize sharing resources such as critical sections, heaps, and handles with other threads in the process, otherwise priority inversions can occur. If there are threads executing at high priority, a thread in background processing mode may not be scheduled promptly, but it will never be starved.</para>
      <para>Each  thread can enter background processing mode independently using <see cref="SetThreadPriority" />. Do not call <b>SetPriorityClass</b> to enter background processing mode after a thread in the process has called <b>SetThreadPriority</b> to enter background processing mode. After a process ends background processing mode, it resets all threads in the process; however, it is not possible for the process to know which threads were already in background processing mode.</para>
      <h4>Examples</h4>
      <para>The following example demonstrates the use of process background mode.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;

int main( void )
{
   DWORD dwError, dwPriClass;

   if(!SetPriorityClass(GetCurrentProcess(), PROCESS_MODE_BACKGROUND_BEGIN))
   {
      dwError = GetLastError();
      if( ERROR_PROCESS_MODE_ALREADY_BACKGROUND == dwError)
         _tprintf(TEXT("Already in background mode\n"));
      else _tprintf(TEXT("Failed to enter background mode (%d)\n"), dwError);
      goto Cleanup;
   }

   // Display priority class

   dwPriClass = GetPriorityClass(GetCurrentProcess());

   _tprintf(TEXT("Current priority class is 0x%x\n"), dwPriClass);

   //
   // Perform background work
   //
   ;

   if(!SetPriorityClass(GetCurrentProcess(), PROCESS_MODE_BACKGROUND_END))
   {
      _tprintf(TEXT("Failed to end background mode (%d)\n"), GetLastError());
   }

Cleanup:
   // Clean up
   ;
return 0;
}

</code>
    </remarks>
    <seealso cref="CreateProcess" />
    <seealso cref="CreateThread" />
    <seealso cref="GetPriorityClass" />
    <seealso cref="GetThreadPriority" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</seealso>
    <seealso cref="SetThreadPriority" />
  </member>
  <member name="Windows.SetProcessAffinityUpdateMode">
    <summary>
      <para>Sets the affinity update mode of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must be returned by the <see cref="GetCurrentProcess" /> function.</para>
    </param>
    <param name="dwFlags">
      <para>The affinity update mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Disables dynamic update of the process affinity by the system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_AFFINITY_ENABLE_AUTO_UPDATE</b>
                </description>
              </item>
              <item>
                <description>0x00000001UL</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables dynamic update of the process affinity by the system.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The system can adjust process affinity under various conditions, such as when a processor is added dynamically. By default, dynamic updates to the process affinity are disabled for each process.</para>
      <para>Processes should use this function to indicate whether they can handle dynamic adjustment of process affinity by the system. After a process enables affinity update mode, it can call this function to disable it. However, a process cannot enable affinity update mode after it has used this function to disable it.</para>
      <para>Child processes do not inherit the affinity update mode of the parent process. The affinity update mode must be explicitly set for each child process.</para>
      <para>To compile an application that calls this function, define _WIN32_WINNT as 0x0600 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="QueryProcessAffinityUpdateMode" />
  </member>
  <member name="Windows.SetProcessDefaultCpuSetMasks">
    <summary>
      <para>Sets the default CPU Sets assignment for threads in the specified process.</para>
    </summary>
    <param name="Process">
      <para>Specifies the process for which to set the default CPU Sets. This handle must have the <a href="https://docs.microsoft.com//windows/win32/procthread/process-security-and-access-rights">PROCESS_SET_LIMITED_INFORMATION</a> access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</para>
    </param>
    <param name="CpuSetMasks">
      <para>Specifies an optional buffer of <see cref="GROUP_AFFINITY" /> structures representing the CPU Sets to set as the process default CPU set. If this is NULL, the <b>SetProcessDefaultCpuSetMasks</b> function clears out any assignment.</para>
    </param>
    <param name="CpuSetMaskCount">
      <para>Specifies the size of the <i>CpuSetMasks</i> array, in elements. If the buffer is NULL, this value must be zero.</para>
    </param>
    <returns>
      <para>This function cannot fail when passed valid parameters.</para>
    </returns>
    <remarks>
      <para>Threads belonging to this process which don’t have CPU Sets explicitly set using <see cref="SetThreadSelectedCpuSetMasks" /> or <see cref="SetThreadSelectedCpuSets" />, will inherit the sets specified by <b>SetProcessDefaultCpuSetMasks</b> automatically.</para>
      <para>This function is analogous to <see cref="SetProcessDefaultCpuSets" />, except that it uses group affinities as opposed to CPU Set IDs to represent a list of CPU sets. This means that the resulting process default CPU Set assignment is the set of all CPU sets with a home processor in the provided list of group affinities.</para>
    </remarks>
  </member>
  <member name="Windows.SetProcessDefaultCpuSets">
    <summary>
      <para>Sets the default CPU Sets assignment for threads in the specified process. Threads that are created, which don’t have CPU Sets explicitly set using , will inherit the sets specified by <b>SetProcessDefaultCpuSets</b> automatically.</para>
    </summary>
    <param name="Process">
      <para>Specifies the process for which to set the default CPU Sets. This handle must have the PROCESS_SET_LIMITED_INFORMATION access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</para>
    </param>
    <param name="CpuSetIds">
      <para>Specifies the list of CPU Set IDs to set as the process default CPU set. If this is NULL, the <b>SetProcessDefaultCpuSets</b> clears out any assignment.</para>
    </param>
    <param name="CpuSetIdCount">
      <para>Specifies the number of IDs in the list passed in the <b>CpuSetIds</b> argument. If that value is NULL, this should be 0.</para>
    </param>
    <returns>
      <para>This function cannot fail when passed valid parameters</para>
    </returns>
  </member>
  <member name="Windows.SetProcessDynamicEHContinuationTargets">
    <summary>
      <para>Sets dynamic exception handling continuation targets for the specified process.</para>
    </summary>
    <param name="Process">
      <para>A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right.
For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="NumberOfTargets">
      <para>Supplies the number of dynamic exception handling continuation targets to set.</para>
    </param>
    <param name="Targets">
      <para>A pointer to an array of dynamic exception handling continuation targets. For more information on this structure, see <see cref="PROCESS_DYNAMIC_EH_CONTINUATION_TARGET" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.
Note that even if the function fails, a portion of the supplied continuation targets may have been successfully processed.
The caller needs to check the flags in each individual continuation target specified via <i>Targets</i> to determine if it was successfully processed.</para>
    </returns>
    <remarks>
      <para>If user-mode Hardware-enforced Stack Protection is enabled for a process, when calling APIs that modify the execution context of a thread such as
<see cref="RtlRestoreContext" /> and
<see cref="SetThreadContext" />,
validation is performed on the Instruction Pointer specified in the new execution context.
<i>RtlRestoreContext</i> is used during <a href="https://docs.microsoft.com//windows/win32/debug/about-structured-exception-handling">Structured Exception Handling</a> (SEH)
exception unwinding to unwind to the target frame that contains the <code>__except</code> block and to start executing code at the continuation target.
Therefore, the operating system needs to know the instruction addresses of all the valid continuation targets in order to allow the unwind operation via <i>RtlRestoreContext</i>.
For compiled binaries, the list of continuation targets is generated by the linker and stored in the binary image.
For dynamic code, the continuation targets need to be specified using <i>SetProcessDynamicEHContinuationTargets</i>.</para>
    </remarks>
  </member>
  <member name="Windows.SetProcessDynamicEnforcedCetCompatibleRanges">
    <summary>
      <blockquote>
        <para>[!NOTE]
This API was added to the 19041 SDK in an update released in November 2020.</para>
      </blockquote>
      <para>Sets dynamic enforced CETCOMPAT ranges for the specified process.</para>
    </summary>
    <param name="Process">
      <para>A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right.
For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="NumberOfRanges">
      <para>Supplies the number of dynamic enforced CETCOMPAT ranges to set.</para>
    </param>
    <param name="Ranges">
      <para>A pointer to an array of dynamic enforced CETCOMPAT ranges. For more information on this structure, see <see cref="PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.
Note that even if the function fails, a portion of the supplied CETCOMPAT ranges may have been successfully processed.
The caller needs to check the flags in each individual CETCOMPAT range specified via <i>Ranges</i> to determine if it was successfully processed.</para>
    </returns>
    <remarks>
      <para>User-mode Hardware-enforced Stack Protection (HSP) is a security feature where the CPU verifies function return addresses at runtime by employing a shadow stack mechanism, if supported by the hardware.
In HSP compatibility mode, only shadow stack violations occurring in modules that are considered compatible with shadow stacks (CETCOMPAT) are fatal.
For a module to be considered CETCOMPAT, it needs to be either compiled with <a href="https://docs.microsoft.com//cpp/build/reference/cetcompat">CETCOMPAT</a> for binaries, or marked using <i>SetProcessDynamicEnforcedCetCompatibleRanges</i> for dynamic code.
In HSP strict mode, all shadow stack violations are fatal.</para>
    </remarks>
  </member>
  <member name="Windows.SetProcessInformation">
    <summary>
      <para>Sets information for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access
right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="ProcessInformationClass">
      <para>A member of the <see cref="PROCESS_INFORMATION_CLASS" /> enumeration specifying the kind of information to set.</para>
    </param>
    <param name="ProcessInformation">
      <para>Pointer to an object that contains the type of information specified by the
<i>ProcessInformationClass</i> parameter.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessMemoryPriority</b>, this parameter must point to a
<see cref="MEMORY_PRIORITY_INFORMATION" /> structure.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessPowerThrottling</b>, this parameter must point to a
<see cref="PROCESS_POWER_THROTTLING_STATE" /> structure.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessLeapSecondInfo</b>, this parameter must point to a
<see cref="PROCESS_LEAP_SECOND_INFO" /> structure.</para>
    </param>
    <param name="ProcessInformationSize">
      <para>The size in bytes of the structure specified by the <i>ProcessInformation</i> parameter.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessMemoryPriority</b>, this parameter must be
<code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessPowerThrottling</b>, this parameter must be
<code>sizeof(PROCESS_POWER_THROTTLING_STATE)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is
<b>ProcessLeapSecondInfo</b>, this parameter must be
<code>sizeof(PROCESS_LEAP_SECOND_INFO)</code>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To help improve system performance, applications should use the
<b>SetProcessInformation</b> function with
<b>ProcessMemoryPriority</b> to lower the default memory priority of threads that perform
background operations or access files and data that are not expected to be accessed again soon. For example, a
file indexing application might set a lower default priority for the process that performs the indexing task.</para>
      <para>
        <b>Memory priority</b> helps to determine how long pages remain in the
<a href="https://docs.microsoft.com//windows/desktop/Memory/working-set">working set</a> of a process before they are trimmed. A process's
memory priority determines the default priority of the physical pages that are added to the process working set by
the threads of that process. When the memory manager trims the working set, it trims lower priority pages before
higher priority pages. This improves overall system performance because higher priority pages are less likely to
be trimmed from the working set and then trigger a page fault when they are accessed again.</para>
      <para>
        <b>ProcessPowerThrottling</b> enables throttling policies on a process, which can be used to balance out performance and power efficiency in cases where optimal performance is not required.</para>
      <para>When a process opts into enabling <code>PROCESS_POWER_THROTTLING_EXECUTION_SPEED</code>, the process will be classified as EcoQoS. The system will try to increase power efficiency through strategies such as reducing CPU frequency or using more power efficient cores. EcoQoS should be used when the work is not contributing to the foreground user experience, which provides longer battery life, and reduced heat and fan noise. EcoQoS should not be used for performance critical or foreground user experiences. (Prior to Windows 11, the EcoQoS level did not exist and the process was labeled as LowQoS). If an application does not explicitly enable <code>PROCESS_POWER_THROTTLING_EXECUTION_SPEED</code>, the system will use its own heuristics to automatically infer a Quality of Service level. For more information, see <a href="https://docs.microsoft.com//windows/win32/procthread/quality-of-service">Quality of Service</a>.</para>
      <para>When a process opts into enabling <code>PROCESS_POWER_THROTTLING_IGNORE_TIMER_RESOLUTION</code>, any current timer resolution requests made by the process will be ignored. Timers belonging to the process are no longer guaranteed to expire with higher timer resolution, which can improve power efficiency. After explicitly disabling <code>PROCESS_POWER_THROTTLING_IGNORE_TIMER_RESOLUTION</code>, the system remembers and honors any previous timer resolution request by the process. By default in Windows 11 if a window owning process becomes fully occluded, minimized, or otherwise non-visible to the end user, and non-audible, Windows may automatically ignore the timer resolution request and thus does not guarantee a higher resolution than the default system resolution.</para>
      <h4>Examples</h4>
      <para>The following example shows how to call
<b>SetProcessInformation</b> with
<b>ProcessMemoryPriority</b> to set low memory priority as the default for the calling
process.</para>
      <code>    DWORD ErrorCode;
    BOOL Success;
    MEMORY_PRIORITY_INFORMATION MemPrio;

    //
    // Set low memory priority on the current process.
    //

    ZeroMemory(&amp;amp;amp;amp;amp;amp;amp;MemPrio, sizeof(MemPrio));
    MemPrio.MemoryPriority = MEMORY_PRIORITY_LOW;

    Success = SetProcessInformation(GetCurrentProcess(),
                                   ProcessMemoryPriority,
                                   &amp;amp;amp;amp;amp;amp;amp;MemPrio,
                                   sizeof(MemPrio));

    if (!Success) {
        ErrorCode = GetLastError();
        fprintf(stderr, "Set process memory priority failed: %d\n", ErrorCode);
        goto cleanup;
    }
</code>
      <para>The following example shows how to call
<b>SetProcessInformation</b> with
<b>ProcessPowerThrottling</b> to control the Quality of Service of a process.</para>
      <code>PROCESS_POWER_THROTTLING_STATE PowerThrottling;
RtlZeroMemory(&amp;amp;amp;amp;amp;amp;amp;PowerThrottling, sizeof(PowerThrottling));
PowerThrottling.Version = PROCESS_POWER_THROTTLING_CURRENT_VERSION;

//
// EcoQoS
// Turn EXECUTION_SPEED throttling on.
// ControlMask selects the mechanism and StateMask declares which mechanism should be on or off.
//

PowerThrottling.ControlMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
PowerThrottling.StateMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;

SetProcessInformation(GetCurrentProcess(),
                      ProcessPowerThrottling,
                      &amp;amp;amp;amp;amp;amp;amp;PowerThrottling,
                      sizeof(PowerThrottling));

//
// HighQoS
// Turn EXECUTION_SPEED throttling off.
// ControlMask selects the mechanism and StateMask is set to zero as mechanisms should be turned off.
//

PowerThrottling.ControlMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
PowerThrottling.StateMask = 0;

SetProcessInformation(GetCurrentProcess(),
                      ProcessPowerThrottling,
                      &amp;amp;amp;amp;amp;amp;amp;PowerThrottling,
                      sizeof(PowerThrottling));

</code>
      <para>The following example shows how to call
<b>SetProcessInformation</b> with
<b>ProcessPowerThrottling</b> to control the Timer Resolution of a process.</para>
      <code>PROCESS_POWER_THROTTLING_STATE PowerThrottling;
RtlZeroMemory(&amp;amp;amp;amp;amp;amp;amp;PowerThrottling, sizeof(PowerThrottling));
PowerThrottling.Version = PROCESS_POWER_THROTTLING_CURRENT_VERSION;

//
// Ignore Timer Resolution Requests.
// Turn IGNORE_TIMER_RESOLUTION throttling on.
// ControlMask selects the mechanism and StateMask declares which mechanism should be on or off.
//

PowerThrottling.ControlMask = PROCESS_POWER_THROTTLING_IGNORE_TIMER_RESOLUTION;
PowerThrottling.StateMask = PROCESS_POWER_THROTTLING_IGNORE_TIMER_RESOLUTION;

SetProcessInformation(GetCurrentProcess(),
                      ProcessPowerThrottling,
                      &amp;amp;amp;amp;amp;amp;amp;PowerThrottling,
                      sizeof(PowerThrottling));

//
// Always honor Timer Resolution Requests.
// Turn IGNORE_TIMER_RESOLUTION throttling off.
// ControlMask selects the mechanism and StateMask is set to zero as mechanisms should be turned off.
//

PowerThrottling.ControlMask = PROCESS_POWER_THROTTLING_IGNORE_TIMER_RESOLUTION;
PowerThrottling.StateMask = 0;

SetProcessInformation(GetCurrentProcess(),
                      ProcessPowerThrottling,
                      &amp;amp;amp;amp;amp;amp;amp;PowerThrottling,
                      sizeof(PowerThrottling));

</code>
      <para>The following example shows how to call
<b>SetProcessInformation</b> with
<b>ProcessPowerThrottling</b> to reset to the default system managed behavior.</para>
      <code>PROCESS_POWER_THROTTLING_STATE PowerThrottling;
RtlZeroMemory(&amp;amp;amp;amp;amp;amp;amp;PowerThrottling, sizeof(PowerThrottling));
PowerThrottling.Version = PROCESS_POWER_THROTTLING_CURRENT_VERSION;

//
// Let system manage all power throttling. ControlMask is set to 0 as we don’t want
// to control any mechanisms.
//

PowerThrottling.ControlMask = 0;
PowerThrottling.StateMask = 0;

SetProcessInformation(GetCurrentProcess(),
                      ProcessPowerThrottling,
                      &amp;amp;amp;amp;amp;amp;amp;PowerThrottling,
                      sizeof(PowerThrottling));

</code>
    </remarks>
    <seealso cref="GetProcessInformation" />
    <seealso cref="MEMORY_PRIORITY_INFORMATION" />
    <seealso href="https://docs.microsoft.com//previous-versions/mt767996(v=vs.85)">PROCESS_INFORMATION_CLASS</seealso>
    <seealso cref="SetThreadInformation" />
  </member>
  <member name="Windows.SetProcessMitigationPolicy">
    <summary>
      <para>Sets a mitigation policy for the calling process. Mitigation policies enable a process to harden itself against various types of attacks.</para>
    </summary>
    <param name="MitigationPolicy">
      <para>The mitigation policy to apply. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ProcessDEPPolicy</b>
          </description>
          <description>
            <para>The data execution prevention (DEP) policy of the process.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_DEP_POLICY" /> structure that specifies the DEP policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessASLRPolicy</b>
          </description>
          <description>
            <para>The Address Space Layout Randomization (ASLR) policy of the process.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_ASLR_POLICY" /> structure that specifies the ASLR policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessDynamicCodePolicy</b>
          </description>
          <description>
            <para>The dynamic code policy of the process. When turned on, the process cannot generate dynamic code or modify existing executable code.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_DYNAMIC_CODE_POLICY" /> structure that specifies the dynamic code policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessStrictHandleCheckPolicy</b>
          </description>
          <description>
            <para>The process will receive a fatal error if it manipulates a handle that is not valid.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY" /> structure that specifies the handle check policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessSystemCallDisablePolicy</b>
          </description>
          <description>
            <para>Disables the ability to use NTUser/GDI functions at the lowest layer.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY" /> structure that specifies the system call disable policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessMitigationOptionsMask</b>
          </description>
          <description>
            <para>Returns the mask of valid bits for all the mitigation options on the system.  An application can set many mitigation options without querying the operating system for mitigation options by combining bitwise with the mask to exclude all non-supported bits at once.</para>
            <para>The <i>lpBuffer</i> parameter points to a <b>ULONG64</b> bit vector for the mask, or to accommodate more than 64 bits, a two-element array of <b>ULONG64</b> bit vectors.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessExtensionPointDisablePolicy</b>
          </description>
          <description>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY" /> structure that specifies the extension point disable policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessControlFlowGuardPolicy</b>
          </description>
          <description>
            <para>The Control Flow Guard (CFG) policy of the process.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY" /> structure that specifies the CFG policy flags.</para>
            <para>
              <b>Note</b>  This value is not currently supported.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessSignaturePolicy</b>
          </description>
          <description>
            <para>The policy of a process that can restrict image loading to those images that are either signed by Microsoft, by the Windows Store, or by Microsoft, the Windows Store and the Windows Hardware Quality Labs (WHQL).</para>
            <para>he <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY" /> structure that specifies the signature policy flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessFontDisablePolicy</b>
          </description>
          <description>
            <para>The policy regarding font loading for the process. When turned on, the process cannot load non-system fonts.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_FONT_DISABLE_POLICY" /> structure that specifies the policy flags for font loading.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessImageLoadPolicy</b>
          </description>
          <description>
            <para>The policy regarding image loading for the process, which determines the types of executable images that are allowed to be mapped into the process. When turned on, images cannot be loaded from some locations, such a remote devices or files that have the low mandatory label.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_IMAGE_LOAD_POLICY" /> structure that specifies the policy flags for image loading.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ProcessUserShadowStackPolicy</b>
          </description>
          <description>
            <para>Windows 10, version 2004 and above: The policy regarding user-mode Hardware-enforced Stack Protection for the process.</para>
            <para>The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY" /> structure that specifies the policy flags for user-mode Hardware-enforced Stack Protection.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessDEPPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_DEP_POLICY" /> structure that specifies the DEP policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessASLRPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_ASLR_POLICY" /> structure that specifies the ASLR policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_IMAGE_LOAD_POLICY" /> structure that receives the policy flags for image loading.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessStrictHandleCheckPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY" /> structure that specifies the handle check policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSystemCallDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY" /> structure that specifies the system call disable policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessMitigationOptionsMask</b>, this parameter points to a <b>ULONG64</b> bit vector for the mask, or to accommodate more than 64 bits, a two-element array of <b>ULONG64</b> bit vectors.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessExtensionPointDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY" /> structure that specifies the extension point disable policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessControlFlowGuardPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY" /> structure that specifies the CFG policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSignaturePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY" /> structure that specifies the signature policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessFontDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_FONT_DISABLE_POLICY" /> structure that specifies the policy flags for font loading.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_IMAGE_LOAD_POLICY" /> structure that specifies the policy flags for image loading.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessUserShadowStackPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY" /> structure that specifies the policy flags for user-mode Hardware-enforced Stack Protection.</para>
    </param>
    <param name="dwLength">
      <para>The size of <i>lpBuffer</i>, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Setting mitigation policy for a process helps prevent an attacker from exploiting security vulnerabilities. Use the <b>SetProcessMitigationPolicy</b> function to enable or disable security mitigation programmatically.</para>
      <para>For maximum effectiveness, mitigation policies should be applied before or during process initialization. For example, setting the ASLR policy that enables forced relocation of images is effective only if it is applied before all of the images in a process have been loaded.</para>
      <para>ASLR mitigation policies cannot be made less restrictive after they have been applied.</para>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0602. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.SetProcessPriorityBoost">
    <summary>
      <para>Disables or enables the ability of the system to temporarily boost the priority of the threads of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must have the PROCESS_SET_INFORMATION access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="bDisablePriorityBoost">
      <para>If this parameter is TRUE, dynamic boosting is disabled. If the parameter is FALSE, dynamic boosting is enabled.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a thread is running in one of the dynamic priority classes, the system temporarily boosts the thread's priority when it is taken out of a wait state. If
<b>SetProcessPriorityBoost</b> is called with the <i>DisablePriorityBoost</i> parameter set to TRUE, its threads' priorities are not boosted. This setting affects all existing threads and any threads subsequently created by the process. To restore normal behavior, call
<b>SetProcessPriorityBoost</b> with <i>DisablePriorityBoost</i> set to FALSE.</para>
    </remarks>
    <seealso cref="GetProcessPriorityBoost" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/priority-boosts">Priority Boosts</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</seealso>
  </member>
  <member name="Windows.SetProcessShutdownParameters">
    <summary>
      <para>Sets shutdown parameters for the currently calling process. This function sets a shutdown order for a process relative to the other processes in the system.</para>
    </summary>
    <param name="dwLevel">
      <para>The shutdown priority for a process relative to other processes in the system. The system shuts down processes from high <i>dwLevel</i> values to low. The highest and lowest shutdown priorities are reserved for system components. This parameter must be in the following range of values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>000-0FF</para>
          </description>
          <description>
            <para>System reserved last shutdown range.</para>
          </description>
        </item>
        <item>
          <description>
            <para>100-1FF</para>
          </description>
          <description>
            <para>Application reserved last shutdown range.</para>
          </description>
        </item>
        <item>
          <description>
            <para>200-2FF</para>
          </description>
          <description>
            <para>Application reserved "in between" shutdown range.</para>
          </description>
        </item>
        <item>
          <description>
            <para>300-3FF</para>
          </description>
          <description>
            <para>Application reserved first shutdown range.</para>
          </description>
        </item>
        <item>
          <description>
            <para>400-4FF</para>
          </description>
          <description>
            <para>System reserved first shutdown range.</para>
          </description>
        </item>
      </list>
      <para>All processes start at shutdown level 0x280.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SHUTDOWN_NORETRY</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system terminates the process without displaying a retry dialog box for the user.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function is succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications running in the system security context do not get shut down by the operating system. They get notified of shutdown or logoff through the callback function installable via
<a href="https://docs.microsoft.com//windows/console/setconsolectrlhandler">SetConsoleCtrlHandler</a>. They also get notified in the order specified by the <i>dwLevel</i> parameter.</para>
    </remarks>
    <seealso cref="GetProcessShutdownParameters" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//windows/console/setconsolectrlhandler">SetConsoleCtrlHandler</seealso>
  </member>
  <member name="Windows.SetProtectedPolicy">
    <summary>
      <para>Sets a protected policy. This function is for use primarily by Windows, and not designed for external use.</para>
    </summary>
    <param name="PolicyGuid">
      <para>The globally-unique identifier of the policy to set.</para>
    </param>
    <param name="PolicyValue">
      <para>The value to set the policy to.</para>
    </param>
    <param name="OldPolicyValue">
      <para>Optionally receives the original value that was associated with the supplied policy.</para>
    </param>
    <returns>
      <para>True if the function succeeds; otherwise, false. To retrieve error values for this function, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Protected policies are process-wide configuration settings that are stored in read-only memory. This is intended to help protect the policy from being corrupted or altered in an unintended way while an application is executing. Protected policies are primarily a construct internal to Windows.</para>
      <para>To compile an application that calls this function, define _WIN32_WINNT as 0x0603 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers.</a></para>
      <para>This function became available in update 3 (the November 2014 update) for Windows 8.1 and  Windows Server 2012 R2.</para>
    </remarks>
  </member>
  <member name="Windows.SetThreadContext">
    <summary>
      <para>Sets the context for the specified thread.</para>
      <para>A 64-bit application can set the context of a WOW64 thread using the
<see cref="Wow64SetThreadContext" /> function.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread whose context is to be set. The handle must have the
<b>THREAD_SET_CONTEXT</b> access right to the thread. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="lpContext">
      <para>A pointer to a <see cref="CONTEXT" /> structure that contains the
context to be set in the specified thread. The value of the <b>ContextFlags</b> member of
this structure specifies which portions of a thread's context to set. Some values in the
<b>CONTEXT</b> structure that cannot be specified are silently
set to the correct value. This includes bits in the CPU status register that specify the privileged processor
mode, global enabling bits in the debugging register, and other states that must be controlled by the operating
system.</para>
    </param>
    <returns>
      <para>If the context was set, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The function sets the thread context based on the value of the <b>ContextFlags</b> member
of the context structure. The thread identified by the <i>hThread</i> parameter is typically
being debugged, but the function can also operate even when the thread is not being debugged.</para>
      <para>Do not try to set the context for a running thread; the results are unpredictable. Use the
<see cref="SuspendThread" /> function to suspend the thread before
calling <b>SetThreadContext</b>.</para>
    </remarks>
    <seealso cref="CONTEXT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/debugging-functions">Debugging Functions</seealso>
    <seealso cref="GetThreadContext" />
    <seealso cref="GetXStateFeaturesMask" />
    <seealso cref="SetXStateFeaturesMask" />
    <seealso cref="SuspendThread" />
  </member>
  <member name="Windows.SetThreadDescription">
    <summary>
      <para>Assigns a description to a thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle for the thread for which you want to set the description. The handle must have THREAD_SET_LIMITED_INFORMATION access.</para>
    </param>
    <param name="lpThreadDescription">
      <para>A Unicode string that specifies the description of the thread.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the <b>HRESULT</b> that denotes a successful operation.
If the function fails, the return value is an <b>HRESULT</b> that denotes the error.</para>
    </returns>
    <remarks>
      <para>The description of a thread can be set more than once; the most recently set value is used. You can retrieve the description of a thread by calling <see cref="GetThreadDescription" />.</para>
      <para>
        <b>Windows Server 2016</b>, <b>Windows 10 LTSB 2016</b> and <b>Windows 10 version 1607</b>: SetThreadDescription is only available by <a href="https://docs.microsoft.com//windows/win32/dlls/using-run-time-dynamic-linking">Run Time Dynamic Linking</a> in KernelBase.dll.</para>
      <h4>Examples</h4>
      <para>The following example sets the description for the current thread to <code>simulation_thread</code>.</para>
      <code>HRESULT hr = SetThreadDescription(GetCurrentThread(), L"simulation_thread");
if (FAILED(hr))
{
    // Call failed.
}
</code>
    </remarks>
    <seealso cref="GetThreadDescription" />
    <seealso href="https://docs.microsoft.com//visualstudio/debugger/how-to-set-a-thread-name-in-native-code">How to: Set a Thread Name in Native Code</seealso>
  </member>
  <member name="Windows.SetThreadIdealProcessor">
    <summary>
      <para>Sets a preferred processor for a thread. The system schedules threads on their preferred processors whenever possible.</para>
      <para>On a system with more than 64 processors, this function sets the preferred processor to a logical processor in the <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a> to which the calling thread is assigned. Use the <see cref="SetThreadIdealProcessorEx" /> function to specify a processor group and preferred processor.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread whose preferred processor is to be set. The handle must have the THREAD_SET_INFORMATION access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="dwIdealProcessor">
      <para>The number of the preferred processor for the thread. This value is zero-based. If this parameter is MAXIMUM_PROCESSORS, the function returns the current ideal processor without changing it.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the previous preferred processor.</para>
      <para>If the function fails, the return value is (DWORD) – 1. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>You can use the <see cref="GetSystemInfo" /> function to determine the number of processors on the computer. You can also use the
<see cref="GetProcessAffinityMask" /> function to check the processors on which the thread is allowed to run. Note that
<b>GetProcessAffinityMask</b> returns a bitmask whereas
<b>SetThreadIdealProcessor</b> uses an integer value to represent the processor.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>
        <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.</para>
    </remarks>
    <seealso cref="GetProcessAffinityMask" />
    <seealso cref="GetSystemInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-processors">Multiple Processors</seealso>
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="SetThreadAffinityMask" />
    <seealso cref="SetThreadIdealProcessorEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.SetThreadIdealProcessorEx">
    <summary>
      <para>Sets the ideal processor for the specified thread and optionally retrieves the previous ideal processor.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread for which to set the ideal processor. This handle must have been created with the THREAD_SET_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="lpIdealProcessor">
      <para>A pointer to a <see cref="PROCESSOR_NUMBER" /> structure that specifies the processor number of the desired ideal processor.</para>
    </param>
    <param name="lpPreviousIdealProcessor">
      <para>A pointer to a <see cref="PROCESSOR_NUMBER" /> structure to receive the previous ideal processor. This parameter can point to the same memory location as the <i>lpIdealProcessor</i> parameter. This parameter can be NULL if the previous ideal processor is not required.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, it returns zero. To get extended error information, use <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Specifying a thread ideal processor provides a hint to the scheduler about the preferred processor for a thread. The scheduler runs the thread on the thread's ideal processor when possible.</para>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0601. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>
        <b>Windows Phone 8.1:</b> This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later.</para>
      <para>
        <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.</para>
    </remarks>
    <seealso cref="GetThreadIdealProcessorEx" />
    <seealso cref="SetThreadIdealProcessor" />
  </member>
  <member name="Windows.SetThreadInformation">
    <summary>
      <para>Sets information for the specified thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread. The handle must have THREAD_SET_INFORMATION access right. For more information, see  <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="ThreadInformationClass">
      <para>The class of information to set. The only supported values are <b>ThreadMemoryPriority</b> and <b>ThreadPowerThrottling</b>.</para>
    </param>
    <param name="ThreadInformation">
      <para>Pointer to a structure that contains the type of information specified by the <i>ThreadInformationClass</i> parameter.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must point to a <b>MEMORY_PRIORITY_INFORMATION</b> structure.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadPowerThrottling</b>, this parameter must point to a <b>THREAD_POWER_THROTTLING_STATE</b> structure.</para>
    </param>
    <param name="ThreadInformationSize">
      <para>The size in bytes of the structure specified by the <i>ThreadInformation</i> parameter.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must be <code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadPowerThrottling</b>, this parameter must be <code>sizeof(THREAD_POWER_THROTTLING_STATE)</code>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To help improve system performance, applications should use the <b>SetThreadInformation</b> function with <b>ThreadMemoryPriority</b> to lower the memory priority of threads that perform background operations or access files and data that are not expected to be accessed again soon. For example, an anti-malware application might lower the priority of threads involved in scanning files.</para>
      <para>
        <b>Memory priority</b> helps to determine how long pages remain in the <a href="https://docs.microsoft.com//windows/desktop/Memory/working-set">working set</a> of a process before they are trimmed. A thread's memory priority determines the minimum priority of the physical pages that are added to the process working set by that thread. When the memory manager trims the working set, it trims lower priority pages before higher priority pages. This improves overall system performance because higher priority pages are less likely to be trimmed from the working set and then trigger a page fault when they are accessed again.</para>
      <para>
        <b>ThreadPowerThrottling</b> enables throttling policies on a thread, which can be used to balance out performance and power efficiency in cases where optimal performance is not required. When a thread opts into enabling <code>THREAD_POWER_THROTTLING_EXECUTION_SPEED</code>, the thread will be classified as EcoQoS. The system will try to increase power efficiency through strategies such as reducing CPU frequency or using more power efficient cores. EcoQoS should be used when the work is not contributing to the foreground user experience, which provides longer battery life, and reduced heat and fan noise. EcoQoS should not be used for performance critical or foreground user experiences. (Prior to Windows 11, the EcoQoS level did not exist and the process was instead labeled as LowQoS). If an application does not explicitly enable <code>THREAD_POWER_THROTTLING_EXECUTION_SPEED</code>, the system will use its own heuristics to automatically infer a Quality of Service level. For more information, see <a href="https://docs.microsoft.com//windows/win32/procthread/quality-of-service">Quality of Service</a>.</para>
      <h4>Examples</h4>
      <para>The following example shows how to call <b>SetThreadInformation</b> with <b>ThreadMemoryPriority</b> to set low memory priority on the current thread.</para>
      <code>DWORD ErrorCode;
    BOOL Success;
    MEMORY_PRIORITY_INFORMATION MemPrio;

    //
    // Set low memory priority on the current thread.
    //

    ZeroMemory(&amp;amp;amp;amp;amp;amp;amp;MemPrio, sizeof(MemPrio));
    MemPrio.MemoryPriority = MEMORY_PRIORITY_LOW;

    Success = SetThreadInformation(GetCurrentThread(),
                                   ThreadMemoryPriority,
                                   &amp;amp;amp;amp;amp;amp;amp;MemPrio,
                                   sizeof(MemPrio));

    if (!Success) {
        ErrorCode = GetLastError();
        fprintf(stderr, "Set thread memory priority failed: %d\n", ErrorCode);
        goto cleanup;
    }
</code>
      <para>The following example shows how to call <b>SetThreadInformation</b> with <b>ThreadPowerThrottling</b> to control the Quality of Service of a thread.</para>
      <code>THREAD_POWER_THROTTLING_STATE PowerThrottling;
RtlZeroMemory(&amp;amp;amp;amp;amp;amp;amp;PowerThrottling, sizeof(PowerThrottling));
PowerThrottling.Version = THREAD_POWER_THROTTLING_CURRENT_VERSION;

//
// EcoQoS
// Turn EXECUTION_SPEED throttling on.
// ControlMask selects the mechanism and StateMask declares which mechanism should be on or off.
//

PowerThrottling.ControlMask = THREAD_POWER_THROTTLING_EXECUTION_SPEED;
PowerThrottling.StateMask = THREAD_POWER_THROTTLING_EXECUTION_SPEED;

SetThreadInformation(GetCurrentThread(),
                     ThreadPowerThrottling,
                     &amp;amp;amp;amp;amp;amp;amp;PowerThrottling,
                     sizeof(PowerThrottling));

//
// HighQoS
// Turn EXECUTION_SPEED throttling off.
// ControlMask selects the mechanism and StateMask is set to zero as mechanisms should be turned off.
//

PowerThrottling.ControlMask = THREAD_POWER_THROTTLING_EXECUTION_SPEED;
PowerThrottling.StateMask = 0;

SetThreadInformation(GetCurrentThread(),
                     ThreadPowerThrottling,
                     &amp;amp;amp;amp;amp;amp;amp;PowerThrottling,
                     sizeof(PowerThrottling));

//
// Let system manage all power throttling. ControlMask is set to 0 as we don’t want
// to control any mechanisms.
//

PowerThrottling.ControlMask = 0;
PowerThrottling.StateMask = 0;

SetThreadInformation(GetCurrentThread(),
                     ThreadPowerThrottling,
                     &amp;amp;amp;amp;amp;amp;amp;PowerThrottling,
                     sizeof(PowerThrottling));

</code>
    </remarks>
    <seealso cref="GetThreadInformation" />
    <seealso cref="SetProcessInformation" />
  </member>
  <member name="Windows.SetThreadPriority">
    <summary>
      <para>Sets the priority value for the specified thread. This value, together with the priority class of the thread's process, determines the thread's base priority level.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread whose priority value is to be set.</para>
      <para>The handle must have the <b>THREAD_SET_INFORMATION</b> or <b>THREAD_SET_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.<b>Windows Server 2003:  </b>The handle must have the <b>THREAD_SET_INFORMATION</b> access right.</para>
    </param>
    <param name="nPriority">
      <para>The priority value for the thread. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Priority</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_MODE_BACKGROUND_BEGIN</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Begin background processing mode. The system lowers the resource scheduling priorities of the thread so that it can perform background work without significantly affecting activity in the foreground.</para>
            <para>This value can be specified only if <i>hThread</i> is a handle to the current thread.  The function fails if the thread is already in background processing mode.</para>
            <para>
              <b>Windows Server 2003:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_MODE_BACKGROUND_END</b>
                </description>
              </item>
              <item>
                <description>0x00020000</description>
              </item>
            </list>
          </description>
          <description>
            <para>End background processing mode. The system restores the resource scheduling priorities of the thread as they were before the thread entered background processing mode.</para>
            <para>This value can be specified only if <i>hThread</i> is a handle to the current thread. The function fails if the thread is not in background processing mode.</para>
            <para>
              <b>Windows Server 2003:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_ABOVE_NORMAL</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Priority 1 point above the priority class.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_BELOW_NORMAL</b>
                </description>
              </item>
              <item>
                <description>-1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Priority 1 point below the priority class.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_HIGHEST</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Priority 2 points above the priority class.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_IDLE</b>
                </description>
              </item>
              <item>
                <description>-15</description>
              </item>
            </list>
          </description>
          <description>
            <para>Base priority of 1 for <b>IDLE_PRIORITY_CLASS</b>, <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or <b>HIGH_PRIORITY_CLASS</b> processes, and a base priority of 16 for <b>REALTIME_PRIORITY_CLASS</b> processes.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_LOWEST</b>
                </description>
              </item>
              <item>
                <description>-2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Priority 2 points below the priority class.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_NORMAL</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Normal priority for the priority class.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>THREAD_PRIORITY_TIME_CRITICAL</b>
                </description>
              </item>
              <item>
                <description>15</description>
              </item>
            </list>
          </description>
          <description>
            <para>Base priority of 15 for <b>IDLE_PRIORITY_CLASS</b>, <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or <b>HIGH_PRIORITY_CLASS</b> processes, and a base priority of 31 for <b>REALTIME_PRIORITY_CLASS</b> processes.</para>
          </description>
        </item>
      </list>
      <para>If the thread has the <b>REALTIME_PRIORITY_CLASS</b> base class, this parameter can also be -7, -6, -5, -4, -3, 3, 4, 5, or 6. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>
        <b>Windows Phone 8.1:  </b>Windows Phone Store apps may call this function but it has no effect. The function will return a nonzero value indicating success.</para>
    </returns>
    <remarks>
      <para>Every thread has a base priority level determined by the thread's priority value and the priority class of its process. The system uses the base priority level of all executable threads to determine which thread gets the next slice of CPU time. Threads are scheduled in a round-robin fashion at each priority level, and only when there are no executable threads at a higher level does scheduling of threads at a lower level take place.</para>
      <para>The
<b>SetThreadPriority</b> function enables setting the base priority level of a thread relative to the priority class of its process. For example, specifying <b>THREAD_PRIORITY_HIGHEST</b> in a call to
<b>SetThreadPriority</b> for a thread of an <b>IDLE_PRIORITY_CLASS</b> process sets the thread's base priority level to 6. For a table that shows the base priority levels for each combination of priority class and thread priority value, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>.</para>
      <para>For <b>IDLE_PRIORITY_CLASS</b>, <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, and <b>HIGH_PRIORITY_CLASS</b> processes, the system dynamically boosts a thread's base priority level when events occur that are important to the thread. <b>REALTIME_PRIORITY_CLASS</b> processes do not receive dynamic boosts.</para>
      <para>All threads initially start at <b>THREAD_PRIORITY_NORMAL</b>. Use the
<see cref="GetPriorityClass" /> and
<see cref="SetPriorityClass" /> functions to get and set the priority class of a process. Use the
<see cref="GetThreadPriority" /> function to get the priority value of a thread.</para>
      <para>Use the priority class of a process to differentiate between applications that are time critical and those that have normal or below normal scheduling requirements. Use thread priority values to differentiate the relative priorities of the tasks of a process. For example, a thread that handles input for a window could have a higher priority level than a thread that performs intensive calculations for the CPU.</para>
      <para>When manipulating priorities, be very careful to ensure that a high-priority thread does not consume all of the available CPU time. A thread with a base priority level above 11 interferes with the normal operation of the operating system. Using <b>REALTIME_PRIORITY_CLASS</b> may cause disk caches to not flush, cause the mouse to stop responding, and so on.</para>
      <para>The <b>THREAD_PRIORITY_*</b> values affect the CPU scheduling priority of the thread. For threads that perform background work such as file I/O, network I/O, or data processing, it is not sufficient to adjust the CPU scheduling priority; even an idle CPU priority thread can easily interfere with system responsiveness when it uses the disk and memory. Threads that perform background work should use the <b>THREAD_MODE_BACKGROUND_BEGIN</b> and <b>THREAD_MODE_BACKGROUND_END</b> values to adjust their resource scheduling priorities; threads that interact with the user should not use <b>THREAD_MODE_BACKGROUND_BEGIN</b>.</para>
      <para>When a thread is in background processing mode, it should minimize sharing resources such as critical sections, heaps, and handles with other threads in the process, otherwise priority inversions can occur. If there are threads executing at high priority, a thread in background processing mode may not be scheduled promptly, but it will never be starved.</para>
      <para>
        <b>Windows Server 2008 and Windows Vista:  </b>While the system is starting, the <b>SetThreadPriority</b> function returns a success return value but does not change thread priority  for applications that are started from the system Startup folder or listed in the <b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows</b>\<b>CurrentVersion</b>\<b>Run</b> registry key. These applications run at reduced priority for a short time (approximately 60 seconds) to make the system more responsive to user actions during startup.</para>
      <para>
        <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps.</para>
      <para>
        <b>Windows Phone 8.1:</b>Windows Phone Store apps may call this function but it has no effect.</para>
      <h4>Examples</h4>
      <para>The following example demonstrates the use of thread background mode.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;

int main( void )
{
   DWORD dwError, dwThreadPri;

   if(!SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_BEGIN))
   {
      dwError = GetLastError();
      if( ERROR_THREAD_MODE_ALREADY_BACKGROUND == dwError)
         _tprintf(TEXT("Already in background mode\n"));
      else _tprintf(TEXT("Failed to enter background mode (%d)\n"), dwError);
      goto Cleanup;
   }

   // Display thread priority

   dwThreadPri = GetThreadPriority(GetCurrentThread());

   _tprintf(TEXT("Current thread priority is 0x%x\n"), dwThreadPri);

   //
   // Perform background work
   //
   ;

   if(!SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_END))
   {
      _tprintf(TEXT("Failed to end background mode (%d)\n"), GetLastError());
   }

Cleanup:
   // Clean up
   ;
return 0;
}

</code>
    </remarks>
    <seealso cref="GetPriorityClass" />
    <seealso cref="GetThreadPriority" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</seealso>
    <seealso cref="SetPriorityClass" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.SetThreadPriorityBoost">
    <summary>
      <para>Disables or enables the ability of the system to temporarily boost the priority of a thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread whose priority is to be boosted. The handle must have the <b>THREAD_SET_INFORMATION</b> or <b>THREAD_SET_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_SET_INFORMATION</b> access right.</para>
    </param>
    <param name="bDisablePriorityBoost">
      <para>If this parameter is <b>TRUE</b>, dynamic boosting is disabled. If the parameter is <b>FALSE</b>, dynamic boosting is enabled.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a thread is running in one of the dynamic priority classes, the system temporarily boosts the thread's priority when it is taken out of a wait state. If
<b>SetThreadPriorityBoost</b> is called with the <i>DisablePriorityBoost</i> parameter set to <b>TRUE</b>, the thread's priority is not boosted. To restore normal behavior, call
<b>SetThreadPriorityBoost</b> with <i>DisablePriorityBoost</i> set to <b>FALSE</b>.</para>
    </remarks>
    <seealso cref="GetThreadPriorityBoost" />
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/priority-boosts">Priority Boosts</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.SetThreadSelectedCpuSetMasks">
    <summary>
      <para>Sets the selected CPU Sets assignment for the specified thread. This assignment overrides the process default assignment, if one is set.</para>
    </summary>
    <param name="Thread">
      <para>Specifies the thread on which to set the CPU Set assignment. <a href="https://docs.microsoft.com//windows/win32/procthread/process-security-and-access-rights">PROCESS_SET_LIMITED_INFORMATION</a> access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</para>
    </param>
    <param name="CpuSetMasks">
      <para>Specifies an optional buffer of <see cref="GROUP_AFFINITY" /> structures representing the CPU Sets to set as the thread selected CPU set. If this is NULL, the <b>SetThreadSelectedCpuSetMasks</b> function clears out any assignment, reverting to process default assignment if one is set.</para>
    </param>
    <param name="CpuSetMaskCount">
      <para>Specifies the number of <b>GROUP_AFFINITY</b> structures in the list passed in the GroupCpuSets argument. If the buffer is NULL, this value must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero and extended error information can be retrieved by calling <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is analogous to <see cref="SetThreadSelectedCpuSets" />, except that it uses group affinities as opposed to CPU Set IDs to represent a list of CPU sets. This means that the resulting thread selected CPU Set assignment is the set of all CPU sets with a home processor in the provided list of group affinities.</para>
    </remarks>
  </member>
  <member name="Windows.SetThreadSelectedCpuSets">
    <summary>
      <para>Sets the selected CPU Sets assignment for the specified thread. This assignment overrides the process default assignment, if one is set.</para>
    </summary>
    <param name="Thread">
      <para>Specifies the thread on which to set the CPU Set assignment. This handle must have the THREAD_SET_LIMITED_INFORMATION access right. The value returned by <see cref="GetCurrentThread" /> can also be used.</para>
    </param>
    <param name="CpuSetIds">
      <para>Specifies the list of CPU Set IDs to set as the thread selected CPU set. If this is NULL, the API clears out any assignment, reverting to process default assignment if one is set.</para>
    </param>
    <param name="CpuSetIdCount">
      <para>Specifies the number of IDs in the list passed in the <b>CpuSetIds</b> argument. If that value is NULL, this should be 0.</para>
    </param>
    <returns>
      <para>This function cannot fail when passed valid parameters.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadStackGuarantee">
    <summary>
      <para>Sets the minimum size of the stack associated with the calling thread or fiber that will be available during any stack overflow exceptions. This is useful for handling stack overflow exceptions; the application can safely use the specified number of bytes during exception handling.</para>
    </summary>
    <param name="StackSizeInBytes">
      <para>The size of the stack, in bytes. On return, this value is set to the size of the previous stack, in bytes.</para>
      <para>If this parameter is 0 (zero), the function succeeds and the parameter contains the size of the current stack.</para>
      <para>If the specified size is less than the current size, the function succeeds but ignores this request. Therefore, you cannot use this function to reduce the size of the stack.</para>
      <para>This value cannot be larger than the reserved stack size.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the function is successful, the application can handle possible EXCEPTION_STACK_OVERFLOW exceptions using <a href="https://docs.microsoft.com//windows/desktop/Debug/structured-exception-handling">structured exception handling</a>. To resume execution after handling a stack overflow, you must perform certain recovery steps. If you are using the Microsoft C/C++ compiler, call the <b>_resetstkoflw</b> function. If you are using another compiler, see the documentation for the compiler for information on recovering from stack overflows.</para>
      <para>To set the stack guarantee for a fiber, you must first call the <see cref="SwitchToFiber" /> function to execute the fiber. After you set the guarantee for this fiber, it is used by the fiber no matter which thread executes the fiber.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.SetThreadToken">
    <summary>
      <para>The <b>SetThreadToken</b> function assigns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> to a thread. The function can also cause a thread to stop using an impersonation token.</para>
    </summary>
    <param name="Thread">
      <para>A pointer to a handle to the thread to which the function assigns the impersonation token.</para>
      <para>If <i>Thread</i> is <b>NULL</b>, the function assigns the impersonation token to the calling thread.</para>
    </param>
    <param name="Token">
      <para>A handle to the impersonation token to assign to the thread. This handle must have been opened with TOKEN_IMPERSONATE access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
      <para>If <i>Token</i> is <b>NULL</b>, the function causes the thread to stop using an impersonation token.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When using the <b>SetThreadToken</b> function to impersonate, you must have the impersonate  privileges and make sure that the <b>SetThreadToken</b> function succeeds before calling the <see cref="RevertToSelf" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="OpenThreadToken" />
  </member>
  <member name="Windows.SuspendThread">
    <summary>
      <para>Suspends the specified thread.</para>
      <para>A 64-bit application can suspend a WOW64 thread using the <see cref="Wow64SuspendThread" /> function.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread that is to be suspended.</para>
      <para>The handle must have the <b>THREAD_SUSPEND_RESUME</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is <code>(DWORD) -1</code>. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>If the function succeeds, execution of the specified thread is suspended and the thread's suspend count is incremented. Suspending a thread causes the thread to stop executing user-mode (application) code.</para>
      <para>This function is primarily designed for use by debuggers. It is not intended to be used for thread synchronization. Calling
<b>SuspendThread</b> on a thread that owns a synchronization object, such as a mutex or critical section, can lead to a deadlock if the calling thread tries to obtain a synchronization object owned by a suspended thread. To avoid this situation, a thread within an application that is not a debugger should signal the other thread to suspend itself. The target thread must be designed to watch for this signal and respond appropriately.</para>
      <para>Each thread has a suspend count (with a maximum value of <b>MAXIMUM_SUSPEND_COUNT</b>). If the suspend count is greater than zero, the thread is suspended; otherwise, the thread is not suspended and is eligible for execution. Calling
<b>SuspendThread</b> causes the target thread's suspend count to be incremented. Attempting to increment past the maximum suspend count causes an error without incrementing the count.</para>
      <para>The
<see cref="ResumeThread" /> function decrements the suspend count of a suspended thread.</para>
      <para>
        <b>Windows Phone 8.1:</b> This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later.</para>
      <para>
        <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.</para>
    </remarks>
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="ResumeThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/suspending-thread-execution">Suspending Thread Execution</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.SwitchToThread">
    <summary>
      <para>Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the next thread to be executed.</para>
    </summary>
    <returns>
      <para>If calling the
<b>SwitchToThread</b> function caused the operating system to switch execution to another thread, the return value is nonzero.</para>
      <para>If there are no other threads ready to execute, the operating system does not switch execution to another thread, and the return value is zero.</para>
    </returns>
    <remarks>
      <para>The yield of execution is in effect for up to one thread-scheduling time slice on the processor of the calling thread. The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</para>
      <para>After the yielding thread's time slice elapses, the operating system reschedules execution for the yielding thread. The rescheduling is determined by the priority of the yielding thread and the status of other threads that are available to run.</para>
      <para>Note that the operating system will not switch to a thread that is being prevented from running only by concurrency control. For example, an I/O completion port or thread pool limits the number of associated threads that can run. If the maximum number of threads is already running, no additional associated thread can run until a running thread finishes.   If a thread uses <b>SwitchToThread</b> to wait for one of the additional associated threads to accomplish some work, the process might deadlock.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="SuspendThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/suspending-thread-execution">Suspending Thread Execution</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.TerminateProcess">
    <summary>
      <para>Terminates the specified process and all of its threads.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process to be terminated.</para>
      <para>The handle must have the <b>PROCESS_TERMINATE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="uExitCode">
      <para>The exit code to be used by the process and threads terminated as a result of this call. Use the
<see cref="GetExitCodeProcess" /> function to retrieve a process's exit value. Use the
<see cref="GetExitCodeThread" /> function to retrieve a thread's exit value.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>TerminateProcess</b> function is used to unconditionally cause a process to exit. The state of global data maintained by dynamic-link libraries (DLLs) may be compromised if
<b>TerminateProcess</b> is used rather than
<see cref="ExitProcess" />.</para>
      <para>This function stops execution of all threads within the process and requests cancellation of all pending I/O. The terminated process cannot exit until all pending I/O has been completed or canceled. When a process terminates, its kernel object is not destroyed until all processes that have open handles to the process have released those handles.</para>
      <para>When a process terminates itself, <b>TerminateProcess</b> stops execution of the calling thread and does not return.
Otherwise, <b>TerminateProcess</b> is asynchronous; it initiates termination and returns immediately. If you need to be
sure the process has terminated, call the
<see cref="WaitForSingleObject" /> function with a handle
to the process.</para>
      <para>A process cannot prevent itself from being terminated.</para>
      <para>After a process has terminated, call to <b>TerminateProcess</b> with open handles to the process fails with <b>ERROR_ACCESS_DENIED</b> (5) error code.</para>
    </remarks>
    <seealso cref="ExitProcess" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="GetExitCodeThread" />
    <seealso cref="OpenProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</seealso>
  </member>
  <member name="Windows.TerminateThread">
    <summary>
      <para>Terminates a thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread to be terminated.</para>
      <para>The handle must have the <b>THREAD_TERMINATE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="dwExitCode">
      <para>The exit code for the thread. Use the
<see cref="GetExitCodeThread" /> function to retrieve a thread's exit value.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>TerminateThread</b> is used to cause a thread to exit. When this occurs, the target thread has no chance to execute any user-mode code. DLLs attached to the thread are not notified that the thread is terminating. The system frees the thread's initial stack.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The target thread's initial stack is not freed, causing a resource leak.</para>
      <para>
        <b>TerminateThread</b> is a dangerous function that should only be used in the most extreme cases. You should call
<b>TerminateThread</b> only if you know exactly what the target thread is doing, and you control all of the code that the target thread could possibly be running at the time of the termination. For example,
<b>TerminateThread</b> can result in the following problems:</para>
      <list type="bullet">
        <item>
          <description>If the target thread owns a critical section, the critical section will not be released.</description>
        </item>
        <item>
          <description>If the target thread is allocating memory from the heap, the heap lock will not be released.</description>
        </item>
        <item>
          <description>If the target thread is executing certain kernel32 calls when it is terminated, the kernel32 state for the thread's process could be inconsistent.</description>
        </item>
        <item>
          <description>If the target thread is manipulating the global state of a shared DLL, the state of the DLL could be destroyed, affecting other users of the DLL.</description>
        </item>
      </list>
      <para>A thread cannot protect itself against
<b>TerminateThread</b>, other than by controlling access to its handles. The thread handle returned by the
<see cref="CreateThread" /> and
<see cref="CreateProcess" /> functions has <b>THREAD_TERMINATE</b> access, so any caller holding one of these handles can terminate your thread.</para>
      <para>If the target thread is the last thread of a process when this function is called, the thread's process is also terminated.</para>
      <para>The state of the thread object becomes signaled, releasing any other threads that had been waiting for the thread to terminate. The thread's termination status changes from <b>STILL_ACTIVE</b> to the value of the <i>dwExitCode</i> parameter.</para>
      <para>Terminating a thread does not necessarily remove the thread object from the system. A thread object is deleted when the last thread handle is closed.</para>
    </remarks>
    <seealso cref="CreateProcess" />
    <seealso cref="CreateThread" />
    <seealso cref="ExitThread" />
    <seealso cref="GetExitCodeThread" />
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-thread">Terminating a Thread</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.TlsAlloc">
    <summary>
      <para>Allocates a thread local storage (TLS) index. Any thread of the process can subsequently use this index to store and retrieve values that are local to the thread, because each thread receives its own slot for the index.</para>
    </summary>
    <returns>
      <para>If the function succeeds, the return value is a TLS index. The slots for the index are initialized to zero.</para>
      <para>If the function fails, the return value is <b>TLS_OUT_OF_INDEXES</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows Phone 8.1:</b> This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. When a Windows Phone Store app calls this function, it is replaced with an inline call to <b>FlsAlloc</b>. Refer to <see cref="FlsAlloc" /> for function documentation.</para>
      <para>
        <b>Windows 8.1</b>,  <b>Windows Server 2012 R2</b>, and <b>Windows 10, version 1507</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and Windows 10, version 1507. When a Windows Store app calls this function, it is replaced with an inline call to <b>FlsAlloc</b>. Refer to <see cref="FlsAlloc" /> for function documentation.</para>
      <para>
        <b>Windows 10, version 1511</b> and <b>Windows 10, version 1607</b>: This function is fully supported for Universal Windows Platform (UWP) apps, and is no longer replaced with an inline call to <b>FlsAlloc</b>.</para>
      <para>The threads of the process can use the TLS index in subsequent calls to the
<see cref="TlsFree" />,
<see cref="TlsSetValue" />, or
<see cref="TlsGetValue" /> functions. The value of the TLS index should be treated as an opaque value; do not assume that it is an index into a zero-based array.</para>
      <para>TLS indexes are typically allocated during process or dynamic-link library (DLL) initialization. When a TLS index is allocated, its storage slots are initialized to <b>NULL</b>. After a TLS index has been allocated, each thread of the process can use it to access its own TLS storage slot. To store a value in its TLS slot, a thread specifies the index in a call to
<see cref="TlsSetValue" />. The thread specifies the same index in a subsequent call to
<see cref="TlsGetValue" />, to retrieve the stored value.</para>
      <para>TLS indexes are not valid across process boundaries. A DLL cannot assume that an index assigned in one process is valid in another process.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-thread-local-storage">Using Thread Local Storage</a> or
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic-Link Library</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-local-storage">Thread Local Storage</seealso>
    <seealso cref="TlsFree" />
    <seealso cref="TlsGetValue" />
    <seealso cref="TlsSetValue" />
  </member>
  <member name="Windows.TlsFree">
    <summary>
      <para>Releases a thread local storage (TLS) index, making it available for reuse.</para>
    </summary>
    <param name="dwTlsIndex">
      <para>The TLS index that was allocated by the
<see cref="TlsAlloc" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows Phone 8.1:</b> This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. When a Windows Phone Store app calls this function, it is replaced with an inline call to <b>FlsFree</b>. Refer to <see cref="FlsFree" /> for function documentation.</para>
      <para>
        <b>Windows 8.1</b>, <b>Windows Server 2012 R2</b>, and <b>Windows 10, version 1507</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and Windows 10, version 1507. When a Windows Store app calls this function, it is replaced with an inline call to <b>FlsFree</b>. Refer to <see cref="FlsFree" /> for function documentation.</para>
      <para>
        <b>Windows 10, version 1511</b> and <b>Windows 10, version 1607</b>: This function is fully supported for Universal Windows Platform (UWP) apps, and is no longer replaced with an inline call to <b>FlsFree</b>.</para>
      <para>If the threads of the process have allocated memory and stored a pointer to the memory in a TLS slot, they should free the memory before calling
<b>TlsFree</b>. The
<b>TlsFree</b> function does not free memory blocks whose addresses have been stored in the TLS slots associated with the TLS index. It is expected that DLLs call this function (if at all) only during <b>DLL_PROCESS_DETACH</b>.</para>
      <para>For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-local-storage">Thread Local Storage</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-thread-local-storage">Using Thread Local Storage</a> or
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic-Link Library</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/processes-and-threads">Processes and Threads Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-local-storage">Thread Local Storage</seealso>
    <seealso cref="TlsAlloc" />
    <seealso cref="TlsGetValue" />
    <seealso cref="TlsSetValue" />
  </member>
  <member name="Windows.TlsGetValue">
    <summary>
      <para>Retrieves the value in the calling thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.</para>
    </summary>
    <param name="dwTlsIndex">
      <para>The TLS index that was allocated by the
<see cref="TlsAlloc" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the value stored in the calling thread's TLS slot associated with the specified index. If <i>dwTlsIndex</i> is a valid index allocated by a successful call to <see cref="TlsAlloc" />, this function always succeeds.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The data stored in a TLS slot can have a value of 0 because it still has its initial value or because the thread called the <see cref="TlsSetValue" /> function with 0. Therefore, if the return value is 0, you must check whether <see cref="GetLastError" /> returns <b>ERROR_SUCCESS</b> before determining that the function has failed. If <b>GetLastError</b> returns <b>ERROR_SUCCESS</b>, then the function has succeeded and the data stored in the TLS slot is 0. Otherwise, the function has failed.</para>
      <para>Functions that return indications of failure call <see cref="SetLastError" /> when they fail. They generally do not call <b>SetLastError</b> when they succeed. The
<b>TlsGetValue</b> function is an exception to this general rule. The
<b>TlsGetValue</b> function calls <b>SetLastError</b> to clear a thread's last error when it succeeds. That allows checking for the error-free retrieval of zero values.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows Phone 8.1:</b> This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. When a Windows Phone Store app calls this function, it is replaced with an inline call to <b>FlsGetValue</b>. Refer to <see cref="FlsGetValue" /> for function documentation.</para>
      <para>
        <b>Windows 8.1</b>, <b>Windows Server 2012 R2</b>, and <b>Windows 10, version 1507</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and Windows 10, version 1507. When a Windows Store app calls this function, it is replaced with an inline call to <b>FlsGetValue</b>. Refer to <see cref="FlsGetValue" /> for function documentation.</para>
      <para>
        <b>Windows 10, version 1511</b> and <b>Windows 10, version 1607</b>: This function is fully supported for Universal Windows Platform (UWP) apps, and is no longer replaced with an inline call to <b>FlsGetValue</b>.</para>
      <para>TLS indexes are typically allocated by the
<see cref="TlsAlloc" /> function during process or DLL initialization. After a TLS index is allocated, each thread of the process can use it to access its own TLS slot for that index. A thread specifies a TLS index in a call to
<see cref="TlsSetValue" /> to store a value in its slot. The thread specifies the same index in a subsequent call to
<b>TlsGetValue</b> to retrieve the stored value.</para>
      <para>
        <b>TlsGetValue</b> was implemented with speed as the primary goal. The function performs minimal parameter validation and error checking. In particular, it succeeds if <i>dwTlsIndex</i> is in the range 0 through (<b>TLS_MINIMUM_AVAILABLE</b>– 1). It is up to the programmer to ensure that the index is valid and that the thread calls <see cref="TlsSetValue" /> before calling <b>TlsGetValue</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-thread-local-storage">Using Thread Local Storage</a> or
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic-Link Library</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-local-storage">Thread Local Storage</seealso>
    <seealso cref="TlsAlloc" />
    <seealso cref="TlsFree" />
    <seealso cref="TlsSetValue" />
  </member>
  <member name="Windows.TlsSetValue">
    <summary>
      <para>Stores a value in the calling thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.</para>
    </summary>
    <param name="dwTlsIndex">
      <para>The TLS index that was allocated by the <see cref="TlsAlloc" /></para>
      <para>function.</para>
    </param>
    <param name="lpTlsValue">
      <para>The value to be stored in the calling thread's TLS slot for the index.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows Phone 8.1:</b> This function is supported for Windows Phone Store apps on Windows Phone 8.1 and later. When a Windows Phone Store app calls this function, it is replaced with an inline call to <b>FlsSetValue</b>. Refer to <see cref="FlsSetValue" /> for function documentation.</para>
      <para>
        <b>Windows 8.1</b>, <b>Windows Server 2012 R2</b>, and <b>Windows 10, version 1507</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and Windows 10, version 1507. When a Windows Store app calls this function, it is replaced with an inline call to <b>FlsSetValue</b>. Refer to <see cref="FlsSetValue" /> for function documentation.</para>
      <para>
        <b>Windows 10, version 1511</b> and <b>Windows 10, version 1607</b>: This function is fully supported for Universal Windows Platform (UWP) apps, and is no longer replaced with an inline call to <b>FlsSetValue</b>.</para>
      <para>TLS indexes are typically allocated by the
<see cref="TlsAlloc" /> function during process or DLL initialization. When a TLS index is allocated, its storage slots are initialized to NULL. After a TLS index is allocated, each thread of the process can use it to access its own TLS slot for that index. A thread specifies a TLS index in a call to
<b>TlsSetValue</b>, to store a value in its slot. The thread specifies the same index in a subsequent call to
<see cref="TlsGetValue" />, to retrieve the stored value.</para>
      <para>
        <b>TlsSetValue</b> was implemented with speed as the primary goal. The function performs minimal parameter validation and error checking. In particular, it succeeds if <i>dwTlsIndex</i> is in the range 0 through (<b>TLS_MINIMUM_AVAILABLE </b>– 1). It is up to the programmer to ensure that the index is valid before calling <see cref="TlsGetValue" />.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-thread-local-storage">Using Thread Local Storage</a> or
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic-Link Library</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-local-storage">Thread Local Storage</seealso>
    <seealso cref="TlsAlloc" />
    <seealso cref="TlsFree" />
    <seealso cref="TlsGetValue" />
  </member>
</doc>