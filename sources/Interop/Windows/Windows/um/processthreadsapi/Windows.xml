<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.CreateProcess">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the<see cref="CreateProcessAsUser" /> or<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by <i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
      <para>
        <b>Windows 7:  </b>STD_INPUT_HANDLE, STD_OUTPUT_HANDLE, and STD_ERROR_HANDLE are inherited, even when the parameter is FALSE.</para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcessA">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the<see cref="CreateProcessAsUser" /> or<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by <i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
      <para>
        <b>Windows 7:  </b>STD_INPUT_HANDLE, STD_OUTPUT_HANDLE, and STD_ERROR_HANDLE are inherited, even when the parameter is FALSE.</para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcessW">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the<see cref="CreateProcessAsUser" /> or<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by <i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
      <para>
        <b>Windows 7:  </b>STD_INPUT_HANDLE, STD_OUTPUT_HANDLE, and STD_ERROR_HANDLE are inherited, even when the parameter is FALSE.</para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcessAsUser">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the<see cref="LogonUser" /> function. Alternatively, you can call the<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</param>
    <param name="lpThreadAttributes">A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcessAsUserA">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the<see cref="LogonUser" /> function. Alternatively, you can call the<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</param>
    <param name="lpThreadAttributes">A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcessAsUserW">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the<see cref="LogonUser" /> function. Alternatively, you can call the<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</param>
    <param name="lpThreadAttributes">A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcessAsUser">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the<see cref="LogonUser" /> function. Alternatively, you can call the<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</param>
    <param name="lpThreadAttributes">A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcessAsUserA">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the<see cref="LogonUser" /> function. Alternatively, you can call the<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</param>
    <param name="lpThreadAttributes">A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcessAsUserW">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.</para>
      <para>Typically, the process that calls the<b>CreateProcessAsUser</b> function must have the <b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token is not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the <see cref="CreateProcessWithLogonW" /> function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>, <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the<see cref="LogonUser" /> function. Alternatively, you can call the<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>If <i>hToken</i> is a restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not required. If the necessary privileges are not already enabled,<b>CreateProcessAsUser</b> enables them for the duration of the call. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>
        <b>Terminal Services:  </b>The process is run in the session specified in the token. By default, this is the same session that called <see cref="LogonUser" />. To change the session, use the<see cref="SetTokenInformation" /> function.</para>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications created by<b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in<see cref="CreateProcess" />).</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.</param>
    <param name="lpThreadAttributes">A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i> parameter. This security descriptor may not allow access for the caller.</param>
    <param name="bInheritHandles">
      <para>If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process. If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is <b>TRUE</b>, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>If the size of the combined user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no longer runs with the environment block passed to the function by the parent process. Instead, the child process runs with the environment block returned by the <see cref="CreateEnvironmentBlock" /> function.</para>
      <para>To retrieve a copy of the environment block for a given user, use the<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in <a href="https://docs.microsoft.com//windows/desktop/winstation/process-connection-to-a-window-station">Process Connection to a Window Station</a>.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcess">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the<see cref="CreateProcessAsUser" /> or<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by <i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcessA">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the<see cref="CreateProcessAsUser" /> or<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by <i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcessW">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the calling process.</para>
      <para>If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the<see cref="CreateProcessAsUser" /> or<see cref="CreateProcessWithLogonW" /> function.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <list type="number">
        <item>
          <description>
            <b>c:\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program.exe</b>
          </description>
        </item>
        <item>
          <description>
            <b>c:\program files\sub dir\program name.exe</b>
          </description>
        </item>
      </list>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
      <para>To run a batch file, you must start the command interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c plus the name of the batch file.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 32,767 characters, including the Unicode terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters.</para>
      <para>The Unicode version of this function, <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, the null-terminated string pointed to by <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by <i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="lpProcessAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.<b>Windows XP:  </b>The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="lpThreadAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="bInheritHandles">
      <para>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</para>
      <para>
        <b>Terminal Services:  </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</para>
      <para>
        <b>Protected Process Light (PPL) processes:  </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control the priority class and the creation of the process. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process inherits both the error mode of the caller and the parent's console.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the environment of the calling process.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i>\0</para>
      <para>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>.</para>
      <para>The ANSI version of this function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767 characters.</para>
      <para>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>To set extended attributes, use a <see cref="STARTUPINFOEX" /> structure and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  The caller is responsible for ensuring that the standard handle fields in <see cref="STARTUPINFO" /> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b> member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information about the new process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateRemoteThread">
    <summary>
      <para>Creates a thread that runs in the virtual address space of another process.</para>
      <para>Use the <see cref="CreateRemoteThreadEx" /> function to create a thread that runs in the virtual address space of another process and optionally specify extended attributes.</para>
    </summary>
    <param name="hProcess">A handle to the process in which the thread is to be created. The handle must have the <b>PROCESS_CREATE_THREAD</b>, <b>PROCESS_QUERY_INFORMATION</b>, <b>PROCESS_VM_OPERATION</b>, <b>PROCESS_VM_WRITE</b>, and <b>PROCESS_VM_READ</b> access rights, and may fail without these rights on certain platforms. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="lpThreadAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If <i>lpThreadAttributes</i> is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.</para>
      <para>
        <b>Windows XP:  </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.</para>
    </param>
    <param name="dwStackSize">The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</param>
    <param name="lpStartAddress">A pointer to the application-defined function of type <b>LPTHREAD_START_ROUTINE</b> to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. For more information, see<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>.</param>
    <param name="lpParameter">A pointer to a variable to be passed to the thread function.</param>
    <param name="dwCreationFlags">
      <para>The flags that control the creation of the thread.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The thread runs immediately after creation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_SUSPENDED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The thread is created in a suspended state, and does not run until the <see cref="ResumeThread" /> function is called.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>STACK_SIZE_PARAM_IS_A_RESERVATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00010000</term>
              </listheader>
            </list>
          </description>
          <description>The <i>dwStackSize</i> parameter specifies the initial reserve size of the stack. If this flag is not specified, <i>dwStackSize</i> specifies the commit size.</description>
        </listheader>
      </list>
    </param>
    <param name="lpThreadId">
      <para>A pointer to a variable that receives the thread identifier.</para>
      <para>If this parameter is <b>NULL</b>, the thread identifier is not returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the new thread.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that<b>CreateRemoteThread</b> may succeed even if <i>lpStartAddress</i> points to data, code, or is not accessible. If the start address is invalid when the thread runs, an exception occurs, and the thread terminates. Thread termination due to a invalid start address is handled as an error exit for the thread's process. This behavior is similar to the asynchronous nature of<see cref="CreateProcess" />, where the process is created even if it refers to invalid or missing dynamic-link libraries (DLL).</para>
    </returns>
  </member>
  <member name="Windows.CreateRemoteThreadEx">
    <summary>Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.</summary>
    <param name="hProcess">A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights. In Windows 10, version 1607, your code must obtain these access rights for the new handle. However, starting in Windows 10, version 1703, if the new handle is entitled to these access rights, the system obtains them for you. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="lpThreadAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If <i>lpThreadAttributes</i> is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.</param>
    <param name="dwStackSize">The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</param>
    <param name="lpStartAddress">A pointer to the application-defined function of type <b>LPTHREAD_START_ROUTINE</b> to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. For more information, see<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>.</param>
    <param name="lpParameter">A pointer to a variable to be passed to the thread function pointed to by <i>lpStartAddress</i>. This parameter can be NULL.</param>
    <param name="dwCreationFlags">
      <para>The flags that control the creation of the thread.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The thread runs immediately after creation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_SUSPENDED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The thread is created in a suspended state and does not run until the <see cref="ResumeThread" /> function is called.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>STACK_SIZE_PARAM_IS_A_RESERVATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00010000</term>
              </listheader>
            </list>
          </description>
          <description>The <i>dwStackSize</i> parameter specifies the initial reserve size of the stack. If this flag is not specified, <i>dwStackSize</i> specifies the commit size.</description>
        </listheader>
      </list>
    </param>
    <param name="lpAttributeList">An attribute list that contains additional parameters for the new thread. This list is created by the <see cref="InitializeProcThreadAttributeList" /> function.</param>
    <param name="lpThreadId">
      <para>A pointer to a variable that receives the thread identifier.</para>
      <para>If this parameter is NULL, the thread identifier is not returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the new thread.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateThread">
    <summary>
      <para>Creates a thread to execute within the virtual address space of the calling process.</para>
      <para>To create a thread that runs in the virtual address space of another process, use the<see cref="CreateRemoteThread" /> function.</para>
    </summary>
    <param name="lpThreadAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether the returned handle can be inherited by child processes. If<i>lpThreadAttributes</i> is NULL, the handle cannot be inherited.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new thread. If <i>lpThreadAttributes</i> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the primary token of the creator.</para>
    </param>
    <param name="dwStackSize">The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is zero, the new thread uses the default size for the executable. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</param>
    <param name="lpStartAddress">A pointer to the application-defined function to be executed by the thread. This pointer represents the starting address of the thread. For more information on the thread function, see<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>.</param>
    <param name="lpParameter">A pointer to a variable to be passed to the thread.</param>
    <param name="dwCreationFlags">
      <para>The flags that control the creation of the thread.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The thread runs immediately after creation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_SUSPENDED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The thread is created in a suspended state, and does not run until the <see cref="ResumeThread" /> function is called.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>STACK_SIZE_PARAM_IS_A_RESERVATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00010000</term>
              </listheader>
            </list>
          </description>
          <description>The <i>dwStackSize</i> parameter specifies the initial reserve size of the stack. If this flag is not specified, <i>dwStackSize</i> specifies the commit size.</description>
        </listheader>
      </list>
    </param>
    <param name="lpThreadId">A pointer to a variable that receives the thread identifier. If this parameter is<b>NULL</b>, the thread identifier is not returned.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the new thread.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that <b>CreateThread</b> may succeed even if<i>lpStartAddress</i> points to data, code, or is not accessible. If the start address is invalid when the thread runs, an exception occurs, and the thread terminates. Thread termination due to a invalid start address is handled as an error exit for the thread's process. This behavior is similar to the asynchronous nature of <see cref="CreateProcess" />, where the process is created even if it refers to invalid or missing dynamic-link libraries (DLLs).</para>
    </returns>
  </member>
  <member name="Windows.DeleteProcThreadAttributeList">
    <summary>Deletes the specified list of attributes for process and thread creation.</summary>
    <param name="lpAttributeList">The attribute list. This list is created by the <see cref="InitializeProcThreadAttributeList" /> function.</param>
  </member>
  <member name="Windows.ExitProcess">
    <summary>Ends the calling process and all its threads.</summary>
    <param name="uExitCode">The exit code for the process and all threads.</param>
  </member>
  <member name="Windows.ExitThread">
    <summary>Ends the calling thread.</summary>
    <param name="dwExitCode">The exit code for the thread.</param>
  </member>
  <member name="Windows.FlushInstructionCache">
    <summary>Flushes the instruction cache for the specified process.</summary>
    <param name="hProcess">A handle to a process whose instruction cache is to be flushed.</param>
    <param name="lpBaseAddress">A pointer to the base of the region to be flushed. This parameter can be <b>NULL</b>.</param>
    <param name="dwSize">The size of the region to be flushed if the <i>lpBaseAddress</i> parameter is not <b>NULL</b>, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FlushProcessWriteBuffers">
    <summary>Flushes the write queue of each processor that is running a thread of the current process.</summary>
  </member>
  <member name="Windows.GetCurrentProcess">
    <summary>Retrieves a pseudo handle for the current process.</summary>
    <returns>The return value is a pseudo handle to the current process.</returns>
  </member>
  <member name="Windows.GetCurrentProcessId">
    <summary>Retrieves the process identifier of the calling process.</summary>
    <returns>The return value is the process identifier of the calling process.</returns>
  </member>
  <member name="Windows.GetCurrentProcessorNumber">
    <summary>Retrieves the number of the processor the current thread was running on during the call to this function.</summary>
    <returns>The function returns the current processor number.</returns>
  </member>
  <member name="Windows.RtlGetCurrentProcessorNumber">
    <summary>Retrieves the number of the processor the current thread was running on during the call to this function.</summary>
    <returns>The function returns the current processor number.</returns>
  </member>
  <member name="Windows.GetCurrentProcessorNumberEx">
    <summary>Retrieves the processor group and number of the logical processor in which the calling thread is running.</summary>
    <param name="ProcNumber">A pointer to a <see cref="PROCESSOR_NUMBER" /> structure that receives the processor group to which the logical processor is assigned and the number of the logical processor within its group.</param>
  </member>
  <member name="Windows.GetCurrentProcessToken">
    <summary>Retrieves a pseudo-handle that you can use as a shorthand way to refer to the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> associated with a process.</summary>
    <returns>A pseudo-handle that you can use as a shorthand way to refer to the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> associated with a process.</returns>
  </member>
  <member name="Windows.GetCurrentThread">
    <summary>Retrieves a pseudo handle for the calling thread.</summary>
    <returns>The return value is a pseudo handle for the current thread.</returns>
  </member>
  <member name="Windows.GetCurrentThreadEffectiveToken">
    <summary>Retrieves a pseudo-handle that you can use as a shorthand way to refer to the token that is currently in effect for the thread, which is the thread token if one exists and the process token otherwise.</summary>
    <returns>A pseudo-handle that you can use as a shorthand way to refer to the token that is currently in effect for the thread.</returns>
  </member>
  <member name="Windows.GetCurrentThreadId">
    <summary>Retrieves the thread identifier of the calling thread.</summary>
    <returns>The return value is the thread identifier of the calling thread.</returns>
  </member>
  <member name="Windows.GetCurrentThreadStackLimits">
    <summary>Retrieves the boundaries of the stack that was allocated by the system for the current thread.</summary>
    <param name="LowLimit">A pointer variable that receives the lower boundary of the current thread stack.</param>
    <param name="HighLimit">A pointer variable that receives the upper boundary of the current thread stack.</param>
  </member>
  <member name="Windows.GetCurrentThreadToken">
    <summary>Retrieves a pseudo-handle that you can use as a shorthand way to refer to the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that was assigned to the current thread.</summary>
    <returns>A pseudo-handle that you can use as a shorthand way to refer to the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that was assigned to the current thread.</returns>
  </member>
  <member name="Windows.GetExitCodeProcess">
    <summary>Retrieves the termination status of the specified process.</summary>
    <param name="hProcess">
      <para>A handle to the process.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpExitCode">A pointer to a variable to receive the process termination status. For more information, see Remarks.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetExitCodeThread">
    <summary>Retrieves the termination status of the specified thread.</summary>
    <param name="hThread">
      <para>A handle to the thread.</para>
      <para>The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpExitCode">A pointer to a variable to receive the thread termination status. For more information, see Remarks.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetMachineTypeAttributes">
    <summary>Queries if the specified architecture is supported on the current system, either natively or by any form of compatibility or emulation layer.</summary>
    <param name="Machine">An IMAGE_FILE_MACHINE_* value corresponding to the architecture of code to be tested for supportability. See the list of architecture values in <a href="https://docs.microsoft.com//windows/win32/sysinfo/image-file-machine-constants">Image File Machine Constants</a>.</param>
    <param name="MachineTypeAttributes">Output parameter receives a pointer to a value from the <see cref="MACHINE_ATTRIBUTES" /> enumeration indicating if the specified code architecture can run in user mode, kernel mode, and/or under WOW64 on the host operating system.</param>
    <returns>If the function fails, the return value is a nonzero HRESULT value. If the function succeeds, the return value is zero.</returns>
  </member>
  <member name="Windows.GetPriorityClass">
    <summary>Retrieves the priority class for the specified process. This value, together with the priority value of each thread of the process, determines each thread's base priority level.</summary>
    <param name="hProcess">
      <para>A handle to the process.</para>
      <para>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the priority class of the specified process.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The process's priority class is one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ABOVE_NORMAL_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00008000</term>
              </listheader>
            </list>
          </description>
          <description>Process that has priority above <b>NORMAL_PRIORITY_CLASS</b> but below <b>HIGH_PRIORITY_CLASS</b>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>BELOW_NORMAL_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00004000</term>
              </listheader>
            </list>
          </description>
          <description> Process that has priority above <b>IDLE_PRIORITY_CLASS</b> but below <b>NORMAL_PRIORITY_CLASS</b>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>HIGH_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000080</term>
              </listheader>
            </list>
          </description>
          <description>Process that performs time-critical tasks that must be executed immediately for it to run correctly. The threads of a high-priority class process preempt the threads of normal or idle priority class processes. An example is the Task List, which must respond quickly when called by the user, regardless of the load on the operating system. Use extreme care when using the high-priority class, because a high-priority class CPU-bound application can use nearly all available cycles.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IDLE_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description>Process whose threads run only when the system is idle and are preempted by the threads of any process running in a higher priority class. An example is a screen saver. The idle priority class is inherited by child processes.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NORMAL_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>Process with no special scheduling needs.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>REALTIME_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Process that has the highest possible priority. The threads of a real-time priority class process preempt the threads of all other processes, including operating system processes performing important tasks. For example, a real-time process that executes for more than a very brief interval can cause disk caches not to flush or cause the mouse to be unresponsive.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetProcessDefaultCpuSetMasks">
    <summary>Retrieves the list of CPU Sets in the process default set that was set by <see cref="SetProcessDefaultCpuSetMasks" /> or <see cref="SetProcessDefaultCpuSets" />.</summary>
    <param name="Process">Specifies a process handle for the process to query. This handle must have the <a href="https://docs.microsoft.com//windows/win32/procthread/process-security-and-access-rights">PROCESS_QUERY_LIMITED_INFORMATION</a> access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</param>
    <param name="CpuSetMasks">Specifies an optional buffer to retrieve a list of <see cref="GROUP_AFFINITY" /> structures representing the process default CPU Sets.</param>
    <param name="CpuSetMaskCount">Specifies the size of the <i>CpuSetMasks</i> array, in elements.</param>
    <param name="RequiredMaskCount">On successful return, specifies the number of affinity structures written to the array. If the <i>CpuSetMasks</i> array is too small, the function fails with <b>ERROR_INSUFFICIENT_BUFFER</b> and sets the <i>RequiredMaskCount</i> parameter to the number of elements required. The number of required elements is always less than or equal to the maximum group count returned by <see cref="GetMaximumProcessorGroupCount" />.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero and extended error information can be retrieved by calling <see cref="GetLastError" />.</para>
      <para>If the array supplied is too small, the error value is <b>ERROR_INSUFFICIENT_BUFFER</b> and the <i>RequiredMaskCount</i> is set to the number of elements required.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessDefaultCpuSets">
    <summary>Retrieves the list of CPU Sets in the process default set that was set by <see cref="SetProcessDefaultCpuSets" />. If no default CPU Sets are set for a given process, then the <b>RequiredIdCount</b> is set to 0 and the function succeeds.</summary>
    <param name="Process">Specifies a process handle for the process to query. This handle must have the PROCESS_QUERY_LIMITED_INFORMATION access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</param>
    <param name="CpuSetIds">Specifies an optional buffer to retrieve the list of CPU Set identifiers.</param>
    <param name="CpuSetIdCount">Specifies the capacity of the buffer specified in <b>CpuSetIds</b>. If the buffer is NULL, this must be 0.</param>
    <param name="RequiredIdCount">Specifies the required capacity of the buffer to hold the entire list of process default CPU Sets. On successful return, this specifies the number of IDs filled into the buffer.</param>
    <returns>This API returns TRUE on success. If the buffer is not large enough the API returns FALSE, and the <b>GetLastError</b> value is ERROR_INSUFFICIENT_BUFFER. This API cannot fail when passed valid parameters and the return buffer is large enough.</returns>
  </member>
  <member name="Windows.GetProcessHandleCount">
    <summary>Retrieves the number of open handles that belong to the specified process.</summary>
    <param name="hProcess">
      <para>A handle to the process whose handle count is being requested. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the PROCESS_QUERY_INFORMATION access right.</para>
    </param>
    <param name="pdwHandleCount">A pointer to a variable that receives the number of open handles that belong to the specified process.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessId">
    <summary>Retrieves the process identifier of the specified process.</summary>
    <param name="Process">
      <para>A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the PROCESS_QUERY_INFORMATION access right.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the process identifier.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessIdOfThread">
    <summary>Retrieves the process identifier of the process associated with the specified thread.</summary>
    <param name="Thread">
      <para>A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003:  </b>The handle must have the THREAD_QUERY_INFORMATION access right.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the process identifier of the process associated with the specified thread.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessInformation">
    <summary>Retrieves information about the specified process.</summary>
    <param name="hProcess">A handle to the process. This handle must have at least the <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/win32/procthread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="ProcessInformationClass">A member of the <see cref="PROCESS_INFORMATION_CLASS" /> enumeration specifying the kind of information to retrieve.</param>
    <param name="ProcessInformation">
      <para>Pointer to an object to receive the type of information specified by the <i>ProcessInformationClass</i> parameter.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessMemoryPriority</b>, this parameter must point to a <see cref="MEMORY_PRIORITY_INFORMATION structure" />.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessPowerThrottling</b>, this parameter must point to a <see cref="PROCESS_POWER_THROTTLING_STATE structure" />.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessProtectionLevelInfo</b>, this parameter must point to a <see cref="PROCESS_PROTECTION_LEVEL_INFORMATION structure" />.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessLeapSecondInfo</b>, this parameter must point to a <see cref="PROCESS_LEAP_SECOND_INFO structure" />.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessAppMemoryInfo</b>, this parameter must point to a <see cref="APP_MEMORY_INFORMATION structure" />.</para>
    </param>
    <param name="ProcessInformationSize">
      <para>The size in bytes of the structure specified by the <i>ProcessInformation</i> parameter.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessMemoryPriority</b>, this parameter must be <code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessPowerThrottling</b>, this parameter must be <code>sizeof(PROCESS_POWER_THROTTLING_STATE)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessProtectionLevelInfo</b>, this parameter must be <code>sizeof(PROCESS_PROTECTION_LEVEL_INFORMATION)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessLeapSecondInfo</b>, this parameter must be <code>sizeof(PROCESS_LEAP_SECOND_INFO)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is <b>ProcessAppMemoryInfo</b>, this parameter must be <code>sizeof(APP_MEMORY_INFORMATION)</code>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError function" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessMitigationPolicy">
    <summary>Retrieves mitigation policy settings for the calling process.</summary>
    <param name="hProcess">A handle to the process. This handle must have the PROCESS_QUERY_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="MitigationPolicy">
      <para>The mitigation policy to retrieve. This parameter can be one of the following values.</para>
      <para>|Value |Meaning | |---------|---------| |<b>ProcessDEPPolicy</b> | The data execution prevention (DEP) policy of the process.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_DEP_POLICY" /> structure that specifies the DEP policy flags. | | <b>ProcessASLRPolicy</b> | The Address Space Layout Randomization (ASLR) policy of the process.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_ASLR_POLICY" /> structure that specifies the ASLR policy flags. | | <b>ProcessDynamicCodePolicy</b> | The dynamic code policy of the process. When turned on, the process cannot generate dynamic code or modify existing executable code.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_DYNAMIC_CODE_POLICY" /> structure that specifies the dynamic code policy flags. | | <b>ProcessStrictHandleCheckPolicy</b> | The process will receive a fatal error if it manipulates a handle that is not valid.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY" /> structure that specifies the handle check policy flags. | | <b>ProcessSystemCallDisablePolicy</b> | Disables the ability to use NTUser/GDI functions at the lowest layer.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY" /> structure that specifies the system call disable policy flags. | | <b>ProcessMitigationOptionsMask</b> | Returns the mask of valid bits for all the mitigation options on the system. An application can set many mitigation options without querying the operating system for mitigation options by combining bitwise with the mask to exclude all non-supported bits at once.<br />The <i>lpBuffer</i> parameter points to a <b>ULONG64</b> bit vector for the mask, or a two-element array of <b>ULONG64</b> bit vectors. | | <b>ProcessExtensionPointDisablePolicy</b> | Prevents certain built-in third party extension points from being enabled, preventing legacy extension point DLLs from being loaded into the process.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY" /> structure that specifies the extension point disable policy flags. | | <b>ProcessControlFlowGuardPolicy</b> | The Control Flow Guard (CFG) policy of the process.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY" /> structure that specifies the CFG policy flags. | | <b>ProcessSignaturePolicy</b> | The policy of a process that can restrict image loading to those images that are either signed by Microsoft, by the Windows Store, or by Microsoft, the Windows Store and the Windows Hardware Quality Labs (WHQL).<br />he <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY" /> structure that specifies the signature policy flags. | | <b>ProcessFontDisablePolicy</b> | The policy regarding font loading for the process. When turned on, the process cannot load non-system fonts.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_FONT_DISABLE_POLICY" /> structure that specifies the policy flags for font loading. | | <b>ProcessImageLoadPolicy</b> | The policy regarding image loading for the process, which determines the types of executable images that are allowed to be mapped into the process. When turned on, images cannot be loaded from some locations, such a remote devices or files that have the low mandatory label.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_IMAGE_LOAD_POLICY" /> structure that specifies the policy flags for image loading. | | <b>ProcessRedirectionTrustPolicy</b> | The RedirectionGuard policy of a process. The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY" /> structure that specifies the mitigation mode. | | <b>ProcessSideChannelIsolationPolicy</b> | Windows 10, version 1809 and above: The policy regarding isolation of side channels for the specified process.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY" /> structure that specifies the policy flags for side channel isolation. | | <b>ProcessUserShadowStackPolicy</b> | Windows 10, version 2004 and above: The policy regarding user-mode Hardware-enforced Stack Protection for the specified process.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY" /> structure that specifies the policy flags for user-mode Hardware-enforced Stack Protection. |</para>
    </param>
    <param name="lpBuffer">
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessDEPPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_DEP_POLICY" /> structure that receives the DEP policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessASLRPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_ASLR_POLICY" /> structure that receives the ASLR policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessDynamicCodePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_DYNAMIC_CODE_POLICY" /> structure that receives the dynamic code policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessStrictHandleCheckPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY" /> structure that specifies the handle check policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSystemCallDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY" /> structure that specifies the system call disable policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessMitigationOptionsMask</b>, this parameter points to a <b>ULONG64</b> bit vector for the mask or a two-element array of <b>ULONG64</b> bit vectors.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessExtensionPointDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY" /> structure that specifies the extension point disable policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessControlFlowGuardPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY" /> structure that specifies the CFG policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSignaturePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY" /> structure that receives the signature policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessFontDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_FONT_DISABLE_POLICY" /> structure that receives the policy flags for font loading.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_IMAGE_LOAD_POLICY" /> structure that receives the policy flags for image loading.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessRedirectionTrustPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY structure" /> that specifies the mitigation mode.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessUserShadowStackPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY" /> structure that receives the policy flags for user-mode Hardware-enforced Stack Protection.</para>
    </param>
    <param name="dwLength">The size of <i>lpBuffer</i>, in bytes.</param>
    <returns>If the function succeeds, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.GetProcessPriorityBoost">
    <summary>Retrieves the priority boost control state of the specified process.</summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="pDisablePriorityBoost">A pointer to a variable that receives the priority boost control state. A value of TRUE indicates that dynamic boosting is disabled. A value of FALSE indicates normal behavior.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero. In that case, the variable pointed to by the <i>pDisablePriorityBoost</i> parameter receives the priority boost control state.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessShutdownParameters">
    <summary>Retrieves the shutdown parameters for the currently calling process.</summary>
    <param name="lpdwLevel">
      <para>A pointer to a variable that receives the shutdown priority level. Higher levels shut down first. System level shutdown orders are reserved for system components. Higher numbers shut down first. Following are the level conventions.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>000-0FF</term>
              </listheader>
            </list>
          </description>
          <description>System reserved last shutdown range.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>100-1FF</term>
              </listheader>
            </list>
          </description>
          <description>Application reserved last shutdown range.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>200-2FF</term>
              </listheader>
            </list>
          </description>
          <description>Application reserved "in between" shutdown range.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>300-3FF</term>
              </listheader>
            </list>
          </description>
          <description>Application reserved first shutdown range.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>400-4FF</term>
              </listheader>
            </list>
          </description>
          <description>System reserved first shutdown range.</description>
        </listheader>
      </list> <para>All processes start at shutdown level 0x280.</para></param>
    <param name="lpdwFlags">
      <para>A pointer to a variable that receives the shutdown flags. This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SHUTDOWN_NORETRY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>If this process takes longer than the specified timeout to shut down, do not display a retry dialog box for the user. Instead, just cause the process to directly exit.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessTimes">
    <summary>Retrieves timing information for the specified process.</summary>
    <param name="hProcess">
      <para>A handle to the process whose timing information is sought. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpCreationTime">A pointer to a<see cref="FILETIME" /> structure that receives the creation time of the process.</param>
    <param name="lpExitTime">A pointer to a <see cref="FILETIME" /> structure that receives the exit time of the process. If the process has not exited, the content of this structure is undefined.</param>
    <param name="lpKernelTime">A pointer to a<see cref="FILETIME" /> structure that receives the amount of time that the process has executed in kernel mode. The time that each of the threads of the process has executed in kernel mode is determined, and then all of those times are summed together to obtain this value.</param>
    <param name="lpUserTime">A pointer to a <see cref="FILETIME" /> structure that receives the amount of time that the process has executed in user mode. The time that each of the threads of the process has executed in user mode is determined, and then all of those times are summed together to obtain this value. Note that this value can exceed the amount of real time elapsed (between <i>lpCreationTime</i> and <i>lpExitTime</i>) if the process executes across multiple CPU cores.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessVersion">
    <summary>Retrieves the major and minor version numbers of the system on which the specified process expects to run.</summary>
    <param name="ProcessId">The process identifier of the process of interest. A value of zero specifies the calling process.</param>
    <returns>
      <para>If the function succeeds, the return value is the version of the system on which the process expects to run. The high word of the return value contains the major version number. The low word of the return value contains the minor version number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. The function fails if <i>ProcessId</i> is an invalid value.</para>
    </returns>
  </member>
  <member name="Windows.GetStartupInfo">
    <summary>Retrieves the contents of the<see cref="STARTUPINFO" /> structure that was specified when the calling process was created.</summary>
    <param name="lpStartupInfo">A pointer to a<see cref="STARTUPINFO" /> structure that receives the startup information.</param>
  </member>
  <member name="Windows.GetStartupInfoA">
    <summary>Retrieves the contents of the<see cref="STARTUPINFO" /> structure that was specified when the calling process was created.</summary>
    <param name="lpStartupInfo">A pointer to a<see cref="STARTUPINFO" /> structure that receives the startup information.</param>
  </member>
  <member name="Windows.GetStartupInfoW">
    <summary>Retrieves the contents of the<see cref="STARTUPINFO" /> structure that was specified when the calling process was created.</summary>
    <param name="lpStartupInfo">A pointer to a<see cref="STARTUPINFO" /> structure that receives the startup information.</param>
  </member>
  <member name="Windows.GetSystemCpuSetInformation">
    <summary>Allows an application to query the available CPU Sets on the system, and their current state.</summary>
    <param name="Information">A pointer to a <see cref="SYSTEM_CPU_SET_INFORMATION" /> structure that receives the CPU Set data. Pass NULL with a buffer length of 0 to determine the required buffer size.</param>
    <param name="BufferLength">The length, in bytes, of the output buffer passed as the Information argument.</param>
    <param name="ReturnedLength">The length, in bytes, of the valid data in the output buffer if the buffer is large enough, or the required size of the output buffer. If no CPU Sets exist, this value will be 0.</param>
    <param name="Process">An optional handle to a process. This process is used to determine the value of the <b>AllocatedToTargetProcess</b> flag in the SYSTEM_CPU_SET_INFORMATION structure. If a CPU Set is allocated to the specified process, the flag is set. Otherwise, it is clear. This handle must have the PROCESS_QUERY_LIMITED_INFORMATION access right. The value returned by <see cref="GetCurrentProcess" /> may also be specified here.</param>
    <param name="Flags">Reserved, must be 0.</param>
    <returns>If the API succeeds it returns TRUE. If it fails, the error reason is available through <b>GetLastError</b>. If the Information buffer was NULL or not large enough, the error code ERROR_INSUFFICIENT_BUFFER is returned. This API cannot fail when passed valid parameters and a buffer that is large enough to hold all of the return data.</returns>
  </member>
  <member name="Windows.GetSystemTimes">
    <summary>Retrieves system timing information. On a multiprocessor system, the values returned are the sum of the designated times across all processors.</summary>
    <param name="lpIdleTime">A pointer to a <see cref="FILETIME" /> structure that receives the amount of time that the system has been idle.</param>
    <param name="lpKernelTime">A pointer to a <see cref="FILETIME" /> structure that receives the amount of time that the system has spent executing in Kernel mode (including all threads in all processes, on all processors). This time value also includes the amount of time the system has been idle.</param>
    <param name="lpUserTime">A pointer to a <see cref="FILETIME" /> structure that receives the amount of time that the system has spent executing in User mode (including all threads in all processes, on all processors).</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetThreadContext">
    <summary>
      <para>Retrieves the context of the specified thread.</para>
      <para>A 64-bit application can retrieve the context of a WOW64 thread using the <a href="https://github.com/microsoftdocs/sdk-api/blob/docs/sdk-api-src/content/winbase/nf-winbase-wow64getthreadcontext.md">Wow64GetThreadContext</a>.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread whose context is to be retrieved. The handle must have <b>THREAD_GET_CONTEXT</b> access to the thread. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows XP or Windows Server 2003:</b> The handle must also have <b>THREAD_QUERY_INFORMATION</b> access.</para>
    </param>
    <param name="lpContext">A pointer to a <see cref="CONTEXT" /> structure (such as <see cref="ARM64_NT_CONTEXT" />) that receives the appropriate context of the specified thread. The value of the <b>ContextFlags</b> member of this structure specifies which portions of a thread's context are retrieved. The <b>CONTEXT</b> structure is highly processor specific. Refer to the WinNT.h header file for processor-specific definitions of this structures and any alignment requirements.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetThreadDescription">
    <summary>Retrieves the description that was assigned to a thread by calling <see cref="SetThreadDescription" />.</summary>
    <param name="hThread">A handle to the thread for which to retrieve the description. The handle must have THREAD_QUERY_LIMITED_INFORMATION access.</param>
    <param name="ppszThreadDescription">A Unicode string that contains the description of the thread.</param>
    <returns>If the function succeeds, the return value is the <b>HRESULT</b> that denotes a successful operation. If the function fails, the return value is an <b>HRESULT</b> that denotes the error.</returns>
  </member>
  <member name="Windows.GetThreadId">
    <summary>Retrieves the thread identifier of the specified thread.</summary>
    <param name="Thread">
      <para>A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information about access rights, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003:  </b>The handle must have the THREAD_QUERY_INFORMATION access right.</para>
    </param>
    <returns>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.GetThreadIdealProcessorEx">
    <summary>Retrieves the processor number of the ideal processor for the specified thread.</summary>
    <param name="hThread">A handle to the thread for which to retrieve the ideal processor. This handle must have been created with the THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
    <param name="lpIdealProcessor">Points to <see cref="PROCESSOR_NUMBER" /> structure to receive the number of the ideal processor.</param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, it returns zero. To get extended error information, use <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetThreadInformation">
    <summary>Retrieves information about the specified thread.</summary>
    <param name="hThread">A handle to the thread. The handle must have THREAD_QUERY_INFORMATION access rights. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
    <param name="ThreadInformationClass">
      <para>The class of information to retrieve. This value can be <b>ThreadMemoryPriority</b>, <b>ThreadAbsoluteCpuPriority</b> or <b>ThreadDynamicCodePolicy</b>.</para>
      <blockquote>[!NOTE]<b>ThreadDynamicCodePolicy</b> is supported in Windows Server 2016 and newer, Windows 10 LTSB 2016 and newer, and Windows 10 version 1607 and newer.</blockquote>
    </param>
    <param name="ThreadInformation">
      <para>Pointer to a structure to receive the type of information specified by the <i>ThreadInformationClass</i> parameter.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must point to a <b>MEMORY_PRIORITY_INFORMATION</b> structure.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadAbsoluteCpuPriority</b>, this parameter must point to a <b>LONG</b>.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadDynamicCodePolicy</b>, this parameter must point to a <b>DWORD</b>.</para>
    </param>
    <param name="ThreadInformationSize">
      <para>The size in bytes of the structure specified by the <i>ThreadInformation</i> parameter.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must be <code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadAbsoluteCpuPriority</b>, this parameter must be <code>sizeof(LONG)</code>.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadDynamicCodePolicy</b>, this parameter must be <code>sizeof(DWORD)</code>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetThreadIOPendingFlag">
    <summary>Determines whether a specified thread has any I/O requests pending.</summary>
    <param name="hThread">A handle to the thread in question. This handle must have been created with the THREAD_QUERY_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
    <param name="lpIOIsPending">A pointer to a variable which the function sets to TRUE if the specified thread has one or more I/O requests pending, or to FALSE otherwise.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetThreadPriority">
    <summary>Retrieves the priority value for the specified thread. This value, together with the priority class of the thread's process, determines the thread's base-priority level.</summary>
    <param name="hThread">
      <para>A handle to the thread.</para>
      <para>The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the thread's priority level.</para>
      <para>If the function fails, the return value is <b>THREAD_PRIORITY_ERROR_RETURN</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>
        <b>Windows Phone 8.1:  </b>This function will always return <b>THREAD_PRIORITY_NORMAL</b>.</para>
      <para>The thread's priority level is one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_ABOVE_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Priority 1 point above the priority class.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_BELOW_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>-1</term>
              </listheader>
            </list>
          </description>
          <description>Priority 1 point below the priority class.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_HIGHEST</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Priority 2 points above the priority class.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_IDLE</b>
                </term>
              </listheader>
              <listheader>
                <term>-15</term>
              </listheader>
            </list>
          </description>
          <description>Base priority of 1 for <b>IDLE_PRIORITY_CLASS</b>, <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or <b>HIGH_PRIORITY_CLASS</b> processes, and a base priority of 16 for <b>REALTIME_PRIORITY_CLASS</b> processes.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_LOWEST</b>
                </term>
              </listheader>
              <listheader>
                <term>-2</term>
              </listheader>
            </list>
          </description>
          <description>Priority 2 points below the priority class.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Normal priority for the priority class.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_TIME_CRITICAL</b>
                </term>
              </listheader>
              <listheader>
                <term>15</term>
              </listheader>
            </list>
          </description>
          <description>Base-priority level of 15 for <b>IDLE_PRIORITY_CLASS</b>, <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or <b>HIGH_PRIORITY_CLASS</b> processes, and a base-priority level of 31 for <b>REALTIME_PRIORITY_CLASS</b> processes.</description>
        </listheader>
      </list> <para>If the thread has the <b>REALTIME_PRIORITY_CLASS</b> base class, this function can also return one of the following values: -7, -6, -5, -4, -3, 3, 4, 5, or 6. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>.</para></returns>
  </member>
  <member name="Windows.GetThreadPriorityBoost">
    <summary>Retrieves the priority boost control state of the specified thread.</summary>
    <param name="hThread">
      <para>A handle to the thread. The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="pDisablePriorityBoost">A pointer to a variable that receives the priority boost control state. A value of TRUE indicates that dynamic boosting is disabled. A value of FALSE indicates normal behavior.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero. In that case, the variable pointed to by the <i>pDisablePriorityBoost</i> parameter receives the priority boost control state.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetThreadSelectedCpuSetMasks">
    <summary>Returns the explicit CPU Set assignment of the specified thread, if any assignment was set using <see cref="SetThreadSelectedCpuSetMasks" /> or <see cref="SetThreadSelectedCpuSets" />.</summary>
    <param name="Thread">Specifies the thread for which to query the selected CPU Sets. This handle must have the <a href="https://docs.microsoft.com//windows/win32/procthread/process-security-and-access-rights">PROCESS_QUERY_LIMITED_INFORMATION</a> access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</param>
    <param name="CpuSetMasks">Specifies an optional buffer to retrieve a list of <see cref="GROUP_AFFINITY" /> structures representing the thread selected CPU Sets.</param>
    <param name="CpuSetMaskCount">Specifies the size of the <i>CpuSetMasks</i> array, in elements.</param>
    <param name="RequiredMaskCount">On successful return, specifies the number of affinity structures written to the array. If the array is too small, the function fails with <b>ERROR_INSUFFICIENT_BUFFER</b> and sets the <i>RequiredMaskCount</i> parameter to the number of elements required. The number of required elements is always less than or equal to the maximum group count returned by <see cref="GetMaximumProcessorGroupCount" />.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero and extended error information can be retrieved by calling <see cref="GetLastError" />.</para>
      <para>If the array supplied is too small, the error value is <b>ERROR_INSUFFICIENT_BUFFER</b> and the RequiredMaskCount is set to the number of elements required.</para>
    </returns>
  </member>
  <member name="Windows.GetThreadSelectedCpuSets">
    <summary>Returns the explicit CPU Set assignment of the specified thread, if any assignment was set using the <see cref="SetThreadSelectedCpuSets" /> API. If no explicit assignment is set, <b>RequiredIdCount</b> is set to 0 and the function returns TRUE.</summary>
    <param name="Thread">Specifies the thread for which to query the selected CPU Sets. This handle must have the THREAD_QUERY_LIMITED_INFORMATION access right. The value returned by <see cref="GetCurrentThread" /> can also be specified here.</param>
    <param name="CpuSetIds">Specifies an optional buffer to retrieve the list of CPU Set identifiers.</param>
    <param name="CpuSetIdCount">Specifies the capacity of the buffer specified in <b>CpuSetIds</b>. If the buffer is NULL, this must be 0.</param>
    <param name="RequiredIdCount">Specifies the required capacity of the buffer to hold the entire list of thread selected CPU Sets. On successful return, this specifies the number of IDs filled into the buffer.</param>
    <returns>This API returns TRUE on success. If the buffer is not large enough, the <b>GetLastError</b> value is ERROR_INSUFFICIENT_BUFFER. This API cannot fail when passed valid parameters and the return buffer is large enough.</returns>
  </member>
  <member name="Windows.GetThreadTimes">
    <summary>Retrieves timing information for the specified thread.</summary>
    <param name="hThread">
      <para>A handle to the thread whose timing information is sought. The handle must have the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpCreationTime">A pointer to a<see cref="FILETIME" /> structure that receives the creation time of the thread.</param>
    <param name="lpExitTime">A pointer to a <see cref="FILETIME" /> structure that receives the exit time of the thread. If the thread has not exited, the content of this structure is undefined.</param>
    <param name="lpKernelTime">A pointer to a<see cref="FILETIME" /> structure that receives the amount of time that the thread has executed in kernel mode.</param>
    <param name="lpUserTime">A pointer to a <see cref="FILETIME" /> structure that receives the amount of time that the thread has executed in user mode.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.InitializeProcThreadAttributeList">
    <summary>Initializes the specified list of attributes for process and thread creation.</summary>
    <param name="lpAttributeList">The attribute list. This parameter can be NULL to determine the buffer size required to support the specified number of attributes.</param>
    <param name="dwAttributeCount">The count of attributes to be added to the list.</param>
    <param name="dwFlags">This parameter is reserved and must be zero.</param>
    <param name="lpSize">
      <para>If <i>lpAttributeList</i> is not NULL, this parameter specifies the size in bytes of the <i>lpAttributeList</i> buffer on input. On output, this parameter receives the size in bytes of the initialized attribute list.</para>
      <para>If <i>lpAttributeList</i> is NULL, this parameter receives the required buffer size in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.IsProcessCritical">
    <summary>Determines whether the specified process is considered critical.</summary>
    <param name="hProcess">A handle to the process to query. The process must have been opened with <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access.</param>
    <param name="Critical">A pointer to the <b>BOOL</b> value this function will use to indicate whether the process is considered critical.</param>
    <returns>This routine returns FALSE on failure. Any other value indicates success. Call <see cref="GetLastError" /> to query for the specific error reason on failure.</returns>
  </member>
  <member name="Windows.IsProcessorFeaturePresent">
    <summary>Determines whether the specified processor feature is supported by the current computer.</summary>
    <param name="ProcessorFeature">
      <para>The processor feature to be tested. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_64BIT_LOADSTORE_ATOMIC</b>
                </term>
              </listheader>
              <listheader>
                <term>25</term>
              </listheader>
            </list>
          </description>
          <description>The 64-bit load/store atomic instructions are available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>24</term>
              </listheader>
            </list>
          </description>
          <description>The divide instructions are available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_EXTERNAL_CACHE_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>26</term>
              </listheader>
            </list>
          </description>
          <description>The external cache is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>27</term>
              </listheader>
            </list>
          </description>
          <description>The floating-point multiply-accumulate instruction is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_VFP_32_REGISTERS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>18</term>
              </listheader>
            </list>
          </description>
          <description>The VFP/Neon: 32 x 64bit register bank is present. This flag has the same meaning as <b>PF_ARM_VFP_EXTENDED_REGISTERS</b>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_3DNOW_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>7</term>
              </listheader>
            </list>
          </description>
          <description>The 3D-Now instruction set is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_CHANNELS_ENABLED</b>
                </term>
              </listheader>
              <listheader>
                <term>16</term>
              </listheader>
            </list>
          </description>
          <description>The processor channels are enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_COMPARE_EXCHANGE_DOUBLE</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The atomic compare and exchange operation (cmpxchg) is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_COMPARE_EXCHANGE128</b>
                </term>
              </listheader>
              <listheader>
                <term>14</term>
              </listheader>
            </list>
          </description>
          <description>The atomic compare and exchange 128-bit operation (cmpxchg16b) is available.<para><b>Windows Server 2003 and Windows XP/2000:  </b>This feature is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_COMPARE64_EXCHANGE128</b>
                </term>
              </listheader>
              <listheader>
                <term>15</term>
              </listheader>
            </list>
          </description>
          <description>The atomic compare 64 and exchange 128-bit operation (cmp8xchg16) is available.<para><b>Windows Server 2003 and Windows XP/2000:  </b>This feature is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_FASTFAIL_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>23</term>
              </listheader>
            </list>
          </description>
          <description>_fastfail() is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_FLOATING_POINT_EMULATED</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Floating-point operations are emulated using a software emulator.<para>This function returns a nonzero value if floating-point operations are emulated; otherwise, it returns zero.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_FLOATING_POINT_PRECISION_ERRATA</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>On a Pentium, a floating-point precision error can occur in rare circumstances.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_MMX_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The MMX instruction set is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_NX_ENABLED</b>
                </term>
              </listheader>
              <listheader>
                <term>12</term>
              </listheader>
            </list>
          </description>
          <description>
            <para>
              <a href="https://docs.microsoft.com//windows/desktop/Memory/data-execution-prevention">Data execution prevention</a> is enabled.</para>
            <para>
              <b>Windows XP/2000:  </b>This feature is not supported until Windows XP with SP2 and Windows Server 2003 with SP1.</para>
          </description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_PAE_ENABLED</b>
                </term>
              </listheader>
              <listheader>
                <term>9</term>
              </listheader>
            </list>
          </description>
          <description>The processor is PAE-enabled. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/physical-address-extension">Physical Address Extension</a>.<para>All x64 processors always return a nonzero value for this feature.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_RDTSC_INSTRUCTION_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>8</term>
              </listheader>
            </list>
          </description>
          <description>The RDTSC instruction is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_RDWRFSGSBASE_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>22</term>
              </listheader>
            </list>
          </description>
          <description>RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE instructions are available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_SECOND_LEVEL_ADDRESS_TRANSLATION</b>
                </term>
              </listheader>
              <listheader>
                <term>20</term>
              </listheader>
            </list>
          </description>
          <description>Second Level Address Translation is supported by the hardware.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_SSE3_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>13</term>
              </listheader>
            </list>
          </description>
          <description>The SSE3 instruction set is available.<para><b>Windows Server 2003 and Windows XP/2000:  </b>This feature is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_SSSE3_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>36</term>
              </listheader>
            </list>
          </description>
          <description>The SSSE3 instruction set is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_SSE4_1_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>37</term>
              </listheader>
            </list>
          </description>
          <description>The SSE4_1 instruction set is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_SSE4_2_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>38</term>
              </listheader>
            </list>
          </description>
          <description>The SSE4_2 instruction set is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_AVX_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>39</term>
              </listheader>
            </list>
          </description>
          <description>The AVX instruction set is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_AVX2_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>40</term>
              </listheader>
            </list>
          </description>
          <description>The AVX2 instruction set is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_AVX512F_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>41</term>
              </listheader>
            </list>
          </description>
          <description>The AVX512F instruction set is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_VIRT_FIRMWARE_ENABLED</b>
                </term>
              </listheader>
              <listheader>
                <term>21</term>
              </listheader>
            </list>
          </description>
          <description>Virtualization is enabled in the firmware and made available by the operating system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_XMMI_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The SSE instruction set is available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_XMMI64_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>10</term>
              </listheader>
            </list>
          </description>
          <description>The SSE2 instruction set is available.<para><b>Windows 2000:  </b>This feature is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_XSAVE_ENABLED</b>
                </term>
              </listheader>
              <listheader>
                <term>17</term>
              </listheader>
            </list>
          </description>
          <description>The processor implements the XSAVE and XRSTOR instructions.<para><b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:  </b>This feature is not supported until Windows 7 and Windows Server 2008 R2.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_V8_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>29</term>
              </listheader>
            </list>
          </description>
          <description>This Arm processor implements the Arm v8 instructions set.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>30</term>
              </listheader>
            </list>
          </description>
          <description>This Arm processor implements the Arm v8 extra cryptographic instructions (for example, AES, SHA1 and SHA2).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>31</term>
              </listheader>
            </list>
          </description>
          <description>This Arm processor implements the Arm v8 extra CRC32 instructions.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>34</term>
              </listheader>
            </list>
          </description>
          <description>This Arm processor implements the Arm v8.1 atomic instructions (for example, CAS, SWP).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>43</term>
              </listheader>
            </list>
          </description>
          <description>This Arm processor implements the Arm v8.2 DP instructions (for example, SDOT, UDOT). This feature is optional in Arm v8.2 implementations and mandatory in Arm v8.4 implementations.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_V83_JSCVT_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>44</term>
              </listheader>
            </list>
          </description>
          <description>This Arm processor implements the Arm v8.3 JSCVT instructions (for example, FJCVTZS).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PF_ARM_V83_LRCPC_INSTRUCTIONS_AVAILABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>45</term>
              </listheader>
            </list>
          </description>
          <description>This Arm processor implements the Arm v8.3 LRCPC instructions (for example, LDAPR). Note that certain Arm v8.2 CPUs may optionally support the LRCPC instructions.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the feature is supported, the return value is a nonzero value.</para>
      <para>If the feature is not supported, the return value is zero.</para>
      <para>If the HAL does not support detection of the feature, whether or not the hardware supports the feature, the return value is also zero.</para>
    </returns>
  </member>
  <member name="Windows.OpenProcess">
    <summary>Opens an existing local process object.</summary>
    <param name="dwDesiredAccess">
      <para>The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">process access rights</a>.</para>
      <para>If the caller has enabled the <a href="https://docs.microsoft.com//windows/win32/secauthz/privilege-constants#SE_DEBUG_NAME">SeDebugPrivilege privilege</a>, the requested access is granted regardless of the contents of the security descriptor.</para>
    </param>
    <param name="bInheritHandle">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="dwProcessId">
      <para>The identifier of the local process to be opened.</para>
      <para>If the specified process is the System Idle Process (0x00000000), the function fails and the last error code is <code>ERROR_INVALID_PARAMETER</code>. If the specified process is the System process or one of the Client Server Run-Time Subsystem (CSRSS) processes, this function fails and the last error code is <code>ERROR_ACCESS_DENIED</code> because their access restrictions prevent user-level code from opening them.</para>
      <para>If you are using <see cref="GetCurrentProcessId" /> as an argument to this function, consider using <see cref="GetCurrentProcess" /> instead of OpenProcess, for improved performance.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified process.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenProcessToken">
    <summary>The <b>OpenProcessToken</b> function opens the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> associated with a process.</summary>
    <param name="ProcessHandle">A handle to the process whose access token is opened. The process must have the PROCESS_QUERY_LIMITED_INFORMATION access permission. See <a href="https://docs.microsoft.com//windows/win32/procthread/process-security-and-access-rights">Process Security and Access Rights</a> for more info.</param>
    <param name="DesiredAccess">
      <para>Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the requested types of access to the access token. These requested access types are compared with the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/d-gly">discretionary access control list</a> (DACL) of the token to determine which accesses are granted or denied.</para>
      <para>For a list of access rights for access tokens, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="TokenHandle">A pointer to a handle that identifies the newly opened access token when the function returns.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenThread">
    <summary>Opens an existing thread object.</summary>
    <param name="dwDesiredAccess">
      <para>The access to the thread object. This access right is checked against the security descriptor for the thread. This parameter can be one or more of the<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">thread access rights</a>.</para>
      <para>If the caller has enabled the SeDebugPrivilege privilege, the requested access is granted regardless of the contents of the security descriptor.</para>
    </param>
    <param name="bInheritHandle">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="dwThreadId">The identifier of the thread to be opened.</param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified thread.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenThreadToken">
    <summary>The <b>OpenThreadToken</b> function opens the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> associated with a thread.</summary>
    <param name="ThreadHandle">A handle to the thread whose access token is opened.</param>
    <param name="DesiredAccess">
      <para>Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the requested types of access to the access token. These requested access types are reconciled against the token's <a href="https://docs.microsoft.com//windows/desktop/SecGloss/d-gly">discretionary access control list</a> (DACL) to determine which accesses are granted or denied.</para>
      <para>For a list of access rights for access tokens, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
    </param>
    <param name="OpenAsSelf">
      <para>TRUE if the access check is to be made against the process-level <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security context</a>.</para>
      <para>
        <b>FALSE</b> if the access check is to be made against the current security context of the thread calling the <b>OpenThreadToken</b> function.</para>
      <para>The <i>OpenAsSelf</i> parameter allows the caller of this function to open the access token of a specified thread when the caller is impersonating a token at <b>SecurityIdentification</b> level. Without this parameter, the calling thread cannot open the access token on the specified thread because it is impossible to open executive-level objects by using the <b>SecurityIdentification</b> impersonation level.</para>
    </param>
    <param name="TokenHandle">A pointer to a variable that receives the handle to the newly opened access token.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If the token has the anonymous impersonation level, the token will not be opened and <b>OpenThreadToken</b> sets ERROR_CANT_OPEN_ANONYMOUS as the error.</para>
    </returns>
  </member>
  <member name="Windows.ProcessIdToSessionId">
    <summary>Retrieves the Remote Desktop Services session associated with a specified process.</summary>
    <param name="dwProcessId">Specifies a process identifier. Use the<see cref="GetCurrentProcessId" /> function to retrieve the process identifier for the current process.</param>
    <param name="pSessionId">Pointer to a variable that receives the identifier of the Remote Desktop Services session under which the specified process is running. To retrieve the identifier of the session currently attached to the console, use the <see cref="WTSGetActiveConsoleSessionId" />function.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryProcessAffinityUpdateMode">
    <summary>Retrieves the affinity update mode of the specified process.</summary>
    <param name="hProcess">A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="lpdwFlags">
      <para>The affinity update mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Dynamic update of the process affinity by the system is disabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_AFFINITY_ENABLE_AUTO_UPDATE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001UL</term>
              </listheader>
            </list>
          </description>
          <description>Dynamic update of the process affinity by the system is enabled.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryProtectedPolicy">
    <summary>Queries the value associated with a protected policy.</summary>
    <param name="PolicyGuid">
      <code>The globally-unique identifier of the policy to query.</code>
    </param>
    <param name="PolicyValue">
      <code>Receives the value that the supplied policy is set to.</code>
    </param>
    <returns>True if the function succeeds; otherwise, false.</returns>
  </member>
  <member name="Windows.QueueUserAPC">
    <summary>Adds a user-mode <a href="https://docs.microsoft.com//windows/win32/sync/asynchronous-procedure-calls">asynchronous procedure call</a> (APC) object to the APC queue of the specified thread.</summary>
    <param name="pfnAPC">A pointer to the application-supplied APC function to be called when the specified thread performs an alertable wait operation. For more information, see <a href="https://docs.microsoft.com/../winnt/nc-winnt-papcfunc.md">PAPCFUNC callback function</a>.</param>
    <param name="hThread">A handle to the thread. The handle must have the <b>THREAD_SET_CONTEXT</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="dwData">A single value that is passed to the APC function pointed to by the <i>pfnAPC</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. <b>Windows Server 2003 and Windows XP:</b> There are no error values defined for this function that can be retrieved by calling <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueueUserAPC2">
    <summary>Adds a user-mode <a href="https://docs.microsoft.com//windows/win32/sync/asynchronous-procedure-calls">asynchronous procedure call</a> (APC) object to the APC queue of the specified thread.</summary>
    <param name="ApcRoutine">
      <para>A pointer to the application-supplied APC function to be called when the specified thread performs an alertable wait operation. For more information, see <a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-papcfunc">APCProc</a>.</para>
      <para>For special user-mode APCs, an alertable wait is not required. See <a href="https://docs.microsoft.com/#remarks">Remarks</a> for more information about special user-mode APCs.</para>
    </param>
    <param name="Thread">A handle to the thread. The handle must have <b>THREAD_SET_CONTEXT</b> access permission. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <param name="Data">A single value that is passed to the APC function pointed to by the <i>ApcRoutine</i> parameter.</param>
    <param name="Flags">A value from <see cref="QUEUE_USER_APC_FLAGS enumeration" /> that modifies the behavior of the user-mode APC.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ResumeThread">
    <summary>Decrements a thread's suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed.</summary>
    <param name="hThread">
      <para>A handle to the thread to be restarted.</para>
      <para>This handle must have the THREAD_SUSPEND_RESUME access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the thread's previous suspend count.</para>
      <para>If the function fails, the return value is (DWORD) -1. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetPriorityClass">
    <summary>Sets the priority class for the specified process. This value together with the priority value of each thread of the process determines each thread's base priority level.</summary>
    <param name="hProcess">
      <para>A handle to the process.</para>
      <para>The handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwPriorityClass">
      <para>The priority class for the process. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Priority</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ABOVE_NORMAL_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00008000</term>
              </listheader>
            </list>
          </description>
          <description> Process that has priority above <b>NORMAL_PRIORITY_CLASS</b> but below <b>HIGH_PRIORITY_CLASS</b>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>BELOW_NORMAL_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00004000</term>
              </listheader>
            </list>
          </description>
          <description> Process that has priority above <b>IDLE_PRIORITY_CLASS</b> but below <b>NORMAL_PRIORITY_CLASS</b>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>HIGH_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000080</term>
              </listheader>
            </list>
          </description>
          <description>Process that performs time-critical tasks that must be executed immediately. The threads of the process preempt the threads of normal or idle priority class processes. An example is the Task List, which must respond quickly when called by the user, regardless of the load on the operating system. Use extreme care when using the high-priority class, because a high-priority class application can use nearly all available CPU time.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IDLE_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description>Process whose threads run only when the system is idle. The threads of the process are preempted by the threads of any process running in a higher priority class. An example is a screen saver. The idle-priority class is inherited by child processes.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NORMAL_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>Process with no special scheduling needs.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_MODE_BACKGROUND_BEGIN</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00100000</term>
              </listheader>
            </list>
          </description>
          <description>Begin background processing mode. The system lowers the resource scheduling priorities of the process (and its threads) so that it can perform background work without significantly affecting activity in the foreground.<para>This value can be specified only if <i>hProcess</i> is a handle to the current process. The function fails if the process is already in background processing mode.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_MODE_BACKGROUND_END</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00200000</term>
              </listheader>
            </list>
          </description>
          <description>End background processing mode. The system restores the resource scheduling priorities of the process (and its threads) as they were before the process entered background processing mode.<para>This value can be specified only if <i>hProcess</i> is a handle to the current process. The function fails if the process is not in background processing mode.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>REALTIME_PRIORITY_CLASS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Process that has the highest possible priority. The threads of the process preempt the threads of all other processes, including operating system processes performing important tasks. For example, a real-time process that executes for more than a very brief interval can cause disk caches not to flush or cause the mouse to be unresponsive.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetProcessAffinityUpdateMode">
    <summary>Sets the affinity update mode of the specified process.</summary>
    <param name="hProcess">A handle to the process. This handle must be returned by the <see cref="GetCurrentProcess" /> function.</param>
    <param name="dwFlags">
      <para>The affinity update mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Disables dynamic update of the process affinity by the system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_AFFINITY_ENABLE_AUTO_UPDATE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001UL</term>
              </listheader>
            </list>
          </description>
          <description>Enables dynamic update of the process affinity by the system.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetProcessDefaultCpuSetMasks">
    <summary>Sets the default CPU Sets assignment for threads in the specified process.</summary>
    <param name="Process">Specifies the process for which to set the default CPU Sets. This handle must have the <a href="https://docs.microsoft.com//windows/win32/procthread/process-security-and-access-rights">PROCESS_SET_LIMITED_INFORMATION</a> access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</param>
    <param name="CpuSetMasks">Specifies an optional buffer of <see cref="GROUP_AFFINITY" /> structures representing the CPU Sets to set as the process default CPU set. If this is NULL, the <b>SetProcessDefaultCpuSetMasks</b> function clears out any assignment.</param>
    <param name="CpuSetMaskCount">Specifies the size of the <i>CpuSetMasks</i> array, in elements. If the buffer is NULL, this value must be zero.</param>
    <returns>This function cannot fail when passed valid parameters.</returns>
  </member>
  <member name="Windows.SetProcessDefaultCpuSets">
    <summary>Sets the default CPU Sets assignment for threads in the specified process. Threads that are created, which don’t have CPU Sets explicitly set using <see cref="SetThreadSelectedCpuSets" />, will inherit the sets specified by <b>SetProcessDefaultCpuSets</b> automatically.</summary>
    <param name="Process">Specifies the process for which to set the default CPU Sets. This handle must have the PROCESS_SET_LIMITED_INFORMATION access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</param>
    <param name="CpuSetIds">Specifies the list of CPU Set IDs to set as the process default CPU set. If this is NULL, the <b>SetProcessDefaultCpuSets</b> clears out any assignment.</param>
    <param name="CpuSetIdCount">Specifies the number of IDs in the list passed in the <b>CpuSetIds</b> argument. If that value is NULL, this should be 0.</param>
    <returns>This function cannot fail when passed valid parameters</returns>
  </member>
  <member name="Windows.SetProcessDynamicEHContinuationTargets">
    <summary>Sets dynamic exception handling continuation targets for the specified process.</summary>
    <param name="Process">A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="NumberOfTargets">Supplies the number of dynamic exception handling continuation targets to set.</param>
    <param name="Targets">A pointer to an array of dynamic exception handling continuation targets. For more information on this structure, see <see cref="PROCESS_DYNAMIC_EH_CONTINUATION_TARGET" />.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Note that even if the function fails, a portion of the supplied continuation targets may have been successfully processed. The caller needs to check the flags in each individual continuation target specified via <i>Targets</i> to determine if it was successfully processed.</para>
    </returns>
  </member>
  <member name="Windows.SetProcessDynamicEnforcedCetCompatibleRanges">
    <summary>
      <blockquote>[!NOTE] This API was added to the 19041 SDK in an update released in November 2020.</blockquote>
      <para>Sets dynamic enforced CETCOMPAT ranges for the specified process.</para>
    </summary>
    <param name="Process">A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="NumberOfRanges">Supplies the number of dynamic enforced CETCOMPAT ranges to set.</param>
    <param name="Ranges">A pointer to an array of dynamic enforced CETCOMPAT ranges. For more information on this structure, see <see cref="PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE" />.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Note that even if the function fails, a portion of the supplied CETCOMPAT ranges may have been successfully processed. The caller needs to check the flags in each individual CETCOMPAT range specified via <i>Ranges</i> to determine if it was successfully processed.</para>
    </returns>
  </member>
  <member name="Windows.SetProcessInformation">
    <summary>Sets information for the specified process.</summary>
    <param name="hProcess">A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="ProcessInformationClass">A member of the <see cref="PROCESS_INFORMATION_CLASS" /> enumeration specifying the kind of information to set.</param>
    <param name="ProcessInformation">
      <para>Pointer to an object that contains the type of information specified by the<i>ProcessInformationClass</i> parameter.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is<b>ProcessMemoryPriority</b>, this parameter must point to a<see cref="MEMORY_PRIORITY_INFORMATION" /> structure.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is<b>ProcessPowerThrottling</b>, this parameter must point to a<see cref="PROCESS_POWER_THROTTLING_STATE" /> structure.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is<b>ProcessLeapSecondInfo</b>, this parameter must point to a<see cref="PROCESS_LEAP_SECOND_INFO" /> structure.</para>
    </param>
    <param name="ProcessInformationSize">
      <para>The size in bytes of the structure specified by the <i>ProcessInformation</i> parameter.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is<b>ProcessMemoryPriority</b>, this parameter must be<code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is<b>ProcessPowerThrottling</b>, this parameter must be<code>sizeof(PROCESS_POWER_THROTTLING_STATE)</code>.</para>
      <para>If the <i>ProcessInformationClass</i> parameter is<b>ProcessLeapSecondInfo</b>, this parameter must be<code>sizeof(PROCESS_LEAP_SECOND_INFO)</code>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetProcessMitigationPolicy">
    <summary>Sets a mitigation policy for the calling process. Mitigation policies enable a process to harden itself against various types of attacks.</summary>
    <param name="MitigationPolicy">
      <para>The mitigation policy to apply. This parameter can be one of the following values.</para>
      <para>|Value |Meaning | |---------|---------| |<b>ProcessDEPPolicy</b> | The data execution prevention (DEP) policy of the process.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_DEP_POLICY" /> structure that specifies the DEP policy flags. | |<b>ProcessASLRPolicy</b> | The Address Space Layout Randomization (ASLR) policy of the process.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_ASLR_POLICY" /> structure that specifies the ASLR policy flags. | |<b>ProcessDynamicCodePolicy</b> | The dynamic code policy of the process. When turned on, the process cannot generate dynamic code or modify existing executable code.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_DYNAMIC_CODE_POLICY" /> structure that specifies the dynamic code policy flags.| |<b>ProcessStrictHandleCheckPolicy</b> | The process will receive a fatal error if it manipulates a handle that is not valid.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY" /> structure that specifies the handle check policy flags. | |<b>ProcessSystemCallDisablePolicy</b> | Disables the ability to use NTUser/GDI functions at the lowest layer.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY" /> structure that specifies the system call disable policy flags.| |<b>ProcessMitigationOptionsMask</b> | Returns the mask of valid bits for all the mitigation options on the system. An application can set many mitigation options without querying the operating system for mitigation options by combining bitwise with the mask to exclude all non-supported bits at once.<br />The <i>lpBuffer</i> parameter points to a <b>ULONG64</b> bit vector for the mask, or to accommodate more than 64 bits, a two-element array of <b>ULONG64</b> bit vectors.| |<b>ProcessExtensionPointDisablePolicy</b> | The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY" /> structure that specifies the extension point disable policy flags.| |<b>ProcessControlFlowGuardPolicy</b> | The Control Flow Guard (CFG) policy of the process.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY" /> structure that specifies the CFG policy flags.| |<b>ProcessSignaturePolicy</b> | The policy of a process that can restrict image loading to those images that are either signed by Microsoft, by the Windows Store, or by Microsoft, the Windows Store and the Windows Hardware Quality Labs (WHQL).<br />he <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY" /> structure that specifies the signature policy flags. | |<b>ProcessFontDisablePolicy</b> | The policy regarding font loading for the process. When turned on, the process cannot load non-system fonts.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_FONT_DISABLE_POLICY" /> structure that specifies the policy flags for font loading.| |<b>ProcessImageLoadPolicy</b> | The policy regarding image loading for the process, which determines the types of executable images that are allowed to be mapped into the process. When turned on, images cannot be loaded from some locations, such a remote devices or files that have the low mandatory label.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_IMAGE_LOAD_POLICY" /> structure that specifies the policy flags for image loading.| | <b>ProcessRedirectionTrustPolicy</b> | The RedirectionGuard policy of a process. The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY" /> structure that specifies the mitigation mode. | | <b>ProcessSideChannelIsolationPolicy</b> | Windows 10, version 1809 and above: The policy regarding isolation of side channels for the specified process.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY" /> structure that specifies the policy flags for side channel isolation. | |<b>ProcessUserShadowStackPolicy</b> | Windows 10, version 2004 and above: The policy regarding user-mode Hardware-enforced Stack Protection for the process.<br />The <i>lpBuffer</i> parameter points to a <see cref="PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY" /> structure that specifies the policy flags for user-mode Hardware-enforced Stack Protection.|</para>
    </param>
    <param name="lpBuffer">
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessDEPPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_DEP_POLICY" /> structure that specifies the DEP policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessASLRPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_ASLR_POLICY" /> structure that specifies the ASLR policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_IMAGE_LOAD_POLICY" /> structure that receives the policy flags for image loading.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessStrictHandleCheckPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY" /> structure that specifies the handle check policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSystemCallDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY" /> structure that specifies the system call disable policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessMitigationOptionsMask</b>, this parameter points to a <b>ULONG64</b> bit vector for the mask, or to accommodate more than 64 bits, a two-element array of <b>ULONG64</b> bit vectors.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessExtensionPointDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY" /> structure that specifies the extension point disable policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessControlFlowGuardPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY" /> structure that specifies the CFG policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessSignaturePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY" /> structure that specifies the signature policy flags.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessFontDisablePolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_FONT_DISABLE_POLICY" /> structure that specifies the policy flags for font loading.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_IMAGE_LOAD_POLICY" /> structure that specifies the policy flags for image loading.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessRedirectionTrustPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY structure" /> that specifies the mitigation mode.</para>
      <para>If the <i>MitigationPolicy</i> parameter is <b>ProcessUserShadowStackPolicy</b>, this parameter points to a <see cref="PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY" /> structure that specifies the policy flags for user-mode Hardware-enforced Stack Protection.</para>
    </param>
    <param name="dwLength">The size of <i>lpBuffer</i>, in bytes.</param>
    <returns>If the function succeeds, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.SetProcessPriorityBoost">
    <summary>Disables or enables the ability of the system to temporarily boost the priority of the threads of the specified process.</summary>
    <param name="hProcess">A handle to the process. This handle must have the PROCESS_SET_INFORMATION access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="bDisablePriorityBoost">If this parameter is TRUE, dynamic boosting is disabled. If the parameter is FALSE, dynamic boosting is enabled.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetProcessShutdownParameters">
    <summary>Sets shutdown parameters for the currently calling process. This function sets a shutdown order for a process relative to the other processes in the system.</summary>
    <param name="dwLevel">
      <para>The shutdown priority for a process relative to other processes in the system. The system shuts down processes from high <i>dwLevel</i> values to low. The highest and lowest shutdown priorities are reserved for system components. This parameter must be in the following range of values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>000-0FF</term>
              </listheader>
            </list>
          </description>
          <description>System reserved last shutdown range.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>100-1FF</term>
              </listheader>
            </list>
          </description>
          <description>Application reserved last shutdown range.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>200-2FF</term>
              </listheader>
            </list>
          </description>
          <description>Application reserved "in between" shutdown range.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>300-3FF</term>
              </listheader>
            </list>
          </description>
          <description>Application reserved first shutdown range.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>400-4FF</term>
              </listheader>
            </list>
          </description>
          <description>System reserved first shutdown range.</description>
        </listheader>
      </list> <para>All processes start at shutdown level 0x280.</para></param>
    <param name="dwFlags">
      <para>This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SHUTDOWN_NORETRY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The system terminates the process without displaying a retry dialog box for the user.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function is succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetProtectedPolicy">
    <summary>Sets a protected policy. This function is for use primarily by Windows, and not designed for external use.</summary>
    <param name="PolicyGuid">
      <code>The globally-unique identifier of the policy to set.</code>
    </param>
    <param name="PolicyValue">
      <code>The value to set the policy to.</code>
    </param>
    <param name="OldPolicyValue">
      <code>Optionally receives the original value that was associated with the supplied policy.</code>
    </param>
    <returns>
      <code>True if the function succeeds; otherwise, false. To retrieve error values for this function, call &lt;a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror"&gt;GetLastError&lt;/a&gt;.</code>
    </returns>
  </member>
  <member name="Windows.SetThreadContext">
    <summary>
      <para>Sets the context for the specified thread.</para>
      <para>A 64-bit application can set the context of a WOW64 thread using the<a href="https://github.com/microsoftdocs/sdk-api/blob/docs/sdk-api-src/content/winbase/nf-winbase-wow64setthreadcontext.md">Wow64SetThreadContext</a> function.</para>
    </summary>
    <param name="hThread">A handle to the thread whose context is to be set. The handle must have the<b>THREAD_SET_CONTEXT</b> access right to the thread. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
    <param name="lpContext">A pointer to a <see cref="CONTEXT" /> structure that contains the context to be set in the specified thread. The value of the <b>ContextFlags</b> member of this structure specifies which portions of a thread's context to set. Some values in the<b>CONTEXT</b> structure that cannot be specified are silently set to the correct value. This includes bits in the CPU status register that specify the privileged processor mode, global enabling bits in the debugging register, and other states that must be controlled by the operating system.</param>
    <returns>
      <para>If the context was set, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadDescription">
    <summary>Assigns a description to a thread.</summary>
    <param name="hThread">A handle for the thread for which you want to set the description. The handle must have THREAD_SET_LIMITED_INFORMATION access.</param>
    <param name="lpThreadDescription">A Unicode string that specifies the description of the thread.</param>
    <returns>If the function succeeds, the return value is the <b>HRESULT</b> that denotes a successful operation. If the function fails, the return value is an <b>HRESULT</b> that denotes the error.</returns>
  </member>
  <member name="Windows.SetThreadIdealProcessor">
    <summary>
      <para>Sets a preferred processor for a thread. The system schedules threads on their preferred processors whenever possible.</para>
      <para>On a system with more than 64 processors, this function sets the preferred processor to a logical processor in the <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a> to which the calling thread is assigned. Use the <see cref="SetThreadIdealProcessorEx" /> function to specify a processor group and preferred processor.</para>
    </summary>
    <param name="hThread">A handle to the thread whose preferred processor is to be set. The handle must have the THREAD_SET_INFORMATION access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
    <param name="dwIdealProcessor">The number of the preferred processor for the thread. This value is zero-based. If this parameter is MAXIMUM_PROCESSORS, the function returns the current ideal processor without changing it.</param>
    <returns>
      <para>If the function succeeds, the return value is the previous preferred processor.</para>
      <para>If the function fails, the return value is (DWORD) – 1. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadIdealProcessorEx">
    <summary>Sets the ideal processor for the specified thread and optionally retrieves the previous ideal processor.</summary>
    <param name="hThread">A handle to the thread for which to set the ideal processor. This handle must have been created with the THREAD_SET_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
    <param name="lpIdealProcessor">A pointer to a <see cref="PROCESSOR_NUMBER" /> structure that specifies the processor number of the desired ideal processor.</param>
    <param name="lpPreviousIdealProcessor">A pointer to a <see cref="PROCESSOR_NUMBER" /> structure to receive the previous ideal processor. This parameter can point to the same memory location as the <i>lpIdealProcessor</i> parameter. This parameter can be NULL if the previous ideal processor is not required.</param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, it returns zero. To get extended error information, use <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadInformation">
    <summary>Sets information for the specified thread.</summary>
    <param name="hThread">A handle to the thread. The handle must have THREAD_SET_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
    <param name="ThreadInformationClass">The class of information to set. The only supported values are <b>ThreadMemoryPriority</b> and <b>ThreadPowerThrottling</b>.</param>
    <param name="ThreadInformation">
      <para>Pointer to a structure that contains the type of information specified by the <i>ThreadInformationClass</i> parameter.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must point to a <b>MEMORY_PRIORITY_INFORMATION</b> structure.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadPowerThrottling</b>, this parameter must point to a <b>THREAD_POWER_THROTTLING_STATE</b> structure.</para>
    </param>
    <param name="ThreadInformationSize">
      <para>The size in bytes of the structure specified by the <i>ThreadInformation</i> parameter.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must be <code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>.</para>
      <para>If the <i>ThreadInformationClass</i> parameter is <b>ThreadPowerThrottling</b>, this parameter must be <code>sizeof(THREAD_POWER_THROTTLING_STATE)</code>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadPriority">
    <summary>Sets the priority value for the specified thread. This value, together with the priority class of the thread's process, determines the thread's base priority level.</summary>
    <param name="hThread">
      <para>A handle to the thread whose priority value is to be set.</para>
      <para>The handle must have the <b>THREAD_SET_INFORMATION</b> or <b>THREAD_SET_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.<b>Windows Server 2003:  </b>The handle must have the <b>THREAD_SET_INFORMATION</b> access right.</para>
    </param>
    <param name="nPriority">
      <para>The priority value for the thread. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Priority</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_MODE_BACKGROUND_BEGIN</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00010000</term>
              </listheader>
            </list>
          </description>
          <description>Begin background processing mode. The system lowers the resource scheduling priorities of the thread so that it can perform background work without significantly affecting activity in the foreground.<para>This value can be specified only if <i>hThread</i> is a handle to the current thread. The function fails if the thread is already in background processing mode.</para><para><b>Windows Server 2003:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_MODE_BACKGROUND_END</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00020000</term>
              </listheader>
            </list>
          </description>
          <description>End background processing mode. The system restores the resource scheduling priorities of the thread as they were before the thread entered background processing mode.<para>This value can be specified only if <i>hThread</i> is a handle to the current thread. The function fails if the thread is not in background processing mode.</para><para><b>Windows Server 2003:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_ABOVE_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Priority 1 point above the priority class.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_BELOW_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>-1</term>
              </listheader>
            </list>
          </description>
          <description>Priority 1 point below the priority class.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_HIGHEST</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Priority 2 points above the priority class.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_IDLE</b>
                </term>
              </listheader>
              <listheader>
                <term>-15</term>
              </listheader>
            </list>
          </description>
          <description>Base priority of 1 for <b>IDLE_PRIORITY_CLASS</b>, <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or <b>HIGH_PRIORITY_CLASS</b> processes, and a base priority of 16 for <b>REALTIME_PRIORITY_CLASS</b> processes.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_LOWEST</b>
                </term>
              </listheader>
              <listheader>
                <term>-2</term>
              </listheader>
            </list>
          </description>
          <description>Priority 2 points below the priority class.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_NORMAL</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Normal priority for the priority class.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>THREAD_PRIORITY_TIME_CRITICAL</b>
                </term>
              </listheader>
              <listheader>
                <term>15</term>
              </listheader>
            </list>
          </description>
          <description>Base priority of 15 for <b>IDLE_PRIORITY_CLASS</b>, <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or <b>HIGH_PRIORITY_CLASS</b> processes, and a base priority of 31 for <b>REALTIME_PRIORITY_CLASS</b> processes.</description>
        </listheader>
      </list> <para>If the thread has the <b>REALTIME_PRIORITY_CLASS</b> base class, this parameter can also be -7, -6, -5, -4, -3, 3, 4, 5, or 6. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>.</para></param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>
        <b>Windows Phone 8.1:  </b>Windows Phone Store apps may call this function but it has no effect. The function will return a nonzero value indicating success.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadPriorityBoost">
    <summary>Disables or enables the ability of the system to temporarily boost the priority of a thread.</summary>
    <param name="hThread">
      <para>A handle to the thread whose priority is to be boosted. The handle must have the <b>THREAD_SET_INFORMATION</b> or <b>THREAD_SET_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_SET_INFORMATION</b> access right.</para>
    </param>
    <param name="bDisablePriorityBoost">If this parameter is <b>TRUE</b>, dynamic boosting is disabled. If the parameter is <b>FALSE</b>, dynamic boosting is enabled.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadSelectedCpuSetMasks">
    <summary>Sets the selected CPU Sets assignment for the specified thread. This assignment overrides the process default assignment, if one is set.</summary>
    <param name="Thread">Specifies the thread on which to set the CPU Set assignment. <a href="https://docs.microsoft.com//windows/win32/procthread/process-security-and-access-rights">PROCESS_SET_LIMITED_INFORMATION</a> access right. The value returned by <see cref="GetCurrentProcess" /> can also be specified here.</param>
    <param name="CpuSetMasks">Specifies an optional buffer of <see cref="GROUP_AFFINITY" /> structures representing the CPU Sets to set as the thread selected CPU set. If this is NULL, the <b>SetThreadSelectedCpuSetMasks</b> function clears out any assignment, reverting to process default assignment if one is set.</param>
    <param name="CpuSetMaskCount">Specifies the number of <b>GROUP_AFFINITY</b> structures in the list passed in the GroupCpuSets argument. If the buffer is NULL, this value must be zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero and extended error information can be retrieved by calling <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadSelectedCpuSets">
    <summary>Sets the selected CPU Sets assignment for the specified thread. This assignment overrides the process default assignment, if one is set.</summary>
    <param name="Thread">Specifies the thread on which to set the CPU Set assignment. This handle must have the THREAD_SET_LIMITED_INFORMATION access right. The value returned by <see cref="GetCurrentThread" /> can also be used.</param>
    <param name="CpuSetIds">Specifies the list of CPU Set IDs to set as the thread selected CPU set. If this is NULL, the API clears out any assignment, reverting to process default assignment if one is set.</param>
    <param name="CpuSetIdCount">Specifies the number of IDs in the list passed in the <b>CpuSetIds</b> argument. If that value is NULL, this should be 0.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>This function cannot fail when passed valid parameters.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadStackGuarantee">
    <summary>Sets the minimum size of the stack associated with the calling thread or fiber that will be available during any stack overflow exceptions. This is useful for handling stack overflow exceptions; the application can safely use the specified number of bytes during exception handling.</summary>
    <param name="StackSizeInBytes">
      <para>The size of the stack, in bytes. On return, this value is set to the size of the previous stack, in bytes.</para>
      <para>If this parameter is 0 (zero), the function succeeds and the parameter contains the size of the current stack.</para>
      <para>If the specified size is less than the current size, the function succeeds but ignores this request. Therefore, you cannot use this function to reduce the size of the stack.</para>
      <para>This value cannot be larger than the reserved stack size.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadToken">
    <summary>The <b>SetThreadToken</b> function assigns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> to a thread. The function can also cause a thread to stop using an impersonation token.</summary>
    <param name="Thread">
      <para>A pointer to a handle to the thread to which the function assigns the impersonation token.</para>
      <para>If <i>Thread</i> is <b>NULL</b>, the function assigns the impersonation token to the calling thread.</para>
    </param>
    <param name="Token">
      <para>A handle to the impersonation token to assign to the thread. This handle must have been opened with TOKEN_IMPERSONATE access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.</para>
      <para>If <i>Token</i> is <b>NULL</b>, the function causes the thread to stop using an impersonation token.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SuspendThread">
    <summary>
      <para>Suspends the specified thread.</para>
      <para>A 64-bit application can suspend a WOW64 thread using the <see cref="Wow64SuspendThread" /> function.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread that is to be suspended.</para>
      <para>The handle must have the <b>THREAD_SUSPEND_RESUME</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <returns>If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is <code>(DWORD) -1</code>. To get extended error information, use the<see cref="GetLastError" /> function.</returns>
  </member>
  <member name="Windows.SwitchToThread">
    <summary>Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the next thread to be executed.</summary>
    <returns>
      <para>If calling the<b>SwitchToThread</b> function caused the operating system to switch execution to another thread, the return value is nonzero.</para>
      <para>If there are no other threads ready to execute, the operating system does not switch execution to another thread, and the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.TerminateProcess">
    <summary>Terminates the specified process and all of its threads.</summary>
    <param name="hProcess">
      <para>A handle to the process to be terminated.</para>
      <para>The handle must have the <b>PROCESS_TERMINATE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="uExitCode">The exit code to be used by the process and threads terminated as a result of this call. Use the<see cref="GetExitCodeProcess" /> function to retrieve a process's exit value. Use the<see cref="GetExitCodeThread" /> function to retrieve a thread's exit value.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.TerminateThread">
    <summary>Terminates a thread.</summary>
    <param name="hThread">
      <para>A handle to the thread to be terminated.</para>
      <para>The handle must have the <b>THREAD_TERMINATE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="dwExitCode">The exit code for the thread. Use the<see cref="GetExitCodeThread" /> function to retrieve a thread's exit value.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.TlsAlloc">
    <summary>Allocates a thread local storage (TLS) index. Any thread of the process can subsequently use this index to store and retrieve values that are local to the thread, because each thread receives its own slot for the index.</summary>
    <returns>
      <para>If the function succeeds, the return value is a TLS index. The slots for the index are initialized to zero.</para>
      <para>If the function fails, the return value is <b>TLS_OUT_OF_INDEXES</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.TlsFree">
    <summary>Releases a thread local storage (TLS) index, making it available for reuse.</summary>
    <param name="dwTlsIndex">The TLS index that was allocated by the<see cref="TlsAlloc" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.TlsGetValue">
    <summary>Retrieves the value in the calling thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.</summary>
    <param name="dwTlsIndex">The TLS index that was allocated by the<see cref="TlsAlloc" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is the value stored in the calling thread's TLS slot associated with the specified index. If <i>dwTlsIndex</i> is a valid index allocated by a successful call to <see cref="TlsAlloc" />, this function always succeeds.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The data stored in a TLS slot can have a value of 0 because it still has its initial value or because the thread called the <see cref="TlsSetValue" /> function with 0. Therefore, if the return value is 0, you must check whether <see cref="GetLastError" /> returns <b>ERROR_SUCCESS</b> before determining that the function has failed. If <b>GetLastError</b> returns <b>ERROR_SUCCESS</b>, then the function has succeeded and the data stored in the TLS slot is 0. Otherwise, the function has failed.</para>
      <para>Functions that return indications of failure call <see cref="SetLastError" /> when they fail. They generally do not call <b>SetLastError</b> when they succeed. The<b>TlsGetValue</b> function is an exception to this general rule. The<b>TlsGetValue</b> function calls <b>SetLastError</b> to clear a thread's last error when it succeeds. That allows checking for the error-free retrieval of zero values.</para>
    </returns>
  </member>
  <member name="Windows.TlsSetValue">
    <summary>Stores a value in the calling thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.</summary>
    <param name="dwTlsIndex">The TLS index that was allocated by the <see cref="TlsAlloc" />function.</param>
    <param name="lpTlsValue">The value to be stored in the calling thread's TLS slot for the index.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
</doc>