<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.C_ASSERT">
    <summary>
      <para>Checks assertions at compile time.</para>
    </summary>
    <param name="e">
      <para>An expression that can be determined at compile time.</para>
    </param>
    <remarks>
      <para>The <b>C_ASSERT</b> macro is defined as follows.</para>
      <code>#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
</code>
      <para>The following examples demonstrate common types of compile-time assertions.</para>
      <code>C_ASSERT (BUFFER_CCH_SIZE &lt;= MAX_PATH);

C_ASSERT (ARRAYSIZE(array1) == ARRAYSIZE(array2));

C_ASSERT (FIELD_OFFSET(STRUCT_DEF, MemberName) == 0x1d4);

C_ASSERT (sizeof(BOOLEAN) == sizeof(UCHAR));
</code>
    </remarks>
  </member>
  <member name="Windows.FIELD_OFFSET">
    <summary>
      <para>The <b>FIELD_OFFSET</b> macro returns the byte offset of a named field in a known structure type.</para>
    </summary>
    <param name="type">
      <para>Specifies the name of a known structure type containing <i>Field</i>.</para>
    </param>
    <param name="field">
      <para>Specifies the name of a field in a structure of type <i>Type</i>.</para>
    </param>
    <remarks>
      <para>Used by device driver writers to symbolically determine the offset of a known field in a known structure type.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows-hardware/drivers/kernel/mm-bad-pointer">CONTAINING_RECORD</seealso>
  </member>
  <member name="Windows.GetCurrentFiber">
    <summary>
      <para>Retrieves the address of the current fiber.</para>
    </summary>
    <returns>
      <para>The macro returns the address of the currently running fiber.</para>
    </returns>
    <remarks>
      <para>The
<see cref="CreateFiber" /> and
<see cref="ConvertThreadToFiber" /> functions return the fiber address when the fiber is created. The
<b>GetCurrentFiber</b> macro allows you to retrieve the address at any other time.</para>
    </remarks>
    <seealso cref="ConvertThreadToFiber" />
    <seealso cref="CreateFiber" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/fibers">Fibers</seealso>
  </member>
  <member name="Windows.GetFiberData">
    <summary>
      <para>Retrieves the fiber data associated with the current fiber.</para>
    </summary>
    <returns>
      <para>The macro returns the fiber data for the currently running fiber.</para>
    </returns>
    <remarks>
      <para>The fiber data is the value passed to the
<see cref="CreateFiber" /> or
<see cref="ConvertThreadToFiber" /> function in the <i>lpParameter</i> parameter. This value is also received as the parameter to the fiber function. It is stored as part of the fiber state information.</para>
    </remarks>
    <seealso cref="ConvertThreadToFiber" />
    <seealso cref="CreateFiber" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/fibers">Fibers</seealso>
  </member>
  <member name="Windows.Int32x32To64">
    <summary>
      <para>Multiplies two signed 32-bit integers, returning a signed 64-bit integer result. The function performs optimally on 32-bit Windows.</para>
    </summary>
    <param name="a">
      <para>The first signed 32-bit integer for the multiplication operation.</para>
    </param>
    <param name="b">
      <para>The second signed 32-bit integer for the multiplication operation.</para>
    </param>
    <remarks>
      <para>This function is implemented on all platforms by optimal inline code: a single multiply instruction that returns a 64-bit result.</para>
      <para>Please note that the function's return value is a 64-bit value, not a
<see cref="LARGE_INTEGER" /> structure.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/large-integers">Large Integers</seealso>
    <seealso cref="UInt32x32To64" />
  </member>
  <member name="Windows.Int64ShllMod32">
    <summary>
      <para>Performs a left logical shift operation on an unsigned 64-bit integer value. The function provides improved shifting code for left logical shifts where the shift count is in the range 0-31.</para>
    </summary>
    <param name="a">
      <para>The unsigned 64-bit integer to be shifted.</para>
    </param>
    <param name="b">
      <para>The shift count in the range 0-31.</para>
    </param>
    <remarks>
      <para>The shift count is the number of bit positions that the value's bits move.</para>
      <para>In a left logical shift operation on an unsigned value, the value's bits move to the left, and vacated bits on the right side of the value are set to zero.</para>
      <para>A compiler can generate optimal code for a left logical shift operation when the shift count is a constant. However, if the shift count is a variable whose range of values is unknown, the compiler must assume the worst case, leading to non-optimal code: code that calls a subroutine, or code that is inline but branches. By restricting the shift count to the range 0-31, the
<b>Int64ShllMod32</b> function lets the compiler generate optimal or near-optimal code.</para>
      <para>Please note that the
<b>Int64ShllMod32</b> function's <i>Value</i> parameter and return value are 64-bit values, not
<see cref="LARGE_INTEGER" /> structures.</para>
    </remarks>
    <seealso cref="Int64ShraMod32" />
    <seealso cref="Int64ShrlMod32" />
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/large-integers">Large Integers</seealso>
  </member>
  <member name="Windows.Int64ShraMod32">
    <summary>
      <para>Performs a right arithmetic shift operation on a signed 64-bit integer value. The function provides improved shifting code for right arithmetic shifts where the shift count is in the range 0-31.</para>
    </summary>
    <param name="a">
      <para>The signed 64-bit integer to be shifted.</para>
    </param>
    <param name="b">
      <para>The shift count in the range 0-31.</para>
    </param>
    <remarks>
      <para>The shift count is the number of bit positions that the value's bits move.</para>
      <para>In a right arithmetic shift operation on a signed value, the value's bits move to the right, and vacated bits on the left side of the value are set to the value of the sign bit.</para>
      <para>A compiler can generate optimal code for a right arithmetic shift operation when the shift count is a constant. However, if the shift count is a variable whose range of values is unknown, the compiler must assume the worst case, leading to non-optimal code: code that calls a subroutine, or code that is inline but branches. By restricting the shift count to the range 0-31, the
<b>Int64ShraMod32</b> function lets the compiler generate optimal or near-optimal code.</para>
      <para>Please note that the
<b>Int64ShraMod32</b> function's <i>Value</i> parameter and return value are 64-bit values, not
<see cref="LARGE_INTEGER" /> structures.</para>
    </remarks>
    <seealso cref="Int64ShllMod32" />
    <seealso cref="Int64ShrlMod32" />
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/large-integers">Large Integers</seealso>
  </member>
  <member name="Windows.Int64ShrlMod32">
    <summary>
      <para>Performs a right logical shift operation on an unsigned 64-bit integer value. The function provides improved shifting code for right logical shifts where the shift count is in the range 0-31.</para>
    </summary>
    <param name="a">
      <para>The unsigned 64-bit integer to be shifted.</para>
    </param>
    <param name="b">
      <para>The shift count in the range 0-31.</para>
    </param>
    <remarks>
      <para>The shift count is the number of bit positions that the value's bits move.</para>
      <para>In a right logical shift operation on an unsigned value, the value's bits move to the right, and vacated bits on the left side of the value are set to zero.</para>
      <para>A compiler can generate optimal code for a right logical shift operation when the shift count is a constant. However, if the shift count is a variable whose range of values is unknown, the compiler must assume the worst case, leading to non-optimal code: code that calls a subroutine, or code that is inline but branches. By restricting the shift count to the range 0-31, the
<b>Int64ShrlMod32</b> function lets the compiler generate optimal or near-optimal code.</para>
      <para>
        <b>Note</b>  The
<b>Int64ShrlMod32</b> function's <i>Value</i> parameter and return value are 64-bit values, not
<see cref="LARGE_INTEGER" /> structures.</para>
    </remarks>
    <seealso cref="Int64ShllMod32" />
    <seealso cref="Int64ShraMod32" />
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/large-integers">Large Integers</seealso>
  </member>
  <member name="Windows.InterlockedAdd">
    <summary>
      <para>Performs an atomic addition operation on the specified <b>LONG</b> values.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the result of the operation.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/51s265a6(v=vs.85)">_InterlockedAdd</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedAdd64" />
    <seealso cref="InterlockedAddAcquire" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683510(v=vs.85)">InterlockedAddAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972629(v=vs.85)">InterlockedAddNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972630(v=vs.85)">InterlockedAddNoFence64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683513(v=vs.85)">InterlockedAddRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683514(v=vs.85)">InterlockedAddRelease64</seealso>
    <seealso cref="InterlockedExchangeAdd" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedAnd">
    <summary>
      <para>Performs an atomic AND operation on the specified <b>LONG</b> values.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the <a href="https://docs.microsoft.com//previous-versions/dsx2t7yd(v=vs.85)">_InterlockedAnd</a> compiler intrinsic directly.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683539(v=vs.85)">InterlockedAndAcquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683543(v=vs.85)">InterlockedAndRelease</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedAnd16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683521(v=vs.85)">InterlockedAnd16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972631(v=vs.85)">InterlockedAnd16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683525(v=vs.85)">InterlockedAnd16Release</seealso>
    <seealso cref="InterlockedAnd64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683529(v=vs.85)">InterlockedAnd64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972632(v=vs.85)">InterlockedAnd64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683530(v=vs.85)">InterlockedAnd64Release</seealso>
    <seealso cref="InterlockedAnd8" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683535(v=vs.85)">InterlockedAnd8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972633(v=vs.85)">InterlockedAnd8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683537(v=vs.85)">InterlockedAnd8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683539(v=vs.85)">InterlockedAndAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972634(v=vs.85)">InterlockedAndNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683543(v=vs.85)">InterlockedAndRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedAnd16">
    <summary>
      <para>Performs an atomic AND operation on the specified <b>SHORT</b> values.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the <a href="https://docs.microsoft.com//previous-versions/dsx2t7yd(v=vs.85)">_InterlockedAnd16</a> compiler intrinsic directly.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683521(v=vs.85)">InterlockedAnd16Acquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683525(v=vs.85)">InterlockedAnd16Release</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedAnd" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683521(v=vs.85)">InterlockedAnd16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972631(v=vs.85)">InterlockedAnd16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683525(v=vs.85)">InterlockedAnd16Release</seealso>
    <seealso cref="InterlockedAnd64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683529(v=vs.85)">InterlockedAnd64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972632(v=vs.85)">InterlockedAnd64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683530(v=vs.85)">InterlockedAnd64Release</seealso>
    <seealso cref="InterlockedAnd8" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683535(v=vs.85)">InterlockedAnd8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972633(v=vs.85)">InterlockedAnd8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683537(v=vs.85)">InterlockedAnd8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683539(v=vs.85)">InterlockedAndAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972634(v=vs.85)">InterlockedAndNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683543(v=vs.85)">InterlockedAndRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedAnd64">
    <summary>
      <para>Performs an atomic AND operation on the specified <b>LONGLONG</b> values.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/dsx2t7yd(v=vs.85)">_InterlockedAnd64</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683529(v=vs.85)">InterlockedAnd64Acquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683530(v=vs.85)">InterlockedAnd64Release</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedAnd" />
    <seealso cref="InterlockedAnd16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683521(v=vs.85)">InterlockedAnd16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972631(v=vs.85)">InterlockedAnd16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683525(v=vs.85)">InterlockedAnd16Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683529(v=vs.85)">InterlockedAnd64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972632(v=vs.85)">InterlockedAnd64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683530(v=vs.85)">InterlockedAnd64Release</seealso>
    <seealso cref="InterlockedAnd8" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683535(v=vs.85)">InterlockedAnd8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972633(v=vs.85)">InterlockedAnd8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683537(v=vs.85)">InterlockedAnd8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683539(v=vs.85)">InterlockedAndAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972634(v=vs.85)">InterlockedAndNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683543(v=vs.85)">InterlockedAndRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedAnd8">
    <summary>
      <para>Performs an atomic AND operation on the specified <b>char</b> values.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the <a href="https://docs.microsoft.com//previous-versions/dsx2t7yd(v=vs.85)">_InterlockedAnd8</a> compiler intrinsic directly.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683535(v=vs.85)">InterlockedAnd8Acquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683537(v=vs.85)">InterlockedAnd8Release</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedAnd" />
    <seealso cref="InterlockedAnd16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683521(v=vs.85)">InterlockedAnd16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972631(v=vs.85)">InterlockedAnd16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683525(v=vs.85)">InterlockedAnd16Release</seealso>
    <seealso cref="InterlockedAnd64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683529(v=vs.85)">InterlockedAnd64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972632(v=vs.85)">InterlockedAnd64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683530(v=vs.85)">InterlockedAnd64Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683535(v=vs.85)">InterlockedAnd8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972633(v=vs.85)">InterlockedAnd8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683537(v=vs.85)">InterlockedAnd8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683539(v=vs.85)">InterlockedAndAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972634(v=vs.85)">InterlockedAndNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683543(v=vs.85)">InterlockedAndRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedCompareExchange128">
    <summary>
      <para>Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 128-bit values and exchanges with another 128-bit value based on the outcome of the comparison.</para>
      <para>To operate on 16-bit values, use the <see cref="InterlockedCompareExchange16" /> function.</para>
      <para>To operate on 32-bit values, use the <see cref="InterlockedCompareExchange" /> function.</para>
      <para>To operate on 64-bit values, use the <see cref="InterlockedCompareExchange64" /> function.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the destination value.  This parameter is an array of two 64-bit integers considered as a 128-bit field.</para>
    </param>
    <param name="ExchangeHigh">
      <para>The high part of the exchange value.</para>
    </param>
    <param name="ExchangeLow">
      <para>The low part of the exchange value.</para>
    </param>
    <param name="ComparandResult">
      <para>The value to compare to. This parameter is an array of two 64-bit integers considered as a 128-bit field. On output, this is overwritten with the original value of the destination.</para>
    </param>
    <returns>
      <para>The function returns 1 if <i>ComparandResult</i> equals the original value of the <i>Destination</i> parameter, or 0 if <i>ComparandResult</i> does not equal the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The
function compares the <i>Destination</i> value with the <i>ComparandResult</i> value:</para>
      <list type="bullet">
        <item>
          <description>If the <i>Destination</i> value is equal to the <i>ComparandResult</i> value, the <i>ExchangeHigh</i> and <i>ExchangeLow</i> values are stored in the array specified by <i>Destination</i>, and also in the array specified by <i>ComparandResult</i>.</description>
        </item>
        <item>
          <description>Otherwise, the <i>Destination</i> is left unmodified. </description>
        </item>
      </list>
      <para>Regardless of the result of the comparison, the original <i>Destination</i> value is stored in the array specified by <i>ComparandResult</i>.</para>
      <para>The parameters for this function must be aligned on a 16-byte boundary; otherwise, the function will behave unpredictably on x64 systems. See <b>_aligned_malloc</b>.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is only available on x64-based systems, and it is implemented using a compiler intrinsic. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/ttk2z1ws(v=vs.85)">_InterlockedCompareExchange128</a>.</para>
      <para>This function generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683553(v=vs.85)">InterlockedCompare64Exchange128</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedCompareExchange16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972642(v=vs.85)">InterlockedCompareExchange16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972643(v=vs.85)">InterlockedCompareExchange16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972644(v=vs.85)">InterlockedCompareExchange16Release</seealso>
    <seealso cref="InterlockedCompareExchange64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683564(v=vs.85)">InterlockedCompareExchangeAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683566(v=vs.85)">InterlockedCompareExchangeAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972645(v=vs.85)">InterlockedCompareExchangeNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972646(v=vs.85)">InterlockedCompareExchangeNoFence64</seealso>
    <seealso cref="InterlockedCompareExchangePointer" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683570(v=vs.85)">InterlockedCompareExchangePointerAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972647(v=vs.85)">InterlockedCompareExchangePointerNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683571(v=vs.85)">InterlockedCompareExchangePointerRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683574(v=vs.85)">InterlockedCompareExchangeRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683576(v=vs.85)">InterlockedCompareExchangeRelease64</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedCompareExchange16">
    <summary>
      <para>Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 16-bit values and exchanges with another 16-bit value based on the outcome of the comparison.</para>
      <para>To operate on 32-bit values, use the <see cref="InterlockedCompareExchange" /> function.</para>
      <para>To operate on 64-bit values, use the <see cref="InterlockedCompareExchange64" /> function.</para>
      <para>To operate on 128-bit values, use the <see cref="InterlockedCompareExchange128" /> function.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the destination value.</para>
    </param>
    <param name="ExChange">
      <para>The exchange value.</para>
    </param>
    <param name="Comperand">
      <para>The value to compare to <i>Destination</i>.</para>
    </param>
    <returns>
      <para>The function returns the initial value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The
function compares the <i>Destination</i> value with the <i>Comparand</i> value. If the <i>Destination</i> value is equal to the <i>Comparand</i> value, the <i>Exchange</i> value is stored in the address specified by <i>Destination</i>. Otherwise, no operation is performed.</para>
      <para>The parameters for this function must be aligned on a 16-bit boundary; otherwise, the function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See <b>_aligned_malloc</b>.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/ttk2z1ws(v=vs.85)">_InterlockedCompareExchange16</a>.</para>
      <para>This function generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683553(v=vs.85)">InterlockedCompare64Exchange128</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedCompareExchange128" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972642(v=vs.85)">InterlockedCompareExchange16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972643(v=vs.85)">InterlockedCompareExchange16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972644(v=vs.85)">InterlockedCompareExchange16Release</seealso>
    <seealso cref="InterlockedCompareExchange64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683564(v=vs.85)">InterlockedCompareExchangeAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683566(v=vs.85)">InterlockedCompareExchangeAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972645(v=vs.85)">InterlockedCompareExchangeNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972646(v=vs.85)">InterlockedCompareExchangeNoFence64</seealso>
    <seealso cref="InterlockedCompareExchangePointer" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683570(v=vs.85)">InterlockedCompareExchangePointerAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972647(v=vs.85)">InterlockedCompareExchangePointerNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683571(v=vs.85)">InterlockedCompareExchangePointerRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683574(v=vs.85)">InterlockedCompareExchangeRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683576(v=vs.85)">InterlockedCompareExchangeRelease64</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedCompareExchange64">
    <summary>
      <para>Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified 64-bit values and exchanges with another 64-bit value based on the outcome of the comparison.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the destination value.</para>
    </param>
    <param name="ExChange">
      <para>The exchange value.</para>
    </param>
    <param name="Comperand">
      <para>The value to compare to <i>Destination</i>.</para>
    </param>
    <returns>
      <para>The function returns the initial value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The
function compares the <i>Destination</i> value with the <i>Comparand</i> value. If the <i>Destination</i> value is equal to the <i>Comparand</i> value, the <i>Exchange</i> value is stored in the address specified by <i>Destination</i>. Otherwise, no operation is performed.</para>
      <para>The variables for
this function must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See <b>_aligned_malloc</b>.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/ttk2z1ws(v=vs.85)">_InterlockedCompareExchange64</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683566(v=vs.85)">InterlockedCompareExchangeAcquire64</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683576(v=vs.85)">InterlockedCompareExchangeRelease64</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683553(v=vs.85)">InterlockedCompare64Exchange128</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedCompareExchange128" />
    <seealso cref="InterlockedCompareExchange16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972642(v=vs.85)">InterlockedCompareExchange16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972643(v=vs.85)">InterlockedCompareExchange16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972644(v=vs.85)">InterlockedCompareExchange16Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683564(v=vs.85)">InterlockedCompareExchangeAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683566(v=vs.85)">InterlockedCompareExchangeAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972645(v=vs.85)">InterlockedCompareExchangeNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972646(v=vs.85)">InterlockedCompareExchangeNoFence64</seealso>
    <seealso cref="InterlockedCompareExchangePointer" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683570(v=vs.85)">InterlockedCompareExchangePointerAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972647(v=vs.85)">InterlockedCompareExchangePointerNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683571(v=vs.85)">InterlockedCompareExchangePointerRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683574(v=vs.85)">InterlockedCompareExchangeRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683576(v=vs.85)">InterlockedCompareExchangeRelease64</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedCompareExchangePointer">
    <summary>
      <para>Performs an atomic compare-and-exchange operation on the specified values. The function compares two specified pointer values and exchanges with another pointer value based on the outcome of the comparison.</para>
      <para>To operate on non-pointer values, use the <see cref="InterlockedCompareExchange" /> function.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to a pointer to the destination value.</para>
    </param>
    <param name="Exchange">
      <para>The exchange value.</para>
    </param>
    <param name="Comperand">
      <para>The value to compare to <i>Destination</i>.</para>
    </param>
    <returns>
      <para>The function returns the initial value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The function compares the <i>Destination</i> value with the <i>Comparand</i> value. If the <i>Destination</i> value is equal to the <i>Comparand</i> value, the <i>Exchange</i> value is stored in the address specified by <i>Destination</i>. Otherwise, no operation is performed.</para>
      <para>On a 64-bit system, the parameters are 64 bits and must be aligned on 64-bit boundaries; otherwise, the function will behave unpredictably. On a 32-bit system, the parameters are 32 bits and must be aligned on 32-bit boundaries.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/1b4s3xf5(v=vs.85)">_InterlockedCompareExchangePointer</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683570(v=vs.85)">InterlockedCompareExchangePointerAcquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683571(v=vs.85)">InterlockedCompareExchangePointerRelease</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683553(v=vs.85)">InterlockedCompare64Exchange128</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedCompareExchange128" />
    <seealso cref="InterlockedCompareExchange16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972642(v=vs.85)">InterlockedCompareExchange16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972643(v=vs.85)">InterlockedCompareExchange16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972644(v=vs.85)">InterlockedCompareExchange16Release</seealso>
    <seealso cref="InterlockedCompareExchange64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683564(v=vs.85)">InterlockedCompareExchangeAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683566(v=vs.85)">InterlockedCompareExchangeAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972645(v=vs.85)">InterlockedCompareExchangeNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972646(v=vs.85)">InterlockedCompareExchangeNoFence64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683570(v=vs.85)">InterlockedCompareExchangePointerAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972647(v=vs.85)">InterlockedCompareExchangePointerNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683571(v=vs.85)">InterlockedCompareExchangePointerRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683574(v=vs.85)">InterlockedCompareExchangeRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683576(v=vs.85)">InterlockedCompareExchangeRelease64</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedDecrement">
    <summary>
      <para>Decrements (decreases by one) the value of the specified 32-bit variable as an atomic operation.</para>
      <para>To operate on 64-bit values, use the <see cref="InterlockedDecrement64" /> function.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to the variable to be decremented.</para>
    </param>
    <returns>
      <para>The function returns the resulting decremented value.</para>
    </returns>
    <remarks>
      <para>The variable pointed to by the <i>Addend</i> parameter must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See <b>_aligned_malloc</b>.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/f24ya7ct(v=vs.85)">_InterlockedDecrement</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683583(v=vs.85)">InterlockedDecrementAcquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683586(v=vs.85)">InterlockedDecrementRelease</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedDecrement16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972649(v=vs.85)">InterlockedDecrement16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972650(v=vs.85)">InterlockedDecrement16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972651(v=vs.85)">InterlockedDecrement16Release</seealso>
    <seealso cref="InterlockedDecrement64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683583(v=vs.85)">InterlockedDecrementAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683585(v=vs.85)">InterlockedDecrementAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972652(v=vs.85)">InterlockedDecrementNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972653(v=vs.85)">InterlockedDecrementNoFence64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683586(v=vs.85)">InterlockedDecrementRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683588(v=vs.85)">InterlockedDecrementRelease64</seealso>
    <seealso cref="InterlockedIncrement" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedDecrement16">
    <summary>
      <para>Decrements (decreases by one) the value of the specified 16-bit variable as an atomic operation.</para>
      <para>To operate on 32-bit values, use the <see cref="InterlockedDecrement" /> function.</para>
      <para>To operate on 64-bit values, use the <see cref="InterlockedDecrement64" /> function.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to the variable to be decremented.</para>
    </param>
    <returns>
      <para>The function returns the resulting decremented value.</para>
    </returns>
    <remarks>
      <para>The variable pointed to by the <i>Addend</i> parameter must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See <b>_aligned_malloc</b>.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/f24ya7ct(v=vs.85)">_InterlockedDecrement16</a>.</para>
      <para>This function generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedDecrement" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972649(v=vs.85)">InterlockedDecrement16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972650(v=vs.85)">InterlockedDecrement16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972651(v=vs.85)">InterlockedDecrement16Release</seealso>
    <seealso cref="InterlockedDecrement64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683583(v=vs.85)">InterlockedDecrementAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683585(v=vs.85)">InterlockedDecrementAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972652(v=vs.85)">InterlockedDecrementNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972653(v=vs.85)">InterlockedDecrementNoFence64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683586(v=vs.85)">InterlockedDecrementRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683588(v=vs.85)">InterlockedDecrementRelease64</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedDecrement64">
    <summary>
      <para>Decrements (decreases by one) the value of the specified 64-bit variable as an atomic operation.</para>
      <para>To operate on 32-bit values, use the <see cref="InterlockedDecrement" /> function.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to the variable to be decremented.</para>
    </param>
    <returns>
      <para>The function returns the resulting decremented value.</para>
    </returns>
    <remarks>
      <para>The variable pointed to by the <i>Addend</i> parameter must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See <b>_aligned_malloc</b>.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/f24ya7ct(v=vs.85)">_InterlockedDecrement64</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683585(v=vs.85)">InterlockedDecrementAcquire64</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683588(v=vs.85)">InterlockedDecrementRelease64</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedDecrement" />
    <seealso cref="InterlockedDecrement16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972649(v=vs.85)">InterlockedDecrement16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972650(v=vs.85)">InterlockedDecrement16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972651(v=vs.85)">InterlockedDecrement16Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683583(v=vs.85)">InterlockedDecrementAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683585(v=vs.85)">InterlockedDecrementAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972652(v=vs.85)">InterlockedDecrementNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972653(v=vs.85)">InterlockedDecrementNoFence64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683586(v=vs.85)">InterlockedDecrementRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683588(v=vs.85)">InterlockedDecrementRelease64</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedExchange">
    <summary>
      <para>Sets a 32-bit variable to the specified value as an atomic operation.</para>
      <para>To operate on a pointer variable, use the
<see cref="InterlockedExchangePointer" /> function.</para>
      <para>To operate on a 16-bit variable, use the <see cref="InterlockedExchange16" /> function.</para>
      <para>To operate on a 64-bit variable, use the <see cref="InterlockedExchange64" /> function.</para>
    </summary>
    <param name="Target">
      <para>A pointer to the value to be exchanged. The function sets this variable to <i>Value</i>, and returns its prior value.</para>
    </param>
    <param name="Value">
      <para>The value to be exchanged with the value pointed to by <i>Target</i>.</para>
    </param>
    <returns>
      <para>The function returns the initial value of the <i>Target</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//cpp/intrinsics/interlockedexchange-intrinsic-functions">_InterlockedExchange</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683594(v=vs.85)">InterlockedExchangeAcquire</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedExchange" />
    <seealso cref="InterlockedExchange16" />
    <seealso cref="InterlockedExchange16Acquire" />
    <seealso cref="InterlockedExchange16NoFence" />
    <seealso cref="InterlockedExchange64" />
    <seealso cref="InterlockedExchange8" />
    <seealso cref="InterlockedExchangeAcquire" />
    <seealso cref="InterlockedExchangeAcquire64" />
    <seealso cref="InterlockedExchangeAdd" />
    <seealso cref="InterlockedExchangeAdd64" />
    <seealso cref="InterlockedExchangeAddAcquire" />
    <seealso cref="InterlockedExchangeAddAcquire64" />
    <seealso cref="InterlockedExchangeAddNoFence" />
    <seealso cref="InterlockedExchangeAddNoFence64" />
    <seealso cref="InterlockedExchangeAddRelease" />
    <seealso cref="InterlockedExchangeAddRelease64" />
    <seealso cref="InterlockedExchangeNoFence" />
    <seealso cref="InterlockedExchangeNoFence64" />
    <seealso cref="InterlockedExchangePointer" />
    <seealso cref="InterlockedExchangePointerAcquire" />
    <seealso cref="InterlockedExchangePointerNoFence" />
    <seealso cref="InterlockedExchangeSubtract" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedExchange16">
    <summary>
      <para>Sets a 16-bit variable to the specified value as an atomic operation.</para>
      <para>To operate on a 32-bit variable, use the <see cref="InterlockedExchange" /> function.</para>
      <para>To operate on a 64-bit variable, use the <see cref="InterlockedExchange64" /> function.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the value to be exchanged. The function sets this variable to <i>ExChange</i>, and returns its prior value.</para>
    </param>
    <param name="ExChange">
      <para>The value to be exchanged with the value pointed to by <i>Destination</i>.</para>
    </param>
    <returns>
      <para>The function returns the initial value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <b>_InterlockedExchange16</b>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <see cref="InterlockedExchangeAcquire64" /> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedExchange" />
    <seealso cref="InterlockedExchange16Acquire" />
    <seealso cref="InterlockedExchange16NoFence" />
    <seealso cref="InterlockedExchange64" />
    <seealso cref="InterlockedExchange8" />
    <seealso cref="InterlockedExchangeAcquire" />
    <seealso cref="InterlockedExchangeAcquire64" />
    <seealso cref="InterlockedExchangeAdd" />
    <seealso cref="InterlockedExchangeNoFence" />
    <seealso cref="InterlockedExchangeNoFence64" />
    <seealso cref="InterlockedExchangePointer" />
    <seealso cref="InterlockedExchangePointerAcquire" />
    <seealso cref="InterlockedExchangePointerNoFence" />
    <seealso cref="InterlockedExchangeSubtract" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedExchange64">
    <summary>
      <para>Sets a 64-bit variable to the specified value as an atomic operation.</para>
      <para>To operate on a 16-bit variable, use the <see cref="InterlockedExchange16" /> function.</para>
      <para>To operate on a 32-bit variable, use the <see cref="InterlockedExchange" /> function.</para>
    </summary>
    <param name="Target">
      <para>A pointer to the value to be exchanged. The function sets this variable to <i>Value</i>, and returns its prior value.</para>
    </param>
    <param name="Value">
      <para>The value to be exchanged with the value pointed to by <i>Target</i>.</para>
    </param>
    <returns>
      <para>The function returns the initial value of the <i>Target</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <see cref="_InterlockedExchange64" />.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <see cref="InterlockedExchangeAcquire64" /> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedExchange" />
    <seealso cref="InterlockedExchange16" />
    <seealso cref="InterlockedExchange16Acquire" />
    <seealso cref="InterlockedExchange16NoFence" />
    <seealso cref="InterlockedExchange8" />
    <seealso cref="InterlockedExchangeAcquire" />
    <seealso cref="InterlockedExchangeAcquire64" />
    <seealso cref="InterlockedExchangeAdd" />
    <seealso cref="InterlockedExchangeNoFence" />
    <seealso cref="InterlockedExchangeNoFence64" />
    <seealso cref="InterlockedExchangePointer" />
    <seealso cref="InterlockedExchangePointerAcquire" />
    <seealso cref="InterlockedExchangePointerNoFence" />
    <seealso cref="InterlockedExchangeSubtract" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedExchange8">
    <summary>
      <para>Sets an 8-bit variable to the specified value as an atomic operation.</para>
      <para>To operate on a pointer variable, use the
<see cref="InterlockedExchangePointer" /> function.</para>
      <para>To operate on a 16-bit variable, use the <see cref="InterlockedExchange16" /> function.</para>
      <para>To operate on a 32-bit variable, use the <see cref="InterlockedExchange" /> function.</para>
      <para>To operate on a 64-bit variable, use the <see cref="InterlockedExchange64" /> function.</para>
    </summary>
    <param name="Target">
      <para>A pointer to the value to be exchanged. The function sets this variable to <i>Value</i>, and returns its prior value.</para>
    </param>
    <param name="Value">
      <para>The value to be exchanged with the value pointed to by <i>Target</i>.</para>
    </param>
    <returns>
      <para>The function returns the initial value of the <i>Target</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <see cref="_InterlockedExchange8" />.</para>
      <para>This function generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedExchange" />
    <seealso cref="InterlockedExchange16" />
    <seealso cref="InterlockedExchange16Acquire" />
    <seealso cref="InterlockedExchange16NoFence" />
    <seealso cref="InterlockedExchange64" />
    <seealso cref="InterlockedExchangeAcquire" />
    <seealso cref="InterlockedExchangeAcquire64" />
    <seealso cref="InterlockedExchangeAdd" />
    <seealso cref="InterlockedExchangeNoFence" />
    <seealso cref="InterlockedExchangeNoFence64" />
    <seealso cref="InterlockedExchangePointer" />
    <seealso cref="InterlockedExchangePointerAcquire" />
    <seealso cref="InterlockedExchangePointerNoFence" />
    <seealso cref="InterlockedExchangeSubtract" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedExchangeAdd">
    <summary>
      <para>Performs an atomic addition of two 32-bit values.</para>
      <para>To operate  on 64-bit values, use the <see cref="InterlockedExchangeAdd64" /> function.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to a variable. The value of this variable will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The value to be added to the variable pointed to by the <i>Addend</i> parameter.</para>
    </param>
    <returns>
      <para>The function returns the initial value of  the <i>Addend</i> parameter.</para>
    </returns>
    <remarks>
      <para>The
function performs an atomic addition of <i>Value</i> to the value pointed to by <i>Addend</i>. The result is stored in the address specified by <i>Addend</i>. The function returns the initial value of the variable pointed to by <i>Addend</i>.</para>
      <para>The variables for
this function must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See <b>_aligned_malloc</b>.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <see cref="_InterlockedExchangeAdd" /></para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <see cref="InterlockedExchangeAddAcquire" /> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedExchange" />
    <seealso cref="InterlockedExchangeAdd64" />
    <seealso cref="InterlockedExchangeAddAcquire" />
    <seealso cref="InterlockedExchangeAddAcquire64" />
    <seealso cref="InterlockedExchangeAddNoFence" />
    <seealso cref="InterlockedExchangeAddNoFence64" />
    <seealso cref="InterlockedExchangeAddRelease" />
    <seealso cref="InterlockedExchangeAddRelease64" />
    <seealso cref="InterlockedExchangeSubtract" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedExchangeAdd64">
    <summary>
      <para>Performs an atomic addition of two 64-bit values.</para>
      <para>To operate on 32-bit values, use the <see cref="InterlockedExchangeAdd" /> function.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to a variable. The value of this variable will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The value to be added to the variable pointed to by the <i>Addend</i> parameter.</para>
    </param>
    <returns>
      <para>The function returns the initial value of  the <i>Addend</i> parameter.</para>
    </returns>
    <remarks>
      <para>The
function performs an atomic addition of <i>Value</i> to the value pointed to by <i>Addend</i>. The result is stored in the address specified by <i>Addend</i>. The function returns the initial value of the variable pointed to by <i>Addend</i>.</para>
      <para>The variables for this function must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See <b>_aligned_malloc</b>.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <see cref="_InterlockedExchangeAdd64" />.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <see cref="InterlockedExchangeAddAcquire64" /> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedExchange" />
    <seealso cref="InterlockedExchangeAdd" />
    <seealso cref="InterlockedExchangeAddAcquire" />
    <seealso cref="InterlockedExchangeAddAcquire64" />
    <seealso cref="InterlockedExchangeAddNoFence" />
    <seealso cref="InterlockedExchangeAddNoFence64" />
    <seealso cref="InterlockedExchangeAddRelease" />
    <seealso cref="InterlockedExchangeAddRelease64" />
    <seealso cref="InterlockedExchangeSubtract" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedExchangePointer">
    <summary>
      <para>Atomically exchanges a pair of addresses.</para>
    </summary>
    <param name="Target">
      <para>A pointer to the address to exchange. The function sets the  address pointed to by the <i>Target</i> parameter (<code>*Target</code>) to the address that is the value of the <i>Value</i> parameter, and returns the prior value of the <i>Target</i> parameter.</para>
    </param>
    <param name="Value">
      <para>The address to be exchanged with the address pointed to by the <i>Target</i> parameter (<code>*Target</code>).</para>
    </param>
    <returns>
      <para>The function returns the initial address pointed to by the <i>Target</i> parameter.</para>
    </returns>
    <remarks>
      <para>This function copies the address passed as the second parameter to the first and returns the original address of the first.</para>
      <para>On a 64-bit system, the parameters are 64 bits and the <i>Target</i> parameter must be aligned on 64-bit boundaries; otherwise, the function will behave unpredictably. On a 32-bit system, the parameters are 32 bits and the <i>Target</i> parameter must be aligned on 32-bit boundaries.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <see cref="_InterlockedExchangePointer" />.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <see cref="InterlockedExchangePointerAcquire" /> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedExchange" />
    <seealso cref="InterlockedExchange16" />
    <seealso cref="InterlockedExchange16Acquire" />
    <seealso cref="InterlockedExchange16NoFence" />
    <seealso cref="InterlockedExchange64" />
    <seealso cref="InterlockedExchange8" />
    <seealso cref="InterlockedExchangeAcquire" />
    <seealso cref="InterlockedExchangeAcquire64" />
    <seealso cref="InterlockedExchangeAdd" />
    <seealso cref="InterlockedExchangeNoFence" />
    <seealso cref="InterlockedExchangeNoFence64" />
    <seealso cref="InterlockedExchangePointerAcquire" />
    <seealso cref="InterlockedExchangePointerNoFence" />
    <seealso cref="InterlockedExchangeSubtract" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedIncrement">
    <summary>
      <para>Increments (increases by one) the value of the specified 32-bit variable as an atomic operation.</para>
      <para>To operate on 64-bit values, use the <see cref="InterlockedIncrement64" /> function.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to the variable to be incremented.</para>
    </param>
    <returns>
      <para>The function returns the resulting incremented value.</para>
    </returns>
    <remarks>
      <para>The variable pointed to by the <i>Addend</i> parameter must be aligned on a 32-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See <b>_aligned_malloc</b>.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/2ddez55b(v=vs.85)">_InterlockedIncrement</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683618(v=vs.85)">InterlockedIncrementAcquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683622(v=vs.85)">InterlockedIncrementRelease</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedDecrement" />
    <seealso cref="InterlockedIncrement16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972663(v=vs.85)">InterlockedIncrement16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972664(v=vs.85)">InterlockedIncrement16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972665(v=vs.85)">InterlockedIncrement16Release</seealso>
    <seealso cref="InterlockedIncrement64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683618(v=vs.85)">InterlockedIncrementAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683620(v=vs.85)">InterlockedIncrementAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972667(v=vs.85)">InterlockedIncrementNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972668(v=vs.85)">InterlockedIncrementNoFence64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683622(v=vs.85)">InterlockedIncrementRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683624(v=vs.85)">InterlockedIncrementRelease64</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedIncrement16">
    <summary>
      <para>Increments (increases by one) the value of the specified 16-bit variable as an atomic operation.</para>
      <para>To operate on 32-bit values, use the <see cref="InterlockedIncrement" /> function.</para>
      <para>To operate on 64-bit values, use the <see cref="InterlockedIncrement64" /> function.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to the variable to be incremented.</para>
    </param>
    <returns>
      <para>The function returns the resulting incremented value.</para>
    </returns>
    <remarks>
      <para>The variable pointed to by the <i>Addend</i> parameter must be aligned on a 16-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See <b>_aligned_malloc</b>.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/2ddez55b(v=vs.85)">_InterlockedIncrement16</a>.</para>
      <para>This function generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedDecrement" />
    <seealso cref="InterlockedIncrement" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972663(v=vs.85)">InterlockedIncrement16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972664(v=vs.85)">InterlockedIncrement16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972665(v=vs.85)">InterlockedIncrement16Release</seealso>
    <seealso cref="InterlockedIncrement64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683618(v=vs.85)">InterlockedIncrementAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683620(v=vs.85)">InterlockedIncrementAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972667(v=vs.85)">InterlockedIncrementNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972668(v=vs.85)">InterlockedIncrementNoFence64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683622(v=vs.85)">InterlockedIncrementRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683624(v=vs.85)">InterlockedIncrementRelease64</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedIncrement64">
    <summary>
      <para>Increments (increases by one) the value of the specified 64-bit variable as an atomic operation.</para>
      <para>To operate on 32-bit values, use the <see cref="InterlockedIncrement" /> function.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to the variable to be incremented.</para>
    </param>
    <returns>
      <para>The function returns the resulting incremented value.</para>
    </returns>
    <remarks>
      <para>The variable pointed to by the <i>Addend</i> parameter must be aligned on a 64-bit boundary; otherwise, this function will behave unpredictably on multiprocessor x86 systems and any non-x86 systems. See <b>_aligned_malloc</b>.</para>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/2ddez55b(v=vs.85)">_InterlockedIncrement64</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683620(v=vs.85)">InterlockedIncrementAcquire64</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683624(v=vs.85)">InterlockedIncrementRelease64</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedDecrement" />
    <seealso cref="InterlockedIncrement" />
    <seealso cref="InterlockedIncrement16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972663(v=vs.85)">InterlockedIncrement16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972664(v=vs.85)">InterlockedIncrement16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972665(v=vs.85)">InterlockedIncrement16Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683618(v=vs.85)">InterlockedIncrementAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683620(v=vs.85)">InterlockedIncrementAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972667(v=vs.85)">InterlockedIncrementNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972668(v=vs.85)">InterlockedIncrementNoFence64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683622(v=vs.85)">InterlockedIncrementRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683624(v=vs.85)">InterlockedIncrementRelease64</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedOr">
    <summary>
      <para>Performs an atomic OR operation on the specified <b>LONG</b> values. The function prevents more than one thread from using the same variable simultaneously.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the <a href="https://docs.microsoft.com//previous-versions/b11125ze(v=vs.85)">_InterlockedOr</a> compiler intrinsic directly.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683643(v=vs.85)">InterlockedOrAcquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683646(v=vs.85)">InterlockedOrRelease</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedOr16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683629(v=vs.85)">InterlockedOr16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972669(v=vs.85)">InterlockedOr16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683631(v=vs.85)">InterlockedOr16Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683633(v=vs.85)">InterlockedOr64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683634(v=vs.85)">InterlockedOr64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972670(v=vs.85)">InterlockedOr64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683636(v=vs.85)">InterlockedOr64Release</seealso>
    <seealso cref="InterlockedOr8" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683639(v=vs.85)">InterlockedOr8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972671(v=vs.85)">InterlockedOr8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683640(v=vs.85)">InterlockedOr8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683643(v=vs.85)">InterlockedOrAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972672(v=vs.85)">InterlockedOrNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683646(v=vs.85)">InterlockedOrRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedOr16">
    <summary>
      <para>Performs an atomic OR operation on the specified <b>SHORT</b> values. The function prevents more than one thread from using the same variable simultaneously.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the <a href="https://docs.microsoft.com//previous-versions/b11125ze(v=vs.85)">_InterlockedOr16</a> compiler intrinsic directly.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683629(v=vs.85)">InterlockedOr16Acquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683631(v=vs.85)">InterlockedOr16Release</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedOr" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683629(v=vs.85)">InterlockedOr16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972669(v=vs.85)">InterlockedOr16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683631(v=vs.85)">InterlockedOr16Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683633(v=vs.85)">InterlockedOr64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683634(v=vs.85)">InterlockedOr64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972670(v=vs.85)">InterlockedOr64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683636(v=vs.85)">InterlockedOr64Release</seealso>
    <seealso cref="InterlockedOr8" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683639(v=vs.85)">InterlockedOr8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972671(v=vs.85)">InterlockedOr8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683640(v=vs.85)">InterlockedOr8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683643(v=vs.85)">InterlockedOrAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972672(v=vs.85)">InterlockedOrNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683646(v=vs.85)">InterlockedOrRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedOr64">
    <summary>
      <para>Performs an atomic OR operation on the specified <b>LONGLONG</b> values. The function prevents more than one thread from using the same variable simultaneously.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//cpp/intrinsics/interlockedor-intrinsic-functions">_InterlockedOr64</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683634(v=vs.85)">InterlockedOr64Acquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683636(v=vs.85)">InterlockedOr64Release</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedOr" />
    <seealso cref="InterlockedOr16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683629(v=vs.85)">InterlockedOr16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972669(v=vs.85)">InterlockedOr16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683631(v=vs.85)">InterlockedOr16Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683634(v=vs.85)">InterlockedOr64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972670(v=vs.85)">InterlockedOr64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683636(v=vs.85)">InterlockedOr64Release</seealso>
    <seealso cref="InterlockedOr8" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683639(v=vs.85)">InterlockedOr8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972671(v=vs.85)">InterlockedOr8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683640(v=vs.85)">InterlockedOr8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683643(v=vs.85)">InterlockedOrAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972672(v=vs.85)">InterlockedOrNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683646(v=vs.85)">InterlockedOrRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedOr8">
    <summary>
      <para>Performs an atomic OR operation on the specified <b>char</b> values. The function prevents more than one thread from using the same variable simultaneously.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the <a href="https://docs.microsoft.com//previous-versions/b11125ze(v=vs.85)">_InterlockedOr8</a> compiler intrinsic directly.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683639(v=vs.85)">InterlockedOr8Acquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683640(v=vs.85)">InterlockedOr8Release</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedOr" />
    <seealso cref="InterlockedOr16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683629(v=vs.85)">InterlockedOr16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972669(v=vs.85)">InterlockedOr16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683631(v=vs.85)">InterlockedOr16Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683633(v=vs.85)">InterlockedOr64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683634(v=vs.85)">InterlockedOr64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972670(v=vs.85)">InterlockedOr64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683636(v=vs.85)">InterlockedOr64Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683639(v=vs.85)">InterlockedOr8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972671(v=vs.85)">InterlockedOr8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683640(v=vs.85)">InterlockedOr8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683643(v=vs.85)">InterlockedOrAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972672(v=vs.85)">InterlockedOrNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683646(v=vs.85)">InterlockedOrRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedXor">
    <summary>
      <para>Performs an atomic XOR operation on the specified <b>LONG</b> values. The function prevents more than one thread from using the same variable simultaneously.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the <a href="https://docs.microsoft.com//previous-versions/a8swb4hb(v=vs.85)">_InterlockedXor</a> compiler intrinsic directly.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684117(v=vs.85)">InterlockedXorAcquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684118(v=vs.85)">InterlockedXorRelease</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedXor16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684026(v=vs.85)">InterlockedXor16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972674(v=vs.85)">InterlockedXor16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684033(v=vs.85)">InterlockedXor16Release</seealso>
    <seealso cref="InterlockedXor64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684107(v=vs.85)">InterlockedXor64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972675(v=vs.85)">InterlockedXor64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684108(v=vs.85)">InterlockedXor64Release</seealso>
    <seealso cref="InterlockedXor8" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684112(v=vs.85)">InterlockedXor8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972676(v=vs.85)">InterlockedXor8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684113(v=vs.85)">InterlockedXor8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684117(v=vs.85)">InterlockedXorAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972677(v=vs.85)">InterlockedXorNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684118(v=vs.85)">InterlockedXorRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedXor16">
    <summary>
      <para>Performs an atomic XOR operation on the specified <b>SHORT</b> values. The function prevents more than one thread from using the same variable simultaneously.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the <a href="https://docs.microsoft.com//previous-versions/a8swb4hb(v=vs.85)">_InterlockedXor16</a> compiler intrinsic directly.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684026(v=vs.85)">InterlockedXor16Acquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684033(v=vs.85)">InterlockedXor16Release</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso href="https://docs.microsoft.com//windows-hardware/drivers/ddi/wdm/nf-wdm-interlockedxor">InterlockedXor</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684026(v=vs.85)">InterlockedXor16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972674(v=vs.85)">InterlockedXor16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684033(v=vs.85)">InterlockedXor16Release</seealso>
    <seealso cref="InterlockedXor64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684107(v=vs.85)">InterlockedXor64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972675(v=vs.85)">InterlockedXor64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684108(v=vs.85)">InterlockedXor64Release</seealso>
    <seealso cref="InterlockedXor8" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684112(v=vs.85)">InterlockedXor8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972676(v=vs.85)">InterlockedXor8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684113(v=vs.85)">InterlockedXor8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684117(v=vs.85)">InterlockedXorAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972677(v=vs.85)">InterlockedXorNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684118(v=vs.85)">InterlockedXorRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedXor64">
    <summary>
      <para>Performs an atomic XOR operation on the specified <b>LONGLONG</b> values. The function prevents more than one thread from using the same variable simultaneously.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/a8swb4hb(v=vs.85)">_InterlockedXor64</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684107(v=vs.85)">InterlockedXor64Acquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684108(v=vs.85)">InterlockedXor64Release</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso href="https://docs.microsoft.com//windows-hardware/drivers/ddi/wdm/nf-wdm-interlockedxor">InterlockedXor</seealso>
    <seealso cref="InterlockedXor16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684026(v=vs.85)">InterlockedXor16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972674(v=vs.85)">InterlockedXor16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684033(v=vs.85)">InterlockedXor16Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684107(v=vs.85)">InterlockedXor64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972675(v=vs.85)">InterlockedXor64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684108(v=vs.85)">InterlockedXor64Release</seealso>
    <seealso cref="InterlockedXor8" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684112(v=vs.85)">InterlockedXor8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972676(v=vs.85)">InterlockedXor8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684113(v=vs.85)">InterlockedXor8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684117(v=vs.85)">InterlockedXorAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972677(v=vs.85)">InterlockedXorNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684118(v=vs.85)">InterlockedXorRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedXor8">
    <summary>
      <para>Performs an atomic XOR operation on the specified <b>char</b> values. The function prevents more than one thread from using the same variable simultaneously.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the original value of the <i>Destination</i> parameter.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>For the Intel Itanium-based systems and x64 architectures, this function is implemented using the compiler intrinsic. For the x86 architecture, use the <a href="https://docs.microsoft.com//previous-versions/a8swb4hb(v=vs.85)">_InterlockedXor8</a> compiler intrinsic directly.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Itanium-based systems:  </b>For performance-critical applications, use <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684112(v=vs.85)">InterlockedXor8Acquire</a> or <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684113(v=vs.85)">InterlockedXor8Release</a> instead.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedXor" />
    <seealso cref="InterlockedXor16" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684026(v=vs.85)">InterlockedXor16Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972674(v=vs.85)">InterlockedXor16NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684033(v=vs.85)">InterlockedXor16Release</seealso>
    <seealso cref="InterlockedXor64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684107(v=vs.85)">InterlockedXor64Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972675(v=vs.85)">InterlockedXor64NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684108(v=vs.85)">InterlockedXor64Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684112(v=vs.85)">InterlockedXor8Acquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972676(v=vs.85)">InterlockedXor8NoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684113(v=vs.85)">InterlockedXor8Release</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684117(v=vs.85)">InterlockedXorAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972677(v=vs.85)">InterlockedXorNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms684118(v=vs.85)">InterlockedXorRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.IsReparseTagMicrosoft">
    <summary>
      <para>Determines whether a reparse point tag indicates a Microsoft reparse point.</para>
    </summary>
    <param name="_tag">
      <para>The reparse point tag to be tested.</para>
    </param>
    <remarks>
      <para>If the Microsoft tag bit is set, Microsoft provides the tag. All other tags must use zero for this bit.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_get_reparse_point">FSCTL_GET_REPARSE_POINT</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/reparse-points">Reparse Points</seealso>
  </member>
  <member name="Windows.IsReparseTagNameSurrogate">
    <summary>
      <para>Determines whether a tag's associated reparse point is a surrogate for another named entity (for example, a mounted folder).</para>
    </summary>
    <param name="_tag">
      <para>The reparse point tag to be tested for surrogacy.</para>
    </param>
    <remarks>
      <para>If the surrogacy bit is set, the file or directory represents another named entity in the system, such as a mounted folder that associates this directory with another volume. For more information on volume mounting, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winioctl/ni-winioctl-fsctl_get_reparse_point">FSCTL_GET_REPARSE_POINT</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/reparse-points">Reparse Points</seealso>
  </member>
  <member name="Windows.LANGIDFROMLCID">
    <summary>
      <para>Retrieves a <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> from a <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-identifiers">locale identifier</a>.</para>
    </summary>
    <param name="lcid">
      <para>Locale identifier. You can use the <see cref="MAKELCID" /> macro to create a locale identifier or use one of the following predefined values.</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
          </description>
        </item>
      </list>
      <b>Windows Vista:</b> The following custom locale identifiers are also supported.
<list type="bullet"><item><description><a href="https://docs.microsoft.com//windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a></description></item><item><description><a href="https://docs.microsoft.com//windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a></description></item><item><description><a href="https://docs.microsoft.com//windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a></description></item></list></param>
    <seealso cref="MAKELANGID" />
    <seealso cref="MAKELCID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support-macros">National Language Support Macros</seealso>
    <seealso cref="PRIMARYLANGID" />
    <seealso cref="SUBLANGID" />
  </member>
  <member name="Windows.MAKELANGID">
    <summary>
      <para>Creates a <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> from a primary language identifier and a sublanguage identifier.</para>
    </summary>
    <param name="p">
      <para>Primary language identifier. This identifier can be a predefined value or a value for a user-defined primary language. For a user-defined language, the identifier is a value in the range 0x0200 to 0x03FF. All other values are reserved for operating system use. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifier-constants-and-strings">Language Identifier Constants and Strings</a>.</para>
    </param>
    <param name="s">
      <para>Sublanguage identifier. This parameter can be a predefined sublanguage identifier or a user-defined sublanguage. For a user-defined sublanguage, the identifier is a value in the range 0x20 to 0x3F. All other values are reserved for operating system use. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifier-constants-and-strings">Language Identifier Constants and Strings</a>.</para>
    </param>
    <remarks>
      <para>The following table shows combinations of <i>usPrimaryLanguage</i> and <i>usSubLanguage</i> that have special meaning.</para>
      <list type="table">
        <listheader>
          <description>Primary language identifier</description>
          <description>Sublanguage identifier</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>LANG_NEUTRAL</description>
          <description>SUBLANG_NEUTRAL</description>
          <description>Language neutral</description>
        </item>
        <item>
          <description>LANG_NEUTRAL</description>
          <description>SUBLANG_DEFAULT</description>
          <description>User default language</description>
        </item>
        <item>
          <description>LANG_NEUTRAL</description>
          <description>SUBLANG_SYS_DEFAULT</description>
          <description>System default language</description>
        </item>
        <item>
          <description>LANG_NEUTRAL</description>
          <description>SUBLANG_CUSTOM_DEFAULT</description>
          <description>
            <b>Windows Vista and later:</b> Default custom locale</description>
        </item>
        <item>
          <description>LANG_NEUTRAL</description>
          <description>SUBLANG_CUSTOM_UNSPECIFIED</description>
          <description>
            <b>Windows Vista and later:</b> Unspecified custom locale</description>
        </item>
        <item>
          <description>LANG_NEUTRAL</description>
          <description>SUBLANG_UI_CUSTOM_DEFAULT</description>
          <description>
            <b>Windows Vista and later:</b> Default custom Multilingual User Interface locale</description>
        </item>
      </list>
    </remarks>
    <seealso cref="EnumSystemLocales" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support-macros">National Language Support Macros</seealso>
    <seealso cref="PRIMARYLANGID" />
    <seealso cref="SUBLANGID" />
  </member>
  <member name="Windows.MAKELCID">
    <summary>
      <para>Creates a <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-identifiers">locale identifier</a> from a <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> and a <a href="https://docs.microsoft.com//windows/desktop/Intl/sort-order-identifiers">sort order identifier</a>.</para>
    </summary>
    <param name="lgid">
      <para>
        <a href="https://docs.microsoft.com//windows/win32/intl/language-identifiers">Language identifier</a>. This identifier is a combination of a primary language identifier and a sublanguage identifier and is usually created by using the <see cref="MAKELANGID" /> macro.</para>
    </param>
    <param name="srtid">
      <para>
        <a href="https://docs.microsoft.com//windows/win32/intl/sort-order-identifiers">Sort order identifier</a>.</para>
    </param>
    <seealso cref="LANGIDFROMLCID" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support-macros">National Language Support Macros</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/intl/language-identifier-constants-and-strings">Language Identifier Constants and Strings</seealso>
    <seealso cref="SORTIDFROMLCID" />
  </member>
  <member name="Windows.MAKESORTLCID">
    <summary>
      <para>Constructs a <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-identifiers">locale identifier</a> (LCID) from a <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a>, a <a href="https://docs.microsoft.com//windows/desktop/Intl/sort-order-identifiers">sort order identifier</a>, and the sort version.</para>
    </summary>
    <param name="lgid">
      <para>Language identifier. This parameter is a combination of a primary language identifier and a sublanguage identifier and is usually created by using the <see cref="MAKELANGID" /> macro.</para>
    </param>
    <param name="srtid">
      <para>Sort order identifier.</para>
    </param>
    <param name="ver">
      <para>Reserved; must be 0.</para>
    </param>
    <remarks>
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a> represents a special locale-independent locale identifier. It is designed for system-level functions that require consistent results regardless of the locale that the user has chosen, for example, sorting in the file system. Typically, an application does not use LOCALE_INVARIANT because it expects the results of an action to depend on the rules governing each individual locale.</para>
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a> is composed of a language identifier consisting of LANG_INVARIANT for the primary language and SUBLANG_NEUTRAL for the sublanguage. SORT_DEFAULT is used for the sort order identifier.</para>
    </remarks>
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support-macros">National Language Support Macros</seealso>
  </member>
  <member name="Windows.MemoryBarrier">
    <summary>
      <para>Creates a hardware memory barrier (fence) that prevents the CPU from re-ordering read and write operations. It may also prevent the compiler from re-ordering read and write operations.</para>
    </summary>
    <remarks>
      <para>Use this macro or the interlocked functions when the order of memory read and write operations is critical for program operation.</para>
      <para>The <b>_ReadBarrier</b>, <b>_WriteBarrier</b>, and <b>_ReadWriteBarrier</b> compiler intrinsics prevent compiler re-ordering only. With Visual Studio 2003, <b>volatile</b> to <b>volatile</b> references are ordered; the compiler will not re-order <b>volatile</b> variable access. With Visual Studio 2005, the compiler also uses acquire semantics for read operations on <b>volatile</b> variables and release semantics for write operations on <b>volatile</b> variables (when supported by the CPU). For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-and-multiprocessor-issues">Synchronization and Multiprocessor Issues</a>.</para>
      <para>This macro can be called on all processor platforms where Windows is supported, but it  has no effect on some platforms. The definition varies from platform to platform. The following are some definitions of this macro in Winnt.h.</para>
      <code>
#ifdef _AMD64_
#define MemoryBarrier __faststorefence
#endif

#ifdef _IA64_
#define MemoryBarrier __mf
#endif

// x86

FORCEINLINE
VOID
MemoryBarrier (
    VOID
    )
{
    LONG Barrier;
    __asm {
        xchg Barrier, eax
    }
}
</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
  </member>
  <member name="Windows.Multiply128">
    <summary>
      <para>Multiplies two 64-bit integers to produce a 128-bit integer.</para>
    </summary>
    <param name="Multiplier">
      <para>The first integer.</para>
    </param>
    <param name="Multiplicand">
      <para>The second integer.</para>
    </param>
    <param name="HighProduct">
      <para>The high 64 bits of the product.</para>
    </param>
    <returns>
      <para>The low 64 bits of the product.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//previous-versions/82cxdw50(v=vs.85)">__mul128</seealso>
  </member>
  <member name="Windows.MultiplyExtract128">
    <summary>
      <para>Multiplies two 64-bit integers to produce a 128-bit integer, shifts the product to the right by the specified number of bits, and returns the low 64 bits of the result.</para>
    </summary>
    <param name="Multiplier">
      <para>The first integer.</para>
    </param>
    <param name="Multiplicand">
      <para>The second integer.</para>
    </param>
    <param name="Shift">
      <para>The number of bits to shift.</para>
    </param>
    <returns>
      <para>The low 64 bits of the result.</para>
    </returns>
  </member>
  <member name="Windows.MultiplyHigh">
    <summary>
      <para>Multiplies two 64-bit integers to produce a 128-bit integer and gets the high 64 bits.</para>
    </summary>
    <param name="Multiplier">
      <para>The first integer.</para>
    </param>
    <param name="Multiplicand">
      <para>The second integer.</para>
    </param>
    <returns>
      <para>The high 64 bits of the product.</para>
    </returns>
  </member>
  <member name="Windows.NtCurrentTeb">
    <summary>
      <para>The <b>NtCurrentTeb</b> routine returns a pointer to the Thread Environment Block (<see cref="TEB" />) of the current thread.</para>
    </summary>
    <returns>
      <para>A pointer to the thread environment block of the current thread.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows-hardware/drivers/kernel/ntxxx-routines">NtXxx Routines</seealso>
  </member>
  <member name="Windows.PopulationCount64">
    <summary>
      <para>Counts the number of one bits (population count) in a 64-bit unsigned integer.</para>
    </summary>
    <param name="operand">
      <para>The operand.</para>
    </param>
    <returns>
      <para>The count of one bits.</para>
    </returns>
  </member>
  <member name="Windows.PreFetchCacheLine">
    <summary>
      <para>Indicates to the processor that a cache line will be needed in the near future.</para>
    </summary>
    <param name="l">
      <para>How often the cache line will be needed. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>PF_TEMPORAL_LEVEL_1</b>
          </description>
          <description>
            <para>The cache line should be loaded into all caches and is likely to be accessed multiple times.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PF_NON_TEMPORAL_LEVEL_ALL</b>
          </description>
          <description>
            <para>The cache line is not likely to be needed again after the first reference.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="a">
      <para>The address of the cache line to be loaded. This address is not required to be on a cache line boundary.</para>
    </param>
    <remarks>
      <para>This macro can be called on all processor platforms where Windows is supported, but it  has no effect on some platforms.  The definition varies from platform to platform.  The following are some definitions of this macro in Winnt.h:</para>
      <code>#define PreFetchCacheLine(l, a)  _mm_prefetch((CHAR CONST *) a, l)

#define PreFetchCacheLine(l, a)

#define PreFetchCacheLine  __lfetch

</code>
    </remarks>
  </member>
  <member name="Windows.PRIMARYLANGID">
    <summary>
      <para>Extracts a primary language identifier from a <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a>.</para>
    </summary>
    <param name="lgid">
      <para>Language identifier. This value is a combination of a primary language identifier and a sublanguage identifier and is usually created by using the <see cref="MAKELANGID" /> macro.</para>
    </param>
    <seealso cref="EnumSystemLocales" />
    <seealso cref="LANGIDFROMLCID" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support-macros">National Language Support Macros</seealso>
    <seealso cref="SUBLANGID" />
  </member>
  <member name="Windows.RtlAddFunctionTable">
    <summary>
      <para>Adds a dynamic function table to the dynamic function table list.</para>
    </summary>
    <param name="FunctionTable">
      <para>A pointer to an array of function entries. For a definition of the
<b>PRUNTIME_FUNCTION</b> type, see WinNT.h. For more information on runtime
function entries, see the calling convention documentation for the processor.</para>
    </param>
    <param name="EntryCount">
      <para>The number of entries in the <i>FunctionTable</i> array.</para>
    </param>
    <param name="BaseAddress">
      <para>The base address to use when computing full virtual addresses from relative virtual addresses of function
table entries.</para>
      <h4>- TargetGp [in]</h4>
      <para>The target global pointer. This is part of the Intel IPF calling convention. It is a pointer to a data
area in an image.</para>
      <para>This parameter does not exist on x64.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. Otherwise, the return value
is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Function tables are used on 64-bit Windows to determine how to unwind or walk the stack. These tables are
usually generated by the compiler and stored as part of the image. However, applications must provide the
function table for dynamically generated code. For more information about function tables, see the architecture
guide for your system.</para>
      <para>This function is useful for code that is generated from a template or generated only once during the life of
the process. For more dynamically generated code, use the
<see cref="RtlInstallFunctionTableCallback" /></para>
      <para>function.</para>
    </remarks>
    <seealso cref="RtlDeleteFunctionTable" />
    <seealso cref="RtlInstallFunctionTableCallback" />
  </member>
  <member name="Windows.RtlAddGrowableFunctionTable">
    <summary>
      <para>Informs the system of a dynamic function table representing a region of memory containing
code.</para>
    </summary>
    <param name="DynamicTable">
      <para>A pointer to a variable that receives an opaque reference to the newly-added table on success.</para>
    </param>
    <param name="FunctionTable">
      <para>A pointer to a partially-filled array of
<see cref="RUNTIME_FUNCTION" /> entries which provides
unwind information for the region of code. The entries in this array must remain sorted in ascending order of
the <b>BeginAddress</b> members.</para>
    </param>
    <param name="EntryCount">
      <para>The number of entries currently populated in the function table. This value may be zero.</para>
    </param>
    <param name="MaximumEntryCount">
      <para>The capacity of the function table.</para>
    </param>
    <param name="RangeBase">
      <para>The beginning of the memory range described by the function table.</para>
    </param>
    <param name="RangeEnd">
      <para>The end of the memory range described by the function table.</para>
    </param>
    <returns>
      <para>This function returns zero on success. (More detail).</para>
      <para>See
<a href="https://docs.microsoft.com//openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55">http://msdn.microsoft.com/en-us/library/cc704588(PROT.10).aspx</a></para>
      <para>for a list of <b>NTSTATUS</b> values.</para>
    </returns>
    <remarks>
      <para>The function table can grow as code is added to the memory region. The entries in the table must be sorted.
This table is used for dispatching exceptions through runtime-generated code and for collecting stack
backtraces.</para>
    </remarks>
  </member>
  <member name="Windows.RtlCaptureContext">
    <summary>
      <para>Retrieves a
context record in the context of the caller.</para>
    </summary>
    <param name="ContextRecord">
      <para>A pointer to a <see cref="CONTEXT" /> structure.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
    </returns>
    <seealso cref="CONTEXT" />
    <seealso cref="RtlRestoreContext" />
  </member>
  <member name="Windows.CaptureStackBackTrace">
    <summary>
      <para>The <b>RtlCaptureStackBackTrace</b> routine captures a stack back trace by walking up the stack and recording the information for each frame.</para>
    </summary>
    <param name="FramesToSkip">
      <para>The number of frames to skip from the start of the back trace.</para>
    </param>
    <param name="FramesToCapture">
      <para>The number of frames to be captured.</para>
    </param>
    <param name="BackTrace">
      <para>An array of pointers captured from the current stack trace.</para>
    </param>
    <param name="BackTraceHash">
      <para>An optional value that can be used to organize hash tables. If this parameter is <b>NULL</b>, no hash value is computed.</para>
      <para>This value is calculated based on the values of the pointers returned in the <i>BackTrace</i> array. Two identical stack traces will generate identical hash values.</para>
    </param>
    <returns>
      <para>The number of captured frames.</para>
    </returns>
  </member>
  <member name="Windows.RtlCaptureStackBackTrace">
    <summary>
      <para>The <b>RtlCaptureStackBackTrace</b> routine captures a stack back trace by walking up the stack and recording the information for each frame.</para>
    </summary>
    <param name="FramesToSkip">
      <para>The number of frames to skip from the start of the back trace.</para>
    </param>
    <param name="FramesToCapture">
      <para>The number of frames to be captured.</para>
    </param>
    <param name="BackTrace">
      <para>An array of pointers captured from the current stack trace.</para>
    </param>
    <param name="BackTraceHash">
      <para>An optional value that can be used to organize hash tables. If this parameter is <b>NULL</b>, no hash value is computed.</para>
      <para>This value is calculated based on the values of the pointers returned in the <i>BackTrace</i> array. Two identical stack traces will generate identical hash values.</para>
    </param>
    <returns>
      <para>The number of captured frames.</para>
    </returns>
  </member>
  <member name="Windows.RtlDeleteFunctionTable">
    <summary>
      <para>Removes a dynamic function table from the dynamic function table list.</para>
    </summary>
    <param name="FunctionTable">
      <para>A pointer to an array of function entries that were previously passed to
<see cref="RtlAddFunctionTable" /> or an identifier previously
passed to
<see cref="RtlInstallFunctionTableCallback" />. For
a definition of the <b>PRUNTIME_FUNCTION</b> type, see WinNT.h.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. Otherwise, the return value
is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Function tables are used on 64-bit Windows to determine how to unwind or walk the stack. These tables are
usually generated by the compiler and stored as part of the image. However, applications must provide the function
table for dynamically generated code. For more information about function tables, see the architecture guide for
your system.</para>
    </remarks>
    <seealso cref="RtlAddFunctionTable" />
    <seealso cref="RtlInstallFunctionTableCallback" />
  </member>
  <member name="Windows.RtlDeleteGrowableFunctionTable">
    <summary>
      <para>Informs the system that a previously reported dynamic function table is no longer in use.</para>
    </summary>
    <param name="DynamicTable">
      <para>An opaque reference returned by <see cref="RtlAddGrowableFunctionTable." /></para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
    </returns>
  </member>
  <member name="Windows.RtlFirstEntrySList">
    <summary>
      <para>Retrieves the first entry in a singly linked list. Access to the list is synchronized on a multiprocessor system.</para>
    </summary>
    <param name="ListHead">
      <para>A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list. This structure is for system use only.</para>
      <para>The list must  be previously initialized with the <see cref="InitializeSListHead" /> function.</para>
    </param>
    <returns>
      <para>The return value is a pointer to the first entry in the list. If the list is empty, the return value is <b>NULL</b>.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-singly-linked-lists">Interlocked Singly Linked Lists</seealso>
  </member>
  <member name="Windows.RtlGrowFunctionTable">
    <summary>
      <para>Reports that a dynamic function table has increased in size.</para>
    </summary>
    <param name="DynamicTable">
      <para>An opaque reference returned by <see cref="RtlAddGrowableFunctionTable." />.</para>
    </param>
    <param name="NewEntryCount">
      <para>The new number of entries in the <a href="https://docs.microsoft.com//cpp/build/struct-runtime-function">RUNTIME_FUNCTION</a> array. This must be greater than the previously reported size of the array.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
    </returns>
    <remarks>
      <para>
        <b>RtlGrowFunctionTable</b> should be called after populating the corresponding entries in the <a href="https://docs.microsoft.com//cpp/build/struct-runtime-function">RUNTIME_FUNCTION</a> array specified in <see cref="RtlAddGrowableFunctionTable." /></para>
    </remarks>
  </member>
  <member name="Windows.RtlInitializeSListHead">
    <summary>
      <para>Initializes the head of a singly linked list.</para>
    </summary>
    <param name="ListHead">
      <para>A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list. This structure is for system use only.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
    </returns>
    <remarks>
      <para>Calls to the <see cref="InitializeSListHead" /> function are forwarded to the <b>RtlInitializeSListHead</b> function. Applications should call <b>InitializeSListHead</b> instead of calling this function directly.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-singly-linked-lists">Interlocked Singly Linked Lists</seealso>
  </member>
  <member name="Windows.RtlInstallFunctionTableCallback">
    <summary>
      <para>Adds a dynamic function table to the dynamic function table list.</para>
    </summary>
    <param name="TableIdentifier">
      <para>The identifier for the dynamic function table callback. The two low-order bits must be set. For example,
<i>BaseAddress</i>|0x3.</para>
    </param>
    <param name="BaseAddress">
      <para>The base address of the region of memory managed by the callback function.</para>
    </param>
    <param name="Length">
      <para>The size of the region of memory managed by the callback function, in bytes.</para>
    </param>
    <param name="Callback">
      <para>A pointer to the callback function that is called to retrieve the function table entries for the functions
in the specified region of memory. For a definition of the
<b>PGET_RUNTIME_FUNCTION_CALLBACK</b> type, see WinNT.h.</para>
    </param>
    <param name="Context">
      <para>A pointer to the user-defined data to be passed to the callback function.</para>
    </param>
    <param name="OutOfProcessCallbackDll">
      <para>An optional pointer to a string that specifies the path of a DLL that provides function table entries that
are outside the process.</para>
      <para>When a debugger unwinds to a function in the range of addresses managed by the callback function, it loads
this DLL and calls the <b>OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME</b></para>
      <para>function, whose type is <b>POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK</b>. For more
information, see the definitions of these items in WinNT.h.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the
return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Function tables are used on 64-bit Windows to determine how to unwind or walk the stack. These tables are
usually generated by the compiler and stored as part of the image. However, applications must provide the function
table for dynamically generated code. For more information about function tables, see the architecture guide for
your system.</para>
      <para>This function is useful for very dynamic code. The application specifies the memory range for the generated
code, but does not need to generate a table until it is needed by an unwind request. At that time, the system
calls the callback function with the <i>Context</i> and the control address. The callback
function must return the runtime function entry for the specified address. Be sure to avoid creating a deadlock
between the callback function and the code generator.</para>
      <para>For code that is generated from a template or generated only once during the life of the process, use the
<see cref="RtlAddFunctionTable" /> function.</para>
    </remarks>
    <seealso cref="RtlAddFunctionTable" />
    <seealso cref="RtlDeleteFunctionTable" />
  </member>
  <member name="Windows.RtlInterlockedFlushSList">
    <summary>
      <para>Removes all items from a singly linked list. Access to the list is synchronized on a multiprocessor system.</para>
    </summary>
    <param name="ListHead">
      <para>A pointer to an <b>SLIST_HEADER</b> structure that represents the head of the singly linked list. This structure is for system use only.</para>
    </param>
    <returns>
      <para>The return value is a pointer to the items removed from the list. If the list is empty, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Calls to the <see cref="InterlockedFlushSList" /> function are forwarded to the <b>RtlInterlockedFlushSList</b> function. Applications should call <b>InterlockedFlushSList</b> instead of calling this function directly.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-singly-linked-lists">Interlocked Singly Linked Lists</seealso>
  </member>
  <member name="Windows.RtlInterlockedPopEntrySList">
    <summary>
      <para>Removes an item from the front of a singly linked list. Access to the list is synchronized on a multiprocessor system.</para>
    </summary>
    <param name="ListHead">
      <para>A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list.</para>
    </param>
    <returns>
      <para>The return value is a pointer to the item removed from the list. If the list is empty, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Calls to the <see cref="InterlockedPopEntrySList" /> function are forwarded to the <b>RtlInterlockedPopEntrySList</b> function. Applications should call <b>InterlockedPopEntrySList</b> instead of calling this function directly.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-singly-linked-lists">Interlocked Singly Linked Lists</seealso>
  </member>
  <member name="Windows.RtlInterlockedPushEntrySList">
    <summary>
      <para>Inserts an item at the front of a singly linked list. Access to the list is synchronized on a multiprocessor system.</para>
    </summary>
    <param name="ListHead">
      <para>A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list.</para>
    </param>
    <param name="ListEntry">
      <para>A pointer to an
<see cref="SLIST_ENTRY" /> structure that represents an item in a singly linked list.</para>
    </param>
    <returns>
      <para>The return value is the previous first item in the list. If the list was previously empty, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Calls to the <see cref="InterlockedPushEntrySList" /> function are forwarded to the <b>RtlInterlockedPushEntrySList</b> function. Applications should call <b>InterlockedPushEntrySList</b> instead of calling this function directly.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-singly-linked-lists">Interlocked Singly Linked Lists</seealso>
  </member>
  <member name="Windows.RtlLookupFunctionEntry">
    <summary>
      <para>Searches the active function tables for an entry that corresponds to the specified PC
value.</para>
    </summary>
    <param name="ControlPc">
      <para>The virtual address of an instruction bundle within the function.</para>
    </param>
    <param name="ImageBase">
      <para>The base address of module to which the function belongs.</para>
    </param>
    <param name="HistoryTable">
      <para>The global pointer value of the module.</para>
      <para>This parameter has a different declaration on x64 and ARM systems. For more information, see x64 Definition
and ARM Definition.</para>
    </param>
    <returns>
      <para>If there is no entry in the function table for the specified PC, the function returns
<b>NULL</b>. Otherwise, the function returns the address of the function table entry that
corresponds to the specified PC.</para>
    </returns>
    <seealso cref="RtlUnwindEx" />
    <seealso cref="RtlVirtualUnwind" />
  </member>
  <member name="Windows.RtlPcToFileHeader">
    <summary>
      <para>Retrieves the base address of the image that contains the specified PC value.</para>
    </summary>
    <param name="PcValue">
      <para>The PC value. The function searches all modules mapped into the address space of the calling process for a module that contains this value.</para>
    </param>
    <param name="BaseOfImage">
      <para>The base address of the image containing the PC value. This value must be added to any relative addresses in the headers to locate the image.</para>
    </param>
    <returns>
      <para>If the PC value is found, the function returns the base address of the image that contains the PC value.</para>
      <para>If no image contains the PC value, the function returns <b>NULL</b>.</para>
    </returns>
    <seealso cref="RtlLookupFunctionEntry" />
  </member>
  <member name="Windows.RtlQueryDepthSList">
    <summary>
      <para>Retrieves the number of entries in the specified singly linked list.</para>
    </summary>
    <param name="ListHead">
      <para>A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list. This structure is for system use only.</para>
      <para>The list must  be previously initialized with the <see cref="InitializeSListHead" /> function.</para>
    </param>
    <returns>
      <para>The function returns the number of entries in the list.</para>
    </returns>
    <remarks>
      <para>Calls to the <see cref="QueryDepthSList" /> function are forwarded to the <b>RtlQueryDepthSList</b> function. Applications should call <b>QueryDepthSList</b> instead of calling this function directly.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-singly-linked-lists">Interlocked Singly Linked Lists</seealso>
  </member>
  <member name="Windows.RtlRestoreContext">
    <summary>
      <para>Restores the context of the caller to the specified context record.</para>
    </summary>
    <param name="ContextRecord">
      <para>A pointer to a <see cref="CONTEXT" /> structure.</para>
    </param>
    <param name="ExceptionRecord">
      <para>A pointer to an <see cref="EXCEPTION_RECORD" /> structure. This parameter is optional and should typically be <b>NULL</b>.</para>
      <para>An exception record is used primarily with long jump and C++ catch-throw support. If the <b>ExceptionCode</b> member is STATUS_LONGJUMP, the <b>ExceptionInformation</b> member contains a pointer to a jump buffer. <b>RtlRestoreContext</b> will copy the non-volatile state from the jump buffer in to the context record before the context record is restored.</para>
      <para>If the <b>ExceptionCode</b> member is STATUS_UNWIND_CONSOLIDATE, the <b>ExceptionInformation</b> member contains a pointer to a callback function, such as a catch handler. <b>RtlRestoreContext</b> consolidates the call frames between its frame and the frame specified in the context record before calling the callback function. This hides frames from any exception handling that might occur in the callback function. The difference between this and a typical unwind is that the data on the stack is still present, so frame data such as a throw object is still available. The callback function returns a new program counter to update in the context record, which is then used in a normal restore context.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
    </returns>
    <seealso cref="CONTEXT" />
    <seealso cref="RtlCaptureContext" />
  </member>
  <member name="Windows.RtlUnwind">
    <summary>
      <para>Initiates an unwind of procedure call frames.</para>
    </summary>
    <param name="TargetFrame">
      <para>A pointer to the call frame that is the target of the unwind. If this parameter is
<b>NULL</b>, the function performs an exit unwind.</para>
    </param>
    <param name="TargetIp">
      <para>The continuation address of the unwind. This parameter is ignored if <i>TargetFrame</i></para>
      <para>is <b>NULL</b>.</para>
    </param>
    <param name="ExceptionRecord">
      <para>A pointer to an <see cref="EXCEPTION_RECORD" /></para>
      <para>structure.</para>
    </param>
    <param name="ReturnValue">
      <para>A value to be placed in the integer function return register before continuing execution.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
    </returns>
    <seealso cref="EXCEPTION_RECORD" />
  </member>
  <member name="Windows.RtlUnwind2">
    <summary>
      <para>Initiates an unwind of
procedure call frames.</para>
    </summary>
    <param name="TargetFrame">
      <para>A pointer to the call frame that is the target of the unwind. If this parameter is
<b>NULL</b>, the function performs an exit unwind.</para>
    </param>
    <param name="TargetIp">
      <para>The continuation address of the unwind. This parameter is ignored if <i>TargetFrame</i></para>
      <para>is <b>NULL</b>.</para>
    </param>
    <param name="ExceptionRecord">
      <para>A pointer to an <see cref="EXCEPTION_RECORD" /></para>
      <para>structure.</para>
    </param>
    <param name="ReturnValue">
      <para>A value to be placed in the integer function return register before continuing execution.</para>
    </param>
    <param name="ContextRecord">
      <para>A pointer to a <see cref="CONTEXT" /> structure that stores context
during the unwind operation.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
    </returns>
    <remarks>
      <para>The <b>FRAME_POINTERS</b> structure is defined as follows:</para>
      <code>typedef struct _FRAME_POINTERS {
    ULONGLONG MemoryStackFp;
    ULONGLONG BackingStoreFp;
} FRAME_POINTERS, *PFRAME_POINTERS;
</code>
    </remarks>
    <seealso cref="CONTEXT" />
    <seealso cref="EXCEPTION_RECORD" />
  </member>
  <member name="Windows.RtlUnwindEx">
    <summary>
      <para>Initiates an unwind of
procedure call frames.</para>
    </summary>
    <param name="TargetFrame">
      <para>A pointer to the call frame that is the target of the unwind. If this parameter is <b>NULL</b>, the function
performs an exit unwind.</para>
    </param>
    <param name="TargetIp">
      <para>The continuation address of the unwind. This parameter is ignored if <i>TargetFrame</i> is
<b>NULL</b>.</para>
    </param>
    <param name="ExceptionRecord">
      <para>A pointer to an <see cref="EXCEPTION_RECORD" /> structure.</para>
    </param>
    <param name="ReturnValue">
      <para>A value to be placed in the integer function return register before continuing execution.</para>
    </param>
    <param name="ContextRecord">
      <para>A pointer to a <see cref="CONTEXT" /> structure that stores context
during the unwind operation.</para>
    </param>
    <param name="HistoryTable">
      <para>A pointer to the unwind history table. This structure is processor specific. For definitions of this
structure, see Winternl.h.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
    </returns>
    <remarks>
      <para>The <b>FRAME_POINTERS</b> structure is defined as follows:</para>
      <code>typedef struct _FRAME_POINTERS {
    ULONGLONG MemoryStackFp;
    ULONGLONG BackingStoreFp;
} FRAME_POINTERS, *PFRAME_POINTERS;
</code>
    </remarks>
    <seealso cref="CONTEXT" />
    <seealso cref="EXCEPTION_RECORD" />
  </member>
  <member name="Windows.RtlVirtualUnwind">
    <summary>
      <para>Retrieves
the invocation context of the function that precedes the specified function context.</para>
      <para>
        <b>Note</b>  This function is not implemented on all processor platforms and the implementation is different on each platform that supports it.  The following prototype lists all the potential parameters and their application.  Read further for processor-specific function prototypes.</para>
    </summary>
    <param name="HandlerType">
      <para>The handler type. This parameter can be one of the following values.</para>
      <para>This parameter is only present on x64.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>UNW_FLAG_NHANDLER</b>
                </description>
              </item>
              <item>
                <description>0x0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function has no handler.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>UNW_FLAG_EHANDLER</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function has an exception handler that should be called.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>UNW_FLAG_UHANDLER</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function has a termination handler that should be called when unwinding an exception.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>UNW_FLAG_CHAININFO</b>
                </description>
              </item>
              <item>
                <description>0x4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <b>FunctionEntry</b> member is the contents of a previous function table entry.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="ImageBase">
      <para>The base address of the module to which the function belongs.</para>
    </param>
    <param name="ControlPc">
      <para>The virtual address where control left the specified function.</para>
    </param>
    <param name="FunctionEntry">
      <para>The address of the function table entry for the specified function. To obtain the function table entry, call
the <see cref="RtlLookupFunctionEntry" /> function.</para>
    </param>
    <param name="ContextRecord">
      <para>A pointer to a <see cref="CONTEXT" /> structure that represents the
context of the previous frame.</para>
    </param>
    <param name="HandlerData">
      <para>The location of the PC. If this parameter is 0, the PC is in the prologue, epilogue, or a null frame region
of the function. If this parameter is 1, the PC is in the body of the function.</para>
      <para>This parameter is not present on x64.</para>
    </param>
    <param name="EstablisherFrame">
      <para>A pointer to a <b>FRAME_POINTERS</b> structure that receives the establisher frame
pointer value. The real frame pointer is defined only if <i>InFunction</i> is 1.</para>
      <para>This parameter is of type <b>PULONG64</b> on x64.</para>
    </param>
    <param name="ContextPointers">
      <para>An optional pointer to a context pointers structure.</para>
    </param>
    <returns>
      <para>This function returns a pointer to an <i>EXCEPTION_ROUTINE</i> callback
function.</para>
    </returns>
    <remarks>
      <para>The complete list of epilogue markers for x64 is as follows:</para>
      <list type="bullet">
        <item>
          <description>ret</description>
        </item>
        <item>
          <description>ret <i>n</i></description>
        </item>
        <item>
          <description>rep ret</description>
        </item>
        <item>
          <description>jmp <i>imm8</i> | <i>imm32</i> where the target is outside the function being unwound</description>
        </item>
        <item>
          <description>jmp qword ptr <i>imm32</i></description>
        </item>
        <item>
          <description>rex.w jmp <i>reg</i></description>
        </item>
      </list>
    </remarks>
    <seealso cref="CONTEXT" />
    <seealso cref="EXCEPTION_RECORD" />
    <seealso cref="RtlLookupFunctionEntry" />
  </member>
  <member name="Windows.ShiftLeft128">
    <summary>
      <para>Shifts 128-bit left.</para>
    </summary>
    <param name="LowPart">
      <para>The low 64 bits.</para>
    </param>
    <param name="HighPart">
      <para>The high 64 bits.</para>
    </param>
    <param name="Shift">
      <para>Bytes to shift.</para>
    </param>
    <returns>
      <para>The shifted bits.</para>
    </returns>
  </member>
  <member name="Windows.ShiftRight128">
    <summary>
      <para>Shifts 128-bit right.</para>
    </summary>
    <param name="LowPart">
      <para>The low 64 bits.</para>
    </param>
    <param name="HighPart">
      <para>The high 64 bits.</para>
    </param>
    <param name="Shift">
      <para>Bytes to shift.</para>
    </param>
    <returns>
      <para>The shifted bits.</para>
    </returns>
  </member>
  <member name="Windows.SORTIDFROMLCID">
    <summary>
      <para>Retrieves a <a href="https://docs.microsoft.com//windows/desktop/Intl/sort-order-identifiers">sort order identifier</a> from a <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-identifiers">locale identifier</a>.</para>
    </summary>
    <param name="lcid">
      <para>Locale identifier. You can use the <see cref="MAKELCID" /> macro to create a locale identifier or use one of the following predefined values.</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
          </description>
        </item>
      </list>
      <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
<list type="bullet"><item><description><a href="https://docs.microsoft.com//windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a></description></item><item><description><a href="https://docs.microsoft.com//windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a></description></item><item><description><a href="https://docs.microsoft.com//windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a></description></item></list></param>
    <seealso cref="MAKELANGID" />
    <seealso cref="MAKELCID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support-macros">National Language Support Macros</seealso>
    <seealso cref="PRIMARYLANGID" />
    <seealso cref="SUBLANGID" />
  </member>
  <member name="Windows.SORTVERSIONFROMLCID">
    <summary>
      <para>Retrieves the sort version from a <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-identifiers">locale identifier</a>.</para>
    </summary>
    <param name="lcid">
      <para>Locale identifier. You can use the <see cref="MAKELCID" /> macro to create a locale identifier or use one of the following predefined values.</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
          </description>
        </item>
      </list>
      <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
<list type="bullet"><item><description><a href="https://docs.microsoft.com//windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a></description></item><item><description><a href="https://docs.microsoft.com//windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a></description></item><item><description><a href="https://docs.microsoft.com//windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a></description></item></list></param>
    <remarks>
      <para>Note that this macro is entirely distinct from <see cref="SORTIDFROMLCID" />.</para>
    </remarks>
    <seealso cref="MAKELCID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support-macros">National Language Support Macros</seealso>
    <seealso cref="SORTIDFROMLCID" />
  </member>
  <member name="Windows.SUBLANGID">
    <summary>
      <para>Extracts a sublanguage identifier from a <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a>.</para>
    </summary>
    <param name="lgid">
      <para>Language identifier. You can supply predefined values for this parameter, or create an identifier using the <see cref="MAKELANGID" /> macro.</para>
    </param>
    <seealso cref="EnumSystemLocales" />
    <seealso cref="LANGIDFROMLCID" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support-macros">National Language Support Macros</seealso>
    <seealso cref="PRIMARYLANGID" />
  </member>
  <member name="Windows.TEXT">
    <summary>
      <para>Identifies a string as Unicode when UNICODE is defined by a preprocessor directive during compilation. Otherwise, the macro identifies a string as an ANSI string.</para>
    </summary>
    <param name="quote">
      <para>Pointer to the string to interpret as UTF-16 or ANSI.</para>
    </param>
    <remarks>
      <para>This macro interprets an ANSI string at runtime according to the current Windows ANSI code page. Literal ANSI strings that are not strictly ASCII are interpreted differently when processed with different Windows ANSI code pages. For example, "\0xC4" in code page 1252 (Latin-1) represents Upper Case A with Dieresis (Ä). However, in code page 1253 (Greek), the string represents Upper Case Delta (Δ). These different interpretations lead to development and maintenance issues. For example, a developer might correct a string when using a different system code page from the page used by the original developer; or a build computer might use a different code page. The different interpretations also pose runtime issues, for example, when the end user computer uses a different code page to interpret a string from that used by the build computer.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/unicode-and-character-set-macros">Unicode and Character Set Macros</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/unicode-and-character-sets">Unicode and Character Sets</seealso>
  </member>
  <member name="Windows.TpDestroyCallbackEnviron">
    <summary>
      <para>Deletes the specified callback environment. Call this function when the callback environment is no longer needed for creating new thread pool objects.</para>
    </summary>
    <param name="CallbackEnviron">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="TpInitializeCallbackEnviron" /> function returns this structure.</para>
    </param>
    <seealso cref="TpInitializeCallbackEnviron" />
    <seealso cref="TpSetCallbackActivationContext" />
    <seealso cref="TpSetCallbackCleanupGroup" />
    <seealso cref="TpSetCallbackFinalizationCallback" />
    <seealso cref="TpSetCallbackLongFunction" />
    <seealso cref="TpSetCallbackNoActivationContext" />
    <seealso cref="TpSetCallbackPersistent" />
    <seealso cref="TpSetCallbackPriority" />
    <seealso cref="TpSetCallbackRaceWithDll" />
    <seealso cref="TpSetCallbackThreadpool" />
  </member>
  <member name="Windows.TpInitializeCallbackEnviron">
    <summary>
      <para>Initializes a callback environment for the thread pool.</para>
    </summary>
    <param name="CallbackEnviron">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. Allocate space for this structure and initialize it using this function.</para>
    </param>
    <remarks>
      <para>The thread pool callback environment is subject to default behaviors that can be changed. For example, callbacks execute in the global pool by default, but a different thread pool can be specified using <see cref="TpSetCallbackThreadpool" />. Thread pool callback environment behavior can be changed with the following functions:</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="TpSetCallbackActivationContext" />
          </description>
        </item>
        <item>
          <description>
            <see cref="TpSetCallbackCleanupGroup" />
          </description>
        </item>
        <item>
          <description>
            <see cref="TpSetCallbackFinalizationCallback" />
          </description>
        </item>
        <item>
          <description>
            <see cref="TpSetCallbackLongFunction" />
          </description>
        </item>
        <item>
          <description>
            <see cref="TpSetCallbackNoActivationContext" />
          </description>
        </item>
        <item>
          <description>
            <see cref="TpSetCallbackPersistent" />
          </description>
        </item>
        <item>
          <description>
            <see cref="TpSetCallbackPriority" />
          </description>
        </item>
        <item>
          <description>
            <see cref="TpSetCallbackRaceWithDll" />
          </description>
        </item>
        <item>
          <description>
            <see cref="TpSetCallbackThreadpool" />
          </description>
        </item>
      </list>
      <para>Call
<b>TpInitializeCallbackEnviron</b> to create a callback environment that can be modified. Call <see cref="TpDestroyCallbackEnviron" /> to destroy the callback environment.</para>
      <para>This function is implemented as an inline function.</para>
    </remarks>
  </member>
  <member name="Windows.TpSetCallbackActivationContext">
    <summary>
      <para>Assigns an activation context to the callback environment.</para>
    </summary>
    <param name="CallbackEnviron">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="TpInitializeCallbackEnviron" /> function returns this structure.</para>
    </param>
    <param name="ActivationContext">
      <para>Pointer to an <b>_ACTIVATION_CONTEXT</b> structure.</para>
    </param>
    <remarks>
      <para>This function is implemented as an inline function.</para>
    </remarks>
    <seealso cref="TpDestroyCallbackEnviron" />
    <seealso cref="TpInitializeCallbackEnviron" />
    <seealso cref="TpSetCallbackCleanupGroup" />
    <seealso cref="TpSetCallbackFinalizationCallback" />
    <seealso cref="TpSetCallbackLongFunction" />
    <seealso cref="TpSetCallbackNoActivationContext" />
    <seealso cref="TpSetCallbackPersistent" />
    <seealso cref="TpSetCallbackPriority" />
    <seealso cref="TpSetCallbackRaceWithDll" />
    <seealso cref="TpSetCallbackThreadpool" />
  </member>
  <member name="Windows.TpSetCallbackCleanupGroup">
    <summary>
      <para>Associates the specified cleanup group with the specified callback environment.</para>
    </summary>
    <param name="CallbackEnviron">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="TpInitializeCallbackEnviron" /> function returns this structure.</para>
    </param>
    <param name="CleanupGroup">
      <para>A <b>TP_CLEANUP_GROUP</b> structure that defines the cleanup group. The <see cref="CreateThreadpoolCleanupGroup" /> function returns this structure.</para>
    </param>
    <param name="CleanupGroupCancelCallback">
      <para>The cleanup callback to be called if the cleanup group is canceled before the associated object is released. The function is called when you call <see cref="CloseThreadpoolCleanupGroupMembers" />.</para>
    </param>
    <remarks>
      <para>This function is implemented as an inline function.</para>
    </remarks>
    <seealso cref="TpDestroyCallbackEnviron" />
    <seealso cref="TpInitializeCallbackEnviron" />
    <seealso cref="TpSetCallbackActivationContext" />
    <seealso cref="TpSetCallbackFinalizationCallback" />
    <seealso cref="TpSetCallbackLongFunction" />
    <seealso cref="TpSetCallbackNoActivationContext" />
    <seealso cref="TpSetCallbackPersistent" />
    <seealso cref="TpSetCallbackPriority" />
    <seealso cref="TpSetCallbackRaceWithDll" />
    <seealso cref="TpSetCallbackThreadpool" />
  </member>
  <member name="Windows.TpSetCallbackFinalizationCallback">
    <summary>
      <para>Indicates a function to call when the callback environment is finalized.</para>
    </summary>
    <param name="CallbackEnviron">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="TpInitializeCallbackEnviron" /> function returns this structure.</para>
    </param>
    <param name="FinalizationCallback">
      <para>Pointer to a <b>TP_SIMPLE_CALLBACK</b> structure indicating a function to call when the callback environment is finalized.</para>
    </param>
    <remarks>
      <para>This function is implemented as an inline function.</para>
    </remarks>
    <seealso cref="TpDestroyCallbackEnviron" />
    <seealso cref="TpInitializeCallbackEnviron" />
    <seealso cref="TpSetCallbackActivationContext" />
    <seealso cref="TpSetCallbackCleanupGroup" />
    <seealso cref="TpSetCallbackLongFunction" />
    <seealso cref="TpSetCallbackNoActivationContext" />
    <seealso cref="TpSetCallbackPersistent" />
    <seealso cref="TpSetCallbackPriority" />
    <seealso cref="TpSetCallbackRaceWithDll" />
    <seealso cref="TpSetCallbackThreadpool" />
  </member>
  <member name="Windows.TpSetCallbackLongFunction">
    <summary>
      <para>Indicates that callbacks associated with this callback environment may not return quickly.</para>
    </summary>
    <param name="CallbackEnviron">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="TpInitializeCallbackEnviron" /> function returns this structure.</para>
    </param>
    <remarks>
      <para>The thread pool may use this information to better determine when a new thread should be created.</para>
      <para>This function is implemented as an inline function.</para>
    </remarks>
    <seealso cref="TpDestroyCallbackEnviron" />
    <seealso cref="TpInitializeCallbackEnviron" />
    <seealso cref="TpSetCallbackActivationContext" />
    <seealso cref="TpSetCallbackCleanupGroup" />
    <seealso cref="TpSetCallbackFinalizationCallback" />
    <seealso cref="TpSetCallbackNoActivationContext" />
    <seealso cref="TpSetCallbackPersistent" />
    <seealso cref="TpSetCallbackPriority" />
    <seealso cref="TpSetCallbackRaceWithDll" />
    <seealso cref="TpSetCallbackThreadpool" />
  </member>
  <member name="Windows.TpSetCallbackNoActivationContext">
    <summary>
      <para>Indicates that the callback environment has no activation context.</para>
    </summary>
    <param name="CallbackEnviron">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="TpInitializeCallbackEnviron" /> function returns this structure.</para>
    </param>
    <remarks>
      <para>This function is implemented as an inline function.</para>
    </remarks>
    <seealso cref="TpDestroyCallbackEnviron" />
    <seealso cref="TpInitializeCallbackEnviron" />
    <seealso cref="TpSetCallbackActivationContext" />
    <seealso cref="TpSetCallbackCleanupGroup" />
    <seealso cref="TpSetCallbackFinalizationCallback" />
    <seealso cref="TpSetCallbackLongFunction" />
    <seealso cref="TpSetCallbackPersistent" />
    <seealso cref="TpSetCallbackPriority" />
    <seealso cref="TpSetCallbackRaceWithDll" />
    <seealso cref="TpSetCallbackThreadpool" />
  </member>
  <member name="Windows.TpSetCallbackPersistent">
    <summary>
      <para>Specifies that the callback should run on a persistent thread.</para>
    </summary>
    <param name="CallbackEnviron">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="TpInitializeCallbackEnviron" /> function returns this structure.</para>
    </param>
    <remarks>
      <para>This function is implemented as an inline function.</para>
    </remarks>
    <seealso cref="TpDestroyCallbackEnviron" />
    <seealso cref="TpInitializeCallbackEnviron" />
    <seealso cref="TpSetCallbackActivationContext" />
    <seealso cref="TpSetCallbackCleanupGroup" />
    <seealso cref="TpSetCallbackFinalizationCallback" />
    <seealso cref="TpSetCallbackLongFunction" />
    <seealso cref="TpSetCallbackNoActivationContext" />
    <seealso cref="TpSetCallbackPriority" />
    <seealso cref="TpSetCallbackRaceWithDll" />
    <seealso cref="TpSetCallbackThreadpool" />
  </member>
  <member name="Windows.TpSetCallbackPriority">
    <summary>
      <para>Specifies the priority of a callback function relative to other work items in the same thread pool.</para>
    </summary>
    <param name="CallbackEnviron">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="TpInitializeCallbackEnviron" /> function returns this structure.</para>
    </param>
    <param name="Priority">
      <para>The priority for the callback relative to other callbacks in the same thread pool. This parameter can be one of the following <b>TP_CALLBACK_PRIORITY</b> enumeration values:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>TP_CALLBACK_PRIORITY_HIGH</b>
          </description>
          <description>
            <para>The callback should run at high priority.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TP_CALLBACK_PRIORITY_LOW</b>
          </description>
          <description>
            <para>The callback should run at low priority.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TP_CALLBACK_PRIORITY_NORMAL</b>
          </description>
          <description>
            <para>The callback should run at normal priority.</para>
          </description>
        </item>
      </list>
    </param>
    <remarks>
      <para>Higher priority callbacks are guaranteed to be run first by the first available worker thread, but they are not guaranteed to finish before lower priority callbacks.</para>
      <para>This function is implemented as an inline function.</para>
    </remarks>
    <seealso cref="TpDestroyCallbackEnviron" />
    <seealso cref="TpInitializeCallbackEnviron" />
    <seealso cref="TpSetCallbackActivationContext" />
    <seealso cref="TpSetCallbackCleanupGroup" />
    <seealso cref="TpSetCallbackFinalizationCallback" />
    <seealso cref="TpSetCallbackLongFunction" />
    <seealso cref="TpSetCallbackNoActivationContext" />
    <seealso cref="TpSetCallbackPersistent" />
    <seealso cref="TpSetCallbackRaceWithDll" />
    <seealso cref="TpSetCallbackThreadpool" />
  </member>
  <member name="Windows.TpSetCallbackRaceWithDll">
    <summary>
      <para>Ensures that the specified DLL remains loaded as long as there are outstanding callbacks.</para>
    </summary>
    <param name="CallbackEnviron">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</para>
    </param>
    <param name="DllHandle">
      <para>A handle to the DLL.</para>
    </param>
    <remarks>
      <para>You should call this function if a callback might acquire the loader lock. This prevents a deadlock from occurring when one thread in DllMain is waiting for the callback to end, and another thread that is executing the callback attempts to acquire the loader lock.</para>
      <para>If the DLL containing the callback might be unloaded, the cleanup code in DllMain must cancel outstanding callbacks before releasing the object.</para>
      <para>Managing callbacks created with a TP_CALLBACK_ENVIRON that specifies a callback library is somewhat processing-intensive.  You should consider other options for ensuring that the library is not unloaded while callbacks are executing, or to guarantee that callbacks which may be executing do not acquire the loader lock.</para>
      <para>This function is implemented as an inline function.</para>
    </remarks>
    <seealso cref="TpDestroyCallbackEnviron" />
    <seealso cref="TpInitializeCallbackEnviron" />
    <seealso cref="TpSetCallbackActivationContext" />
    <seealso cref="TpSetCallbackCleanupGroup" />
    <seealso cref="TpSetCallbackFinalizationCallback" />
    <seealso cref="TpSetCallbackLongFunction" />
    <seealso cref="TpSetCallbackNoActivationContext" />
    <seealso cref="TpSetCallbackPersistent" />
    <seealso cref="TpSetCallbackPriority" />
    <seealso cref="TpSetCallbackThreadpool" />
  </member>
  <member name="Windows.TpSetCallbackThreadpool">
    <summary>
      <para>Assigns a thread pool to a callback environment.</para>
    </summary>
    <param name="CallbackEnviron">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="TpInitializeCallbackEnviron" /> function returns this structure.</para>
    </param>
    <param name="Pool">
      <para>A <b>TP_POOL</b> structure that defines a thread pool. The <see cref="CreateThreadpool" /> function returns this structure.</para>
    </param>
    <remarks>
      <para>If you do not specify a thread pool, the global thread pool is used.</para>
      <para>This function is implemented as an inline function.</para>
    </remarks>
    <seealso cref="TpDestroyCallbackEnviron" />
    <seealso cref="TpInitializeCallbackEnviron" />
    <seealso cref="TpSetCallbackActivationContext" />
    <seealso cref="TpSetCallbackCleanupGroup" />
    <seealso cref="TpSetCallbackFinalizationCallback" />
    <seealso cref="TpSetCallbackLongFunction" />
    <seealso cref="TpSetCallbackNoActivationContext" />
    <seealso cref="TpSetCallbackPersistent" />
    <seealso cref="TpSetCallbackPriority" />
    <seealso cref="TpSetCallbackRaceWithDll" />
  </member>
  <member name="Windows.UInt32x32To64">
    <summary>
      <para>Multiplies two unsigned 32-bit integers, returning an unsigned 64-bit integer result. The function performs optimally on 32-bit Windows.</para>
    </summary>
    <param name="a">
      <para>The first unsigned 32-bit integer for the multiplication operation.</para>
    </param>
    <param name="b">
      <para>The second unsigned 32-bit integer for the multiplication operation.</para>
    </param>
    <remarks>
      <para>This function is implemented on all platforms by optimal inline code: a single multiply instruction that returns a 64-bit result.</para>
      <para>Please note that the function's return value is a 64-bit value, not a
<see cref="LARGE_INTEGER" /> structure.</para>
    </remarks>
    <seealso cref="Int32x32To64" />
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/large-integers">Large Integers</seealso>
  </member>
  <member name="Windows.UnsignedMultiply128">
    <summary>
      <para>Multiplies two unsigned 64-bit integers to produce an unsigned 128-bit integer.</para>
    </summary>
    <param name="Multiplier">
      <para>The first integer.</para>
    </param>
    <param name="Multiplicand">
      <para>The second integer.</para>
    </param>
    <param name="HighProduct">
      <para>The high 64 bits of the product.</para>
    </param>
    <returns>
      <para>The low 64 bits of the product.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//previous-versions/3dayytw9(v=vs.85)">_umu128</seealso>
  </member>
  <member name="Windows.UnsignedMultiplyExtract128">
    <summary>
      <para>Multiplies two unsigned 64-bit integers to produce an unsigned 128-bit integer, shifts the product to the right by the specified number of bits, and returns the low 64 bits of the result.</para>
    </summary>
    <param name="Multiplier">
      <para>The first integer.</para>
    </param>
    <param name="Multiplicand">
      <para>The second integer.</para>
    </param>
    <param name="Shift">
      <para>The number of bits to shift.</para>
    </param>
    <returns>
      <para>The low 64 bits of the result.</para>
    </returns>
  </member>
  <member name="Windows.UnsignedMultiplyHigh">
    <summary>
      <para>Multiplies two 64-bit integers to produce a 128-bit integer and gets the high unsigned 64 bits.</para>
    </summary>
    <param name="Multiplier">
      <para>The first integer.</para>
    </param>
    <param name="Multiplicand">
      <para>The second integer.</para>
    </param>
    <returns>
      <para>The high 64 bits of the product.</para>
    </returns>
  </member>
  <member name="Windows.VerSetConditionMask">
    <summary>
      <para>Sets the bits of a 64-bit value to indicate the comparison operator to use for a specified operating system version attribute. This function is used to build the <i>dwlConditionMask</i> parameter of the
<see cref="VerifyVersionInfo" /> function.</para>
    </summary>
    <param name="ConditionMask">
      <para>A value to be passed as the <i>dwlConditionMask</i> parameter of the
<see cref="VerifyVersionInfo" /> function. The function stores the comparison information in the bits of this variable.</para>
      <para>Before the first call to <b>VerSetCondition</b>, initialize this variable to zero. For subsequent calls, pass in the variable used in the previous call.</para>
    </param>
    <param name="TypeMask">
      <para>A mask that indicates the member of the
<see cref="OSVERSIONINFOEX" /> structure whose comparison operator is being set. This value corresponds to one of the bits specified in the <i>dwTypeMask</i> parameter for the
<see cref="VerifyVersionInfo" /> function. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_BUILDNUMBER</b>
                </description>
              </item>
              <item>
                <description>0x0000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>dwBuildNumber</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_MAJORVERSION</b>
                </description>
              </item>
              <item>
                <description>0x0000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>dwMajorVersion</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_MINORVERSION</b>
                </description>
              </item>
              <item>
                <description>0x0000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>dwMinorVersion</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_PLATFORMID</b>
                </description>
              </item>
              <item>
                <description>0x0000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>dwPlatformId</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_PRODUCT_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>wProductType</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_SERVICEPACKMAJOR</b>
                </description>
              </item>
              <item>
                <description>0x0000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>wServicePackMajor</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_SERVICEPACKMINOR</b>
                </description>
              </item>
              <item>
                <description>0x0000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>wServicePackMinor</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_SUITENAME</b>
                </description>
              </item>
              <item>
                <description>0x0000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>wSuiteMask</para>
          </description>
        </item>
      </list>
    </param>
    <param name="Condition">
      <para>The operator to be used for the comparison. The
<see cref="VerifyVersionInfo" /> function uses this operator to compare a specified attribute value to the corresponding value for the currently running system.</para>
      <para>For all values of <i>dwTypeBitMask</i> other than VER_SUITENAME, this parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_EQUAL</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The current value must be equal to the specified value.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_GREATER</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The current value must be greater than the specified value.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_GREATER_EQUAL</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The current value must be greater than or equal to the specified value.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_LESS</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The current value must be less than the specified value.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_LESS_EQUAL</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The current value must be less than or equal to the specified value.</para>
          </description>
        </item>
      </list>
      <para>If <i>dwTypeBitMask</i> is VER_SUITENAME, this parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_AND</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>All product suites specified in the <b>wSuiteMask</b> member must be present in the current system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_OR</b>
                </description>
              </item>
              <item>
                <description>7</description>
              </item>
            </list>
          </description>
          <description>
            <para>At least one of the specified product suites must be present in the current system.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>The function returns the condition mask value.</para>
    </returns>
    <remarks>
      <para>Call this function once for each bit set in the <i>dwTypeMask</i> parameter of the
<see cref="VerifyVersionInfo" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/verifying-the-system-version">Verifying the System Version</a>.</para>
    </remarks>
    <seealso cref="OSVERSIONINFOEX" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/operating-system-version">Operating System Version</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
    <seealso cref="VerifyVersionInfo" />
  </member>
  <member name="Windows.VER_SET_CONDITION">
    <summary>
      <para>Sets the bits of a 64-bit value to indicate the comparison operator to use for a specified operating system version attribute. This macro is used to build the <i>dwlConditionMask</i> parameter of the
<see cref="VerifyVersionInfo" /> function.</para>
    </summary>
    <param name="m">
      <para>A variable to be passed as the <i>dwlConditionMask</i> parameter of the
<see cref="VerifyVersionInfo" /> function. The macro stores the comparison information in the bits of this variable.</para>
      <para>Before the first call to
<b>VER_SET_CONDITION</b>, initialize this variable to zero. For subsequent calls to
<b>VER_SET_CONDITION</b>, pass in the variable used in the previous call.</para>
    </param>
    <param name="t">
      <para>A mask that indicates the member of the
<see cref="OSVERSIONINFOEX" /> structure whose comparison type is being set. This value corresponds to one of the bits specified in the <i>dwTypeMask</i> parameter for the
<see cref="VerifyVersionInfo" /> function. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_BUILDNUMBER</b>
                </description>
              </item>
              <item>
                <description>0x0000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>dwBuildNumber</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_MAJORVERSION</b>
                </description>
              </item>
              <item>
                <description>0x0000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>dwMajorVersion</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_MINORVERSION</b>
                </description>
              </item>
              <item>
                <description>0x0000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>dwMinorVersion</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_PLATFORMID</b>
                </description>
              </item>
              <item>
                <description>0x0000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>dwPlatformId</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_PRODUCT_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>wProductType</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_SERVICEPACKMAJOR</b>
                </description>
              </item>
              <item>
                <description>0x0000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>wServicePackMajor</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_SERVICEPACKMINOR</b>
                </description>
              </item>
              <item>
                <description>0x0000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>wServicePackMinor</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_SUITENAME</b>
                </description>
              </item>
              <item>
                <description>0x0000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>wSuiteMask</para>
          </description>
        </item>
      </list>
    </param>
    <param name="c">
      <para>The operator to use for the comparison. The
<see cref="VerifyVersionInfo" /> function uses this operator to compare a specified attribute value to the corresponding value for the currently running system.</para>
      <para>For all values of <i>dwTypeBitMask</i> other than VER_SUITENAME, this parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_EQUAL</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The current value must be equal to the specified value.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_GREATER</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The current value must be greater than the specified value.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_GREATER_EQUAL</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The current value must be greater than or equal to the specified value.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_LESS</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The current value must be less than the specified value.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_LESS_EQUAL</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The current value must be less than or equal to the specified value.</para>
          </description>
        </item>
      </list>
      <para>If <i>dwTypeBitMask</i> is VER_SUITENAME, this parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_AND</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>All product suites specified in the <b>wSuiteMask</b> member must be present in the current system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VER_OR</b>
                </description>
              </item>
              <item>
                <description>7</description>
              </item>
            </list>
          </description>
          <description>
            <para>At least one of the specified product suites must be present in the current system.</para>
          </description>
        </item>
      </list>
    </param>
    <remarks>
      <para>Call this macro once for each bit set in the <i>dwTypeMask</i> parameter of the
<see cref="VerifyVersionInfo" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/verifying-the-system-version">Verifying the System Version</a>.</para>
    </remarks>
    <seealso cref="OSVERSIONINFOEX" />
    <seealso cref="VerifyVersionInfo" />
  </member>
  <member name="Windows.YieldProcessor">
    <summary>
      <para>Signals to the processor to give resources to threads that are waiting for them. This macro is only effective on processors that  support technology allowing multiple threads running on a single processor, such as Intel's Hyperthreading technology.</para>
    </summary>
    <remarks>
      <para>This macro can be called on all processor platforms where Windows is supported, but  it  has no effect on some platforms.  The definition varies from platform to platform. The following are some definitions of this macro in Winnt.h:</para>
      <code>#define YieldProcessor() __asm { rep nop }

#define YieldProcessor _mm_pause

#define YieldProcessor __yield

</code>
    </remarks>
  </member>
  <member name="Windows.InterlockedAddAcquire">
    <summary>
      <para>Performs an atomic addition operation on the specified <b>LONG</b> values. The operation is performed with acquire memory ordering semantics.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the result of the operation.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/51s265a6(v=vs.85)">_InterlockedAdd_acq</a>.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedAdd" />
    <seealso cref="InterlockedAdd64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683510(v=vs.85)">InterlockedAddAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972629(v=vs.85)">InterlockedAddNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972630(v=vs.85)">InterlockedAddNoFence64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683513(v=vs.85)">InterlockedAddRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683514(v=vs.85)">InterlockedAddRelease64</seealso>
    <seealso cref="InterlockedExchangeAdd" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedAdd64">
    <summary>
      <para>Performs an atomic addition operation on the specified <b>LONG64</b> values.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to the first operand. This value will be replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The second operand.</para>
    </param>
    <returns>
      <para>The function returns the result of the operation.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/51s265a6(v=vs.85)">_InterlockedAdd64</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedAdd" />
    <seealso cref="InterlockedAddAcquire" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683510(v=vs.85)">InterlockedAddAcquire64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972629(v=vs.85)">InterlockedAddNoFence</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972630(v=vs.85)">InterlockedAddNoFence64</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683513(v=vs.85)">InterlockedAddRelease</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms683514(v=vs.85)">InterlockedAddRelease64</seealso>
    <seealso cref="InterlockedExchangeAdd" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedBitTestAndReset">
    <summary>
      <para>Tests the specified bit of the specified <b>LONG</b> value and sets it to 0. The operation is atomic.</para>
    </summary>
    <param name="Base">
      <para>A pointer to a variable.</para>
    </param>
    <param name="Offset">
      <para>The bit position to be tested.</para>
    </param>
    <returns>
      <para>The value of the specified bit.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/h1haebfw(v=vs.85)">_interlockedbittestandreset</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedBitTestAndReset64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972636(v=vs.85)">InterlockedBitTestAndResetAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972637(v=vs.85)">InterlockedBitTestAndResetRelease</seealso>
    <seealso cref="InterlockedBitTestAndSet" />
    <seealso cref="InterlockedBitTestAndSet64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972638(v=vs.85)">InterlockedBitTestAndSetAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972639(v=vs.85)">InterlockedBitTestAndSetRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedBitTestAndReset64">
    <summary>
      <para>Tests the specified bit of the specified <b>LONG64</b> value and sets it to 0. The operation is atomic.</para>
    </summary>
    <param name="Base">
      <para>A pointer to a variable.</para>
    </param>
    <param name="Offset">
      <para>The bit position to be tested.</para>
    </param>
    <returns>
      <para>The value of the specified bit.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/h1haebfw(v=vs.85)">_interlockedbittestandreset64</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedBitTestAndReset" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972636(v=vs.85)">InterlockedBitTestAndResetAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972637(v=vs.85)">InterlockedBitTestAndResetRelease</seealso>
    <seealso cref="InterlockedBitTestAndSet" />
    <seealso cref="InterlockedBitTestAndSet64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972638(v=vs.85)">InterlockedBitTestAndSetAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972639(v=vs.85)">InterlockedBitTestAndSetRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedBitTestAndSet">
    <summary>
      <para>Tests the specified bit of the specified <b>LONG</b> value and sets it to 1. The operation is atomic.</para>
    </summary>
    <param name="Base">
      <para>A pointer to a variable.</para>
    </param>
    <param name="Offset">
      <para>The bit position to be tested.</para>
    </param>
    <returns>
      <para>The value of the specified bit.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/646k06sz(v=vs.85)">_interlockedbittestandset</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
      <para>
        <b>Note</b>  This function is supported on Windows RT-based systems.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedBitTestAndReset" />
    <seealso cref="InterlockedBitTestAndReset64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972636(v=vs.85)">InterlockedBitTestAndResetAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972637(v=vs.85)">InterlockedBitTestAndResetRelease</seealso>
    <seealso cref="InterlockedBitTestAndSet64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972638(v=vs.85)">InterlockedBitTestAndSetAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972639(v=vs.85)">InterlockedBitTestAndSetRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.InterlockedBitTestAndSet64">
    <summary>
      <para>Tests the specified bit of the specified <b>LONG64</b> value and sets it to 1. The operation is atomic.</para>
    </summary>
    <param name="Base">
      <para>A pointer to a variable.</para>
    </param>
    <param name="Offset">
      <para>The bit position to be tested.</para>
    </param>
    <returns>
      <para>The value of the specified bit before it is set.</para>
    </returns>
    <remarks>
      <para>The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads. This function is atomic with respect to calls to other interlocked functions.</para>
      <para>This function is implemented using a compiler intrinsic where possible. For more information, see the WinBase.h header file and <a href="https://docs.microsoft.com//previous-versions/646k06sz(v=vs.85)">_interlockedbittestandset64</a>.</para>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedBitTestAndReset" />
    <seealso cref="InterlockedBitTestAndReset64" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972636(v=vs.85)">InterlockedBitTestAndResetAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972637(v=vs.85)">InterlockedBitTestAndResetRelease</seealso>
    <seealso cref="InterlockedBitTestAndSet" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972638(v=vs.85)">InterlockedBitTestAndSetAcquire</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh972639(v=vs.85)">InterlockedBitTestAndSetRelease</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
</doc>