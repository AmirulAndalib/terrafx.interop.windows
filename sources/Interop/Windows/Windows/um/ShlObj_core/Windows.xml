<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AssocGetDetailsOfPropKey">
    <summary>
      <para>Retrieves the value for a given property key using the file association information provided by the <a href="https://docs.microsoft.com//windows/desktop/shell/nse-works">Namespace Extensions</a>.</para>
    </summary>
    <param name="psf">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>A pointer to the shell folder for which the details of the property key of the file association are being retrieved.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>The PIDL of the child item for which the file associations are being requested.</para>
    </param>
    <param name="pkey">
      <para>Type: <b><see cref="PROPERTYKEY" />*</b></para>
      <para>A pointer to the property key that is being retrieved.</para>
    </param>
    <param name="pv">
      <para>Type: <b>VARIANT*</b></para>
      <para>When this function returns, contains the details of the given property key.</para>
    </param>
    <param name="pfFoundPropKey">
      <para>Type: <b>BOOL*</b></para>
      <para>When this function returns, contains a flag that is <b>TRUE</b> if the property key was found, otherwise <b>FALSE</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function is to be used only by implementers of
<see cref="IShellFolder" /><a href="https://docs.microsoft.com//windows/desktop/shell/nse-works">Namespace Extensions</a>. Other calling applications should use
<see cref="IShellFolder2.GetDetailsEx" /> to get a value
for a <see cref="PROPERTYKEY" />. This function is to be used by
implementers of <b>IShellFolder</b> Namespace Extensions.</para>
      <para>The provided namespace extension must support the use of this API in one of the following three ways.</para>
      <list type="number">
        <item>
          <description>If the provided <a href="https://docs.microsoft.com//windows/desktop/shell/nse-works">Namespace Extensions</a> supports retrieving an <see cref="IQueryAssociations" /> interface for the item by implementing <see cref="IShellFolder.GetUIObjectOf" />(..., <b>IID_IQueryAssociations</b>, ...), then <b>AssocGetDetailsOfPropKey</b> will use the provided file associations API to retrieve the value for the property key.</description>
        </item>
        <item>
          <description>If the provided namespace extension returns <b>SFGAO_FILESYSTEM</b> for the item from <see cref="IShellFolder.GetAttributesOf" /> and provides a parsing name for the item, then <b>AssocGetDetailsOfPropKey</b> will use the standard file system associations to retrieve the value for the property key.</description>
        </item>
        <item>
          <description>If the provided namespace extension returns <b>SFGAO_FOLDER</b> | <b>SFGAO_BROWSABLE</b> for the item from <see cref="IShellFolder.GetAttributesOf" />, then <b>AssocGetDetailsOfPropKey</b> will use the file association for folders (<b>ASSOCCLASS_FOLDER</b>) to retrieve the value for the property key.</description>
        </item>
      </list>
      <para>If the ShellFolder being implemented contains items that are extensible through the file associations mechanism, then you can use this function to retrieve <b>PropertyKeys</b> that are declared for a given file association. For example, if a given Shell folder drives a details pane and you want the properties displayed in that pane to be governed by third party file name extensions, then you can use this function to return <b>PKEY_PropList_PreviewDetails</b>.  This key has a value that is declared in the registry for that file name extension with a semicolon delimited list of properties. There is a list of file name extension defined properties in the registry. This list includes but is not limited to the following:</para>
      <list type="bullet">
        <item>
          <description>
            <b>PKEY_PropList_PreviewDetails</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_PropList_PreviewTitle</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_PropList_FullDetails</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_PropList_TileInfo</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_PropList_ExtendedTileInfo</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_PropList_InfoTip</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_PropList_QuickTip</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_PropList_FileOperationPrompt</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_PropList_ConflictPrompt</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_PropList_SetDefaultsFor</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_PropList_NonPersonal</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_NewMenuPreferredTypes</b>
          </description>
        </item>
        <item>
          <description>
            <b>PKEY_NewMenuAllowedTypes</b>
          </description>
        </item>
      </list>
    </remarks>
  </member>
  <member name="Windows.CDefFolderMenu_Create2">
    <summary>
      <para>Creates a context menu for a selected group of file folder objects.</para>
    </summary>
    <param name="pidlFolder">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>An <see cref="ITEMIDLIST" /> structure for the parent folder. This value can be <b>NULL</b>.</para>
    </param>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window. This value can be <b>NULL</b>.</para>
    </param>
    <param name="cidl">
      <para>Type: <b>UINT</b></para>
      <para>The number of <see cref="ITEMIDLIST" /> structures in the array pointed to by <i>apidl</i>.</para>
    </param>
    <param name="apidl">
      <para>Type: <b>PCUITEMID_CHILD_ARRAY*</b></para>
      <para>A pointer to an array of <see cref="ITEMIDLIST" /> structures, one for each item that is selected.</para>
    </param>
    <param name="psf">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>A pointer to the parent folder's <see cref="IShellFolder" /> interface. This <b>IShellFolder</b> must support the <see cref="IDataObject" /> interface. If it does not, <b>CDefFolderMenu_Create2</b> fails and returns E_NOINTERFACE. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pfn">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/api/shlobj_core/nc-shlobj_core-lpfndfmcallback">LPFNDFMCALLBACK</a></b></para>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/api/shlobj_core/nc-shlobj_core-lpfndfmcallback">LPFNDFMCALLBACK</a> callback object. This value can be <b>NULL</b> if the callback object is not needed.</para>
    </param>
    <param name="nKeys">
      <para>Type: <b>UINT</b></para>
      <para>The number of registry keys in the array pointed to by <i>ahkeys</i>.</para>
      <para>
        <b>Note</b>  The maximum number of registry keys is 16. Callers must enforce this limit as the API does not. Failing to do so can result in memory corruption.</para>
    </param>
    <param name="ahkeys">
      <para>Type: <b>const HKEY*</b></para>
      <para>A pointer to an array of registry keys that specify the context menu handlers used with the menu's entries. For more information on context menu handlers, see <a href="https://docs.microsoft.com//windows/desktop/shell/context-menu-handlers">Creating Context Menu Handlers</a>. This array can contain a maximum of 16 registry keys.</para>
    </param>
    <param name="ppcm">
      <para>Type: <b><see cref="IContextMenu" />**</b></para>
      <para>The address of an <see cref="IContextMenu" /> interface pointer that, when this function returns successfully, points to the <b>IContextMenu</b> object that represents the context menu.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <seealso cref="SHCreateDefaultContextMenu" />
  </member>
  <member name="Windows.IDListContainerIsConsistent">
    <summary>
      <para>Verifies that the container structure of an IDList is valid.</para>
    </summary>
    <param name="pidl">
      <para>A pointer to the IDList to validate.</para>
    </param>
    <param name="cbAlloc">
      <para>The size, in bytes, of the PIDL specified in the <i>pidl</i> parameter.</para>
    </param>
    <returns>
      <para>
        <b>TRUE</b> if the IDList structure is valid; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>This function should be used by any code that reads an IDList from a persisted format to ensure that invalid forms do not lead to a security exploit in the code that interprets the IDList. Shell data sources are responsible for validating private sections of the ITEMIDs. Hidden data is validated by the functions that interpret that data.</para>
    </remarks>
  </member>
  <member name="Windows.ILAppendID">
    <summary>
      <para>Appends or prepends an <see cref="SHITEMID" /> structure to an <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PIDLIST_RELATIVE</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> structure. When the function returns, the <see cref="SHITEMID" /> structure specified by <i>pmkid</i> is appended or prepended.</para>
    </param>
    <param name="pmkid">
      <para>Type: <b>LPSHITEMID</b></para>
      <para>A pointer to a <see cref="SHITEMID" /> structure to be appended or prepended to <i>pidl</i>.</para>
    </param>
    <param name="fAppend">
      <para>Type: <b>BOOL</b></para>
      <para>Value that is set to <b>TRUE</b> to append <i>pmkid</i> to <i>pidl</i>. Set this value to <b>FALSE</b> to prepend <i>pmkid</i> to <i>pidl</i>.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_RELATIVE</b></para>
      <para>Returns the <see cref="ITEMIDLIST" /> structure specified by <i>pidl</i>, with <i>pmkid</i> appended or prepended. Returns <b>NULL</b> on failure.</para>
    </returns>
  </member>
  <member name="Windows.ILClone">
    <summary>
      <para>Clones an <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A pointer to the <see cref="ITEMIDLIST" /> structure to be cloned.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_RELATIVE</b></para>
      <para>Returns a pointer to a copy of the <see cref="ITEMIDLIST" /> structure pointed to by <i>pidl</i>.</para>
    </returns>
    <remarks>
      <para>When you are finished with the cloned <see cref="ITEMIDLIST" /> structure, release it with <see cref="ILFree" /> to avoid memory leaks.</para>
    </remarks>
  </member>
  <member name="Windows.ILCloneChild">
    <summary>
      <para>Clones a child <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the child <see cref="ITEMIDLIST" /> structure to be cloned.</para>
    </param>
    <returns>
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to a copy of the child <see cref="ITEMIDLIST" /> structure pointed to by <i>pidl</i>.</para>
    </returns>
    <remarks>
      <para>When you are finished with the cloned <see cref="ITEMIDLIST" /> structure, release it with <see cref="ILFree" /> to avoid memory leaks.</para>
    </remarks>
  </member>
  <member name="Windows.ILCloneFirst">
    <summary>
      <para>Clones the first <see cref="SHITEMID" /> structure in an <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A pointer to the <see cref="ITEMIDLIST" /> structure that you want to clone.</para>
    </param>
    <returns>
      <para>Type: <b>PITEMID_CHILD</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> structure that contains the first <see cref="SHITEMID" /> structure from the <b>ITEMIDLIST</b> structure specified by <i>pidl</i>. Returns <b>NULL</b> on failure.</para>
    </returns>
    <seealso cref="ILClone" />
  </member>
  <member name="Windows.ILCloneFull">
    <summary>
      <para>Clones a full, or absolute, <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_ABSOLUTE</b></para>
      <para>A pointer to the full, or absolute, <see cref="ITEMIDLIST" /> structure to be cloned.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>A pointer to a copy of the <see cref="ITEMIDLIST" /> structure pointed to by <i>pidl</i>.</para>
    </returns>
    <remarks>
      <para>When you are finished with the cloned <see cref="ITEMIDLIST" /> structure, release it with <see cref="ILFree" /> to avoid memory leaks.</para>
    </remarks>
  </member>
  <member name="Windows.ILCombine">
    <summary>
      <para>Combines two <see cref="ITEMIDLIST" /> structures.</para>
    </summary>
    <param name="pidl1">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>A pointer to the first <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <param name="pidl2">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A pointer to the second <see cref="ITEMIDLIST" /> structure. This structure is appended to the structure pointed to by <i>pidl1</i>.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns an <see cref="ITEMIDLIST" /> containing the combined structures. If you set either <i>pidl1</i> or <i>pidl2</i> to <b>NULL</b>, the returned <b>ITEMIDLIST</b> structure is a clone of the non-<b>NULL</b> parameter. Returns <b>NULL</b> if <i>pidl1</i> and <i>pidl2</i> are both set to <b>NULL</b>.</para>
    </returns>
  </member>
  <member name="Windows.ILCreateFromPath">
    <summary>
      <para>Returns the <see cref="ITEMIDLIST" /> structure associated with a specified file path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a pointer to an <see cref="ITEMIDLIST" /> structure that corresponds to the path.</para>
    </returns>
    <remarks>
      <para>Call <see cref="ILFree" /> to release the <see cref="ITEMIDLIST" /> when you are finished with it.</para>
    </remarks>
  </member>
  <member name="Windows.ILCreateFromPathA">
    <summary>
      <para>Returns the <see cref="ITEMIDLIST" /> structure associated with a specified file path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a pointer to an <see cref="ITEMIDLIST" /> structure that corresponds to the path.</para>
    </returns>
    <remarks>
      <para>Call <see cref="ILFree" /> to release the <see cref="ITEMIDLIST" /> when you are finished with it.</para>
    </remarks>
  </member>
  <member name="Windows.ILCreateFromPathW">
    <summary>
      <para>Returns the <see cref="ITEMIDLIST" /> structure associated with a specified file path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a pointer to an <see cref="ITEMIDLIST" /> structure that corresponds to the path.</para>
    </returns>
    <remarks>
      <para>Call <see cref="ILFree" /> to release the <see cref="ITEMIDLIST" /> when you are finished with it.</para>
    </remarks>
  </member>
  <member name="Windows.ILCreateFromPath">
    <summary>
      <para>Returns the <see cref="ITEMIDLIST" /> structure associated with a specified file path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a pointer to an <see cref="ITEMIDLIST" /> structure that corresponds to the path.</para>
    </returns>
    <remarks>
      <para>Call <see cref="ILFree" /> to release the <see cref="ITEMIDLIST" /> when you are finished with it.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines ILCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ILCreateFromPathA">
    <summary>
      <para>Returns the <see cref="ITEMIDLIST" /> structure associated with a specified file path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a pointer to an <see cref="ITEMIDLIST" /> structure that corresponds to the path.</para>
    </returns>
    <remarks>
      <para>Call <see cref="ILFree" /> to release the <see cref="ITEMIDLIST" /> when you are finished with it.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines ILCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ILCreateFromPathW">
    <summary>
      <para>Returns the <see cref="ITEMIDLIST" /> structure associated with a specified file path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a pointer to an <see cref="ITEMIDLIST" /> structure that corresponds to the path.</para>
    </returns>
    <remarks>
      <para>Call <see cref="ILFree" /> to release the <see cref="ITEMIDLIST" /> when you are finished with it.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines ILCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ILCreateFromPath">
    <summary>
      <para>Returns the <see cref="ITEMIDLIST" /> structure associated with a specified file path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a pointer to an <see cref="ITEMIDLIST" /> structure that corresponds to the path.</para>
    </returns>
    <remarks>
      <para>Call <see cref="ILFree" /> to release the <see cref="ITEMIDLIST" /> when you are finished with it.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines ILCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ILCreateFromPathA">
    <summary>
      <para>Returns the <see cref="ITEMIDLIST" /> structure associated with a specified file path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a pointer to an <see cref="ITEMIDLIST" /> structure that corresponds to the path.</para>
    </returns>
    <remarks>
      <para>Call <see cref="ILFree" /> to release the <see cref="ITEMIDLIST" /> when you are finished with it.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines ILCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ILCreateFromPathW">
    <summary>
      <para>Returns the <see cref="ITEMIDLIST" /> structure associated with a specified file path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a pointer to an <see cref="ITEMIDLIST" /> structure that corresponds to the path.</para>
    </returns>
    <remarks>
      <para>Call <see cref="ILFree" /> to release the <see cref="ITEMIDLIST" /> when you are finished with it.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines ILCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ILFindChild">
    <summary>
      <para>Determines whether a specified <see cref="ITEMIDLIST" /> structure is the child of another <b>ITEMIDLIST</b> structure.</para>
    </summary>
    <param name="pidlParent">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>A pointer to the parent <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <param name="pidlChild">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>A pointer to the child <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <returns>
      <para>Type: <b>PUIDLIST_RELATIVE</b></para>
      <para>Returns a pointer to the child's simple <see cref="ITEMIDLIST" /> structure if <i>pidlChild</i> is a child of <i>pidlParent</i>. The returned structure consists of <i>pidlChild</i>, minus the <see cref="SHITEMID" /> structures that make up <i>pidlParent</i>. Returns <b>NULL</b> if <i>pidlChild</i> is not a child of <i>pidlParent</i>.</para>
      <para>
        <b>Note</b>  The returned pointer is a pointer into the existing parent structure. It is an alias for <i>pidlChild</i>. No new memory is allocated in association with the returned pointer. It is not the caller's responsibility to free the returned value.</para>
    </returns>
  </member>
  <member name="Windows.ILFindLastID">
    <summary>
      <para>Returns a pointer to the last <see cref="SHITEMID" /> structure in an <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <returns>
      <para>Type: <b>PUITEMID_CHILD</b></para>
      <para>A pointer to the last <see cref="SHITEMID" /> structure in <i>pidl</i>.</para>
    </returns>
    <remarks>
      <para>This function does not clone the last item, so you do not have to call <see cref="ILFree" /> to release the returned pointer.</para>
    </remarks>
  </member>
  <member name="Windows.HashTable_CoTaskMemFreeCB">
    <summary>
      <para>Frees an <see cref="ITEMIDLIST" /> structure allocated by the Shell.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PIDLIST_RELATIVE</b></para>
      <para>A pointer to the <see cref="ITEMIDLIST" /> structure to be freed. This parameter can be <b>NULL</b>.</para>
    </param>
    <remarks>
      <para>
        <b>ILFree</b> is often used with <see cref="ITEMIDLIST" /> structures allocated by one of the other IL functions, but it can be used to free any such structure returned by the Shell—for example, the <b>ITEMIDLIST</b> structure returned by <see cref="SHBrowseForFolder" /> or used in a call to <see cref="SHGetFolderLocation" />.</para>
      <para>
        <b>Note</b>  When using Windows 2000 or later, use <see cref="CoTaskMemFree" /> rather than <b>ILFree</b>. <see cref="ITEMIDLIST" /> structures are always allocated with the Component Object Model (COM) task allocator on those platforms.</para>
    </remarks>
    <seealso cref="ILAppendID" />
    <seealso cref="ILClone" />
    <seealso cref="ILCloneFirst" />
    <seealso cref="ILCombine" />
  </member>
  <member name="Windows.ILFree">
    <summary>
      <para>Frees an <see cref="ITEMIDLIST" /> structure allocated by the Shell.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PIDLIST_RELATIVE</b></para>
      <para>A pointer to the <see cref="ITEMIDLIST" /> structure to be freed. This parameter can be <b>NULL</b>.</para>
    </param>
    <remarks>
      <para>
        <b>ILFree</b> is often used with <see cref="ITEMIDLIST" /> structures allocated by one of the other IL functions, but it can be used to free any such structure returned by the Shell—for example, the <b>ITEMIDLIST</b> structure returned by <see cref="SHBrowseForFolder" /> or used in a call to <see cref="SHGetFolderLocation" />.</para>
      <para>
        <b>Note</b>  When using Windows 2000 or later, use <see cref="CoTaskMemFree" /> rather than <b>ILFree</b>. <see cref="ITEMIDLIST" /> structures are always allocated with the Component Object Model (COM) task allocator on those platforms.</para>
    </remarks>
    <seealso cref="ILAppendID" />
    <seealso cref="ILClone" />
    <seealso cref="ILCloneFirst" />
    <seealso cref="ILCombine" />
  </member>
  <member name="Windows.ILGetNext">
    <summary>
      <para>Retrieves the next <see cref="SHITEMID" /> structure in an <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A pointer to a particular <see cref="SHITEMID" /> structure in a larger <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <returns>
      <para>Type: <b>PUIDLIST_RELATIVE</b></para>
      <para>Returns a pointer to the <see cref="SHITEMID" /> structure that follows the one specified by <i>pidl</i>. Returns <b>NULL</b> if <i>pidl</i> points to the last <b>SHITEMID</b> structure.</para>
    </returns>
  </member>
  <member name="Windows.ILGetSize">
    <summary>
      <para>Returns the size, in bytes, of an <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>The size of the <see cref="ITEMIDLIST" /> structure specified by <i>pidl</i>, in bytes.</para>
    </returns>
  </member>
  <member name="Windows.ILIsAligned">
    <summary>
      <para>Verifies whether a constant <see cref="ITEMIDLIST" /> is aligned on a pointer boundary, which is a <b>DWORD</b> on 32-bit architectures and a <b>QWORD</b> on 64-bit architectures.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A constant PIDL relative to a parent folder that is being checked for alignment.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if aligned; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>For use where STRICT_TYPED_ITEMIDS is defined.</para>
    </remarks>
  </member>
  <member name="Windows.ILIsChild">
    <summary>
      <para>Verifies whether a pointer to an item identifier list (PIDL) is a child PIDL, which is a PIDL with exactly one <see cref="SHITEMID" />.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A constant, unaligned, relative PIDL that is being checked.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the given PIDL is a child PIDL; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>This function does not guarantee that the PIDL is non-NULL or non-empty.</para>
      <para>For use where STRICT_TYPED_ITEMIDS is defined.</para>
    </remarks>
  </member>
  <member name="Windows.ILIsEmpty">
    <summary>
      <para>Verifies whether an <see cref="ITEMIDLIST" /> structure is empty.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUID_RELATIVE</b></para>
      <para>A pointer to the <see cref="ITEMIDLIST" /> structure to be checked.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the <i>pidl</i> parameter is <b>NULL</b> or the <see cref="ITEMIDLIST" /> structure pointed to by <i>pidl</i> is empty; otherwise <b>FALSE</b>.</para>
    </returns>
  </member>
  <member name="Windows.ILIsEqual">
    <summary>
      <para>Tests whether two <see cref="ITEMIDLIST" /> structures are equal in a binary comparison.</para>
    </summary>
    <param name="pidl1">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>The first <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <param name="pidl2">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>The second <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the two structures are equal, <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>ILIsEqual</b> performs a binary comparison of the item data. It is possible for two <see cref="ITEMIDLIST" /> structures to differ at the binary level while referring to the same item. <see cref="IShellFolder.CompareIDs" /> should be used to perform a non-binary comparison.</para>
    </remarks>
  </member>
  <member name="Windows.ILIsParent">
    <summary>
      <para>Tests whether an <see cref="ITEMIDLIST" /> structure is the parent of another <b>ITEMIDLIST</b> structure.</para>
    </summary>
    <param name="pidl1">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> (PIDL) structure that specifies the parent. This must be an absolute PIDL.</para>
    </param>
    <param name="pidl2">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> (PIDL) structure that specifies the child. This must be an absolute PIDL.</para>
    </param>
    <param name="fImmediate">
      <para>Type: <b>BOOL</b></para>
      <para>A Boolean value that is set to <b>TRUE</b> to test for immediate parents of <i>pidl2</i>, or <b>FALSE</b> to test for any parents of <i>pidl2</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pidl1</i> is a parent of <i>pidl2</i>. If <i>fImmediate</i> is set to <b>TRUE</b>, the function only returns <b>TRUE</b> if <i>pidl1</i> is the immediate parent of <i>pidl2</i>. Otherwise, the function returns <b>FALSE</b>.</para>
    </returns>
  </member>
  <member name="Windows.ILNext">
    <summary>
      <para>Retrieves the next <see cref="SHITEMID" /> structure in an <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A constant, unaligned, relative PIDL for which the next <see cref="SHITEMID" /> structure is being retrieved.</para>
    </param>
    <returns>
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>When this function returns, contains one of three results: If <i>pidl</i> is valid and not the last <see cref="SHITEMID" /> in the <see cref="ITEMIDLIST" />, then it contains a pointer to the next <b>ITEMIDLIST</b> structure. If the last <b>ITEMIDLIST</b> structure is passed, it contains <b>NULL</b>, which signals the end of the PIDL. For other values of <i>pidl</i>, the return value is meaningless.</para>
    </returns>
    <remarks>
      <para>For use where STRICT_TYPED_ITEMIDS is defined.</para>
      <para>To verify if the return value is <b>NULL</b>, use <see cref="ILIsEmpty" />.</para>
    </remarks>
  </member>
  <member name="Windows.ILRemoveLastID">
    <summary>
      <para>Removes the last <see cref="SHITEMID" /> structure from an <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PUIDLIST_RELATIVE</b></para>
      <para>A pointer to the <see cref="ITEMIDLIST" /> structure to be shortened. When the function returns, this variable points to the shortened structure.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.</para>
    </returns>
  </member>
  <member name="Windows.ILSaveToStream">
    <summary>
      <para>Saves an <see cref="ITEMIDLIST" /> structure to a stream.</para>
    </summary>
    <param name="pstm">
      <para>Type: <b>IStream *</b></para>
      <para>A pointer to the <see cref="IStream" /> interface where the <see cref="ITEMIDLIST" /> is saved.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A pointer to the <see cref="ITEMIDLIST" /> structure to be saved.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>The stream must be opened for writing, or <b>ILSaveToStream</b> returns an error.</para>
    </remarks>
    <seealso cref="ILLoadFromStream" />
  </member>
  <member name="Windows.ILSkip">
    <summary>
      <para>Skips a given number of bytes in a constant, unaligned, relative <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A constant, unaligned, relative PIDL in which bytes are to be skipped.</para>
    </param>
    <param name="cb">
      <para>Type: <b>UINT</b></para>
      <para>The number of bytes to skip.</para>
    </param>
    <returns>
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>When this function returns, if <i>pidl</i> and <i>cb</i> are valid, contains a constant pointer to the <see cref="ITEMIDLIST" /> structure that results after the skip. Otherwise, the value is meaningless.</para>
    </returns>
    <remarks>
      <para>For use where STRICT_TYPED_ITEMIDS is defined.</para>
    </remarks>
  </member>
  <member name="Windows.PathMakeUniqueName">
    <summary>
      <para>Creates a unique path name from a template.</para>
    </summary>
    <param name="pszUniqueName">
      <para>Type: <b>PWSTR</b></para>
      <para>A buffer that receives a null-terminated Unicode string that contains the unique path name. It should be at least MAX_PATH characters in length.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The number of characters in the buffer pointed to by <i>pszUniqueName</i>.</para>
    </param>
    <param name="pszTemplate">
      <para>Type: <b>PCWSTR</b></para>
      <para>A null-terminated Unicode string that contains a template that is used to construct the unique name. This template is used for drives that require file names with the 8.3 format. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <param name="pszLongPlate">
      <para>Type: <b>PCWSTR</b></para>
      <para>A null-terminated Unicode string that contains a template that is used to construct the unique name. This template is used for drives that support long file names. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>PCWSTR</b></para>
      <para>A null-terminated string that contains the directory in which the new file resides. This string should be no more than MAX_PATH characters in length, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>This function generates a new unique file name based on the templates specified by <i>pszTemplate</i>, for drives that require the 8.3 format, and <i>pszLongPlate</i> for drives that support long file names. For example, if you specify "My New Filename" for <i>pszLongPlate</i>, <b>PathMakeUniqueName</b> returns names such as "My New Filename (1)", "My New Filename (2)", and so on.</para>
    </remarks>
  </member>
  <member name="Windows.PathYetAnotherMakeUniqueName">
    <summary>
      <para>Creates a unique filename based on an existing filename.</para>
    </summary>
    <param name="pszUniqueName">
      <para>Type: <b>PWSTR</b></para>
      <para>A string buffer that receives a null-terminated Unicode string that contains the fully qualified path of the unique file name. This buffer should be at least MAX_PATH characters long to avoid causing a buffer overrun.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>PCWSTR</b></para>
      <para>A null-terminated Unicode string that contains the fully qualified path of folder that will contain the new file. If <i>pszShort</i> is set to <b>NULL</b>, this string must contain a full destination path, ending with the long file name that the new file name will be base on.</para>
    </param>
    <param name="pszShort">
      <para>Type: <b>PCWSTR</b></para>
      <para>A null-terminated Unicode string that contains the short file name that the unique name will be based on. Set this value to <b>NULL</b> to create a name based on the long file name.</para>
    </param>
    <param name="pszFileSpec">
      <para>Type: <b>PCWSTR</b></para>
      <para>A null-terminated Unicode string that contains the long file name that the unique name will be based on.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a unique name was successfully created; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>If the generated path exceeds MAX_PATH characters, this function may return a truncated string in <b>PathYetAnotherMakeUniqueName</b>. In that case, the function returns <b>FALSE</b>.</para>
    </remarks>
    <seealso cref="PathMakeUniqueName" />
  </member>
  <member name="Windows.SHAddToRecentDocs">
    <summary>
      <para>Notifies the system that an item has been accessed, for the purposes of tracking those items used most recently and most frequently. This function can also be used to clear all usage data.</para>
    </summary>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>A value from the <see cref="SHARD" /> enumeration that indicates the form of the information pointed to by the <i>pv</i> parameter.</para>
    </param>
    <param name="pv">
      <para>Type: <b>LPCVOID</b></para>
      <para>A pointer to data that identifies the item that has been accessed. The item can be specified in this parameter in one of the following forms:</para>
      <list type="bullet">
        <item>
          <description>A null-terminated string that contains the path and file name of the item.</description>
        </item>
        <item>
          <description>A PIDL that identifies the item's file object.</description>
        </item>
        <item>
          <description>
            <b>Windows 7 and later only</b>. A <see cref="SHARDAPPIDINFO" />, <see cref="SHARDAPPIDINFOIDLIST" />, or <see cref="SHARDAPPIDINFOLINK" /> structure that identifies the item through an AppUserModelID. See <a href="https://docs.microsoft.com//windows/desktop/shell/appids">Application User Model IDs (AppUserModelIDs)</a> for more information.</description>
        </item>
        <item>
          <description>
            <b>Windows 7 and later only</b>. An <see cref="IShellLink" /> object that identifies the item through a shortcut.</description>
        </item>
      </list>
      <para>Set this parameter to <b>NULL</b> to clear all usage data on all items.</para>
    </param>
    <remarks>
      <para>The usage statistics gathered through calls to this method are used to determine lists of items accessed most recently and most frequently. These lists are seen in the <b>Start</b> menu and, in Windows 7 and later, in an application's Jump List.</para>
      <para>When this method is called, it affects the following areas:</para>
      <list type="bullet">
        <item>
          <description>Updates the <b>Recent</b> and <b>Frequent</b> lists for the associated application's Jump List.</description>
        </item>
        <item>
          <description>Adds a shortcut to the user's <a href="https://docs.microsoft.com//windows/desktop/shell/manage">Recent</a> folder (<a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">FOLDERID_Recent</a>, <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_RECENT</a>). This is reflected in the <b>My Recent Documents</b> (Windows XP) and <b>Recent Items</b> (Windows Vista and later) menu in the <b>Start</b> menu.</description>
        </item>
        <item>
          <description>Adds a shortcut to the Classic <b>Start</b> menu's <b>Documents</b> submenu. (Note that the Classic <b>Start</b> menu option is not available in Windows 7 and later.)</description>
        </item>
      </list>
      <para>Items represented by an <see cref="IShellLink" /> are not added to the <b>Recent</b> folder, although they are reflected in an application's Jump List.</para>
      <para>In some cases, notably when a user opens an item through Windows Explorer or uses the common file dialog to open, save, or create a file, the Shell calls <b>SHAddToRecentDocs</b> on behalf of the application. An application that has a custom UI for selecting items should call <b>SHAddToRecentDocs</b> explicitly to ensure accurate statistics. Duplicate calls are accounted for by the system so there is no risk of skewing the data by doing so.</para>
      <para>Executable (.exe) files are filtered from the recently used documents list in Windows XP and later versions. Although <b>SHAddToRecentDocs</b> will accept the path of an executable file, that file will not appear in the <b>Recent Items</b> list.</para>
      <para>Folders are also accepted by <b>SHAddToRecentDocs</b>, but appear only in the Jump List for the Windows Explorer taskbar button. Folders do not appear in any other application's Jump List.</para>
      <para>In certain cases, <b>SHAddToRecentDocs</b> attempts to register an application to handle a file type that it is not registered to handle. This occurs under these circumstances:</para>
      <list type="bullet">
        <item>
          <description>An application explicitly calls <b>SHAddToRecentDocs</b> with a file type that it is not registered to handle. This also applies to calls made to <b>SHAddToRecentDocs</b> by the common file dialog on behalf of the application, but only when the dialog is used to open a file, not when it is used to save one.</description>
        </item>
        <item>
          <description>The user drops a file of a type that the application is not registered to handle on the application's taskbar button.</description>
        </item>
      </list>
      <para>This registration is done per-user.</para>
      <para>A set of requirements must be met for the registration to be accomplished successfully:</para>
      <list type="bullet">
        <item>
          <description>The application must be registered under <b>HKEY_CLASSES_ROOT</b>\<b>Applications</b>.</description>
        </item>
        <item>
          <description>That registration cannot include the NoOpenWith value. See <a href="https://docs.microsoft.com//windows/desktop/shell/fa-file-types">File Types</a> for more details on NoOpenWith.</description>
        </item>
        <item>
          <description>That registration cannot supply data under a <b>SupportedTypes</b> subkey. See <a href="https://docs.microsoft.com//windows/desktop/shell/fa-file-types">File Types</a> for more details on the <b>SupportedTypes</b> subkey.</description>
        </item>
        <item>
          <description>
            <para>The application's executable file cannot be listed in the KillList value found here:</para>
            <code>
              <b>HKEY_LOCAL_MACHINE</b>
              <b>Software</b>
              <b>Microsoft</b>
              <b>Windows</b>
              <b>CurrentVersion</b>
              <b>Explorer</b>
              <b>FileAssociation</b>
              <b>KillList</b>
            </code>
            <para>
              <b>Note</b>  Third party applications should not modify the KillList value. It should be regarded as read-only.</para>
          </description>
        </item>
        <item>
          <description>
            <para>The application's <b>HKEY_CLASSES_ROOT</b>\<b>Applications</b> registration must have a set of default verbs defined under a</para>
            <para>
              <b>HKEY_CLASSES_ROOT</b>\<b>Applications</b>\<i>ExampleApp.exe</i>\<b>shell</b> subkey.</para>
            <para>If <b>SHAddToRecentDocs</b> is attempting the registration as the result of a drag-and-drop onto the taskbar button, the <b>shell</b> subkey is created if it does not already exist, as long as the existing application registration does not contain a NoOpenWith value and the application's executable is not listed in the KillList value.</para>
          </description>
        </item>
      </list>
      <h3>Suppressing Calls to SHAddToRecentDocs</h3>
      <para>In versions of Windows before Windows 7, a file type could set the <see cref="FTA_NoRecentDocs" /> flag to prevent that file type from being added to the <b>Recent</b> folder. This mechanism is also supported under Windows 7 and later. See <a href="https://docs.microsoft.com//windows/desktop/shell/fa-file-types">File Types</a> for more information.</para>
      <para>
        <b>SHAddToRecentDocs</b> tracks document usage statistics through the verbs that are invoked to access those documents. Verbs supplied by registered <see cref="IContextMenu" /> handlers are tracked, those items appear in <b>My Recent Documents</b> (Windows XP) and <b>Recent Items</b> (Windows Vista). In Windows 7, the parent folders of the documents appear in the Jump List for the Windows Explorer taskbar button. However, the documents accessed through those <b>IContextMenu</b> verbs do not appear in application Jump Lists. For those items to appear in an application's Jump List, an application must call <b>SHAddToRecentDocs</b> explicitly.</para>
      <para>Prior to Windows 7, only the <code>open</code> verb resulted in a call to <b>SHAddToRecentDocs</b>. In Windows 7 and later, other verbs can also generate usage statistics. This information is used to make a Jump List's destinations more complete and accurate.</para>
      <para>However, some classes of file type association registrations or individual <see cref="IContextMenu" /> implementations are not appropriate for this sort of tracking. The point of usage tracking is to generate a list of items that the user is likely to want to access again. If a particular verb—<code>delete</code>, for instance—is inherently invoked on an item that the user will not access again, or is a secondary action such as a virus scan on a file, that verb is not appropriate for tracking. File type classes should remove themselves from this tracking through the registry entry NoRecentDocs. NoRecentDocs is of type REG_SZ and has no associated data. Its presence is all that is required to prevent the call to <b>SHAddToRecentDocs</b>.</para>
      <para>For example, context menu extensions and static verbs registered under <b>HKEY_CLASSES_ROOT</b> in classes such as "*", "AllFileSystemObjects", or "Folder" should not be tracked. In cases such as these, the NoRecentDocs entry is added to the root of the class key as shown here to suppress tracking of documents launched through any verb or extension registered to that class:</para>
      <code>
        <b>HKEY_CLASSES_ROOT</b>
        <b>AllFileSystemObjects</b>
        <b>NoRecentDocs</b>
      </code>
      <para>The NoRecentDocs entry is assigned by default to the <b>*</b>, <b>AllFileSystemObjects</b>, <b>Folder</b>, <b>Directory</b>, and <b>DesktopBackground</b> class subkeys.</para>
      <para>Individual <see cref="IContextMenu" /> implementations can opt out of tracking by adding a NoRecentDocs subkey to its Component Object Model (COM) object's registration, in its <b>shellex</b> subkey, as shown here:</para>
      <code>
        <b>HKEY_CLASSES_ROOT</b>
        <b>CLSID</b>
        <i>{093C7AAB-5E72-454f-A91D-CA1BC991FCEC}</i>
        <b>shellex</b>
        <b>NoRecentDocs</b>
      </code>
      <para>This subkey is not present by default on any <see cref="IContextMenu" /> implementation.</para>
    </remarks>
    <seealso cref="SHGetFolderLocation" />
    <seealso cref="SHGetFolderPath" />
  </member>
  <member name="Windows.SHBindToFolderIDListParent">
    <summary>
      <para>Given a Shell namespace item specified in the form of a folder, and an item identifier list relative to that folder, this function binds to the parent of the namespace item and optionally returns a pointer to the final component of the item identifier list.</para>
    </summary>
    <param name="psfRoot">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>A pointer to a Shell folder object. If <i>psfRoot</i> is <b>NULL</b>, indicates that the IDList passed is relative to the desktop.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A PIDL to bind to, relative to <i>psfRoot</i>. If <i>psfRoot</i> is <b>NULL</b>, this is an absolute IDList relative to the desktop folder.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>Reference to the desired interface ID. This is typically IID_IShellFolder or IID_IShellFolder2, but can be anything supported by the target folder.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>void**</b></para>
      <para>When this function returns, contains the interface pointer requested in <i>riid</i>. This is typically <see cref="IShellFolder" /> or <see cref="IShellFolder2" />, but can be anything supported by the target folder.</para>
    </param>
    <param name="ppidlLast">
      <para>Type: <b>PCUITEMID_CHILD*</b></para>
      <para>A pointer to the last ID of the <i>pidl</i> parameter, and is a child ID relative to the parent folder returned in <i>ppv</i>. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  Calling the <b>SHBindToFolderIDListParent</b> function is equivalent to calling the <see cref="SHBindToFolderIDListParentEx" /> function with <b>NULL</b> as the bind context.</para>
    </remarks>
    <seealso cref="SHBindToFolderIDListParentEx" />
  </member>
  <member name="Windows.SHBindToFolderIDListParentEx">
    <summary>
      <para>Extends the <see cref="SHBindToFolderIDListParent" /> function by allowing the caller to specify a bind context.</para>
    </summary>
    <param name="psfRoot">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>A pointer to a Shell folder object. If <i>psfRoot</i> is <b>NULL</b>, indicates that the IDList passed is relative to the desktop.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A PIDL to bind to, relative to <i>psfRoot</i>. If <i>psfRoot</i> is <b>NULL</b>, this is an absolute IDList relative to the desktop folder.</para>
    </param>
    <param name="ppbc">
      <para>Type: <b><see cref="IBindCtx" />*</b></para>
      <para>A pointer to <see cref="IBindCtx" /> interface on a bind context object to be used during this operation. If this parameter is not used, set it to <b>NULL</b>, which is equivalent to calling the <see cref="SHBindToFolderIDListParent" /> function. Because support for <i>pbc</i> is optional for folder object implementations, some folders may not support the use of bind contexts.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>Reference to the desired interface ID. This is typically IID_IShellFolder or IID_IShellFolder2, but can be anything supported by the target folder.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>void**</b></para>
      <para>When this function returns, contains the interface pointer requested in <i>riid</i>. This is typically <see cref="IShellFolder" /> or <see cref="IShellFolder2" />, but can be anything supported by the target folder.</para>
    </param>
    <param name="ppidlLast">
      <para>Type: <b>PCUITEMID_CHILD*</b></para>
      <para>A pointer to the last ID of the <i>pidl</i> parameter, and is a child ID relative to the parent folder returned in <i>ppv</i>. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <seealso cref="SHBindToFolderIDListParent" />
  </member>
  <member name="Windows.SHBindToObject">
    <summary>
      <para>Retrieves and binds to a specified object by using the Shell namespace <see cref="IShellFolder.BindToObject" /> method.</para>
    </summary>
    <param name="psf">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>A pointer to <see cref="IShellFolder" />. This parameter can be <b>NULL</b>.   If <i>psf</i> is <b>NULL</b>,  this indicates
parameter <i>pidl</i> is relative to the desktop. In this case, <i>pidl</i> must specify an absolute <see cref="ITEMIDLIST" />.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>A pointer to a constant <see cref="ITEMIDLIST" /> to bind to that is relative to <i>psf</i>. If <i>psf</i> is <b>NULL</b>, this is an absolute <b>ITEMIDLIST</b> relative to the desktop folder.</para>
    </param>
    <param name="pbc">
      <para>Type: <b><see cref="IBindCtx" />*</b></para>
      <para>A pointer to <see cref="IBindCtx" /> interface on a bind context object to be used during this operation. If this parameter is not used, set it to <b>NULL</b>. Because support for <i>pbc</i> is optional for folder object implementations, some folders may not support the use of bind contexts.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>Identifier of the interface to return.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>void**</b></para>
      <para>When this method returns, contains the interface pointer as specified in <i>riid</i> to the bound object. If an error occurs, contains a <b>NULL</b> pointer.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a helper function that gets the desktop object by calling <see cref="SHGetDesktopFolder" />.</para>
    </remarks>
    <seealso cref="IShellFolder" />
    <seealso cref="IShellFolder.BindToObject" />
  </member>
  <member name="Windows.SHBindToParent">
    <summary>
      <para>Takes a pointer to a fully qualified item identifier list (PIDL), and returns a specified interface pointer on the parent object.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>The item's PIDL.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>The <b>REFIID</b> of one of the interfaces exposed by the item's parent object.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>VOID**</b></para>
      <para>A pointer to the interface specified by <i>riid</i>. You must release the object when you are finished.</para>
    </param>
    <param name="ppidlLast">
      <para>Type: <b>PCUITEMID_CHILD*</b></para>
      <para>The item's PIDL relative to the parent folder. This PIDL can be used with many of the methods supported by the parent folder's interfaces. If you set <i>ppidlLast</i> to <b>NULL</b>, the PIDL is not returned.</para>
      <para>
        <b>Note</b>  <b>SHBindToParent</b> does not allocate a new PIDL; it simply receives a pointer through this parameter. Therefore, you are not responsible for freeing this resource.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.SHBrowseForFolder">
    <summary>
      <para>Displays a dialog box that enables the user to select a Shell folder.</para>
    </summary>
    <param name="lpbi">
      <para>Type: <b>LPBROWSEINFO</b></para>
      <para>A pointer to a <see cref="BROWSEINFO" /> structure that contains information used to display the dialog box.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a PIDL that specifies the location of the selected folder relative to the root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is <b>NULL</b>.</para>
      <para>It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full discussion of this case, see the Remarks section.</para>
    </returns>
    <remarks>
      <para>For Windows Vista or later, it is recommended that you use <see cref="IFileDialog" /> with the FOS_PICKFOLDERS option rather than the SHBrowseForFolder function. This uses the Open Files dialog in pick folders mode and is the preferred implementation.</para>
      <para>You must initialize Component Object Model (COM) before you call <b>SHBrowseForFolder</b>. If you initialize COM using <see cref="CoInitializeEx" />, you must set the COINIT_APARTMENTTHREADED flag in its <i>dwCoInit</i> parameter. You can also use <see cref="CoInitialize" /> or <see cref="OleInitialize" />, which always use apartment threading. If you require drag-and-drop functionality, <b>OleInitialize</b> is recommended because it initializes the required OLE as well as COM.</para>
      <para>
        <b>Note</b>  If COM is initialized using <see cref="CoInitializeEx" /> with the COINIT_MULTITHREADED flag, <b>SHBrowseForFolder</b> fails if the calling application uses the BIF_USENEWUI or BIF_NEWDIALOGSTYLE flag in the <see cref="BROWSEINFO" /> structure.</para>
      <para>It is the responsibility of the calling application to call <see cref="CoTaskMemFree" /> to free the IDList returned by <b>SHBrowseForFolder</b> when it is no longer needed.</para>
      <para>There are two styles of dialog box available. The older style is displayed by default and is not resizable. The newer style provides a number of additional features, including drag-and-drop capability within the dialog box, reordering, deletion, shortcut menus, the ability to create new folders, and other shortcut menu commands. Initially, it is larger than the older dialog box, but the user can resize it. To specify a dialog box using the newer style, set the <b>BIF_USENEWUI</b> flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure.</para>
      <para>If you implement a callback function, specified in the <b>lpfn</b> member of the <see cref="BROWSEINFO" /> structure, you receive a handle to the dialog box. One use of this window handle is to modify the layout or contents of the dialog box. Because it is not resizable, modifying the older style dialog box is relatively straightforward. Modifying the newer style dialog box is much more difficult, and not recommended. Not only does it have a different size and layout than the old style, but its dimensions and the positions of its controls change every time it is resized by the user.</para>
      <para>If the BIF_RETURNONLYFSDIRS flag is set in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure, the <b>OK</b> button remains enabled for "\server" items, as well as "\server\share" and directory items. However, if the user selects a "\server" item, passing the PIDL returned by <b>SHBrowseForFolder</b> to <see cref="SHGetPathFromIDList" /> fails.</para>
      <h3>Custom Filtering</h3>
      <para>As of Windows XP, <b>SHBrowseForFolder</b> supports custom filtering on the contents of the dialog box. To create a custom filter, follow these steps.</para>
      <list type="number">
        <item>
          <description>Set the BIF_NEWDIALOGSTYLE flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure pointed to by the <i>lpbi</i> parameter.</description>
        </item>
        <item>
          <description>Specify a callback function in the <b>lpfn</b> member of that same <see cref="BROWSEINFO" /> structure.</description>
        </item>
        <item>
          <description>Code the callback function to receive the BFFM_INITIALIZED and BFFM_IUNKNOWN messages. On receipt of the BFFM_IUNKNOWN message, the callback function's <i>lParam</i> parameter contains a pointer to the dialog box's implementation of <see cref="IUnknown" />. Call <see cref="QueryInterface" /> on that <b>IUnknown</b> to obtain a pointer to an instance of <see cref="IFolderFilterSite" />.</description>
        </item>
        <item>
          <description>Create an object that implements <see cref="IFolderFilter" />.</description>
        </item>
        <item>
          <description>Call <see cref="IFolderFilterSite.SetFilter" />, passing to it a pointer to your <see cref="IFolderFilter" />. <b>IFolderFilter</b> methods can then be used to include and exclude items from the tree.</description>
        </item>
        <item>
          <description>Once the filter is created, the <see cref="IFolderFilterSite" /> interface is no longer needed. Call <see cref="IFolderFilterSite.Release" /> if you have no further use for it.</description>
        </item>
      </list>
      <h3>Dealing With Shortcuts</h3>
      <b>Note</b>  This section applies to only Windows 2000 and earlier systems. By default, Windows XP and later systems return the PIDL of a shortcut's target rather than the shortcut itself, as long as the BIF_NOTRANSLATETARGETS flag is not set in the <see cref="BROWSEINFO" /> structure.
<para>If <b>SHBrowseForFolder</b> returns a PIDL to a shortcut, sending that PIDL to <see cref="SHGetPathFromIDList" /> returns the path of the shortcut itself rather than the path of its target. The path to the shortcut's target can be obtained by using the <see cref="IShellLink" /> interface as shown in this example.</para><code>#include

// Macros for interface casts
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast(static_cast(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &amp;amp;amp;amp;amp;amp;IID_##IType, (void**)(ppType)
#endif

// Retrieves the UIObject interface for the specified full PIDL
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;

    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &amp;amp;amp;amp;amp;amp;psf), &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

#define ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define ILNext(pidl)           ILSkip(pidl, (pidl)-&gt;mkid.cb)

HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;

    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += sizeof (pidl_temp-&gt;mkid.cb);

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp += ILNext (pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);

    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
STDAPI SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;

    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_PPV_ARG(IShellLink, &amp;amp;amp;amp;amp;amp;psl));

    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);

    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder, and
// other items of that nature.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;

    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);

    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);   // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><code>
// Retrieves the UIObject interface for the specified full PIDLstatic
HRESULT SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;
    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_IShellFolder, (LPVOID*)&amp;amp;amp;amp;amp;amp;psf, &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

static HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;
    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += pidl_temp-&gt;mkid.cb;

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp = ILNext(pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);
    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
static HRESULT SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;
    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_IShellLink, (LPVOID*)&amp;amp;amp;amp;amp;amp;psl);
    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);
    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder,
// and so on.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;
    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);
    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);

        // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><blockquote><para>[!NOTE]
The shlobj_core.h header defines SHBrowseForFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/dlgbox/open-and-save-as-dialog-boxes">Open and Save as Dialog Boxes</seealso>
  </member>
  <member name="Windows.SHBrowseForFolderA">
    <summary>
      <para>Displays a dialog box that enables the user to select a Shell folder.</para>
    </summary>
    <param name="lpbi">
      <para>Type: <b>LPBROWSEINFO</b></para>
      <para>A pointer to a <see cref="BROWSEINFO" /> structure that contains information used to display the dialog box.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a PIDL that specifies the location of the selected folder relative to the root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is <b>NULL</b>.</para>
      <para>It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full discussion of this case, see the Remarks section.</para>
    </returns>
    <remarks>
      <para>For Windows Vista or later, it is recommended that you use <see cref="IFileDialog" /> with the FOS_PICKFOLDERS option rather than the SHBrowseForFolder function. This uses the Open Files dialog in pick folders mode and is the preferred implementation.</para>
      <para>You must initialize Component Object Model (COM) before you call <b>SHBrowseForFolder</b>. If you initialize COM using <see cref="CoInitializeEx" />, you must set the COINIT_APARTMENTTHREADED flag in its <i>dwCoInit</i> parameter. You can also use <see cref="CoInitialize" /> or <see cref="OleInitialize" />, which always use apartment threading. If you require drag-and-drop functionality, <b>OleInitialize</b> is recommended because it initializes the required OLE as well as COM.</para>
      <para>
        <b>Note</b>  If COM is initialized using <see cref="CoInitializeEx" /> with the COINIT_MULTITHREADED flag, <b>SHBrowseForFolder</b> fails if the calling application uses the BIF_USENEWUI or BIF_NEWDIALOGSTYLE flag in the <see cref="BROWSEINFO" /> structure.</para>
      <para>It is the responsibility of the calling application to call <see cref="CoTaskMemFree" /> to free the IDList returned by <b>SHBrowseForFolder</b> when it is no longer needed.</para>
      <para>There are two styles of dialog box available. The older style is displayed by default and is not resizable. The newer style provides a number of additional features, including drag-and-drop capability within the dialog box, reordering, deletion, shortcut menus, the ability to create new folders, and other shortcut menu commands. Initially, it is larger than the older dialog box, but the user can resize it. To specify a dialog box using the newer style, set the <b>BIF_USENEWUI</b> flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure.</para>
      <para>If you implement a callback function, specified in the <b>lpfn</b> member of the <see cref="BROWSEINFO" /> structure, you receive a handle to the dialog box. One use of this window handle is to modify the layout or contents of the dialog box. Because it is not resizable, modifying the older style dialog box is relatively straightforward. Modifying the newer style dialog box is much more difficult, and not recommended. Not only does it have a different size and layout than the old style, but its dimensions and the positions of its controls change every time it is resized by the user.</para>
      <para>If the BIF_RETURNONLYFSDIRS flag is set in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure, the <b>OK</b> button remains enabled for "\server" items, as well as "\server\share" and directory items. However, if the user selects a "\server" item, passing the PIDL returned by <b>SHBrowseForFolder</b> to <see cref="SHGetPathFromIDList" /> fails.</para>
      <h3>Custom Filtering</h3>
      <para>As of Windows XP, <b>SHBrowseForFolder</b> supports custom filtering on the contents of the dialog box. To create a custom filter, follow these steps.</para>
      <list type="number">
        <item>
          <description>Set the BIF_NEWDIALOGSTYLE flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure pointed to by the <i>lpbi</i> parameter.</description>
        </item>
        <item>
          <description>Specify a callback function in the <b>lpfn</b> member of that same <see cref="BROWSEINFO" /> structure.</description>
        </item>
        <item>
          <description>Code the callback function to receive the BFFM_INITIALIZED and BFFM_IUNKNOWN messages. On receipt of the BFFM_IUNKNOWN message, the callback function's <i>lParam</i> parameter contains a pointer to the dialog box's implementation of <see cref="IUnknown" />. Call <see cref="QueryInterface" /> on that <b>IUnknown</b> to obtain a pointer to an instance of <see cref="IFolderFilterSite" />.</description>
        </item>
        <item>
          <description>Create an object that implements <see cref="IFolderFilter" />.</description>
        </item>
        <item>
          <description>Call <see cref="IFolderFilterSite.SetFilter" />, passing to it a pointer to your <see cref="IFolderFilter" />. <b>IFolderFilter</b> methods can then be used to include and exclude items from the tree.</description>
        </item>
        <item>
          <description>Once the filter is created, the <see cref="IFolderFilterSite" /> interface is no longer needed. Call <see cref="IFolderFilterSite.Release" /> if you have no further use for it.</description>
        </item>
      </list>
      <h3>Dealing With Shortcuts</h3>
      <b>Note</b>  This section applies to only Windows 2000 and earlier systems. By default, Windows XP and later systems return the PIDL of a shortcut's target rather than the shortcut itself, as long as the BIF_NOTRANSLATETARGETS flag is not set in the <see cref="BROWSEINFO" /> structure.
<para>If <b>SHBrowseForFolder</b> returns a PIDL to a shortcut, sending that PIDL to <see cref="SHGetPathFromIDList" /> returns the path of the shortcut itself rather than the path of its target. The path to the shortcut's target can be obtained by using the <see cref="IShellLink" /> interface as shown in this example.</para><code>#include

// Macros for interface casts
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast(static_cast(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &amp;amp;amp;amp;amp;amp;IID_##IType, (void**)(ppType)
#endif

// Retrieves the UIObject interface for the specified full PIDL
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;

    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &amp;amp;amp;amp;amp;amp;psf), &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

#define ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define ILNext(pidl)           ILSkip(pidl, (pidl)-&gt;mkid.cb)

HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;

    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += sizeof (pidl_temp-&gt;mkid.cb);

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp += ILNext (pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);

    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
STDAPI SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;

    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_PPV_ARG(IShellLink, &amp;amp;amp;amp;amp;amp;psl));

    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);

    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder, and
// other items of that nature.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;

    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);

    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);   // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><code>
// Retrieves the UIObject interface for the specified full PIDLstatic
HRESULT SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;
    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_IShellFolder, (LPVOID*)&amp;amp;amp;amp;amp;amp;psf, &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

static HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;
    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += pidl_temp-&gt;mkid.cb;

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp = ILNext(pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);
    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
static HRESULT SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;
    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_IShellLink, (LPVOID*)&amp;amp;amp;amp;amp;amp;psl);
    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);
    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder,
// and so on.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;
    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);
    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);

        // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><blockquote><para>[!NOTE]
The shlobj_core.h header defines SHBrowseForFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/dlgbox/open-and-save-as-dialog-boxes">Open and Save as Dialog Boxes</seealso>
  </member>
  <member name="Windows.SHBrowseForFolderW">
    <summary>
      <para>Displays a dialog box that enables the user to select a Shell folder.</para>
    </summary>
    <param name="lpbi">
      <para>Type: <b>LPBROWSEINFO</b></para>
      <para>A pointer to a <see cref="BROWSEINFO" /> structure that contains information used to display the dialog box.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a PIDL that specifies the location of the selected folder relative to the root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is <b>NULL</b>.</para>
      <para>It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full discussion of this case, see the Remarks section.</para>
    </returns>
    <remarks>
      <para>For Windows Vista or later, it is recommended that you use <see cref="IFileDialog" /> with the FOS_PICKFOLDERS option rather than the SHBrowseForFolder function. This uses the Open Files dialog in pick folders mode and is the preferred implementation.</para>
      <para>You must initialize Component Object Model (COM) before you call <b>SHBrowseForFolder</b>. If you initialize COM using <see cref="CoInitializeEx" />, you must set the COINIT_APARTMENTTHREADED flag in its <i>dwCoInit</i> parameter. You can also use <see cref="CoInitialize" /> or <see cref="OleInitialize" />, which always use apartment threading. If you require drag-and-drop functionality, <b>OleInitialize</b> is recommended because it initializes the required OLE as well as COM.</para>
      <para>
        <b>Note</b>  If COM is initialized using <see cref="CoInitializeEx" /> with the COINIT_MULTITHREADED flag, <b>SHBrowseForFolder</b> fails if the calling application uses the BIF_USENEWUI or BIF_NEWDIALOGSTYLE flag in the <see cref="BROWSEINFO" /> structure.</para>
      <para>It is the responsibility of the calling application to call <see cref="CoTaskMemFree" /> to free the IDList returned by <b>SHBrowseForFolder</b> when it is no longer needed.</para>
      <para>There are two styles of dialog box available. The older style is displayed by default and is not resizable. The newer style provides a number of additional features, including drag-and-drop capability within the dialog box, reordering, deletion, shortcut menus, the ability to create new folders, and other shortcut menu commands. Initially, it is larger than the older dialog box, but the user can resize it. To specify a dialog box using the newer style, set the <b>BIF_USENEWUI</b> flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure.</para>
      <para>If you implement a callback function, specified in the <b>lpfn</b> member of the <see cref="BROWSEINFO" /> structure, you receive a handle to the dialog box. One use of this window handle is to modify the layout or contents of the dialog box. Because it is not resizable, modifying the older style dialog box is relatively straightforward. Modifying the newer style dialog box is much more difficult, and not recommended. Not only does it have a different size and layout than the old style, but its dimensions and the positions of its controls change every time it is resized by the user.</para>
      <para>If the BIF_RETURNONLYFSDIRS flag is set in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure, the <b>OK</b> button remains enabled for "\server" items, as well as "\server\share" and directory items. However, if the user selects a "\server" item, passing the PIDL returned by <b>SHBrowseForFolder</b> to <see cref="SHGetPathFromIDList" /> fails.</para>
      <h3>Custom Filtering</h3>
      <para>As of Windows XP, <b>SHBrowseForFolder</b> supports custom filtering on the contents of the dialog box. To create a custom filter, follow these steps.</para>
      <list type="number">
        <item>
          <description>Set the BIF_NEWDIALOGSTYLE flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure pointed to by the <i>lpbi</i> parameter.</description>
        </item>
        <item>
          <description>Specify a callback function in the <b>lpfn</b> member of that same <see cref="BROWSEINFO" /> structure.</description>
        </item>
        <item>
          <description>Code the callback function to receive the BFFM_INITIALIZED and BFFM_IUNKNOWN messages. On receipt of the BFFM_IUNKNOWN message, the callback function's <i>lParam</i> parameter contains a pointer to the dialog box's implementation of <see cref="IUnknown" />. Call <see cref="QueryInterface" /> on that <b>IUnknown</b> to obtain a pointer to an instance of <see cref="IFolderFilterSite" />.</description>
        </item>
        <item>
          <description>Create an object that implements <see cref="IFolderFilter" />.</description>
        </item>
        <item>
          <description>Call <see cref="IFolderFilterSite.SetFilter" />, passing to it a pointer to your <see cref="IFolderFilter" />. <b>IFolderFilter</b> methods can then be used to include and exclude items from the tree.</description>
        </item>
        <item>
          <description>Once the filter is created, the <see cref="IFolderFilterSite" /> interface is no longer needed. Call <see cref="IFolderFilterSite.Release" /> if you have no further use for it.</description>
        </item>
      </list>
      <h3>Dealing With Shortcuts</h3>
      <b>Note</b>  This section applies to only Windows 2000 and earlier systems. By default, Windows XP and later systems return the PIDL of a shortcut's target rather than the shortcut itself, as long as the BIF_NOTRANSLATETARGETS flag is not set in the <see cref="BROWSEINFO" /> structure.
<para>If <b>SHBrowseForFolder</b> returns a PIDL to a shortcut, sending that PIDL to <see cref="SHGetPathFromIDList" /> returns the path of the shortcut itself rather than the path of its target. The path to the shortcut's target can be obtained by using the <see cref="IShellLink" /> interface as shown in this example.</para><code>#include

// Macros for interface casts
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast(static_cast(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &amp;amp;amp;amp;amp;amp;IID_##IType, (void**)(ppType)
#endif

// Retrieves the UIObject interface for the specified full PIDL
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;

    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &amp;amp;amp;amp;amp;amp;psf), &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

#define ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define ILNext(pidl)           ILSkip(pidl, (pidl)-&gt;mkid.cb)

HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;

    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += sizeof (pidl_temp-&gt;mkid.cb);

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp += ILNext (pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);

    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
STDAPI SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;

    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_PPV_ARG(IShellLink, &amp;amp;amp;amp;amp;amp;psl));

    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);

    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder, and
// other items of that nature.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;

    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);

    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);   // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><code>
// Retrieves the UIObject interface for the specified full PIDLstatic
HRESULT SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;
    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_IShellFolder, (LPVOID*)&amp;amp;amp;amp;amp;amp;psf, &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

static HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;
    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += pidl_temp-&gt;mkid.cb;

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp = ILNext(pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);
    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
static HRESULT SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;
    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_IShellLink, (LPVOID*)&amp;amp;amp;amp;amp;amp;psl);
    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);
    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder,
// and so on.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;
    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);
    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);

        // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><blockquote><para>[!NOTE]
The shlobj_core.h header defines SHBrowseForFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/dlgbox/open-and-save-as-dialog-boxes">Open and Save as Dialog Boxes</seealso>
  </member>
  <member name="Windows.SHBrowseForFolder">
    <summary>
      <para>Displays a dialog box that enables the user to select a Shell folder.</para>
    </summary>
    <param name="lpbi">
      <para>Type: <b>LPBROWSEINFO</b></para>
      <para>A pointer to a <see cref="BROWSEINFO" /> structure that contains information used to display the dialog box.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a PIDL that specifies the location of the selected folder relative to the root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is <b>NULL</b>.</para>
      <para>It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full discussion of this case, see the Remarks section.</para>
    </returns>
    <remarks>
      <para>For Windows Vista or later, it is recommended that you use <see cref="IFileDialog" /> with the FOS_PICKFOLDERS option rather than the SHBrowseForFolder function. This uses the Open Files dialog in pick folders mode and is the preferred implementation.</para>
      <para>You must initialize Component Object Model (COM) before you call <b>SHBrowseForFolder</b>. If you initialize COM using <see cref="CoInitializeEx" />, you must set the COINIT_APARTMENTTHREADED flag in its <i>dwCoInit</i> parameter. You can also use <see cref="CoInitialize" /> or <see cref="OleInitialize" />, which always use apartment threading. If you require drag-and-drop functionality, <b>OleInitialize</b> is recommended because it initializes the required OLE as well as COM.</para>
      <para>
        <b>Note</b>  If COM is initialized using <see cref="CoInitializeEx" /> with the COINIT_MULTITHREADED flag, <b>SHBrowseForFolder</b> fails if the calling application uses the BIF_USENEWUI or BIF_NEWDIALOGSTYLE flag in the <see cref="BROWSEINFO" /> structure.</para>
      <para>It is the responsibility of the calling application to call <see cref="CoTaskMemFree" /> to free the IDList returned by <b>SHBrowseForFolder</b> when it is no longer needed.</para>
      <para>There are two styles of dialog box available. The older style is displayed by default and is not resizable. The newer style provides a number of additional features, including drag-and-drop capability within the dialog box, reordering, deletion, shortcut menus, the ability to create new folders, and other shortcut menu commands. Initially, it is larger than the older dialog box, but the user can resize it. To specify a dialog box using the newer style, set the <b>BIF_USENEWUI</b> flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure.</para>
      <para>If you implement a callback function, specified in the <b>lpfn</b> member of the <see cref="BROWSEINFO" /> structure, you receive a handle to the dialog box. One use of this window handle is to modify the layout or contents of the dialog box. Because it is not resizable, modifying the older style dialog box is relatively straightforward. Modifying the newer style dialog box is much more difficult, and not recommended. Not only does it have a different size and layout than the old style, but its dimensions and the positions of its controls change every time it is resized by the user.</para>
      <para>If the BIF_RETURNONLYFSDIRS flag is set in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure, the <b>OK</b> button remains enabled for "\server" items, as well as "\server\share" and directory items. However, if the user selects a "\server" item, passing the PIDL returned by <b>SHBrowseForFolder</b> to <see cref="SHGetPathFromIDList" /> fails.</para>
      <h3>Custom Filtering</h3>
      <para>As of Windows XP, <b>SHBrowseForFolder</b> supports custom filtering on the contents of the dialog box. To create a custom filter, follow these steps.</para>
      <list type="number">
        <item>
          <description>Set the BIF_NEWDIALOGSTYLE flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure pointed to by the <i>lpbi</i> parameter.</description>
        </item>
        <item>
          <description>Specify a callback function in the <b>lpfn</b> member of that same <see cref="BROWSEINFO" /> structure.</description>
        </item>
        <item>
          <description>Code the callback function to receive the BFFM_INITIALIZED and BFFM_IUNKNOWN messages. On receipt of the BFFM_IUNKNOWN message, the callback function's <i>lParam</i> parameter contains a pointer to the dialog box's implementation of <see cref="IUnknown" />. Call <see cref="QueryInterface" /> on that <b>IUnknown</b> to obtain a pointer to an instance of <see cref="IFolderFilterSite" />.</description>
        </item>
        <item>
          <description>Create an object that implements <see cref="IFolderFilter" />.</description>
        </item>
        <item>
          <description>Call <see cref="IFolderFilterSite.SetFilter" />, passing to it a pointer to your <see cref="IFolderFilter" />. <b>IFolderFilter</b> methods can then be used to include and exclude items from the tree.</description>
        </item>
        <item>
          <description>Once the filter is created, the <see cref="IFolderFilterSite" /> interface is no longer needed. Call <see cref="IFolderFilterSite.Release" /> if you have no further use for it.</description>
        </item>
      </list>
      <h3>Dealing With Shortcuts</h3>
      <b>Note</b>  This section applies to only Windows 2000 and earlier systems. By default, Windows XP and later systems return the PIDL of a shortcut's target rather than the shortcut itself, as long as the BIF_NOTRANSLATETARGETS flag is not set in the <see cref="BROWSEINFO" /> structure.
<para>If <b>SHBrowseForFolder</b> returns a PIDL to a shortcut, sending that PIDL to <see cref="SHGetPathFromIDList" /> returns the path of the shortcut itself rather than the path of its target. The path to the shortcut's target can be obtained by using the <see cref="IShellLink" /> interface as shown in this example.</para><code>#include

// Macros for interface casts
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast(static_cast(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &amp;amp;amp;amp;amp;amp;IID_##IType, (void**)(ppType)
#endif

// Retrieves the UIObject interface for the specified full PIDL
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;

    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &amp;amp;amp;amp;amp;amp;psf), &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

#define ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define ILNext(pidl)           ILSkip(pidl, (pidl)-&gt;mkid.cb)

HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;

    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += sizeof (pidl_temp-&gt;mkid.cb);

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp += ILNext (pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);

    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
STDAPI SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;

    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_PPV_ARG(IShellLink, &amp;amp;amp;amp;amp;amp;psl));

    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);

    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder, and
// other items of that nature.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;

    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);

    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);   // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><code>
// Retrieves the UIObject interface for the specified full PIDLstatic
HRESULT SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;
    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_IShellFolder, (LPVOID*)&amp;amp;amp;amp;amp;amp;psf, &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

static HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;
    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += pidl_temp-&gt;mkid.cb;

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp = ILNext(pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);
    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
static HRESULT SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;
    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_IShellLink, (LPVOID*)&amp;amp;amp;amp;amp;amp;psl);
    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);
    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder,
// and so on.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;
    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);
    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);

        // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><blockquote><para>[!NOTE]
The shlobj_core.h header defines SHBrowseForFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/dlgbox/open-and-save-as-dialog-boxes">Open and Save as Dialog Boxes</seealso>
  </member>
  <member name="Windows.SHBrowseForFolderA">
    <summary>
      <para>Displays a dialog box that enables the user to select a Shell folder.</para>
    </summary>
    <param name="lpbi">
      <para>Type: <b>LPBROWSEINFO</b></para>
      <para>A pointer to a <see cref="BROWSEINFO" /> structure that contains information used to display the dialog box.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a PIDL that specifies the location of the selected folder relative to the root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is <b>NULL</b>.</para>
      <para>It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full discussion of this case, see the Remarks section.</para>
    </returns>
    <remarks>
      <para>For Windows Vista or later, it is recommended that you use <see cref="IFileDialog" /> with the FOS_PICKFOLDERS option rather than the SHBrowseForFolder function. This uses the Open Files dialog in pick folders mode and is the preferred implementation.</para>
      <para>You must initialize Component Object Model (COM) before you call <b>SHBrowseForFolder</b>. If you initialize COM using <see cref="CoInitializeEx" />, you must set the COINIT_APARTMENTTHREADED flag in its <i>dwCoInit</i> parameter. You can also use <see cref="CoInitialize" /> or <see cref="OleInitialize" />, which always use apartment threading. If you require drag-and-drop functionality, <b>OleInitialize</b> is recommended because it initializes the required OLE as well as COM.</para>
      <para>
        <b>Note</b>  If COM is initialized using <see cref="CoInitializeEx" /> with the COINIT_MULTITHREADED flag, <b>SHBrowseForFolder</b> fails if the calling application uses the BIF_USENEWUI or BIF_NEWDIALOGSTYLE flag in the <see cref="BROWSEINFO" /> structure.</para>
      <para>It is the responsibility of the calling application to call <see cref="CoTaskMemFree" /> to free the IDList returned by <b>SHBrowseForFolder</b> when it is no longer needed.</para>
      <para>There are two styles of dialog box available. The older style is displayed by default and is not resizable. The newer style provides a number of additional features, including drag-and-drop capability within the dialog box, reordering, deletion, shortcut menus, the ability to create new folders, and other shortcut menu commands. Initially, it is larger than the older dialog box, but the user can resize it. To specify a dialog box using the newer style, set the <b>BIF_USENEWUI</b> flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure.</para>
      <para>If you implement a callback function, specified in the <b>lpfn</b> member of the <see cref="BROWSEINFO" /> structure, you receive a handle to the dialog box. One use of this window handle is to modify the layout or contents of the dialog box. Because it is not resizable, modifying the older style dialog box is relatively straightforward. Modifying the newer style dialog box is much more difficult, and not recommended. Not only does it have a different size and layout than the old style, but its dimensions and the positions of its controls change every time it is resized by the user.</para>
      <para>If the BIF_RETURNONLYFSDIRS flag is set in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure, the <b>OK</b> button remains enabled for "\server" items, as well as "\server\share" and directory items. However, if the user selects a "\server" item, passing the PIDL returned by <b>SHBrowseForFolder</b> to <see cref="SHGetPathFromIDList" /> fails.</para>
      <h3>Custom Filtering</h3>
      <para>As of Windows XP, <b>SHBrowseForFolder</b> supports custom filtering on the contents of the dialog box. To create a custom filter, follow these steps.</para>
      <list type="number">
        <item>
          <description>Set the BIF_NEWDIALOGSTYLE flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure pointed to by the <i>lpbi</i> parameter.</description>
        </item>
        <item>
          <description>Specify a callback function in the <b>lpfn</b> member of that same <see cref="BROWSEINFO" /> structure.</description>
        </item>
        <item>
          <description>Code the callback function to receive the BFFM_INITIALIZED and BFFM_IUNKNOWN messages. On receipt of the BFFM_IUNKNOWN message, the callback function's <i>lParam</i> parameter contains a pointer to the dialog box's implementation of <see cref="IUnknown" />. Call <see cref="QueryInterface" /> on that <b>IUnknown</b> to obtain a pointer to an instance of <see cref="IFolderFilterSite" />.</description>
        </item>
        <item>
          <description>Create an object that implements <see cref="IFolderFilter" />.</description>
        </item>
        <item>
          <description>Call <see cref="IFolderFilterSite.SetFilter" />, passing to it a pointer to your <see cref="IFolderFilter" />. <b>IFolderFilter</b> methods can then be used to include and exclude items from the tree.</description>
        </item>
        <item>
          <description>Once the filter is created, the <see cref="IFolderFilterSite" /> interface is no longer needed. Call <see cref="IFolderFilterSite.Release" /> if you have no further use for it.</description>
        </item>
      </list>
      <h3>Dealing With Shortcuts</h3>
      <b>Note</b>  This section applies to only Windows 2000 and earlier systems. By default, Windows XP and later systems return the PIDL of a shortcut's target rather than the shortcut itself, as long as the BIF_NOTRANSLATETARGETS flag is not set in the <see cref="BROWSEINFO" /> structure.
<para>If <b>SHBrowseForFolder</b> returns a PIDL to a shortcut, sending that PIDL to <see cref="SHGetPathFromIDList" /> returns the path of the shortcut itself rather than the path of its target. The path to the shortcut's target can be obtained by using the <see cref="IShellLink" /> interface as shown in this example.</para><code>#include

// Macros for interface casts
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast(static_cast(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &amp;amp;amp;amp;amp;amp;IID_##IType, (void**)(ppType)
#endif

// Retrieves the UIObject interface for the specified full PIDL
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;

    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &amp;amp;amp;amp;amp;amp;psf), &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

#define ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define ILNext(pidl)           ILSkip(pidl, (pidl)-&gt;mkid.cb)

HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;

    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += sizeof (pidl_temp-&gt;mkid.cb);

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp += ILNext (pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);

    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
STDAPI SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;

    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_PPV_ARG(IShellLink, &amp;amp;amp;amp;amp;amp;psl));

    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);

    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder, and
// other items of that nature.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;

    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);

    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);   // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><code>
// Retrieves the UIObject interface for the specified full PIDLstatic
HRESULT SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;
    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_IShellFolder, (LPVOID*)&amp;amp;amp;amp;amp;amp;psf, &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

static HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;
    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += pidl_temp-&gt;mkid.cb;

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp = ILNext(pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);
    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
static HRESULT SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;
    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_IShellLink, (LPVOID*)&amp;amp;amp;amp;amp;amp;psl);
    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);
    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder,
// and so on.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;
    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);
    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);

        // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><blockquote><para>[!NOTE]
The shlobj_core.h header defines SHBrowseForFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/dlgbox/open-and-save-as-dialog-boxes">Open and Save as Dialog Boxes</seealso>
  </member>
  <member name="Windows.SHBrowseForFolderW">
    <summary>
      <para>Displays a dialog box that enables the user to select a Shell folder.</para>
    </summary>
    <param name="lpbi">
      <para>Type: <b>LPBROWSEINFO</b></para>
      <para>A pointer to a <see cref="BROWSEINFO" /> structure that contains information used to display the dialog box.</para>
    </param>
    <returns>
      <para>Type: <b>PIDLIST_ABSOLUTE</b></para>
      <para>Returns a PIDL that specifies the location of the selected folder relative to the root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is <b>NULL</b>.</para>
      <para>It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full discussion of this case, see the Remarks section.</para>
    </returns>
    <remarks>
      <para>For Windows Vista or later, it is recommended that you use <see cref="IFileDialog" /> with the FOS_PICKFOLDERS option rather than the SHBrowseForFolder function. This uses the Open Files dialog in pick folders mode and is the preferred implementation.</para>
      <para>You must initialize Component Object Model (COM) before you call <b>SHBrowseForFolder</b>. If you initialize COM using <see cref="CoInitializeEx" />, you must set the COINIT_APARTMENTTHREADED flag in its <i>dwCoInit</i> parameter. You can also use <see cref="CoInitialize" /> or <see cref="OleInitialize" />, which always use apartment threading. If you require drag-and-drop functionality, <b>OleInitialize</b> is recommended because it initializes the required OLE as well as COM.</para>
      <para>
        <b>Note</b>  If COM is initialized using <see cref="CoInitializeEx" /> with the COINIT_MULTITHREADED flag, <b>SHBrowseForFolder</b> fails if the calling application uses the BIF_USENEWUI or BIF_NEWDIALOGSTYLE flag in the <see cref="BROWSEINFO" /> structure.</para>
      <para>It is the responsibility of the calling application to call <see cref="CoTaskMemFree" /> to free the IDList returned by <b>SHBrowseForFolder</b> when it is no longer needed.</para>
      <para>There are two styles of dialog box available. The older style is displayed by default and is not resizable. The newer style provides a number of additional features, including drag-and-drop capability within the dialog box, reordering, deletion, shortcut menus, the ability to create new folders, and other shortcut menu commands. Initially, it is larger than the older dialog box, but the user can resize it. To specify a dialog box using the newer style, set the <b>BIF_USENEWUI</b> flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure.</para>
      <para>If you implement a callback function, specified in the <b>lpfn</b> member of the <see cref="BROWSEINFO" /> structure, you receive a handle to the dialog box. One use of this window handle is to modify the layout or contents of the dialog box. Because it is not resizable, modifying the older style dialog box is relatively straightforward. Modifying the newer style dialog box is much more difficult, and not recommended. Not only does it have a different size and layout than the old style, but its dimensions and the positions of its controls change every time it is resized by the user.</para>
      <para>If the BIF_RETURNONLYFSDIRS flag is set in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure, the <b>OK</b> button remains enabled for "\server" items, as well as "\server\share" and directory items. However, if the user selects a "\server" item, passing the PIDL returned by <b>SHBrowseForFolder</b> to <see cref="SHGetPathFromIDList" /> fails.</para>
      <h3>Custom Filtering</h3>
      <para>As of Windows XP, <b>SHBrowseForFolder</b> supports custom filtering on the contents of the dialog box. To create a custom filter, follow these steps.</para>
      <list type="number">
        <item>
          <description>Set the BIF_NEWDIALOGSTYLE flag in the <b>ulFlags</b> member of the <see cref="BROWSEINFO" /> structure pointed to by the <i>lpbi</i> parameter.</description>
        </item>
        <item>
          <description>Specify a callback function in the <b>lpfn</b> member of that same <see cref="BROWSEINFO" /> structure.</description>
        </item>
        <item>
          <description>Code the callback function to receive the BFFM_INITIALIZED and BFFM_IUNKNOWN messages. On receipt of the BFFM_IUNKNOWN message, the callback function's <i>lParam</i> parameter contains a pointer to the dialog box's implementation of <see cref="IUnknown" />. Call <see cref="QueryInterface" /> on that <b>IUnknown</b> to obtain a pointer to an instance of <see cref="IFolderFilterSite" />.</description>
        </item>
        <item>
          <description>Create an object that implements <see cref="IFolderFilter" />.</description>
        </item>
        <item>
          <description>Call <see cref="IFolderFilterSite.SetFilter" />, passing to it a pointer to your <see cref="IFolderFilter" />. <b>IFolderFilter</b> methods can then be used to include and exclude items from the tree.</description>
        </item>
        <item>
          <description>Once the filter is created, the <see cref="IFolderFilterSite" /> interface is no longer needed. Call <see cref="IFolderFilterSite.Release" /> if you have no further use for it.</description>
        </item>
      </list>
      <h3>Dealing With Shortcuts</h3>
      <b>Note</b>  This section applies to only Windows 2000 and earlier systems. By default, Windows XP and later systems return the PIDL of a shortcut's target rather than the shortcut itself, as long as the BIF_NOTRANSLATETARGETS flag is not set in the <see cref="BROWSEINFO" /> structure.
<para>If <b>SHBrowseForFolder</b> returns a PIDL to a shortcut, sending that PIDL to <see cref="SHGetPathFromIDList" /> returns the path of the shortcut itself rather than the path of its target. The path to the shortcut's target can be obtained by using the <see cref="IShellLink" /> interface as shown in this example.</para><code>#include

// Macros for interface casts
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast(static_cast(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &amp;amp;amp;amp;amp;amp;IID_##IType, (void**)(ppType)
#endif

// Retrieves the UIObject interface for the specified full PIDL
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;

    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &amp;amp;amp;amp;amp;amp;psf), &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

#define ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define ILNext(pidl)           ILSkip(pidl, (pidl)-&gt;mkid.cb)

HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;

    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += sizeof (pidl_temp-&gt;mkid.cb);

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp += ILNext (pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);

    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
STDAPI SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;

    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_PPV_ARG(IShellLink, &amp;amp;amp;amp;amp;amp;psl));

    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);

    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder, and
// other items of that nature.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;

    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);

    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);   // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><code>
// Retrieves the UIObject interface for the specified full PIDLstatic
HRESULT SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;
    *ppv = NULL;

    HRESULT hr = SHBindToParent(pidl, IID_IShellFolder, (LPVOID*)&amp;amp;amp;amp;amp;amp;psf, &amp;amp;amp;amp;amp;amp;pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf-&gt;GetUIObjectOf(hwnd, 1, &amp;amp;amp;amp;amp;amp;pidlChild, riid, NULL, ppv);
        psf-&gt;Release();
    }
    return hr;
}

static HRESULT SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    DWORD cbTotal = 0;
    if (pidl)
    {
        LPCITEMIDLIST pidl_temp = pidl;
        cbTotal += pidl_temp-&gt;mkid.cb;

        while (pidl_temp-&gt;mkid.cb)
        {
            cbTotal += pidl_temp-&gt;mkid.cb;
            pidl_temp = ILNext(pidl_temp);
        }
    }

    *ppidl = (LPITEMIDLIST)CoTaskMemAlloc(cbTotal);
    if (*ppidl)
        CopyMemory(*ppidl, pidl, cbTotal);

    return  *ppidl ? S_OK: E_OUTOFMEMORY;
}

// Get the target PIDL for a folder PIDL. This also deals with cases of a folder
// shortcut or an alias to a real folder.
static HRESULT SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    IShellLink *psl;
    *ppidl = NULL;

    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_IShellLink, (LPVOID*)&amp;amp;amp;amp;amp;amp;psl);
    if (SUCCEEDED(hr))
    {
        hr = psl-&gt;GetIDList(ppidl);
        psl-&gt;Release();
    }

    // It's not a folder shortcut so get the PIDL normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);
    return hr;
}

// Get the target folder for a folder PIDL. This deals with cases where a folder
// is an alias to a real folder, folder shortcuts, the My Documents folder,
// and so on.
STDAPI SHGetTargetFolderPath(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    LPITEMIDLIST pidlTarget;
    *pszPath = 0;

    HRESULT hr = SHGetTargetFolderIDList(pidlFolder, &amp;amp;amp;amp;amp;amp;pidlTarget);
    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);

        // Make sure it is a path
        CoTaskMemFree(pidlTarget);
    }

    return *pszPath ? S_OK : E_FAIL;
}
</code><blockquote><para>[!NOTE]
The shlobj_core.h header defines SHBrowseForFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/dlgbox/open-and-save-as-dialog-boxes">Open and Save as Dialog Boxes</seealso>
  </member>
  <member name="Windows.SHChangeNotification_Lock">
    <summary>
      <para>Locks the shared memory associated with a Shell change notification event.</para>
    </summary>
    <param name="hChange">
      <para>Type: <b>HANDLE</b></para>
      <para>A handle to a window received as a <i>wParam</i> in the specified Shell change notification message.</para>
    </param>
    <param name="dwProcId">
      <para>Type: <b>DWORD</b></para>
      <para>The process ID (<i>lParam</i> in the message callback).</para>
    </param>
    <param name="pppidl">
      <para>Type: <b>PIDLIST_ABSOLUTE**</b></para>
      <para>The address of a pointer to a PIDLIST_ABSOLUTE that, when this function returns successfully, receives the list of affected PIDLs.</para>
    </param>
    <param name="plEvent">
      <para>Type: <b>LONG*</b></para>
      <para>A pointer to a LONG value that, when this function returns successfully, receives the Shell change notification ID of the event that took place.</para>
    </param>
    <returns>
      <para>Type: <b>HANDLE</b></para>
      <para>Returns a handle (HLOCK) to the locked memory. Pass this value to <see cref="SHChangeNotification_Unlock" /> when finished.</para>
    </returns>
  </member>
  <member name="Windows.SHChangeNotification_Unlock">
    <summary>
      <para>Unlocks shared memory for a change notification.</para>
    </summary>
    <param name="hLock">
      <para>Type: <b>HANDLE</b></para>
      <para>A handle to the memory lock. This is the handle returned by <see cref="SHChangeNotification_Lock" /> when it locked the memory.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> on success; otherwise, <b>FALSE</b>.</para>
    </returns>
  </member>
  <member name="Windows.SHChangeNotify">
    <summary>
      <para>Notifies the system of an event that an application has performed. An application should use this function if it performs an action that may affect the Shell.</para>
    </summary>
    <param name="wEventId">
      <para>Type: <b>LONG</b></para>
      <para>Describes the event that has occurred. Typically, only one event is specified at a time. If more than one event is specified, the values contained in the <i>dwItem1</i> and <i>dwItem2</i> parameters must be the same, respectively, for all specified events. This parameter can be one or more of the following values:</para>
      <h4>SHCNE_ALLEVENTS</h4>
      <para>All events have occurred.</para>
      <h4>SHCNE_ASSOCCHANGED</h4>
      <para>A file type association has changed. <b>SHCNF_IDLIST</b> must be specified in the <i>uFlags</i> parameter. <i>dwItem1</i> and <i>dwItem2</i> are not used and must be <b>NULL</b>. This event should also be sent for registered protocols.</para>
      <h4>SHCNE_ATTRIBUTES</h4>
      <para>The attributes of an item or folder have changed. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the item or folder that has changed. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_CREATE</h4>
      <para>A nonfolder item has been created. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the item that was created. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_DELETE</h4>
      <para>A nonfolder item has been deleted. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the item that was deleted. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_DRIVEADD</h4>
      <para>A drive has been added. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the root of the drive that was added. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_DRIVEADDGUI</h4>
      <para>
        <b>Windows XP and later</b>: Not used.</para>
      <h4>SHCNE_DRIVEREMOVED</h4>
      <para>A drive has been removed. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the root of the drive that was removed. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_EXTENDED_EVENT</h4>
      <para>Not currently used.</para>
      <h4>SHCNE_FREESPACE</h4>
      <para>The amount of free space on a drive has changed. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the root of the drive on which the free space changed. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_MEDIAINSERTED</h4>
      <para>Storage media has been inserted into a drive. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the root of the drive that contains the new media. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_MEDIAREMOVED</h4>
      <para>Storage media has been removed from a drive. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the root of the drive from which the media was removed. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_MKDIR</h4>
      <para>A folder has been created. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the folder that was created. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_NETSHARE</h4>
      <para>A folder on the local computer is being shared via the network. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the folder that is being shared. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_NETUNSHARE</h4>
      <para>A folder on the local computer is no longer being shared via the network. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the folder that is no longer being shared. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_RENAMEFOLDER</h4>
      <para>The name of a folder has changed. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the previous PIDL or name of the folder. <i>dwItem2</i> contains the new PIDL or name of the folder.</para>
      <h4>SHCNE_RENAMEITEM</h4>
      <para>The name of a nonfolder item has changed. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the previous PIDL or name of the item. <i>dwItem2</i> contains the new PIDL or name of the item.</para>
      <h4>SHCNE_RMDIR</h4>
      <para>A folder has been removed. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the folder that was removed. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_SERVERDISCONNECT</h4>
      <para>The computer has disconnected from a server. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the server from which the computer was disconnected. <i>dwItem2</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_UPDATEDIR</h4>
      <para>The contents of an existing folder have changed, but the folder still exists and has not been renamed. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the folder that has changed. <i>dwItem2</i> is not used and should be <b>NULL</b>. If a folder has been created, deleted, or renamed, use <b>SHCNE_MKDIR</b>, <b>SHCNE_RMDIR</b>, or <b>SHCNE_RENAMEFOLDER</b>, respectively.</para>
      <h4>SHCNE_UPDATEIMAGE</h4>
      <para>An image in the system image list has changed. <b>SHCNF_DWORD</b> must be specified in <i>uFlags</i>.</para>
      <para>
        <i>dwItem2</i> contains the index in the system image list that has changed. <i>dwItem1</i> is not used and should be <b>NULL</b>.</para>
      <h4>SHCNE_UPDATEITEM</h4>
      <para>An existing item (a folder or a nonfolder) has changed, but the item still exists and has not been renamed. <b>SHCNF_IDLIST</b> or <b>SHCNF_PATH</b> must be specified in <i>uFlags</i>. <i>dwItem1</i> contains the item that has changed. <i>dwItem2</i> is not used and should be <b>NULL</b>. If a nonfolder item has been created, deleted, or renamed, use <b>SHCNE_CREATE</b>, <b>SHCNE_DELETE</b>, or <b>SHCNE_RENAMEITEM</b>, respectively, instead.</para>
      <h4>SHCNE_DISKEVENTS</h4>
      <para>Specifies a combination of all of the disk event identifiers.</para>
      <h4>SHCNE_GLOBALEVENTS</h4>
      <para>Specifies a combination of all of the global event identifiers.</para>
      <h4>SHCNE_INTERRUPT</h4>
      <para>The specified event occurred as a result of a system interrupt. As this value modifies other event values, it cannot be used alone.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>Flags that, when combined bitwise with <b>SHCNF_TYPE</b>, indicate the meaning of the <i>dwItem1</i> and <i>dwItem2</i> parameters. The <i>uFlags</i> parameter must be one of the following values.</para>
      <h4>SHCNF_DWORD</h4>
      <para>The <i>dwItem1</i> and <i>dwItem2</i> parameters are <b>DWORD</b> values.</para>
      <h4>SHCNF_IDLIST</h4>
      <para>
        <i>dwItem1</i> and <i>dwItem2</i> are the addresses of <see cref="ITEMIDLIST" /> structures that represent the item(s) affected by the change. Each <b>ITEMIDLIST</b> must be relative to the desktop folder.</para>
      <h4>SHCNF_PATH</h4>
      <para>
        <i>dwItem1</i> and <i>dwItem2</i> are the addresses of null-terminated strings of maximum length <b>MAX_PATH</b> that contain the full path names of the items affected by the change.</para>
      <h4>SHCNF_PRINTER</h4>
      <para>
        <i>dwItem1</i> and <i>dwItem2</i> are the addresses of null-terminated strings that represent the friendly names of the printer(s) affected by the change.</para>
      <h4>SHCNF_FLUSH</h4>
      <para>The function should not return until the notification has been delivered to all affected components. As this flag modifies other data-type flags, it cannot be used by itself.</para>
      <h4>SHCNF_FLUSHNOWAIT</h4>
      <para>The function should begin delivering notifications to all affected components but should return as soon as the notification process has begun. As this flag modifies other data-type flags, it cannot by used by itself. This flag includes <b>SHCNF_FLUSH</b>.</para>
      <h4>SHCNF_NOTIFYRECURSIVE</h4>
      <para>Notify clients registered for all children.</para>
    </param>
    <param name="dwItem1">
      <para>Type: <b>LPCVOID</b></para>
      <para>Optional. First event-dependent value.</para>
    </param>
    <param name="dwItem2">
      <para>Type: <b>LPCVOID</b></para>
      <para>Optional. Second event-dependent value.</para>
    </param>
    <remarks>
      <para>Applications that register new handlers of any type must call <b>SHChangeNotify</b> with the <b>SHCNE_ASSOCCHANGED</b> flag to instruct the Shell to invalidate the icon and thumbnail cache. This will also load new icon and thumbnail handlers that have been registered. Note, however, that icon overlay handlers are not reloaded.</para>
      <para>The strings pointed to by <i>dwItem1</i> and <i>dwItem2</i> can be either ANSI or Unicode.</para>
    </remarks>
  </member>
  <member name="Windows.NTSHChangeNotifyDeregister">
    <summary>
      <para>Unregisters the client's window process from receiving <see cref="SHChangeNotify" /> messages.</para>
    </summary>
    <param name="ulID">
      <para>Type: <b>ULONG</b></para>
      <para>A value of type <b>ULONG</b> that specifies the registration ID returned by <see cref="SHChangeNotifyRegister" />.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the specified client was found and removed; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>See the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd940348(v=vs.85)">Change Notify Watcher Sample</a> in the Windows Software Development Kit (SDK) for a full example that demonstrates the use of this function.</para>
      <para>The <b>NTSHChangeNotifyDeregister</b> function, which is no longer available for use as of Windows Vista, was equivalent to <b>SHChangeNotifyDeregister</b>.</para>
    </remarks>
  </member>
  <member name="Windows.SHChangeNotifyDeregister">
    <summary>
      <para>Unregisters the client's window process from receiving <see cref="SHChangeNotify" /> messages.</para>
    </summary>
    <param name="ulID">
      <para>Type: <b>ULONG</b></para>
      <para>A value of type <b>ULONG</b> that specifies the registration ID returned by <see cref="SHChangeNotifyRegister" />.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the specified client was found and removed; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>See the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd940348(v=vs.85)">Change Notify Watcher Sample</a> in the Windows Software Development Kit (SDK) for a full example that demonstrates the use of this function.</para>
      <para>The <b>NTSHChangeNotifyDeregister</b> function, which is no longer available for use as of Windows Vista, was equivalent to <b>SHChangeNotifyDeregister</b>.</para>
    </remarks>
  </member>
  <member name="Windows.NTSHChangeNotifyRegister">
    <summary>
      <para>Registers a window to receive notifications from the file system or Shell, if the file system supports notifications.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the window that receives the change or notification messages.</para>
    </param>
    <param name="fSources">
      <para>Type: <b>int</b></para>
      <para>One or more of the following values that indicate the type of events for which to receive notifications.</para>
      <para>
        <b>Note</b>  In earlier versions of the SDK, these flags are not defined in a header file and implementers must define these values themselves or use their numeric values directly. As of Windows Vista, these flags are defined in Shlobj.h.</para>
      <h4>SHCNRF_InterruptLevel (0x0001)</h4>
      <para>Interrupt level notifications from the file system.</para>
      <h4>SHCNRF_ShellLevel (0x0002)</h4>
      <para>Shell-level notifications from the shell.</para>
      <h4>SHCNRF_RecursiveInterrupt (0x1000)</h4>
      <para>Interrupt events on the whole subtree. This flag must be combined with the <b>SHCNRF_InterruptLevel</b> flag. When using this flag, notifications must also be made recursive by setting the <b>fRecursive</b> member of the corresponding <see cref="SHChangeNotifyEntry" /> structure referenced by <i>pshcne</i> to <b>TRUE</b>. Use of <b>SHCNRF_RecursiveInterrupt</b> on a single level view—for example, a PIDL that is relative and contains only one <see cref="SHITEMID" />—will block event notification at the highest level and thereby prevent a recursive, child update. Thus, an icon dragged into the lowest level of a folder hierarchy may fail to appear in the view as expected.</para>
      <h4>SHCNRF_NewDelivery (0x8000)</h4>
      <para>Messages received use shared memory. Call <see cref="SHChangeNotification_Lock" /> to access the actual data. Call <see cref="SHChangeNotification_Unlock" /> to release the memory when done.</para>
      <para>
        <b>Note</b>  We recommend this flag because it provides a more robust delivery method. All clients should specify this flag.</para>
    </param>
    <param name="fEvents">
      <para>Type: <b>LONG</b></para>
      <para>Change notification events for which to receive notification. See the SHCNE flags listed in <see cref="SHChangeNotify" /> for possible values.</para>
    </param>
    <param name="wMsg">
      <para>Type: <b>UINT</b></para>
      <para>Message to be posted to the window procedure.</para>
    </param>
    <param name="cEntries">
      <para>Type: <b>int</b></para>
      <para>Number of entries in the <i>pshcne</i> array.</para>
    </param>
    <param name="pshcne">
      <para>Type: <b>const <see cref="SHChangeNotifyEntry" />*</b></para>
      <para>Array of <see cref="SHChangeNotifyEntry" /> structures that contain the notifications. This array should always be set to one when calling <b>SHChangeNotifyRegister</b> or <see cref="SHChangeNotifyDeregister" /> will not work properly.</para>
    </param>
    <returns>
      <para>Type: <b>ULONG</b></para>
      <para>Returns a positive integer registration ID. Returns 0 if out of memory or in response to invalid parameters.</para>
    </returns>
    <remarks>
      <para>See the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd940348(v=vs.85)">Change Notify Watcher Sample</a> in the Windows Software Development Kit (SDK) for a full example that demonstrates the use of this function.</para>
      <para>When a change notification event is raised, the message indicated by <i>wMsg</i> is delivered to the window specified by the <i>hwnd</i> parameter.</para>
      <list type="bullet">
        <item>
          <description>If SHCNRF_NewDelivery is specified, the <i>wParam</i> and <i>lParam</i> values in the message should be passed to <see cref="SHChangeNotification_Lock" /> as the <i>hChange</i> and <i>dwProcID</i> parameters respectively.</description>
        </item>
        <item>
          <description>If SHCNRF_NewDelivery is not specified, <i>wParam</i> is a pointer to two PIDLIST_ABSOLUTE pointers, and <i>lParam</i> specifies the event. The two PIDLIST_ABSOLUTE pointers can be <b>NULL</b>, depending on the event being sent.</description>
        </item>
      </list>
      <para>When a relevant file system event takes place and the <i>hwnd</i> parameter is not <b>NULL</b>, then the message indicated by <i>wMsg</i> is posted to the specified window. Otherwise, if the <i>pshcne</i> parameter is not <b>NULL</b>, then that notification entry is used.</para>
      <para>For performance reasons, multiple notifications can be combined into a single notification. For example, if a large number of <see cref="SHCNE_UPDATEITEM" /> notifications are generated for files in the same folder, they can be joined into a single <see cref="SHCNE_UPDATEDIR" /> notification.</para>
      <para>The <b>NTSHChangeNotifyRegister</b> function, which is no longer available as of Windows Vista, was equivalent to <b>SHChangeNotifyRegister</b> with the SHCNRF_NewDelivery flag.</para>
    </remarks>
  </member>
  <member name="Windows.SHChangeNotifyRegister">
    <summary>
      <para>Registers a window to receive notifications from the file system or Shell, if the file system supports notifications.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the window that receives the change or notification messages.</para>
    </param>
    <param name="fSources">
      <para>Type: <b>int</b></para>
      <para>One or more of the following values that indicate the type of events for which to receive notifications.</para>
      <para>
        <b>Note</b>  In earlier versions of the SDK, these flags are not defined in a header file and implementers must define these values themselves or use their numeric values directly. As of Windows Vista, these flags are defined in Shlobj.h.</para>
      <h4>SHCNRF_InterruptLevel (0x0001)</h4>
      <para>Interrupt level notifications from the file system.</para>
      <h4>SHCNRF_ShellLevel (0x0002)</h4>
      <para>Shell-level notifications from the shell.</para>
      <h4>SHCNRF_RecursiveInterrupt (0x1000)</h4>
      <para>Interrupt events on the whole subtree. This flag must be combined with the <b>SHCNRF_InterruptLevel</b> flag. When using this flag, notifications must also be made recursive by setting the <b>fRecursive</b> member of the corresponding <see cref="SHChangeNotifyEntry" /> structure referenced by <i>pshcne</i> to <b>TRUE</b>. Use of <b>SHCNRF_RecursiveInterrupt</b> on a single level view—for example, a PIDL that is relative and contains only one <see cref="SHITEMID" />—will block event notification at the highest level and thereby prevent a recursive, child update. Thus, an icon dragged into the lowest level of a folder hierarchy may fail to appear in the view as expected.</para>
      <h4>SHCNRF_NewDelivery (0x8000)</h4>
      <para>Messages received use shared memory. Call <see cref="SHChangeNotification_Lock" /> to access the actual data. Call <see cref="SHChangeNotification_Unlock" /> to release the memory when done.</para>
      <para>
        <b>Note</b>  We recommend this flag because it provides a more robust delivery method. All clients should specify this flag.</para>
    </param>
    <param name="fEvents">
      <para>Type: <b>LONG</b></para>
      <para>Change notification events for which to receive notification. See the SHCNE flags listed in <see cref="SHChangeNotify" /> for possible values.</para>
    </param>
    <param name="wMsg">
      <para>Type: <b>UINT</b></para>
      <para>Message to be posted to the window procedure.</para>
    </param>
    <param name="cEntries">
      <para>Type: <b>int</b></para>
      <para>Number of entries in the <i>pshcne</i> array.</para>
    </param>
    <param name="pshcne">
      <para>Type: <b>const <see cref="SHChangeNotifyEntry" />*</b></para>
      <para>Array of <see cref="SHChangeNotifyEntry" /> structures that contain the notifications. This array should always be set to one when calling <b>SHChangeNotifyRegister</b> or <see cref="SHChangeNotifyDeregister" /> will not work properly.</para>
    </param>
    <returns>
      <para>Type: <b>ULONG</b></para>
      <para>Returns a positive integer registration ID. Returns 0 if out of memory or in response to invalid parameters.</para>
    </returns>
    <remarks>
      <para>See the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd940348(v=vs.85)">Change Notify Watcher Sample</a> in the Windows Software Development Kit (SDK) for a full example that demonstrates the use of this function.</para>
      <para>When a change notification event is raised, the message indicated by <i>wMsg</i> is delivered to the window specified by the <i>hwnd</i> parameter.</para>
      <list type="bullet">
        <item>
          <description>If SHCNRF_NewDelivery is specified, the <i>wParam</i> and <i>lParam</i> values in the message should be passed to <see cref="SHChangeNotification_Lock" /> as the <i>hChange</i> and <i>dwProcID</i> parameters respectively.</description>
        </item>
        <item>
          <description>If SHCNRF_NewDelivery is not specified, <i>wParam</i> is a pointer to two PIDLIST_ABSOLUTE pointers, and <i>lParam</i> specifies the event. The two PIDLIST_ABSOLUTE pointers can be <b>NULL</b>, depending on the event being sent.</description>
        </item>
      </list>
      <para>When a relevant file system event takes place and the <i>hwnd</i> parameter is not <b>NULL</b>, then the message indicated by <i>wMsg</i> is posted to the specified window. Otherwise, if the <i>pshcne</i> parameter is not <b>NULL</b>, then that notification entry is used.</para>
      <para>For performance reasons, multiple notifications can be combined into a single notification. For example, if a large number of <see cref="SHCNE_UPDATEITEM" /> notifications are generated for files in the same folder, they can be joined into a single <see cref="SHCNE_UPDATEDIR" /> notification.</para>
      <para>The <b>NTSHChangeNotifyRegister</b> function, which is no longer available as of Windows Vista, was equivalent to <b>SHChangeNotifyRegister</b> with the SHCNRF_NewDelivery flag.</para>
    </remarks>
  </member>
  <member name="Windows.SHCreateDataObject">
    <summary>
      <para>Creates a data object in a parent folder.</para>
    </summary>
    <param name="pidlFolder">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> (PIDL) of the parent folder that contains the data object.</para>
    </param>
    <param name="cidl">
      <para>Type: <b>UINT</b></para>
      <para>The number of file objects or subfolders specified in the <i>apidl</i> parameter.</para>
    </param>
    <param name="apidl">
      <para>Type: <b>PCUITEMID_CHILD_ARRAY</b></para>
      <para>An array of pointers to constant <see cref="ITEMIDLIST" /> structures, each of which uniquely identifies a file object or subfolder relative to the parent folder. Each item identifier list must contain exactly one <see cref="SHITEMID" /> structure followed by a terminating zero.</para>
    </param>
    <param name="pdtInner">
      <para>Type: <b><see cref="IDataObject" />*</b></para>
      <para>A pointer to interface <see cref="IDataObject" />. This parameter can be <b>NULL</b>. Specify <i>pdtInner</i> only if the data object created needs to support additional <see cref="FORMATETC" />  clipboard formats beyond the default formats it is assigned at creation.  Alternatively, provide support for populating the created data object using non-default clipboard formats by calling method <see cref="IDataObject.SetData" /> and specifying the format in the <b>FORMATETC</b> structure passed in parameter <i>pFormatetc</i>.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>A reference to the IID of the interface to retrieve through <i>ppv</i>. This must be IID_IDataObject.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>void**</b></para>
      <para>When this method returns successfully, contains the <see cref="IDataObject" /> interface pointer requested in <i>riid</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function is typically called when implementing method <see cref="IShellFolder.GetUIObjectOf" />. When an interface pointer of interface ID  IID_IDataObject is requested (using parameter <i>riid</i>), the implementer can return the interface pointer on the object created with <b>SHCreateDataObject</b> in response.</para>
      <para>This function supports the <a href="https://docs.microsoft.com//windows/desktop/shell/clipboard">CFSTR_SHELLIDLIST</a> (also known as HIDA) clipboard format and also has generic support for arbitrary clipboard formats through <see cref="IDataObject.SetData" />. For more information on clipboard formats, see Shell Clipboard Formats.</para>
      <para>The new data object is intended to be used in operations such as drag-and-drop, in which the data is stored in the clipboard with a given format.</para>
      <para>We recommend that you use the <see cref="IID_PPV_ARGS" /> macro, defined in Objbase.h, to package the <i>riid</i> and <i>ppv</i> parameters. This macro provides the correct IID based on the interface pointed to by the value in <i>ppv</i>, which eliminates the possibility of a coding error in <i>riid</i> that could lead to unexpected results.</para>
    </remarks>
    <seealso cref="CIDLData_CreateFromIDArray" />
  </member>
  <member name="Windows.SHCreateDefaultContextMenu">
    <summary>
      <para>Creates an object that represents the Shell's default context menu implementation.</para>
    </summary>
    <param name="pdcm">
      <para>Type: <b>const <see cref="DEFCONTEXTMENU" />*</b></para>
      <para>A pointer to a constant <see cref="DEFCONTEXTMENU" /> structure.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>Reference to the interface ID of the interface on which to base the object. This is typically the IID of <see cref="IContextMenu" />, <see cref="IContextMenu2" />, or <see cref="IContextMenu3" />.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>void**</b></para>
      <para>When this method returns, contains the interface pointer requested in <i>riid</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function is typically used in the implementation of <see cref="IShellFolder.GetUIObjectOf" />. <b>GetUIObjectOf</b> creates a context menu that merges <see cref="IContextMenu" /> handlers specified by the <see cref="DEFCONTEXTMENU" /> structure, and can optionally provide default context menu verb implementations such as open, explore, delete, and copy.</para>
      <para>The operation of this function is controlled by the input specified in the <see cref="DEFCONTEXTMENU" /> structure.The API<see cref="CDefFolderMenu_Create2" /> is another way to construct the default context menu implementation. It is less expressive than <b>SHCreateDefaultContextMenu</b> but it exists in platforms prior to Windows Vista.</para>
    </remarks>
  </member>
  <member name="Windows.SHCreateShellFolderView">
    <summary>
      <para>Creates a new instance of the default Shell folder view object (DefView).</para>
    </summary>
    <param name="pcsfv">
      <para>Type: <b>const <see cref="SFV_CREATE" />*</b></para>
      <para>Pointer to a <see cref="SFV_CREATE" /> structure that describes the particulars used in creating this instance of the Shell folder view object.</para>
    </param>
    <param name="ppsv">
      <para>Type: <b><see cref="IShellView" />**</b></para>
      <para>When this function returns successfully, contains an interface pointer to the new <see cref="IShellView" /> object. On failure, this value is <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>
        <b>SHCreateShellFolderView</b> is recommended over <see cref="SHCreateShellFolderViewEx" /> because of the greater flexibility of its elements to participate in various scenarios, provide new functionality to the view, and interact with other objects.</para>
      <para>When dealing with several instances of <see cref="IShellView" />, you might want to verify which is the default Shell folder view object. To do so, call <see cref="QueryInterface" /> on the object using the IID_CDefView IID. This call succeeds only when made on the default Shell folder view object.</para>
      <para>Data sources that use the default Shell folder view object must implement these interfaces:</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="IShellFolder" />
          </description>
        </item>
        <item>
          <description>
            <see cref="IShellFolder2" />
          </description>
        </item>
        <item>
          <description>
            <see cref="IPersistFolder" />
          </description>
        </item>
        <item>
          <description>
            <see cref="IPersistFolder2" />
          </description>
        </item>
      </list>
      <para>Optionally, they can also implement <see cref="IPersistFolder3" />.</para>
    </remarks>
    <seealso cref="SFV_CREATE" />
    <seealso cref="SHCreateShellFolderViewEx" />
  </member>
  <member name="Windows.SHCreateShellFolderViewEx">
    <summary>
      <para>Creates a new instance of the default Shell folder view object. It is recommended that you use <see cref="SHCreateShellFolderView" /> rather than this function.</para>
    </summary>
    <param name="pcsfv">
      <para>Type: <b><see cref="CSFV" />*</b></para>
      <para>Pointer to a structure that describes the details used in creating this instance of the Shell folder view object.</para>
    </param>
    <param name="ppsv">
      <para>Type: <b><see cref="IShellView" />**</b></para>
      <para>The address of an <see cref="IShellView" /> interface pointer that, when this function returns successfully, points to the new view object. On failure, this value is <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>
        <see cref="SHCreateShellFolderView" /> is recommended over <b>SHCreateShellFolderViewEx</b> because of the greater flexibility of its elements to participate in various scenarios, provide new functionality to the view, and interact with other objects.</para>
      <para>When dealing with several instances of <see cref="IShellView" />, you might want to verify which is the default Shell folder view object. To do so, call <see cref="QueryInterface" /> on the object using IID_CDefView. This call succeeds only on the default Shell folder view object.</para>
    </remarks>
    <seealso cref="SHCreateShellFolderView" />
  </member>
  <member name="Windows.SHCreateShellItem">
    <summary>
      <para>Creates an <see cref="IShellItem" /> object.</para>
      <para>
        <b>Note</b>  It is recommended that you use <see cref="SHCreateItemWithParent" /> or <see cref="SHCreateItemFromIDList" /> instead of this function.</para>
    </summary>
    <param name="pidlParent">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>A PIDL to the parent. This value can be <b>NULL</b>.</para>
    </param>
    <param name="psfParent">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>A pointer to the parent <see cref="IShellFolder" />. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A PIDL to the requested item. If parent information is not included in <i>pidlParent</i> or <i>psfParent</i>, this must be an absolute PIDL.</para>
    </param>
    <param name="ppsi">
      <para>Type: <b><see cref="IShellItem" />**</b></para>
      <para>When this method returns, contains the interface pointer to the new <see cref="IShellItem" />.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>
        <b>SHCreateShellItem</b> creates an object that represents a Shell namespace item. The caller must provide parent information in <i>pidlParent</i> or <i>psfParent</i>; alternatively, the caller can provide an absolute IDList in the <i>pidl</i> parameter.</para>
      <para>There are three valid calling patterns for this function:</para>
      <list type="number">
        <item>
          <description>The parent folder is identified by an absolute IDList <i>pidlParent</i>. The <i>pidl</i> parameter points to a child IDList that identifies the item within the folder identified by <i>pidlParent</i>.
<code>IShellItem *psi;
SHCreateShellItem(pidlParent, NULL, pidlChild, &amp;amp;amp;amp;amp;amp;psi);

</code></description>
        </item>
        <item>
          <description>The parent folder is identified by <i>psfParent</i>. The <i>pidl</i> parameter points to a child IDList that identifies the item within the folder identified by <i>psfParent</i>.
<code>IShellItem *psi;
SHCreateShellItem(NULL, psfParent, pidlChild, &amp;amp;amp;amp;amp;amp;psi);

</code></description>
        </item>
        <item>
          <description>The item is identified by an absolute IDList passed to the <i>pidl</i> parameter.
<code>IShellItem *psi;
SHCreateShellItem(NULL, NULL, pidlFull, &amp;amp;amp;amp;amp;amp;psi);

</code></description>
        </item>
      </list>
    </remarks>
  </member>
  <member name="Windows.SHDefExtractIcon">
    <summary>
      <para>Provides a default handler to extract an icon from a file.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated buffer that contains the path and name of the file from which the icon is extracted.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>A flag that controls the icon extraction.</para>
      <h4>GIL_SIMULATEDOC</h4>
      <para>Overlays the extracted icon on the default document icon to create the final icon. This icon can be used when no more appropriate icon can be found or retrieved.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the large version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> of <i>nIconSize</i>. This value can be <b>NULL</b>.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the small version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of <i>nIconSize</i>.</para>
    </param>
    <param name="nIconSize">
      <para>Type: <b>UINT</b></para>
      <para>A value that contains the large icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> and the small icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a>. Size is measured in pixels. Pass 0 to specify default large and small sizes.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>This function can return one of these values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Success.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>The requested icon is not present.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>The file cannot be accessed, or is being accessed through a slow link.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>It is the responsibility of the caller to free the icon resources created through this function when they are no longer needed. This can be done through the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHDefExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDefExtractIconA">
    <summary>
      <para>Provides a default handler to extract an icon from a file.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated buffer that contains the path and name of the file from which the icon is extracted.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>A flag that controls the icon extraction.</para>
      <h4>GIL_SIMULATEDOC</h4>
      <para>Overlays the extracted icon on the default document icon to create the final icon. This icon can be used when no more appropriate icon can be found or retrieved.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the large version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> of <i>nIconSize</i>. This value can be <b>NULL</b>.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the small version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of <i>nIconSize</i>.</para>
    </param>
    <param name="nIconSize">
      <para>Type: <b>UINT</b></para>
      <para>A value that contains the large icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> and the small icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a>. Size is measured in pixels. Pass 0 to specify default large and small sizes.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>This function can return one of these values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Success.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>The requested icon is not present.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>The file cannot be accessed, or is being accessed through a slow link.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>It is the responsibility of the caller to free the icon resources created through this function when they are no longer needed. This can be done through the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHDefExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDefExtractIconW">
    <summary>
      <para>Provides a default handler to extract an icon from a file.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated buffer that contains the path and name of the file from which the icon is extracted.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>A flag that controls the icon extraction.</para>
      <h4>GIL_SIMULATEDOC</h4>
      <para>Overlays the extracted icon on the default document icon to create the final icon. This icon can be used when no more appropriate icon can be found or retrieved.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the large version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> of <i>nIconSize</i>. This value can be <b>NULL</b>.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the small version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of <i>nIconSize</i>.</para>
    </param>
    <param name="nIconSize">
      <para>Type: <b>UINT</b></para>
      <para>A value that contains the large icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> and the small icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a>. Size is measured in pixels. Pass 0 to specify default large and small sizes.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>This function can return one of these values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Success.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>The requested icon is not present.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>The file cannot be accessed, or is being accessed through a slow link.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>It is the responsibility of the caller to free the icon resources created through this function when they are no longer needed. This can be done through the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHDefExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDefExtractIcon">
    <summary>
      <para>Provides a default handler to extract an icon from a file.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated buffer that contains the path and name of the file from which the icon is extracted.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>A flag that controls the icon extraction.</para>
      <h4>GIL_SIMULATEDOC</h4>
      <para>Overlays the extracted icon on the default document icon to create the final icon. This icon can be used when no more appropriate icon can be found or retrieved.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the large version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> of <i>nIconSize</i>. This value can be <b>NULL</b>.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the small version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of <i>nIconSize</i>.</para>
    </param>
    <param name="nIconSize">
      <para>Type: <b>UINT</b></para>
      <para>A value that contains the large icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> and the small icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a>. Size is measured in pixels. Pass 0 to specify default large and small sizes.</para>
      <h5>- uFlags.GIL_SIMULATEDOC</h5>
      <para>Overlays the extracted icon on the default document icon to create the final icon. This icon can be used when no more appropriate icon can be found or retrieved.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>This function can return one of these values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Success.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>The requested icon is not present.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>The file cannot be accessed, or is being accessed through a slow link.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>It is the responsibility of the caller to free the icon resources created through this function when they are no longer needed. This can be done through the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHDefExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDefExtractIconA">
    <summary>
      <para>Provides a default handler to extract an icon from a file.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated buffer that contains the path and name of the file from which the icon is extracted.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>A flag that controls the icon extraction.</para>
      <h4>GIL_SIMULATEDOC</h4>
      <para>Overlays the extracted icon on the default document icon to create the final icon. This icon can be used when no more appropriate icon can be found or retrieved.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the large version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> of <i>nIconSize</i>. This value can be <b>NULL</b>.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the small version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of <i>nIconSize</i>.</para>
    </param>
    <param name="nIconSize">
      <para>Type: <b>UINT</b></para>
      <para>A value that contains the large icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> and the small icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a>. Size is measured in pixels. Pass 0 to specify default large and small sizes.</para>
      <h5>- uFlags.GIL_SIMULATEDOC</h5>
      <para>Overlays the extracted icon on the default document icon to create the final icon. This icon can be used when no more appropriate icon can be found or retrieved.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>This function can return one of these values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Success.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>The requested icon is not present.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>The file cannot be accessed, or is being accessed through a slow link.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>It is the responsibility of the caller to free the icon resources created through this function when they are no longer needed. This can be done through the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHDefExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDefExtractIconW">
    <summary>
      <para>Provides a default handler to extract an icon from a file.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated buffer that contains the path and name of the file from which the icon is extracted.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>A flag that controls the icon extraction.</para>
      <h4>GIL_SIMULATEDOC</h4>
      <para>Overlays the extracted icon on the default document icon to create the final icon. This icon can be used when no more appropriate icon can be found or retrieved.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the large version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> of <i>nIconSize</i>. This value can be <b>NULL</b>.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>A pointer to an HICON that, when this function returns successfully, receives the handle of the small version of the icon specified in the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of <i>nIconSize</i>.</para>
    </param>
    <param name="nIconSize">
      <para>Type: <b>UINT</b></para>
      <para>A value that contains the large icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> and the small icon size in its <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a>. Size is measured in pixels. Pass 0 to specify default large and small sizes.</para>
      <h5>- uFlags.GIL_SIMULATEDOC</h5>
      <para>Overlays the extracted icon on the default document icon to create the final icon. This icon can be used when no more appropriate icon can be found or retrieved.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>This function can return one of these values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>Success.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>The requested icon is not present.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>The file cannot be accessed, or is being accessed through a slow link.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>It is the responsibility of the caller to free the icon resources created through this function when they are no longer needed. This can be done through the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHDefExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDoDragDrop">
    <summary>
      <para>Executes a drag-and-drop operation. Supports drag source creation on demand, as well as drag images.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>The handle of the window used to obtain the drag image. This value can be <b>NULL</b>. See Remarks for more details.</para>
    </param>
    <param name="pdata">
      <para>Type: <b><see cref="IDataObject" />*</b></para>
      <para>A pointer to the <see cref="IDataObject" /> interface on a data object that contains the data being dragged.</para>
    </param>
    <param name="pdsrc">
      <para>Type: <b><see cref="IDropSource" />*</b></para>
      <para>A pointer to an implementation of the <see cref="IDropSource" /> interface, which is used to communicate with the source during the drag operation.</para>
      <para>As of Windows Vista, if this value is <b>NULL</b>, the Shell creates a drop source object for you.</para>
    </param>
    <param name="dwEffect">
      <para>Type: <b>DWORD</b></para>
      <para>The effects that the source allows in the drag-and-drop operation. The most significant effect is whether the drag-and-drop operation permits a move. For a list of possible values, see <a href="https://docs.microsoft.com//windows/desktop/com/dropeffect-constants">DROPEFFECT</a>.</para>
    </param>
    <param name="pdwEffect">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that indicates how the drag-and-drop operation affected the source data. The <i>pdwEffect</i> parameter is set only if the operation is not canceled. For a list of possible values, see <a href="https://docs.microsoft.com//windows/desktop/com/dropeffect-constants">DROPEFFECT</a>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>This function supports the standard return value E_OUTOFMEMORY, as well as the following values:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>DRAGDROP_S_DROP</b>
            </para>
          </description>
          <description>
            <para>The drag-and-drop operation was successful.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>DRAGDROP_S_CANCEL</b>
            </para>
          </description>
          <description>
            <para>The drag-and-drop operation was canceled.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_UNSPEC</b>
            </para>
          </description>
          <description>
            <para>Unexpected error occurred.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>As of Windows Vista, if a drag image is not already stored in the data object <i>pdtobj</i> and a drag image cannot be obtained from the window specified by <i>hwnd</i>, the Shell provides a generic drag image. A drag image can fail to be obtained from the specified window either because <i>hwnd</i> is <b>NULL</b> or the specified window does not support the DI_GETDRAGIMAGE message.</para>
    </remarks>
  </member>
  <member name="Windows.SHGetDataFromIDList">
    <summary>
      <para>Retrieves extended property data from a relative identifier list.</para>
    </summary>
    <param name="psf">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>The address of the parent <see cref="IShellFolder" /> interface. This must be the immediate parent of the <see cref="ITEMIDLIST" /> structure referenced by the <i>pidl</i> parameter.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> structure that identifies the object relative to the folder specified in <i>psf</i>.</para>
    </param>
    <param name="nFormat">
      <para>Type: <b>int</b></para>
      <para>The format in which the data is being requested. This parameter must be set to one of the following values.</para>
      <h4>SHGDFIL_FINDDATA</h4>
      <para>Format used for file system objects. The <i>pv</i> parameter is the address of a <see cref="WIN32_FIND_DATA" /> structure.</para>
      <h4>SHGDFIL_NETRESOURCE</h4>
      <para>Format used for network resources. The <i>pv</i> parameter is the address of a <see cref="NETRESOURCE" /> structure.</para>
      <h4>SHGDFIL_DESCRIPTIONID</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 4.71</a>. Format used for network resources. The <i>pv</i> parameter is the address of an <see cref="SHDESCRIPTIONID" /> structure.</para>
    </param>
    <param name="pv">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the requested data. The format of this buffer is determined by <i>nFormat</i>.</para>
      <para>If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>, there are two possible cases. If the buffer is large enough, the net resource's string information (fields for the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large enough, only the net resource structure will be placed into the buffer and the string information pointers will be <b>NULL</b>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>int</b></para>
      <para>Size of the buffer at <i>pv</i>, in bytes.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or E_INVALIDARG otherwise.</para>
    </returns>
    <remarks>
      <para>This function extracts only information that is present in the pointer to an item identifier list (PIDL). Since the content of a PIDL depends on the folder object that created the PIDL, there is no guarantee that all requested information will be available. In addition, the information that is returned reflects the state of the object at the time the PIDL was created. The current state of the object could be different. For example, if you set <i>nFormat</i> to <b>SHGDFIL_FINDDATA</b>, the function might assign meaningful values to only some of the members of the <see cref="WIN32_FIND_DATA" /> structure. The remaining members will be set to zero. To retrieve complete current information on a file system file or folder, use standard file system functions such as <see cref="GetFileTime" /> or <see cref="FindFirstFile" />.</para>
      <para>E_INVALIDARG is returned if the <i>psf</i>, <i>pidl</i>, <i>pv</i>, or <i>cb</i> parameter does not match the <i>nFormat</i> parameter, or if <i>nFormat</i> is not one of the specific SHGDFIL_ values shown above.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetDataFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetDataFromIDListA">
    <summary>
      <para>Retrieves extended property data from a relative identifier list.</para>
    </summary>
    <param name="psf">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>The address of the parent <see cref="IShellFolder" /> interface. This must be the immediate parent of the <see cref="ITEMIDLIST" /> structure referenced by the <i>pidl</i> parameter.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> structure that identifies the object relative to the folder specified in <i>psf</i>.</para>
    </param>
    <param name="nFormat">
      <para>Type: <b>int</b></para>
      <para>The format in which the data is being requested. This parameter must be set to one of the following values.</para>
      <h4>SHGDFIL_FINDDATA</h4>
      <para>Format used for file system objects. The <i>pv</i> parameter is the address of a <see cref="WIN32_FIND_DATA" /> structure.</para>
      <h4>SHGDFIL_NETRESOURCE</h4>
      <para>Format used for network resources. The <i>pv</i> parameter is the address of a <see cref="NETRESOURCE" /> structure.</para>
      <h4>SHGDFIL_DESCRIPTIONID</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 4.71</a>. Format used for network resources. The <i>pv</i> parameter is the address of an <see cref="SHDESCRIPTIONID" /> structure.</para>
    </param>
    <param name="pv">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the requested data. The format of this buffer is determined by <i>nFormat</i>.</para>
      <para>If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>, there are two possible cases. If the buffer is large enough, the net resource's string information (fields for the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large enough, only the net resource structure will be placed into the buffer and the string information pointers will be <b>NULL</b>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>int</b></para>
      <para>Size of the buffer at <i>pv</i>, in bytes.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or E_INVALIDARG otherwise.</para>
    </returns>
    <remarks>
      <para>This function extracts only information that is present in the pointer to an item identifier list (PIDL). Since the content of a PIDL depends on the folder object that created the PIDL, there is no guarantee that all requested information will be available. In addition, the information that is returned reflects the state of the object at the time the PIDL was created. The current state of the object could be different. For example, if you set <i>nFormat</i> to <b>SHGDFIL_FINDDATA</b>, the function might assign meaningful values to only some of the members of the <see cref="WIN32_FIND_DATA" /> structure. The remaining members will be set to zero. To retrieve complete current information on a file system file or folder, use standard file system functions such as <see cref="GetFileTime" /> or <see cref="FindFirstFile" />.</para>
      <para>E_INVALIDARG is returned if the <i>psf</i>, <i>pidl</i>, <i>pv</i>, or <i>cb</i> parameter does not match the <i>nFormat</i> parameter, or if <i>nFormat</i> is not one of the specific SHGDFIL_ values shown above.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetDataFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetDataFromIDListW">
    <summary>
      <para>Retrieves extended property data from a relative identifier list.</para>
    </summary>
    <param name="psf">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>The address of the parent <see cref="IShellFolder" /> interface. This must be the immediate parent of the <see cref="ITEMIDLIST" /> structure referenced by the <i>pidl</i> parameter.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> structure that identifies the object relative to the folder specified in <i>psf</i>.</para>
    </param>
    <param name="nFormat">
      <para>Type: <b>int</b></para>
      <para>The format in which the data is being requested. This parameter must be set to one of the following values.</para>
      <h4>SHGDFIL_FINDDATA</h4>
      <para>Format used for file system objects. The <i>pv</i> parameter is the address of a <see cref="WIN32_FIND_DATA" /> structure.</para>
      <h4>SHGDFIL_NETRESOURCE</h4>
      <para>Format used for network resources. The <i>pv</i> parameter is the address of a <see cref="NETRESOURCE" /> structure.</para>
      <h4>SHGDFIL_DESCRIPTIONID</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 4.71</a>. Format used for network resources. The <i>pv</i> parameter is the address of an <see cref="SHDESCRIPTIONID" /> structure.</para>
    </param>
    <param name="pv">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the requested data. The format of this buffer is determined by <i>nFormat</i>.</para>
      <para>If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>, there are two possible cases. If the buffer is large enough, the net resource's string information (fields for the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large enough, only the net resource structure will be placed into the buffer and the string information pointers will be <b>NULL</b>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>int</b></para>
      <para>Size of the buffer at <i>pv</i>, in bytes.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or E_INVALIDARG otherwise.</para>
    </returns>
    <remarks>
      <para>This function extracts only information that is present in the pointer to an item identifier list (PIDL). Since the content of a PIDL depends on the folder object that created the PIDL, there is no guarantee that all requested information will be available. In addition, the information that is returned reflects the state of the object at the time the PIDL was created. The current state of the object could be different. For example, if you set <i>nFormat</i> to <b>SHGDFIL_FINDDATA</b>, the function might assign meaningful values to only some of the members of the <see cref="WIN32_FIND_DATA" /> structure. The remaining members will be set to zero. To retrieve complete current information on a file system file or folder, use standard file system functions such as <see cref="GetFileTime" /> or <see cref="FindFirstFile" />.</para>
      <para>E_INVALIDARG is returned if the <i>psf</i>, <i>pidl</i>, <i>pv</i>, or <i>cb</i> parameter does not match the <i>nFormat</i> parameter, or if <i>nFormat</i> is not one of the specific SHGDFIL_ values shown above.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetDataFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetDataFromIDList">
    <summary>
      <para>Retrieves extended property data from a relative identifier list.</para>
    </summary>
    <param name="psf">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>The address of the parent <see cref="IShellFolder" /> interface. This must be the immediate parent of the <see cref="ITEMIDLIST" /> structure referenced by the <i>pidl</i> parameter.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> structure that identifies the object relative to the folder specified in <i>psf</i>.</para>
    </param>
    <param name="nFormat">
      <para>Type: <b>int</b></para>
      <para>The format in which the data is being requested. This parameter must be set to one of the following values.</para>
      <h4>SHGDFIL_FINDDATA</h4>
      <para>Format used for file system objects. The <i>pv</i> parameter is the address of a <see cref="WIN32_FIND_DATA" /> structure.</para>
      <h4>SHGDFIL_NETRESOURCE</h4>
      <para>Format used for network resources. The <i>pv</i> parameter is the address of a <see cref="NETRESOURCE" /> structure.</para>
      <h4>SHGDFIL_DESCRIPTIONID</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 4.71</a>. Format used for network resources. The <i>pv</i> parameter is the address of an <see cref="SHDESCRIPTIONID" /> structure.</para>
    </param>
    <param name="pv">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the requested data. The format of this buffer is determined by <i>nFormat</i>.</para>
      <para>If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>, there are two possible cases. If the buffer is large enough, the net resource's string information (fields for the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large enough, only the net resource structure will be placed into the buffer and the string information pointers will be <b>NULL</b>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>int</b></para>
      <para>Size of the buffer at <i>pv</i>, in bytes.</para>
      <h5>- nFormat.SHGDFIL_DESCRIPTIONID</h5>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 4.71</a>. Format used for network resources. The <i>pv</i> parameter is the address of an <see cref="SHDESCRIPTIONID" /> structure.</para>
      <h5>- nFormat.SHGDFIL_FINDDATA</h5>
      <para>Format used for file system objects. The <i>pv</i> parameter is the address of a <see cref="WIN32_FIND_DATA" /> structure.</para>
      <h5>- nFormat.SHGDFIL_NETRESOURCE</h5>
      <para>Format used for network resources. The <i>pv</i> parameter is the address of a <see cref="NETRESOURCE" /> structure.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or E_INVALIDARG otherwise.</para>
    </returns>
    <remarks>
      <para>This function extracts only information that is present in the pointer to an item identifier list (PIDL). Since the content of a PIDL depends on the folder object that created the PIDL, there is no guarantee that all requested information will be available. In addition, the information that is returned reflects the state of the object at the time the PIDL was created. The current state of the object could be different. For example, if you set <i>nFormat</i> to <b>SHGDFIL_FINDDATA</b>, the function might assign meaningful values to only some of the members of the <see cref="WIN32_FIND_DATA" /> structure. The remaining members will be set to zero. To retrieve complete current information on a file system file or folder, use standard file system functions such as <see cref="GetFileTime" /> or <see cref="FindFirstFile" />.</para>
      <para>E_INVALIDARG is returned if the <i>psf</i>, <i>pidl</i>, <i>pv</i>, or <i>cb</i> parameter does not match the <i>nFormat</i> parameter, or if <i>nFormat</i> is not one of the specific SHGDFIL_ values shown above.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetDataFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetDataFromIDListA">
    <summary>
      <para>Retrieves extended property data from a relative identifier list.</para>
    </summary>
    <param name="psf">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>The address of the parent <see cref="IShellFolder" /> interface. This must be the immediate parent of the <see cref="ITEMIDLIST" /> structure referenced by the <i>pidl</i> parameter.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> structure that identifies the object relative to the folder specified in <i>psf</i>.</para>
    </param>
    <param name="nFormat">
      <para>Type: <b>int</b></para>
      <para>The format in which the data is being requested. This parameter must be set to one of the following values.</para>
      <h4>SHGDFIL_FINDDATA</h4>
      <para>Format used for file system objects. The <i>pv</i> parameter is the address of a <see cref="WIN32_FIND_DATA" /> structure.</para>
      <h4>SHGDFIL_NETRESOURCE</h4>
      <para>Format used for network resources. The <i>pv</i> parameter is the address of a <see cref="NETRESOURCE" /> structure.</para>
      <h4>SHGDFIL_DESCRIPTIONID</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 4.71</a>. Format used for network resources. The <i>pv</i> parameter is the address of an <see cref="SHDESCRIPTIONID" /> structure.</para>
    </param>
    <param name="pv">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the requested data. The format of this buffer is determined by <i>nFormat</i>.</para>
      <para>If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>, there are two possible cases. If the buffer is large enough, the net resource's string information (fields for the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large enough, only the net resource structure will be placed into the buffer and the string information pointers will be <b>NULL</b>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>int</b></para>
      <para>Size of the buffer at <i>pv</i>, in bytes.</para>
      <h5>- nFormat.SHGDFIL_DESCRIPTIONID</h5>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 4.71</a>. Format used for network resources. The <i>pv</i> parameter is the address of an <see cref="SHDESCRIPTIONID" /> structure.</para>
      <h5>- nFormat.SHGDFIL_FINDDATA</h5>
      <para>Format used for file system objects. The <i>pv</i> parameter is the address of a <see cref="WIN32_FIND_DATA" /> structure.</para>
      <h5>- nFormat.SHGDFIL_NETRESOURCE</h5>
      <para>Format used for network resources. The <i>pv</i> parameter is the address of a <see cref="NETRESOURCE" /> structure.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or E_INVALIDARG otherwise.</para>
    </returns>
    <remarks>
      <para>This function extracts only information that is present in the pointer to an item identifier list (PIDL). Since the content of a PIDL depends on the folder object that created the PIDL, there is no guarantee that all requested information will be available. In addition, the information that is returned reflects the state of the object at the time the PIDL was created. The current state of the object could be different. For example, if you set <i>nFormat</i> to <b>SHGDFIL_FINDDATA</b>, the function might assign meaningful values to only some of the members of the <see cref="WIN32_FIND_DATA" /> structure. The remaining members will be set to zero. To retrieve complete current information on a file system file or folder, use standard file system functions such as <see cref="GetFileTime" /> or <see cref="FindFirstFile" />.</para>
      <para>E_INVALIDARG is returned if the <i>psf</i>, <i>pidl</i>, <i>pv</i>, or <i>cb</i> parameter does not match the <i>nFormat</i> parameter, or if <i>nFormat</i> is not one of the specific SHGDFIL_ values shown above.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetDataFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetDataFromIDListW">
    <summary>
      <para>Retrieves extended property data from a relative identifier list.</para>
    </summary>
    <param name="psf">
      <para>Type: <b><see cref="IShellFolder" />*</b></para>
      <para>The address of the parent <see cref="IShellFolder" /> interface. This must be the immediate parent of the <see cref="ITEMIDLIST" /> structure referenced by the <i>pidl</i> parameter.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> structure that identifies the object relative to the folder specified in <i>psf</i>.</para>
    </param>
    <param name="nFormat">
      <para>Type: <b>int</b></para>
      <para>The format in which the data is being requested. This parameter must be set to one of the following values.</para>
      <h4>SHGDFIL_FINDDATA</h4>
      <para>Format used for file system objects. The <i>pv</i> parameter is the address of a <see cref="WIN32_FIND_DATA" /> structure.</para>
      <h4>SHGDFIL_NETRESOURCE</h4>
      <para>Format used for network resources. The <i>pv</i> parameter is the address of a <see cref="NETRESOURCE" /> structure.</para>
      <h4>SHGDFIL_DESCRIPTIONID</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 4.71</a>. Format used for network resources. The <i>pv</i> parameter is the address of an <see cref="SHDESCRIPTIONID" /> structure.</para>
    </param>
    <param name="pv">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the requested data. The format of this buffer is determined by <i>nFormat</i>.</para>
      <para>If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>, there are two possible cases. If the buffer is large enough, the net resource's string information (fields for the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large enough, only the net resource structure will be placed into the buffer and the string information pointers will be <b>NULL</b>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>int</b></para>
      <para>Size of the buffer at <i>pv</i>, in bytes.</para>
      <h5>- nFormat.SHGDFIL_DESCRIPTIONID</h5>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 4.71</a>. Format used for network resources. The <i>pv</i> parameter is the address of an <see cref="SHDESCRIPTIONID" /> structure.</para>
      <h5>- nFormat.SHGDFIL_FINDDATA</h5>
      <para>Format used for file system objects. The <i>pv</i> parameter is the address of a <see cref="WIN32_FIND_DATA" /> structure.</para>
      <h5>- nFormat.SHGDFIL_NETRESOURCE</h5>
      <para>Format used for network resources. The <i>pv</i> parameter is the address of a <see cref="NETRESOURCE" /> structure.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or E_INVALIDARG otherwise.</para>
    </returns>
    <remarks>
      <para>This function extracts only information that is present in the pointer to an item identifier list (PIDL). Since the content of a PIDL depends on the folder object that created the PIDL, there is no guarantee that all requested information will be available. In addition, the information that is returned reflects the state of the object at the time the PIDL was created. The current state of the object could be different. For example, if you set <i>nFormat</i> to <b>SHGDFIL_FINDDATA</b>, the function might assign meaningful values to only some of the members of the <see cref="WIN32_FIND_DATA" /> structure. The remaining members will be set to zero. To retrieve complete current information on a file system file or folder, use standard file system functions such as <see cref="GetFileTime" /> or <see cref="FindFirstFile" />.</para>
      <para>E_INVALIDARG is returned if the <i>psf</i>, <i>pidl</i>, <i>pv</i>, or <i>cb</i> parameter does not match the <i>nFormat</i> parameter, or if <i>nFormat</i> is not one of the specific SHGDFIL_ values shown above.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetDataFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetDesktopFolder">
    <summary>
      <para>Retrieves the <see cref="IShellFolder" /> interface for the desktop folder, which is the root of the Shell's namespace.</para>
    </summary>
    <param name="ppshf">
      <para>Type: <b><see cref="IShellFolder" />**</b></para>
      <para>When this method returns, receives an <see cref="IShellFolder" /> interface pointer for the desktop folder. The calling application is responsible for eventually freeing the interface by calling its <see cref="IUnknown.Release" /> method.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.SHGetFolderLocation">
    <summary>
      <para>Deprecated. Retrieves the path of a folder as an <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder to be located. The folders associated with the CSIDLs might not exist on a particular system.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. It is usually set to <b>NULL</b>, but it may be needed when there are multiple users for those folders that are treated as belonging to a single user. The most commonly used folder of this type is <b>My Documents</b>. The calling application is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. It must have appropriate security privileges for the particular user, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
      <para>Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHGetFolderLocation</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>My Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
    </param>
    <param name="ppidl">
      <para>Type: <b>PIDLIST_ABSOLUTE*</b></para>
      <para>The address of a pointer to an item identifier list structure that specifies the folder's location relative to the root of the namespace (the desktop). The <i>ppidl</i> parameter is set to <b>NULL</b> on failure. The calling application is responsible for freeing this resource by calling <see cref="ILFree" />.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or an error value otherwise, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)</b>
            </para>
          </description>
          <description>
            <para>The <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> in <i>nFolder</i> is valid but the folder does not exist.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>The <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> in <i>nFolder</i> is not valid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHGetKnownFolderIDList" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and <b>SHGetKnownFolderIDList</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
      <para>The <b>SHGetFolderLocation</b>, <see cref="SHGetFolderPath" />, <see cref="SHGetSpecialFolderLocation" />, and <see cref="SHGetSpecialFolderPath" /> functions are the preferred ways to obtain handles to folders on systems earlier than Windows Vista. Functions such as <see cref="ExpandEnvironmentStrings" /> that use the environment variable names directly, in the form %VariableName%, may not be reliable.</para>
      <para>This function is a superset of <see cref="SHGetSpecialFolderLocation" />, included with earlier versions of the Shell.</para>
    </remarks>
    <seealso cref="IKnownFolder.GetIDList" />
  </member>
  <member name="Windows.SHGetFolderPath">
    <summary>
      <para>Deprecated. Gets the path of a folder identified by a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHGetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and then <b>SHGetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user.</para>
      <para>
        <b>Microsoft Windows 2000 and earlier:</b> Always set this parameter to <b>NULL</b>.</para>
      <para>
        <b>Windows XP and later:</b> This parameter is usually set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling process is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
      <para>Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also appear in any new user account.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify the path to be returned. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> (or <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a>) can be moved, renamed, redirected, or roamed across languages by a user or administrator.</para>
      <para>The known folder system that underlies <b>SHGetFolderPath</b> allows users or administrators to redirect a known folder to a location that suits their needs. This is achieved by calling <see cref="IKnownFolderManager.Redirect" />, which sets the "current" value of the folder associated with the SHGFP_TYPE_CURRENT flag.</para>
      <para>The default value of the folder, which is the location of the folder if a user or administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value can be used to implement a "restore defaults" feature for a known folder.</para>
      <para>For example, the default value (SHGFP_TYPE_DEFAULT) for <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">FOLDERID_Music</a> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYMUSIC</a>) is "C:\Users\<b>user name</b>\Music". If the folder was redirected, the current value (SHGFP_TYPE_CURRENT) might be "D:\Music". If the folder has not been redirected, then SHGFP_TYPE_DEFAULT and SHGFP_TYPE_CURRENT retrieve the same path.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Retrieve the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Retrieve the folder's default path.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path. If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\".</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function is a superset of <see cref="SHGetSpecialFolderPath" />.</para>
      <para>Only some <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> values are supported, including the following:</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_DOCUMENTS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COOKIES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_CREATE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_VERIFY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_HISTORY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_INTERNET_CACHE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_LOCAL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES_COMMON</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_SYSTEM</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_WINDOWS</a>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFolderPath</b> to find or create a folder and then creates a file in it.</para>
      <code>TCHAR szPath[MAX_PATH];

if(SUCCEEDED(SHGetFolderPath(NULL,
                             CSIDL_PERSONAL|CSIDL_FLAG_CREATE,
                             NULL,
                             0,
                             szPath)))
{
    PathAppend(szPath, TEXT("New Doc.txt"));
    HANDLE hFile = CreateFile(szPath, ...);
}
</code>
    </remarks>
    <seealso cref="IKnownFolder.GetPath" />
  </member>
  <member name="Windows.SHGetFolderPathA">
    <summary>
      <para>Deprecated. Gets the path of a folder identified by a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHGetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and then <b>SHGetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user.</para>
      <para>
        <b>Microsoft Windows 2000 and earlier:</b> Always set this parameter to <b>NULL</b>.</para>
      <para>
        <b>Windows XP and later:</b> This parameter is usually set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling process is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
      <para>Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also appear in any new user account.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify the path to be returned. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> (or <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a>) can be moved, renamed, redirected, or roamed across languages by a user or administrator.</para>
      <para>The known folder system that underlies <b>SHGetFolderPath</b> allows users or administrators to redirect a known folder to a location that suits their needs. This is achieved by calling <see cref="IKnownFolderManager.Redirect" />, which sets the "current" value of the folder associated with the SHGFP_TYPE_CURRENT flag.</para>
      <para>The default value of the folder, which is the location of the folder if a user or administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value can be used to implement a "restore defaults" feature for a known folder.</para>
      <para>For example, the default value (SHGFP_TYPE_DEFAULT) for <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">FOLDERID_Music</a> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYMUSIC</a>) is "C:\Users\<b>user name</b>\Music". If the folder was redirected, the current value (SHGFP_TYPE_CURRENT) might be "D:\Music". If the folder has not been redirected, then SHGFP_TYPE_DEFAULT and SHGFP_TYPE_CURRENT retrieve the same path.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Retrieve the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Retrieve the folder's default path.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path. If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\".</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function is a superset of <see cref="SHGetSpecialFolderPath" />.</para>
      <para>Only some <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> values are supported, including the following:</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_DOCUMENTS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COOKIES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_CREATE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_VERIFY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_HISTORY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_INTERNET_CACHE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_LOCAL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES_COMMON</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_SYSTEM</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_WINDOWS</a>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFolderPath</b> to find or create a folder and then creates a file in it.</para>
      <code>TCHAR szPath[MAX_PATH];

if(SUCCEEDED(SHGetFolderPath(NULL,
                             CSIDL_PERSONAL|CSIDL_FLAG_CREATE,
                             NULL,
                             0,
                             szPath)))
{
    PathAppend(szPath, TEXT("New Doc.txt"));
    HANDLE hFile = CreateFile(szPath, ...);
}
</code>
    </remarks>
    <seealso cref="IKnownFolder.GetPath" />
  </member>
  <member name="Windows.SHGetFolderPathW">
    <summary>
      <para>Deprecated. Gets the path of a folder identified by a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHGetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and then <b>SHGetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user.</para>
      <para>
        <b>Microsoft Windows 2000 and earlier:</b> Always set this parameter to <b>NULL</b>.</para>
      <para>
        <b>Windows XP and later:</b> This parameter is usually set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling process is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
      <para>Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also appear in any new user account.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify the path to be returned. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> (or <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a>) can be moved, renamed, redirected, or roamed across languages by a user or administrator.</para>
      <para>The known folder system that underlies <b>SHGetFolderPath</b> allows users or administrators to redirect a known folder to a location that suits their needs. This is achieved by calling <see cref="IKnownFolderManager.Redirect" />, which sets the "current" value of the folder associated with the SHGFP_TYPE_CURRENT flag.</para>
      <para>The default value of the folder, which is the location of the folder if a user or administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value can be used to implement a "restore defaults" feature for a known folder.</para>
      <para>For example, the default value (SHGFP_TYPE_DEFAULT) for <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">FOLDERID_Music</a> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYMUSIC</a>) is "C:\Users\<b>user name</b>\Music". If the folder was redirected, the current value (SHGFP_TYPE_CURRENT) might be "D:\Music". If the folder has not been redirected, then SHGFP_TYPE_DEFAULT and SHGFP_TYPE_CURRENT retrieve the same path.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Retrieve the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Retrieve the folder's default path.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path. If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\".</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function is a superset of <see cref="SHGetSpecialFolderPath" />.</para>
      <para>Only some <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> values are supported, including the following:</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_DOCUMENTS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COOKIES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_CREATE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_VERIFY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_HISTORY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_INTERNET_CACHE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_LOCAL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES_COMMON</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_SYSTEM</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_WINDOWS</a>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFolderPath</b> to find or create a folder and then creates a file in it.</para>
      <code>TCHAR szPath[MAX_PATH];

if(SUCCEEDED(SHGetFolderPath(NULL,
                             CSIDL_PERSONAL|CSIDL_FLAG_CREATE,
                             NULL,
                             0,
                             szPath)))
{
    PathAppend(szPath, TEXT("New Doc.txt"));
    HANDLE hFile = CreateFile(szPath, ...);
}
</code>
    </remarks>
    <seealso cref="IKnownFolder.GetPath" />
  </member>
  <member name="Windows.SHGetFolderPathAndSubDir">
    <summary>
      <para>Gets the path of a folder and appends a user-provided subfolder path.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder with <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. For systems earlier than Windows 2000, set this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <a href="https://docs.microsoft.com//windows/desktop/shell/manage">My Documents</a>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies whether the path to be returned is the actual path of the folder or the default path. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value may be moved or renamed by the user.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Return the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Return the folder's default path.</para>
    </param>
    <param name="pszSubDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the subpath to be appended to the folder's path. This is a <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be appended.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>When this function returns, this value points to the directory path and appended subpath. This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an error code.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetFolderPathAndSubDir as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetFolderPath" />
  </member>
  <member name="Windows.SHGetFolderPathAndSubDirA">
    <summary>
      <para>Gets the path of a folder and appends a user-provided subfolder path.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder with <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. For systems earlier than Windows 2000, set this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <a href="https://docs.microsoft.com//windows/desktop/shell/manage">My Documents</a>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies whether the path to be returned is the actual path of the folder or the default path. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value may be moved or renamed by the user.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Return the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Return the folder's default path.</para>
    </param>
    <param name="pszSubDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the subpath to be appended to the folder's path. This is a <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be appended.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>When this function returns, this value points to the directory path and appended subpath. This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an error code.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetFolderPathAndSubDir as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetFolderPath" />
  </member>
  <member name="Windows.SHGetFolderPathAndSubDirW">
    <summary>
      <para>Gets the path of a folder and appends a user-provided subfolder path.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder with <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. For systems earlier than Windows 2000, set this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <a href="https://docs.microsoft.com//windows/desktop/shell/manage">My Documents</a>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies whether the path to be returned is the actual path of the folder or the default path. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value may be moved or renamed by the user.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Return the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Return the folder's default path.</para>
    </param>
    <param name="pszSubDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the subpath to be appended to the folder's path. This is a <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be appended.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>When this function returns, this value points to the directory path and appended subpath. This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an error code.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetFolderPathAndSubDir as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetFolderPath" />
  </member>
  <member name="Windows.SHGetFolderPathAndSubDir">
    <summary>
      <para>Gets the path of a folder and appends a user-provided subfolder path.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder with <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. For systems earlier than Windows 2000, set this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <a href="https://docs.microsoft.com//windows/desktop/shell/manage">My Documents</a>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies whether the path to be returned is the actual path of the folder or the default path. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value may be moved or renamed by the user.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Return the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Return the folder's default path.</para>
    </param>
    <param name="pszSubDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the subpath to be appended to the folder's path. This is a <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be appended.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>When this function returns, this value points to the directory path and appended subpath. This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an error code.</para>
      <h5>- dwFlags.SHGFP_TYPE_CURRENT</h5>
      <para>Return the folder's current path.</para>
      <h5>- dwFlags.SHGFP_TYPE_DEFAULT</h5>
      <para>Return the folder's default path.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetFolderPathAndSubDir as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetFolderPath" />
  </member>
  <member name="Windows.SHGetFolderPathAndSubDirA">
    <summary>
      <para>Gets the path of a folder and appends a user-provided subfolder path.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder with <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. For systems earlier than Windows 2000, set this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <a href="https://docs.microsoft.com//windows/desktop/shell/manage">My Documents</a>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies whether the path to be returned is the actual path of the folder or the default path. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value may be moved or renamed by the user.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Return the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Return the folder's default path.</para>
    </param>
    <param name="pszSubDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the subpath to be appended to the folder's path. This is a <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be appended.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>When this function returns, this value points to the directory path and appended subpath. This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an error code.</para>
      <h5>- dwFlags.SHGFP_TYPE_CURRENT</h5>
      <para>Return the folder's current path.</para>
      <h5>- dwFlags.SHGFP_TYPE_DEFAULT</h5>
      <para>Return the folder's default path.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetFolderPathAndSubDir as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetFolderPath" />
  </member>
  <member name="Windows.SHGetFolderPathAndSubDirW">
    <summary>
      <para>Gets the path of a folder and appends a user-provided subfolder path.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder with <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. For systems earlier than Windows 2000, set this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <a href="https://docs.microsoft.com//windows/desktop/shell/manage">My Documents</a>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Specifies whether the path to be returned is the actual path of the folder or the default path. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value may be moved or renamed by the user.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Return the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Return the folder's default path.</para>
    </param>
    <param name="pszSubDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the subpath to be appended to the folder's path. This is a <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be appended.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>When this function returns, this value points to the directory path and appended subpath. This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an error code.</para>
      <h5>- dwFlags.SHGFP_TYPE_CURRENT</h5>
      <para>Return the folder's current path.</para>
      <h5>- dwFlags.SHGFP_TYPE_DEFAULT</h5>
      <para>Return the folder's default path.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetFolderPathAndSubDir as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetFolderPath" />
  </member>
  <member name="Windows.SHGetFolderPath">
    <summary>
      <para>Deprecated. Gets the path of a folder identified by a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHGetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and then <b>SHGetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user.</para>
      <para>
        <b>Microsoft Windows 2000 and earlier:</b> Always set this parameter to <b>NULL</b>.</para>
      <para>
        <b>Windows XP and later:</b> This parameter is usually set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling process is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
      <para>Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also appear in any new user account.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify the path to be returned. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> (or <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a>) can be moved, renamed, redirected, or roamed across languages by a user or administrator.</para>
      <para>The known folder system that underlies <b>SHGetFolderPath</b> allows users or administrators to redirect a known folder to a location that suits their needs. This is achieved by calling <see cref="IKnownFolderManager.Redirect" />, which sets the "current" value of the folder associated with the SHGFP_TYPE_CURRENT flag.</para>
      <para>The default value of the folder, which is the location of the folder if a user or administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value can be used to implement a "restore defaults" feature for a known folder.</para>
      <para>For example, the default value (SHGFP_TYPE_DEFAULT) for <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">FOLDERID_Music</a> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYMUSIC</a>) is "C:\Users\<b>user name</b>\Music". If the folder was redirected, the current value (SHGFP_TYPE_CURRENT) might be "D:\Music". If the folder has not been redirected, then SHGFP_TYPE_DEFAULT and SHGFP_TYPE_CURRENT retrieve the same path.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Retrieve the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Retrieve the folder's default path.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPWSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path. If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\".</para>
      <h5>- dwFlags.SHGFP_TYPE_CURRENT</h5>
      <para>Retrieve the folder's current path.</para>
      <h5>- dwFlags.SHGFP_TYPE_DEFAULT</h5>
      <para>Retrieve the folder's default path.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function is a superset of <see cref="SHGetSpecialFolderPath" />.</para>
      <para>Only some <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> values are supported, including the following:</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_DOCUMENTS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COOKIES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_CREATE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_VERIFY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_HISTORY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_INTERNET_CACHE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_LOCAL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES_COMMON</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_SYSTEM</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_WINDOWS</a>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFolderPath</b> to find or create a folder and then creates a file in it.</para>
      <code>TCHAR szPath[MAX_PATH];

if(SUCCEEDED(SHGetFolderPath(NULL,
                             CSIDL_PERSONAL|CSIDL_FLAG_CREATE,
                             NULL,
                             0,
                             szPath)))
{
    PathAppend(szPath, TEXT("New Doc.txt"));
    HANDLE hFile = CreateFile(szPath, ...);
}
</code>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IKnownFolder.GetPath" />
  </member>
  <member name="Windows.SHGetFolderPathA">
    <summary>
      <para>Deprecated. Gets the path of a folder identified by a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHGetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and then <b>SHGetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user.</para>
      <para>
        <b>Microsoft Windows 2000 and earlier:</b> Always set this parameter to <b>NULL</b>.</para>
      <para>
        <b>Windows XP and later:</b> This parameter is usually set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling process is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
      <para>Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also appear in any new user account.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify the path to be returned. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> (or <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a>) can be moved, renamed, redirected, or roamed across languages by a user or administrator.</para>
      <para>The known folder system that underlies <b>SHGetFolderPath</b> allows users or administrators to redirect a known folder to a location that suits their needs. This is achieved by calling <see cref="IKnownFolderManager.Redirect" />, which sets the "current" value of the folder associated with the SHGFP_TYPE_CURRENT flag.</para>
      <para>The default value of the folder, which is the location of the folder if a user or administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value can be used to implement a "restore defaults" feature for a known folder.</para>
      <para>For example, the default value (SHGFP_TYPE_DEFAULT) for <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">FOLDERID_Music</a> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYMUSIC</a>) is "C:\Users\<b>user name</b>\Music". If the folder was redirected, the current value (SHGFP_TYPE_CURRENT) might be "D:\Music". If the folder has not been redirected, then SHGFP_TYPE_DEFAULT and SHGFP_TYPE_CURRENT retrieve the same path.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Retrieve the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Retrieve the folder's default path.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPWSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path. If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\".</para>
      <h5>- dwFlags.SHGFP_TYPE_CURRENT</h5>
      <para>Retrieve the folder's current path.</para>
      <h5>- dwFlags.SHGFP_TYPE_DEFAULT</h5>
      <para>Retrieve the folder's default path.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function is a superset of <see cref="SHGetSpecialFolderPath" />.</para>
      <para>Only some <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> values are supported, including the following:</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_DOCUMENTS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COOKIES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_CREATE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_VERIFY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_HISTORY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_INTERNET_CACHE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_LOCAL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES_COMMON</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_SYSTEM</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_WINDOWS</a>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFolderPath</b> to find or create a folder and then creates a file in it.</para>
      <code>TCHAR szPath[MAX_PATH];

if(SUCCEEDED(SHGetFolderPath(NULL,
                             CSIDL_PERSONAL|CSIDL_FLAG_CREATE,
                             NULL,
                             0,
                             szPath)))
{
    PathAppend(szPath, TEXT("New Doc.txt"));
    HANDLE hFile = CreateFile(szPath, ...);
}
</code>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IKnownFolder.GetPath" />
  </member>
  <member name="Windows.SHGetFolderPathW">
    <summary>
      <para>Deprecated. Gets the path of a folder identified by a <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value.</para>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHGetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and then <b>SHGetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>Reserved.</para>
    </param>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user.</para>
      <para>
        <b>Microsoft Windows 2000 and earlier:</b> Always set this parameter to <b>NULL</b>.</para>
      <para>
        <b>Windows XP and later:</b> This parameter is usually set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling process is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
      <para>Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also appear in any new user account.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify the path to be returned. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> (or <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a>) can be moved, renamed, redirected, or roamed across languages by a user or administrator.</para>
      <para>The known folder system that underlies <b>SHGetFolderPath</b> allows users or administrators to redirect a known folder to a location that suits their needs. This is achieved by calling <see cref="IKnownFolderManager.Redirect" />, which sets the "current" value of the folder associated with the SHGFP_TYPE_CURRENT flag.</para>
      <para>The default value of the folder, which is the location of the folder if a user or administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value can be used to implement a "restore defaults" feature for a known folder.</para>
      <para>For example, the default value (SHGFP_TYPE_DEFAULT) for <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">FOLDERID_Music</a> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYMUSIC</a>) is "C:\Users\<b>user name</b>\Music". If the folder was redirected, the current value (SHGFP_TYPE_CURRENT) might be "D:\Music". If the folder has not been redirected, then SHGFP_TYPE_DEFAULT and SHGFP_TYPE_CURRENT retrieve the same path.</para>
      <h4>SHGFP_TYPE_CURRENT</h4>
      <para>Retrieve the folder's current path.</para>
      <h4>SHGFP_TYPE_DEFAULT</h4>
      <para>Retrieve the folder's default path.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPWSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path. If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\".</para>
      <h5>- dwFlags.SHGFP_TYPE_CURRENT</h5>
      <para>Retrieve the folder's current path.</para>
      <h5>- dwFlags.SHGFP_TYPE_DEFAULT</h5>
      <para>Retrieve the folder's default path.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function is a superset of <see cref="SHGetSpecialFolderPath" />.</para>
      <para>Only some <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> values are supported, including the following:</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_ADMINTOOLS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COMMON_DOCUMENTS</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_COOKIES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_CREATE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_VERIFY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_HISTORY</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_INTERNET_CACHE</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_LOCAL_APPDATA</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES_COMMON</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_SYSTEM</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_WINDOWS</a>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFolderPath</b> to find or create a folder and then creates a file in it.</para>
      <code>TCHAR szPath[MAX_PATH];

if(SUCCEEDED(SHGetFolderPath(NULL,
                             CSIDL_PERSONAL|CSIDL_FLAG_CREATE,
                             NULL,
                             0,
                             szPath)))
{
    PathAppend(szPath, TEXT("New Doc.txt"));
    HANDLE hFile = CreateFile(szPath, ...);
}
</code>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IKnownFolder.GetPath" />
  </member>
  <member name="Windows.SHGetIconOverlayIndex">
    <summary>
      <para>Returns the index of the overlay icon in the system image list.</para>
    </summary>
    <param name="pszIconPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the fully qualified path of the file that contains the icon.</para>
    </param>
    <param name="iIconIndex">
      <para>Type: <b>int</b></para>
      <para>The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:</para>
      <h4>IDO_SHGIOI_SHARE (0x0FFFFFFF)</h4>
      <para>The overlay icon that indicates a shared folder.</para>
      <h4>IDO_SHGIOI_LINK (0x0FFFFFFE)</h4>
      <para>The overlay icon that indicates a linked folder or file.</para>
      <h4>IDO_SHGIOI_SLOWFILE (0x0FFFFFFD)</h4>
      <para>The overlay icon that indicates a slow file.</para>
      <h4>IDO_SHGIOI_DEFAULT (0x0FFFFFFC)</h4>
      <para>
        <b>Windows 7 and later</b>. The overlay icon that indicates that the item is the default in a set. One example is the default printer.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.</para>
    </returns>
    <remarks>
      <para>Icon overlays are part of the system image list. They have two identifiers. The first is a one-based overlay index that identifies the overlay relative to other overlays in the image list. The other is an image index that identifies the actual image. These two indexes are equivalent to the values that you assign to the <i>iOverlay</i> and <i>iImage</i> parameters, respectively, when you add an icon overlay to a private image list with <see cref="ImageList_SetOverlayImage" />. <b>SHGetIconOverlayIndex</b> returns the overlay index. To convert an overlay index to its equivalent image index, call <see cref="INDEXTOOVERLAYMASK" />.</para>
      <para>
        <b>Note</b>  After the image has been loaded into the system image list during initialization, it cannot be changed. The file name and index specified by <i>pszIconPath</i> and <i>iIconIndex</i> are used only to identify the icon overlay. <b>SHGetIconOverlayIndex</b> cannot be used to modify the system image list.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetIconOverlayIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IShellIconOverlay" />
    <seealso cref="IShellIconOverlayIdentifier" />
  </member>
  <member name="Windows.SHGetIconOverlayIndexA">
    <summary>
      <para>Returns the index of the overlay icon in the system image list.</para>
    </summary>
    <param name="pszIconPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the fully qualified path of the file that contains the icon.</para>
    </param>
    <param name="iIconIndex">
      <para>Type: <b>int</b></para>
      <para>The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:</para>
      <h4>IDO_SHGIOI_SHARE (0x0FFFFFFF)</h4>
      <para>The overlay icon that indicates a shared folder.</para>
      <h4>IDO_SHGIOI_LINK (0x0FFFFFFE)</h4>
      <para>The overlay icon that indicates a linked folder or file.</para>
      <h4>IDO_SHGIOI_SLOWFILE (0x0FFFFFFD)</h4>
      <para>The overlay icon that indicates a slow file.</para>
      <h4>IDO_SHGIOI_DEFAULT (0x0FFFFFFC)</h4>
      <para>
        <b>Windows 7 and later</b>. The overlay icon that indicates that the item is the default in a set. One example is the default printer.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.</para>
    </returns>
    <remarks>
      <para>Icon overlays are part of the system image list. They have two identifiers. The first is a one-based overlay index that identifies the overlay relative to other overlays in the image list. The other is an image index that identifies the actual image. These two indexes are equivalent to the values that you assign to the <i>iOverlay</i> and <i>iImage</i> parameters, respectively, when you add an icon overlay to a private image list with <see cref="ImageList_SetOverlayImage" />. <b>SHGetIconOverlayIndex</b> returns the overlay index. To convert an overlay index to its equivalent image index, call <see cref="INDEXTOOVERLAYMASK" />.</para>
      <para>
        <b>Note</b>  After the image has been loaded into the system image list during initialization, it cannot be changed. The file name and index specified by <i>pszIconPath</i> and <i>iIconIndex</i> are used only to identify the icon overlay. <b>SHGetIconOverlayIndex</b> cannot be used to modify the system image list.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetIconOverlayIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IShellIconOverlay" />
    <seealso cref="IShellIconOverlayIdentifier" />
  </member>
  <member name="Windows.SHGetIconOverlayIndexW">
    <summary>
      <para>Returns the index of the overlay icon in the system image list.</para>
    </summary>
    <param name="pszIconPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the fully qualified path of the file that contains the icon.</para>
    </param>
    <param name="iIconIndex">
      <para>Type: <b>int</b></para>
      <para>The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:</para>
      <h4>IDO_SHGIOI_SHARE (0x0FFFFFFF)</h4>
      <para>The overlay icon that indicates a shared folder.</para>
      <h4>IDO_SHGIOI_LINK (0x0FFFFFFE)</h4>
      <para>The overlay icon that indicates a linked folder or file.</para>
      <h4>IDO_SHGIOI_SLOWFILE (0x0FFFFFFD)</h4>
      <para>The overlay icon that indicates a slow file.</para>
      <h4>IDO_SHGIOI_DEFAULT (0x0FFFFFFC)</h4>
      <para>
        <b>Windows 7 and later</b>. The overlay icon that indicates that the item is the default in a set. One example is the default printer.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.</para>
    </returns>
    <remarks>
      <para>Icon overlays are part of the system image list. They have two identifiers. The first is a one-based overlay index that identifies the overlay relative to other overlays in the image list. The other is an image index that identifies the actual image. These two indexes are equivalent to the values that you assign to the <i>iOverlay</i> and <i>iImage</i> parameters, respectively, when you add an icon overlay to a private image list with <see cref="ImageList_SetOverlayImage" />. <b>SHGetIconOverlayIndex</b> returns the overlay index. To convert an overlay index to its equivalent image index, call <see cref="INDEXTOOVERLAYMASK" />.</para>
      <para>
        <b>Note</b>  After the image has been loaded into the system image list during initialization, it cannot be changed. The file name and index specified by <i>pszIconPath</i> and <i>iIconIndex</i> are used only to identify the icon overlay. <b>SHGetIconOverlayIndex</b> cannot be used to modify the system image list.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetIconOverlayIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IShellIconOverlay" />
    <seealso cref="IShellIconOverlayIdentifier" />
  </member>
  <member name="Windows.SHGetIconOverlayIndex">
    <summary>
      <para>Returns the index of the overlay icon in the system image list.</para>
    </summary>
    <param name="pszIconPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the fully qualified path of the file that contains the icon.</para>
    </param>
    <param name="iIconIndex">
      <para>Type: <b>int</b></para>
      <para>The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:</para>
      <h4>IDO_SHGIOI_SHARE (0x0FFFFFFF)</h4>
      <para>The overlay icon that indicates a shared folder.</para>
      <h4>IDO_SHGIOI_LINK (0x0FFFFFFE)</h4>
      <para>The overlay icon that indicates a linked folder or file.</para>
      <h4>IDO_SHGIOI_SLOWFILE (0x0FFFFFFD)</h4>
      <para>The overlay icon that indicates a slow file.</para>
      <h4>IDO_SHGIOI_DEFAULT (0x0FFFFFFC)</h4>
      <para>
        <b>Windows 7 and later</b>. The overlay icon that indicates that the item is the default in a set. One example is the default printer.</para>
      <h5>- iIconIndex.IDO_SHGIOI_DEFAULT (0x0FFFFFFC)</h5>
      <para>
        <b>Windows 7 and later</b>. The overlay icon that indicates that the item is the default in a set. One example is the default printer.</para>
      <h5>- iIconIndex.IDO_SHGIOI_LINK (0x0FFFFFFE)</h5>
      <para>The overlay icon that indicates a linked folder or file.</para>
      <h5>- iIconIndex.IDO_SHGIOI_SHARE (0x0FFFFFFF)</h5>
      <para>The overlay icon that indicates a shared folder.</para>
      <h5>- iIconIndex.IDO_SHGIOI_SLOWFILE (0x0FFFFFFD)</h5>
      <para>The overlay icon that indicates a slow file.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.</para>
    </returns>
    <remarks>
      <para>Icon overlays are part of the system image list. They have two identifiers. The first is a one-based overlay index that identifies the overlay relative to other overlays in the image list. The other is an image index that identifies the actual image. These two indexes are equivalent to the values that you assign to the <i>iOverlay</i> and <i>iImage</i> parameters, respectively, when you add an icon overlay to a private image list with <see cref="ImageList_SetOverlayImage" />. <b>SHGetIconOverlayIndex</b> returns the overlay index. To convert an overlay index to its equivalent image index, call <see cref="INDEXTOOVERLAYMASK" />.</para>
      <para>
        <b>Note</b>  After the image has been loaded into the system image list during initialization, it cannot be changed. The file name and index specified by <i>pszIconPath</i> and <i>iIconIndex</i> are used only to identify the icon overlay. <b>SHGetIconOverlayIndex</b> cannot be used to modify the system image list.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetIconOverlayIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IShellIconOverlay" />
    <seealso cref="IShellIconOverlayIdentifier" />
  </member>
  <member name="Windows.SHGetIconOverlayIndexA">
    <summary>
      <para>Returns the index of the overlay icon in the system image list.</para>
    </summary>
    <param name="pszIconPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the fully qualified path of the file that contains the icon.</para>
    </param>
    <param name="iIconIndex">
      <para>Type: <b>int</b></para>
      <para>The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:</para>
      <h4>IDO_SHGIOI_SHARE (0x0FFFFFFF)</h4>
      <para>The overlay icon that indicates a shared folder.</para>
      <h4>IDO_SHGIOI_LINK (0x0FFFFFFE)</h4>
      <para>The overlay icon that indicates a linked folder or file.</para>
      <h4>IDO_SHGIOI_SLOWFILE (0x0FFFFFFD)</h4>
      <para>The overlay icon that indicates a slow file.</para>
      <h4>IDO_SHGIOI_DEFAULT (0x0FFFFFFC)</h4>
      <para>
        <b>Windows 7 and later</b>. The overlay icon that indicates that the item is the default in a set. One example is the default printer.</para>
      <h5>- iIconIndex.IDO_SHGIOI_DEFAULT (0x0FFFFFFC)</h5>
      <para>
        <b>Windows 7 and later</b>. The overlay icon that indicates that the item is the default in a set. One example is the default printer.</para>
      <h5>- iIconIndex.IDO_SHGIOI_LINK (0x0FFFFFFE)</h5>
      <para>The overlay icon that indicates a linked folder or file.</para>
      <h5>- iIconIndex.IDO_SHGIOI_SHARE (0x0FFFFFFF)</h5>
      <para>The overlay icon that indicates a shared folder.</para>
      <h5>- iIconIndex.IDO_SHGIOI_SLOWFILE (0x0FFFFFFD)</h5>
      <para>The overlay icon that indicates a slow file.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.</para>
    </returns>
    <remarks>
      <para>Icon overlays are part of the system image list. They have two identifiers. The first is a one-based overlay index that identifies the overlay relative to other overlays in the image list. The other is an image index that identifies the actual image. These two indexes are equivalent to the values that you assign to the <i>iOverlay</i> and <i>iImage</i> parameters, respectively, when you add an icon overlay to a private image list with <see cref="ImageList_SetOverlayImage" />. <b>SHGetIconOverlayIndex</b> returns the overlay index. To convert an overlay index to its equivalent image index, call <see cref="INDEXTOOVERLAYMASK" />.</para>
      <para>
        <b>Note</b>  After the image has been loaded into the system image list during initialization, it cannot be changed. The file name and index specified by <i>pszIconPath</i> and <i>iIconIndex</i> are used only to identify the icon overlay. <b>SHGetIconOverlayIndex</b> cannot be used to modify the system image list.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetIconOverlayIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IShellIconOverlay" />
    <seealso cref="IShellIconOverlayIdentifier" />
  </member>
  <member name="Windows.SHGetIconOverlayIndexW">
    <summary>
      <para>Returns the index of the overlay icon in the system image list.</para>
    </summary>
    <param name="pszIconPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the fully qualified path of the file that contains the icon.</para>
    </param>
    <param name="iIconIndex">
      <para>Type: <b>int</b></para>
      <para>The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:</para>
      <h4>IDO_SHGIOI_SHARE (0x0FFFFFFF)</h4>
      <para>The overlay icon that indicates a shared folder.</para>
      <h4>IDO_SHGIOI_LINK (0x0FFFFFFE)</h4>
      <para>The overlay icon that indicates a linked folder or file.</para>
      <h4>IDO_SHGIOI_SLOWFILE (0x0FFFFFFD)</h4>
      <para>The overlay icon that indicates a slow file.</para>
      <h4>IDO_SHGIOI_DEFAULT (0x0FFFFFFC)</h4>
      <para>
        <b>Windows 7 and later</b>. The overlay icon that indicates that the item is the default in a set. One example is the default printer.</para>
      <h5>- iIconIndex.IDO_SHGIOI_DEFAULT (0x0FFFFFFC)</h5>
      <para>
        <b>Windows 7 and later</b>. The overlay icon that indicates that the item is the default in a set. One example is the default printer.</para>
      <h5>- iIconIndex.IDO_SHGIOI_LINK (0x0FFFFFFE)</h5>
      <para>The overlay icon that indicates a linked folder or file.</para>
      <h5>- iIconIndex.IDO_SHGIOI_SHARE (0x0FFFFFFF)</h5>
      <para>The overlay icon that indicates a shared folder.</para>
      <h5>- iIconIndex.IDO_SHGIOI_SLOWFILE (0x0FFFFFFD)</h5>
      <para>The overlay icon that indicates a slow file.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.</para>
    </returns>
    <remarks>
      <para>Icon overlays are part of the system image list. They have two identifiers. The first is a one-based overlay index that identifies the overlay relative to other overlays in the image list. The other is an image index that identifies the actual image. These two indexes are equivalent to the values that you assign to the <i>iOverlay</i> and <i>iImage</i> parameters, respectively, when you add an icon overlay to a private image list with <see cref="ImageList_SetOverlayImage" />. <b>SHGetIconOverlayIndex</b> returns the overlay index. To convert an overlay index to its equivalent image index, call <see cref="INDEXTOOVERLAYMASK" />.</para>
      <para>
        <b>Note</b>  After the image has been loaded into the system image list during initialization, it cannot be changed. The file name and index specified by <i>pszIconPath</i> and <i>iIconIndex</i> are used only to identify the icon overlay. <b>SHGetIconOverlayIndex</b> cannot be used to modify the system image list.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetIconOverlayIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IShellIconOverlay" />
    <seealso cref="IShellIconOverlayIdentifier" />
  </member>
  <member name="Windows.SHGetInstanceExplorer">
    <summary>
      <para>Retrieves an interface that allows hosted Shell extensions and other components to prevent their host process from closing prematurely. The host process is typically Windows Explorer or Windows Internet Explorer, but this function can also be used by other applications.</para>
    </summary>
    <param name="ppunk">
      <para>Type: <b><see cref="IUnknown" />**</b></para>
      <para>When this function returns successfully, contains the address of the host process' <see cref="IUnknown" /> interface pointer. This is a free-threaded interface used to prevent the host process from terminating. If the function call fails, this value is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>There are a number of components, such as Shell extension handlers, that are implemented as DLLs and run in a host process such as Windows Explorer (Explorer.exe) or Internet Explorer (Iexplore.exe). Typically, when the user closes the host process, the component is shut down immediately as well. Such an abrupt termination can create problems for some components. For example, if a component is using a background thread to download data or run user-interface functions, it might need additional time to safely shut itself down.</para>
      <para>
        <b>SHGetInstanceExplorer</b> allows components that run in a host process to hold a reference on the host process. <b>SHGetInstanceExplorer</b> increments the host's reference count and returns a pointer to the host's <see cref="IUnknown" /> interface. By holding that reference, a component can prevent the host process from closing prematurely. After the component has completed its necessary processing, it should call <see cref="(*ppunk)-&gt;Release" /> to release the host's reference and allow the process to terminate.</para>
      <para>
        <b>Note</b>  If <b>SHGetInstanceExplorer</b> is successful, the component must release the host's reference when it is no longer needed. Otherwise, all resources associated with the process will remain in memory. The <see cref="IUnknown" /> interface pointed to by *<i>ppunk</i> can only be used to release this reference. Components cannot use <see cref="(*ppunk)-&gt;QueryInterface" /> to request other interface pointers.</para>
      <para>
        <b>SHGetInstanceExplorer</b> succeeds only if it is called from from an application which had previously called <see cref="SHSetInstanceExplorer" /> to set a process reference.</para>
    </remarks>
  </member>
  <member name="Windows.SHGetKnownFolderIDList">
    <summary>
      <para>Retrieves the path of a known folder as an <see cref="ITEMIDLIST" /> structure.</para>
    </summary>
    <param name="rfid">
      <para>Type: <b>REFKNOWNFOLDERID</b></para>
      <para>A reference to the <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that identifies the folder. The folders associated with the known folder IDs might not exist on a particular system.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify special retrieval options. This value can be 0; otherwise, it is one or more of the <see cref="KNOWN_FOLDER_FLAG" /> values.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
      <para>Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHGetKnownFolderIDList</b> to find folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.</para>
    </param>
    <param name="ppidl">
      <para>Type: <b>PIDLIST_ABSOLUTE*</b></para>
      <para>When this method returns, contains a pointer to the PIDL of the folder. This parameter is passed uninitialized. The caller is responsible for freeing the returned PIDL when it is no longer needed by calling <see cref="ILFree" />.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or an error value otherwise, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Among other things, this value can indicate that the <i>rfid</i> parameter references a <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on all systems. Use <see cref="IKnownFolderManager.GetFolderIds" /> to retrieve the set of <b>KNOWNFOLDERID</b> values for the current system.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function replaces <see cref="SHGetFolderLocation" />. That older function is now simply a wrapper for <b>SHGetKnownFolderIDList</b>.</para>
      <para>Callers using this function must have at least User privileges.</para>
      <para>Some known folders, for example, the <b>Documents</b> folder, are per-user. Each user has a different path for the <b>Documents</b> folder. If <i>hToken</i> is <b>NULL</b>, the API tries to access the current user's instance of the folder. If <i>hToken</i> is a valid user token, the API tries to impersonate the user using this token, and attempts to access that user's instance of the folder.</para>
    </remarks>
    <seealso cref="IKnownFolder.GetPath" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd940364(v=vs.85)">Known Folders Sample</seealso>
    <seealso cref="SHGetKnownFolderPath" />
    <seealso cref="SHSetKnownFolderPath" />
  </member>
  <member name="Windows.SHGetKnownFolderItem">
    <summary>
      <para>Retrieves an <see cref="IShellItem" /> object that represents a known folder.</para>
    </summary>
    <param name="rfid">
      <para>Type: <b>REFKNOWNFOLDERID</b></para>
      <para>A reference to the <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a>, a <b>GUID</b> that identifies the folder that contains the item.</para>
    </param>
    <param name="flags">
      <para>Type: <b><see cref="KNOWN_FOLDER_FLAG" /></b></para>
      <para>Flags that specify special options used in the retrieval of the known folder <see cref="IShellItem" />. This value can be <b>KF_FLAG_DEFAULT</b>; otherwise, one or more of the <see cref="KNOWN_FOLDER_FLAG" /> values.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling application is responsible for correct impersonation when <i>hToken</i> is non-<b>null</b>. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
      <para>Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <see cref="SHSetKnownFolderPath" /> to set folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>A reference to the IID of the interface that represents the item, usually IID_IShellItem or IID_IShellItem2.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>void**</b></para>
      <para>When this method returns, contains the interface pointer requested in <i>riid</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or an error value otherwise, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Among other things, this value can indicate that the <i>rfid</i> parameter references a <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on all systems. Use <see cref="IKnownFolderManager.GetFolderIds" /> to retrieve the set of <b>KNOWNFOLDERID</b> values for the current system.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The caller of this function must have Administrator privileges. To call this function on public known folders, the caller must have Administrator privileges. For per-user known folders the caller only requires User privileges.</para>
      <para>Some of the known folders, for example, the <b>Documents</b> folder, are per-user. Every user has a different path for their <b>Documents</b> folder. If <i>hToken</i> is <b>NULL</b>, the API tries to access the calling application's instance of the folder, which is that of the current user. If <i>hToken</i> is a valid user token, the API tries to impersonate the user using this token and tries to access that user's instance.</para>
      <para>This function cannot be called on folders of type <see cref="KF_CATEGORY_FIXED" /> and <see cref="KF_CATEGORY_VIRTUAL" />.</para>
      <para>To call this function on a folder of type <see cref="KF_CATEGORY_COMMON" />, the calling application must be running with elevated privileges.</para>
    </remarks>
    <seealso cref="IKnownFolder.GetPath" />
    <seealso cref="IKnownFolderManager.Redirect" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd940364(v=vs.85)">Known Folders Sample</seealso>
    <seealso cref="SHCreateItemInKnownFolder" />
    <seealso cref="SHGetKnownFolderIDList" />
    <seealso cref="SHGetKnownFolderPath" />
  </member>
  <member name="Windows.SHGetKnownFolderPath">
    <summary>
      <para>Retrieves the full path of a known folder identified by the folder's <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a>.</para>
    </summary>
    <param name="rfid">
      <para>Type: <b>REFKNOWNFOLDERID</b></para>
      <para>A reference to the <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that identifies the folder.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify special retrieval options. This value can be 0; otherwise, one or more of the <see cref="KNOWN_FOLDER_FLAG" /> values.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. If this parameter is <b>NULL</b>, which is the most common usage, the function requests the known folder for the current user.</para>
      <para>Request a specific user's folder by passing the <i>hToken</i> of that user. This is typically done in the context of a service that has sufficient privileges to retrieve the token of a given user. That token must be opened with <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">TOKEN_QUERY</a> and <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">TOKEN_IMPERSONATE</a> rights. In some cases, you also need to include <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">TOKEN_DUPLICATE</a>. In addition to passing the user's <i>hToken</i>, the registry hive of that specific user must be mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
      <para>Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHGetKnownFolderPath</b> to find folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.</para>
    </param>
    <param name="ppszPath">
      <para>Type: <b>PWSTR*</b></para>
      <para>When this method returns, contains the address of a pointer to a null-terminated Unicode string that specifies the path of the known folder. The calling process is responsible for freeing this resource once it is no longer needed by calling <see cref="CoTaskMemFree" />, whether <b>SHGetKnownFolderPath</b> succeeds or not. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\".</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or an error value otherwise, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>Among other things, this value can indicate that the <i>rfid</i> parameter references a <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> which does not have a path (such as a folder marked as <see cref="KF_CATEGORY_VIRTUAL" />).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Among other things, this value can indicate that the <i>rfid</i> parameter references a <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on all systems. Use <see cref="IKnownFolderManager.GetFolderIds" /> to retrieve the set of <b>KNOWNFOLDERID</b> values for the current system.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function replaces <see cref="SHGetFolderPath" />. That older function is now simply a wrapper for <b>SHGetKnownFolderPath</b>.</para>
    </remarks>
    <seealso cref="IKnownFolder.GetPath" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd940364(v=vs.85)">Known Folders Sample</seealso>
    <seealso cref="SHGetKnownFolderIDList" />
    <seealso cref="SHSetKnownFolderPath" />
  </member>
  <member name="Windows.SHGetPathFromIDList">
    <summary>
      <para>Converts an item identifier list to a file system path.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>The address of an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer to receive the file system path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>If the location specified by the <i>pidl</i> parameter is not part of the file system, this function will fail.</para>
      <para>If the <i>pidl</i> parameter specifies a shortcut, the <i>pszPath</i> will contain the path to the shortcut, not to the shortcut's target.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetPathFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetPathFromIDListEx" />
    <seealso cref="SHParseDisplayName" />
  </member>
  <member name="Windows.SHGetPathFromIDListA">
    <summary>
      <para>Converts an item identifier list to a file system path.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>The address of an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer to receive the file system path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>If the location specified by the <i>pidl</i> parameter is not part of the file system, this function will fail.</para>
      <para>If the <i>pidl</i> parameter specifies a shortcut, the <i>pszPath</i> will contain the path to the shortcut, not to the shortcut's target.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetPathFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetPathFromIDListEx" />
    <seealso cref="SHParseDisplayName" />
  </member>
  <member name="Windows.SHGetPathFromIDListW">
    <summary>
      <para>Converts an item identifier list to a file system path.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>The address of an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer to receive the file system path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>If the location specified by the <i>pidl</i> parameter is not part of the file system, this function will fail.</para>
      <para>If the <i>pidl</i> parameter specifies a shortcut, the <i>pszPath</i> will contain the path to the shortcut, not to the shortcut's target.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetPathFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetPathFromIDListEx" />
    <seealso cref="SHParseDisplayName" />
  </member>
  <member name="Windows.SHGetPathFromIDListEx">
    <summary>
      <para>Converts an item identifier list to a file system path. This function extends <see cref="SHGetPathFromIDList" /> by allowing you to set the initial size of the string buffer and declare the options below.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>A pointer to an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>PWSTR</b></para>
      <para>When this function is called it is passed a null-terminated, Unicode buffer to receive the file system path. This buffer is of size <i>cchPath</i>.</para>
      <para>When this function returns, contains the address of a null-terminated, Unicode buffer that contains the file system path. This buffer is of size <i>cchPath</i>.</para>
    </param>
    <param name="cchPath">
      <para>Type: <b>DWORD</b></para>
      <para>The size of the buffer pointed to by <i>pszPath</i>, in characters.</para>
    </param>
    <param name="uOpts">
      <para>Type: <b>GPFIDL_FLAGS</b></para>
      <para>These flags determine the type of path returned.</para>
      <h4>GPFIDL_DEFAULT (0x0000)</h4>
      <para>Win32 file names, servers, and root drives are included.</para>
      <h4>GPFIDL_ALTNAME (0x0001)</h4>
      <para>Uses short file names.</para>
      <h4>GPFIDL_UNCPRINTER (0x0002)</h4>
      <para>Include UNC printer names items.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Except for UNC printer names, if the location specified by the <i>pidl</i> parameter is not part of the file system, this function fails.</para>
      <para>If the <i>pidl</i> parameter specifies a shortcut, the <i>pszPath</i> contains the path to the shortcut, not to the shortcut's target.</para>
    </remarks>
    <seealso cref="SHParseDisplayName" />
  </member>
  <member name="Windows.SHGetPathFromIDList">
    <summary>
      <para>Converts an item identifier list to a file system path.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>The address of an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer to receive the file system path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>If the location specified by the <i>pidl</i> parameter is not part of the file system, this function will fail.</para>
      <para>If the <i>pidl</i> parameter specifies a shortcut, the <i>pszPath</i> will contain the path to the shortcut, not to the shortcut's target.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetPathFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetPathFromIDListEx" />
    <seealso cref="SHParseDisplayName" />
  </member>
  <member name="Windows.SHGetPathFromIDListA">
    <summary>
      <para>Converts an item identifier list to a file system path.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>The address of an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer to receive the file system path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>If the location specified by the <i>pidl</i> parameter is not part of the file system, this function will fail.</para>
      <para>If the <i>pidl</i> parameter specifies a shortcut, the <i>pszPath</i> will contain the path to the shortcut, not to the shortcut's target.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetPathFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetPathFromIDListEx" />
    <seealso cref="SHParseDisplayName" />
  </member>
  <member name="Windows.SHGetPathFromIDListW">
    <summary>
      <para>Converts an item identifier list to a file system path.</para>
    </summary>
    <param name="pidl">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>The address of an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer to receive the file system path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>If the location specified by the <i>pidl</i> parameter is not part of the file system, this function will fail.</para>
      <para>If the <i>pidl</i> parameter specifies a shortcut, the <i>pszPath</i> will contain the path to the shortcut, not to the shortcut's target.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHGetPathFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHGetPathFromIDListEx" />
    <seealso cref="SHParseDisplayName" />
  </member>
  <member name="Windows.SHGetSettings">
    <summary>
      <para>Retrieves the current Shell option settings.</para>
    </summary>
    <param name="psfs">
      <para>Type: <b>LPSHELLFLAGSTATE</b></para>
      <para>The address of a <see cref="SHELLFLAGSTATE" /> structure that receives the Shell option settings.</para>
    </param>
    <param name="dwMask">
      <para>Type: <b>DWORD</b></para>
      <para>A set of flags that determine which members of <i>lpsfs</i> are being requested. This can be one or more of the following values.</para>
      <h4>SSF_DESKTOPHTML</h4>
      <para>The <b>fDesktopHTML</b> member is being requested.</para>
      <h4>SSF_DONTPRETTYPATH</h4>
      <para>The <b>fDontPrettyPath</b> member is being requested.</para>
      <h4>SSF_DOUBLECLICKINWEBVIEW</h4>
      <para>The <b>fDoubleClickInWebView</b> member is being requested.</para>
      <h4>SSF_HIDEICONS</h4>
      <para>The <b>fHideIcons</b> member is being requested.</para>
      <h4>SSF_MAPNETDRVBUTTON</h4>
      <para>The
<b>fMapNetDrvBtn</b> member is being requested.</para>
      <h4>SSF_NOCONFIRMRECYCLE</h4>
      <para>The
<b>fNoConfirmRecycle</b> member is being requested.</para>
      <h4>SSF_SHOWALLOBJECTS</h4>
      <para>The
<b>fShowAllObjects</b> member is being requested.</para>
      <h4>SSF_SHOWATTRIBCOL</h4>
      <para>The
<b>fShowAttribCol</b> member is being requested.</para>
      <para>
        <b>Windows Vista:</b> Not used.</para>
      <h4>SSF_SHOWCOMPCOLOR</h4>
      <para>The
<b>fShowCompColor</b> member is being requested.</para>
      <h4>SSF_SHOWEXTENSIONS</h4>
      <para>The
<b>fShowExtensions</b> member is being requested.</para>
      <h4>SSF_SHOWINFOTIP</h4>
      <para>The
<b>fShowInfoTip</b> member is being requested.</para>
      <h4>SSF_SHOWSYSFILES</h4>
      <para>The
<b>fShowSysFiles</b> member is being requested.</para>
      <h4>SSF_WIN95CLASSIC</h4>
      <para>The
<b>fWin95Classic</b> member is being requested.</para>
    </param>
    <seealso cref="SHGetSetSettings" />
  </member>
  <member name="Windows.SHLoadInProc">
    <summary>
      <para>Creates an instance of the specified object class from within the context of the Shell's process.</para>
      <para>
        <b>Windows Vista</b> and later: This function has been disabled and returns E_NOTIMPL.</para>
    </summary>
    <param name="rclsid">
      <para>Type: <b>REFCLSID</b></para>
      <para>The CLSID of the object class to be created.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or an error value otherwise. In Windows Vista and later versions, always returns E_NOTIMPL.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003. It is not available in later versions of Windows, including Windows Vista.</para>
      <para>This function creates the requested object instance by calling the <see cref="CoCreateInstance" /> function and immediately releasing the returned object. The associated DLL is unloaded according to standard Component Object Model (COM) rules when it returns S_OK from its <see cref="DllCanUnloadNow" /> function.</para>
    </remarks>
  </member>
  <member name="Windows.SHOpenFolderAndSelectItems">
    <summary>
      <para>Opens a Windows Explorer window with specified items in a particular folder selected.</para>
    </summary>
    <param name="pidlFolder">
      <para>Type: <b>PCIDLIST_ABSOLUTE</b></para>
      <para>A pointer to a fully qualified item ID list that specifies the folder.</para>
    </param>
    <param name="cidl">
      <para>Type: <b>UINT</b></para>
      <para>A count of items in the selection array, <i>apidl</i>. If <i>cidl</i> is zero, then <i>pidlFolder</i> must point to a fully specified <see cref="ITEMIDLIST" /> describing a single item to select. This function opens the parent folder and selects that item.</para>
    </param>
    <param name="apidl">
      <para>Type: <b>PCUITEMID_CHILD_ARRAY</b></para>
      <para>A pointer to an array of PIDL structures, each of which is an item to select in the target folder referenced by <i>pidlFolder</i>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The optional flags. Under Windows XP this parameter is ignored. In Windows Vista, the following flags are defined.</para>
      <h4>OFASI_EDIT (0x0001)</h4>
      <para>Select an item and put its name in edit mode. This flag can only be used when a single item is being selected. For multiple item selections, it is ignored.</para>
      <h4>OFASI_OPENDESKTOP (0x0002)</h4>
      <para>Select the item or items on the desktop rather than in a Windows Explorer window. Note that if the desktop is obscured behind open windows, it will not be made visible.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>
        <see cref="CoInitialize" /> or <see cref="CoInitializeEx" /> must be called before using <b>SHOpenFolderAndSelectItems</b>. Not doing so causes <b>SHOpenFolderAndSelectItems</b> to fail.</para>
    </remarks>
  </member>
  <member name="Windows.SHOpenWithDialog">
    <summary>
      <para>Displays the <b>Open With</b> dialog box.</para>
    </summary>
    <param name="hwndParent">
      <para>Type: <b>HWND</b></para>
      <para>The handle of the parent window. This value can be <b>NULL</b>.</para>
    </param>
    <param name="poainfo">
      <para>Type: <b>const <see cref="OPENASINFO" />*</b></para>
      <para>A pointer to an <see cref="OPENASINFO" /> structure, which specifies the contents of the resulting dialog.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>Starting in Windows 10, the <b>OAIF_ALLOW_REGISTRATION</b>, <b>OAIF_FORCE_REGISTRATION</b>, and <b>OAIF_HIDE_REGISTRATION</b> flags will be ignored by <b>SHOpenWithDialog</b>. The <b>Open With</b> dialog box can no longer be used to change the default program used to open a file extension. You can only use <b>SHOpenWithDialog</b> to open a single file.</para>
      <para>If <b>SHOpenWithDialog</b> is called without passing <b>OAIF_EXEC</b>, the user will receive a dialog that informs them that they can change the default programs used to open file extensions in their <b>Settings</b>.</para>
    </remarks>
  </member>
  <member name="Windows.SHParseDisplayName">
    <summary>
      <para>Translates a Shell namespace object's display name into an item identifier list and returns the attributes of the object. This function is the preferred method to convert a string to a pointer to an item identifier list (PIDL).</para>
    </summary>
    <param name="pszName">
      <para>Type: <b>LPCWSTR</b></para>
      <para>A pointer to a zero-terminated wide string that contains the display name to parse.</para>
    </param>
    <param name="pbc">
      <para>Type: <b><see cref="IBindCtx" />*</b></para>
      <para>A bind context that controls the parsing operation. This parameter is normally set to <b>NULL</b>.</para>
    </param>
    <param name="ppidl">
      <para>Type: <b>PIDLIST_ABSOLUTE*</b></para>
      <para>The address of a pointer to a variable of type <see cref="ITEMIDLIST" /> that receives the item identifier list for the object. If an error occurs, then this parameter is set to <b>NULL</b>.</para>
    </param>
    <param name="sfgaoIn">
      <para>Type: <b>SFGAOF</b></para>
      <para>A <b>ULONG</b> value that specifies the attributes to query. To query for one or more attributes, initialize this parameter with the flags that represent the attributes of interest. For a list of available SFGAO flags, see <see cref="IShellFolder.GetAttributesOf" />.</para>
    </param>
    <param name="psfgaoOut">
      <para>Type: <b>SFGAOF*</b></para>
      <para>A pointer to a <b>ULONG</b>. On return, those attributes that are true for the object and were requested in <i>sfgaoIn</i> are set. An object's attribute flags can be zero or a combination of SFGAO flags. For a list of available SFGAO flags, see <see cref="IShellFolder.GetAttributesOf" />.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>You should call this function from a background thread. Failure to do so could cause the UI to stop responding.</para>
    </remarks>
    <seealso cref="IBindCtx" />
    <seealso cref="IShellFolder.GetAttributesOf" />
    <seealso cref="IShellFolder.ParseDisplayName" />
    <seealso cref="ITEMIDLIST" />
    <seealso cref="SHGetPathFromIDList" />
  </member>
  <member name="Windows.SHPathPrepareForWrite">
    <summary>
      <para>Checks to see if the path exists. This includes remounting mapped network drives, prompting for ejectable media to be reinserted, creating the paths, prompting for the media to be formatted, and providing the appropriate user interfaces, if necessary. Read/write permissions for the medium are not checked.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to a window that specifies the parent window to be used for any user interface windows that must be created. If set to <b>NULL</b>, user interface windows are not created.</para>
    </param>
    <param name="punkEnableModless">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to an <see cref="IUnknown" /> interface that specifies the <see cref="IOleInPlaceActiveObject" /> object that implements the <see cref="EnableModeless" /> method.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to be verified as valid for writing. This can be a UNC or file drive path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that determine behavior options. This parameter can be a combination of the following values.</para>
      <h4>SHPPFW_NONE</h4>
      <para>Do not create new directories.</para>
      <h4>SHPPFW_DEFAULT</h4>
      <para>Default. Do not prompt the user if a directory needs to be created. This is identical to <b>SHPPFW_DIRCREATE</b>. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_DIRCREATE</h4>
      <para>Create directories without prompting the user. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_ASKDIRCREATE</h4>
      <para>Prompt the user before creating directories. Do not pass with <b>SHPPFW_DIRCREATE</b>.</para>
      <h4>SHPPFW_IGNOREFILENAME</h4>
      <para>Last item in <i>pszPath</i> is a file name, so ignore. For example, if <i>pszPath</i>="C:\MyDir\MyFile.doc", only use "C:\MyDir". If <i>pszPath</i>="C:\MyFirDir\MySecDir", only use "C:\MyFirDir".</para>
      <h4>SHPPFW_NOWRITECHECK</h4>
      <para>Not currently implemented.</para>
      <h4>SHPPFW_MEDIACHECKONLY</h4>
      <para>
        <b>Windows XP or later.</b> Suppresses the "not accessible" error message box, which displays when a failure other than a user cancellation occurs, and <i>hwnd</i> is not <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if the path is available, or an error code otherwise. Note that a return value of S_OK does not mean that the medium is writable; it simply means that the path is available.</para>
    </returns>
    <remarks>
      <para>The primary use of this function is for a program to check a path before using it and display the necessary user interface to prompt the user. For example, if the disk in drive A: were missing, a window that prompts the user to insert the disk would appear.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHPathPrepareForWrite as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHPathPrepareForWriteA">
    <summary>
      <para>Checks to see if the path exists. This includes remounting mapped network drives, prompting for ejectable media to be reinserted, creating the paths, prompting for the media to be formatted, and providing the appropriate user interfaces, if necessary. Read/write permissions for the medium are not checked.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to a window that specifies the parent window to be used for any user interface windows that must be created. If set to <b>NULL</b>, user interface windows are not created.</para>
    </param>
    <param name="punkEnableModless">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to an <see cref="IUnknown" /> interface that specifies the <see cref="IOleInPlaceActiveObject" /> object that implements the <see cref="EnableModeless" /> method.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to be verified as valid for writing. This can be a UNC or file drive path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that determine behavior options. This parameter can be a combination of the following values.</para>
      <h4>SHPPFW_NONE</h4>
      <para>Do not create new directories.</para>
      <h4>SHPPFW_DEFAULT</h4>
      <para>Default. Do not prompt the user if a directory needs to be created. This is identical to <b>SHPPFW_DIRCREATE</b>. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_DIRCREATE</h4>
      <para>Create directories without prompting the user. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_ASKDIRCREATE</h4>
      <para>Prompt the user before creating directories. Do not pass with <b>SHPPFW_DIRCREATE</b>.</para>
      <h4>SHPPFW_IGNOREFILENAME</h4>
      <para>Last item in <i>pszPath</i> is a file name, so ignore. For example, if <i>pszPath</i>="C:\MyDir\MyFile.doc", only use "C:\MyDir". If <i>pszPath</i>="C:\MyFirDir\MySecDir", only use "C:\MyFirDir".</para>
      <h4>SHPPFW_NOWRITECHECK</h4>
      <para>Not currently implemented.</para>
      <h4>SHPPFW_MEDIACHECKONLY</h4>
      <para>
        <b>Windows XP or later.</b> Suppresses the "not accessible" error message box, which displays when a failure other than a user cancellation occurs, and <i>hwnd</i> is not <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if the path is available, or an error code otherwise. Note that a return value of S_OK does not mean that the medium is writable; it simply means that the path is available.</para>
    </returns>
    <remarks>
      <para>The primary use of this function is for a program to check a path before using it and display the necessary user interface to prompt the user. For example, if the disk in drive A: were missing, a window that prompts the user to insert the disk would appear.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHPathPrepareForWrite as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHPathPrepareForWriteW">
    <summary>
      <para>Checks to see if the path exists. This includes remounting mapped network drives, prompting for ejectable media to be reinserted, creating the paths, prompting for the media to be formatted, and providing the appropriate user interfaces, if necessary. Read/write permissions for the medium are not checked.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to a window that specifies the parent window to be used for any user interface windows that must be created. If set to <b>NULL</b>, user interface windows are not created.</para>
    </param>
    <param name="punkEnableModless">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to an <see cref="IUnknown" /> interface that specifies the <see cref="IOleInPlaceActiveObject" /> object that implements the <see cref="EnableModeless" /> method.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to be verified as valid for writing. This can be a UNC or file drive path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that determine behavior options. This parameter can be a combination of the following values.</para>
      <h4>SHPPFW_NONE</h4>
      <para>Do not create new directories.</para>
      <h4>SHPPFW_DEFAULT</h4>
      <para>Default. Do not prompt the user if a directory needs to be created. This is identical to <b>SHPPFW_DIRCREATE</b>. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_DIRCREATE</h4>
      <para>Create directories without prompting the user. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_ASKDIRCREATE</h4>
      <para>Prompt the user before creating directories. Do not pass with <b>SHPPFW_DIRCREATE</b>.</para>
      <h4>SHPPFW_IGNOREFILENAME</h4>
      <para>Last item in <i>pszPath</i> is a file name, so ignore. For example, if <i>pszPath</i>="C:\MyDir\MyFile.doc", only use "C:\MyDir". If <i>pszPath</i>="C:\MyFirDir\MySecDir", only use "C:\MyFirDir".</para>
      <h4>SHPPFW_NOWRITECHECK</h4>
      <para>Not currently implemented.</para>
      <h4>SHPPFW_MEDIACHECKONLY</h4>
      <para>
        <b>Windows XP or later.</b> Suppresses the "not accessible" error message box, which displays when a failure other than a user cancellation occurs, and <i>hwnd</i> is not <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if the path is available, or an error code otherwise. Note that a return value of S_OK does not mean that the medium is writable; it simply means that the path is available.</para>
    </returns>
    <remarks>
      <para>The primary use of this function is for a program to check a path before using it and display the necessary user interface to prompt the user. For example, if the disk in drive A: were missing, a window that prompts the user to insert the disk would appear.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHPathPrepareForWrite as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHPathPrepareForWrite">
    <summary>
      <para>Checks to see if the path exists. This includes remounting mapped network drives, prompting for ejectable media to be reinserted, creating the paths, prompting for the media to be formatted, and providing the appropriate user interfaces, if necessary. Read/write permissions for the medium are not checked.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to a window that specifies the parent window to be used for any user interface windows that must be created. If set to <b>NULL</b>, user interface windows are not created.</para>
    </param>
    <param name="punkEnableModless">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to an <see cref="IUnknown" /> interface that specifies the <see cref="IOleInPlaceActiveObject" /> object that implements the <see cref="EnableModeless" /> method.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to be verified as valid for writing. This can be a UNC or file drive path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that determine behavior options. This parameter can be a combination of the following values.</para>
      <h4>SHPPFW_NONE</h4>
      <para>Do not create new directories.</para>
      <h4>SHPPFW_DEFAULT</h4>
      <para>Default. Do not prompt the user if a directory needs to be created. This is identical to <b>SHPPFW_DIRCREATE</b>. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_DIRCREATE</h4>
      <para>Create directories without prompting the user. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_ASKDIRCREATE</h4>
      <para>Prompt the user before creating directories. Do not pass with <b>SHPPFW_DIRCREATE</b>.</para>
      <h4>SHPPFW_IGNOREFILENAME</h4>
      <para>Last item in <i>pszPath</i> is a file name, so ignore. For example, if <i>pszPath</i>="C:\MyDir\MyFile.doc", only use "C:\MyDir". If <i>pszPath</i>="C:\MyFirDir\MySecDir", only use "C:\MyFirDir".</para>
      <h4>SHPPFW_NOWRITECHECK</h4>
      <para>Not currently implemented.</para>
      <h4>SHPPFW_MEDIACHECKONLY</h4>
      <para>
        <b>Windows XP or later.</b> Suppresses the "not accessible" error message box, which displays when a failure other than a user cancellation occurs, and <i>hwnd</i> is not <b>NULL</b>.</para>
      <h5>- dwFlags.SHPPFW_ASKDIRCREATE</h5>
      <para>Prompt the user before creating directories. Do not pass with <b>SHPPFW_DIRCREATE</b>.</para>
      <h5>- dwFlags.SHPPFW_DEFAULT</h5>
      <para>Default. Do not prompt the user if a directory needs to be created. This is identical to <b>SHPPFW_DIRCREATE</b>. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h5>- dwFlags.SHPPFW_DIRCREATE</h5>
      <para>Create directories without prompting the user. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h5>- dwFlags.SHPPFW_IGNOREFILENAME</h5>
      <para>Last item in <i>pszPath</i> is a file name, so ignore. For example, if <i>pszPath</i>="C:\MyDir\MyFile.doc", only use "C:\MyDir". If <i>pszPath</i>="C:\MyFirDir\MySecDir", only use "C:\MyFirDir".</para>
      <h5>- dwFlags.SHPPFW_MEDIACHECKONLY</h5>
      <para>
        <b>Windows XP or later.</b> Suppresses the "not accessible" error message box, which displays when a failure other than a user cancellation occurs, and <i>hwnd</i> is not <b>NULL</b>.</para>
      <h5>- dwFlags.SHPPFW_NONE</h5>
      <para>Do not create new directories.</para>
      <h5>- dwFlags.SHPPFW_NOWRITECHECK</h5>
      <para>Not currently implemented.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if the path is available, or an error code otherwise. Note that a return value of S_OK does not mean that the medium is writable; it simply means that the path is available.</para>
    </returns>
    <remarks>
      <para>The primary use of this function is for a program to check a path before using it and display the necessary user interface to prompt the user. For example, if the disk in drive A: were missing, a window that prompts the user to insert the disk would appear.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHPathPrepareForWrite as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHPathPrepareForWriteA">
    <summary>
      <para>Checks to see if the path exists. This includes remounting mapped network drives, prompting for ejectable media to be reinserted, creating the paths, prompting for the media to be formatted, and providing the appropriate user interfaces, if necessary. Read/write permissions for the medium are not checked.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to a window that specifies the parent window to be used for any user interface windows that must be created. If set to <b>NULL</b>, user interface windows are not created.</para>
    </param>
    <param name="punkEnableModless">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to an <see cref="IUnknown" /> interface that specifies the <see cref="IOleInPlaceActiveObject" /> object that implements the <see cref="EnableModeless" /> method.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to be verified as valid for writing. This can be a UNC or file drive path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that determine behavior options. This parameter can be a combination of the following values.</para>
      <h4>SHPPFW_NONE</h4>
      <para>Do not create new directories.</para>
      <h4>SHPPFW_DEFAULT</h4>
      <para>Default. Do not prompt the user if a directory needs to be created. This is identical to <b>SHPPFW_DIRCREATE</b>. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_DIRCREATE</h4>
      <para>Create directories without prompting the user. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_ASKDIRCREATE</h4>
      <para>Prompt the user before creating directories. Do not pass with <b>SHPPFW_DIRCREATE</b>.</para>
      <h4>SHPPFW_IGNOREFILENAME</h4>
      <para>Last item in <i>pszPath</i> is a file name, so ignore. For example, if <i>pszPath</i>="C:\MyDir\MyFile.doc", only use "C:\MyDir". If <i>pszPath</i>="C:\MyFirDir\MySecDir", only use "C:\MyFirDir".</para>
      <h4>SHPPFW_NOWRITECHECK</h4>
      <para>Not currently implemented.</para>
      <h4>SHPPFW_MEDIACHECKONLY</h4>
      <para>
        <b>Windows XP or later.</b> Suppresses the "not accessible" error message box, which displays when a failure other than a user cancellation occurs, and <i>hwnd</i> is not <b>NULL</b>.</para>
      <h5>- dwFlags.SHPPFW_ASKDIRCREATE</h5>
      <para>Prompt the user before creating directories. Do not pass with <b>SHPPFW_DIRCREATE</b>.</para>
      <h5>- dwFlags.SHPPFW_DEFAULT</h5>
      <para>Default. Do not prompt the user if a directory needs to be created. This is identical to <b>SHPPFW_DIRCREATE</b>. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h5>- dwFlags.SHPPFW_DIRCREATE</h5>
      <para>Create directories without prompting the user. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h5>- dwFlags.SHPPFW_IGNOREFILENAME</h5>
      <para>Last item in <i>pszPath</i> is a file name, so ignore. For example, if <i>pszPath</i>="C:\MyDir\MyFile.doc", only use "C:\MyDir". If <i>pszPath</i>="C:\MyFirDir\MySecDir", only use "C:\MyFirDir".</para>
      <h5>- dwFlags.SHPPFW_MEDIACHECKONLY</h5>
      <para>
        <b>Windows XP or later.</b> Suppresses the "not accessible" error message box, which displays when a failure other than a user cancellation occurs, and <i>hwnd</i> is not <b>NULL</b>.</para>
      <h5>- dwFlags.SHPPFW_NONE</h5>
      <para>Do not create new directories.</para>
      <h5>- dwFlags.SHPPFW_NOWRITECHECK</h5>
      <para>Not currently implemented.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if the path is available, or an error code otherwise. Note that a return value of S_OK does not mean that the medium is writable; it simply means that the path is available.</para>
    </returns>
    <remarks>
      <para>The primary use of this function is for a program to check a path before using it and display the necessary user interface to prompt the user. For example, if the disk in drive A: were missing, a window that prompts the user to insert the disk would appear.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHPathPrepareForWrite as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHPathPrepareForWriteW">
    <summary>
      <para>Checks to see if the path exists. This includes remounting mapped network drives, prompting for ejectable media to be reinserted, creating the paths, prompting for the media to be formatted, and providing the appropriate user interfaces, if necessary. Read/write permissions for the medium are not checked.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to a window that specifies the parent window to be used for any user interface windows that must be created. If set to <b>NULL</b>, user interface windows are not created.</para>
    </param>
    <param name="punkEnableModless">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to an <see cref="IUnknown" /> interface that specifies the <see cref="IOleInPlaceActiveObject" /> object that implements the <see cref="EnableModeless" /> method.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to be verified as valid for writing. This can be a UNC or file drive path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that determine behavior options. This parameter can be a combination of the following values.</para>
      <h4>SHPPFW_NONE</h4>
      <para>Do not create new directories.</para>
      <h4>SHPPFW_DEFAULT</h4>
      <para>Default. Do not prompt the user if a directory needs to be created. This is identical to <b>SHPPFW_DIRCREATE</b>. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_DIRCREATE</h4>
      <para>Create directories without prompting the user. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h4>SHPPFW_ASKDIRCREATE</h4>
      <para>Prompt the user before creating directories. Do not pass with <b>SHPPFW_DIRCREATE</b>.</para>
      <h4>SHPPFW_IGNOREFILENAME</h4>
      <para>Last item in <i>pszPath</i> is a file name, so ignore. For example, if <i>pszPath</i>="C:\MyDir\MyFile.doc", only use "C:\MyDir". If <i>pszPath</i>="C:\MyFirDir\MySecDir", only use "C:\MyFirDir".</para>
      <h4>SHPPFW_NOWRITECHECK</h4>
      <para>Not currently implemented.</para>
      <h4>SHPPFW_MEDIACHECKONLY</h4>
      <para>
        <b>Windows XP or later.</b> Suppresses the "not accessible" error message box, which displays when a failure other than a user cancellation occurs, and <i>hwnd</i> is not <b>NULL</b>.</para>
      <h5>- dwFlags.SHPPFW_ASKDIRCREATE</h5>
      <para>Prompt the user before creating directories. Do not pass with <b>SHPPFW_DIRCREATE</b>.</para>
      <h5>- dwFlags.SHPPFW_DEFAULT</h5>
      <para>Default. Do not prompt the user if a directory needs to be created. This is identical to <b>SHPPFW_DIRCREATE</b>. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h5>- dwFlags.SHPPFW_DIRCREATE</h5>
      <para>Create directories without prompting the user. Do not pass with <b>SHPPFW_ASKDIRCREATE</b>.</para>
      <h5>- dwFlags.SHPPFW_IGNOREFILENAME</h5>
      <para>Last item in <i>pszPath</i> is a file name, so ignore. For example, if <i>pszPath</i>="C:\MyDir\MyFile.doc", only use "C:\MyDir". If <i>pszPath</i>="C:\MyFirDir\MySecDir", only use "C:\MyFirDir".</para>
      <h5>- dwFlags.SHPPFW_MEDIACHECKONLY</h5>
      <para>
        <b>Windows XP or later.</b> Suppresses the "not accessible" error message box, which displays when a failure other than a user cancellation occurs, and <i>hwnd</i> is not <b>NULL</b>.</para>
      <h5>- dwFlags.SHPPFW_NONE</h5>
      <para>Do not create new directories.</para>
      <h5>- dwFlags.SHPPFW_NOWRITECHECK</h5>
      <para>Not currently implemented.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if the path is available, or an error code otherwise. Note that a return value of S_OK does not mean that the medium is writable; it simply means that the path is available.</para>
    </returns>
    <remarks>
      <para>The primary use of this function is for a program to check a path before using it and display the necessary user interface to prompt the user. For example, if the disk in drive A: were missing, a window that prompts the user to insert the disk would appear.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHPathPrepareForWrite as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHSetFolderPath">
    <summary>
      <para>Deprecated. Assigns a new path to a system folder identified by its CSIDL.</para>
    </summary>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be set. Only physical folders are valid. If a virtual folder is specified, this function fails.</para>
      <para>Add the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> value to the CSIDL to ensure that the string is written to the registry exactly as provided. If the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> flag is not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be set to 0.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the folder's new path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard <b>HRESULT</b> codes, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The folder's path was successfully updated.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Several error conditions cause the return of this value, including the following:</para>
            <list type="bullet">
              <item>
                <description>The <i>csidl</i> value is not valid.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a virtual folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a system folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value refers to a folder that cannot be renamed or moved.</description>
              </item>
              <item>
                <description>The <i>dwFlags</i> value is not 0 (zero).</description>
              </item>
              <item>
                <description>The <i>pszPath</i> value is <b>NULL</b>.</description>
              </item>
              <item>
                <description>The string pointed to by <i>pszPath</i> value is an empty string ("") of length zero.</description>
              </item>
            </list>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHSetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and <b>SHSetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
      <para>
        <b>SHSetFolderPath</b> is not exported by name from Shell32.dll. To use the function, you must call <see cref="GetProcAddress" /> with ordinal 231 for <b>SHSetFolderPathA</b> (for ANSI strings) or ordinal 232 for <b>SHSetFolderPathW</b> (for Unicode strings) to obtain a function pointer.</para>
      <para>It is recommended that the paths be expressed as Unicode strings because folder names might contain Unicode characters not expressible in ANSI.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHSetFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IKnownFolder.SetPath" />
  </member>
  <member name="Windows.SHSetFolderPathA">
    <summary>
      <para>Deprecated. Assigns a new path to a system folder identified by its CSIDL.</para>
    </summary>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be set. Only physical folders are valid. If a virtual folder is specified, this function fails.</para>
      <para>Add the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> value to the CSIDL to ensure that the string is written to the registry exactly as provided. If the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> flag is not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be set to 0.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the folder's new path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard <b>HRESULT</b> codes, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The folder's path was successfully updated.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Several error conditions cause the return of this value, including the following:</para>
            <list type="bullet">
              <item>
                <description>The <i>csidl</i> value is not valid.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a virtual folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a system folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value refers to a folder that cannot be renamed or moved.</description>
              </item>
              <item>
                <description>The <i>dwFlags</i> value is not 0 (zero).</description>
              </item>
              <item>
                <description>The <i>pszPath</i> value is <b>NULL</b>.</description>
              </item>
              <item>
                <description>The string pointed to by <i>pszPath</i> value is an empty string ("") of length zero.</description>
              </item>
            </list>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHSetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and <b>SHSetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
      <para>
        <b>SHSetFolderPath</b> is not exported by name from Shell32.dll. To use the function, you must call <see cref="GetProcAddress" /> with ordinal 231 for <b>SHSetFolderPathA</b> (for ANSI strings) or ordinal 232 for <b>SHSetFolderPathW</b> (for Unicode strings) to obtain a function pointer.</para>
      <para>It is recommended that the paths be expressed as Unicode strings because folder names might contain Unicode characters not expressible in ANSI.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHSetFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IKnownFolder.SetPath" />
  </member>
  <member name="Windows.SHSetFolderPathW">
    <summary>
      <para>Deprecated. Assigns a new path to a system folder identified by its CSIDL.</para>
    </summary>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be set. Only physical folders are valid. If a virtual folder is specified, this function fails.</para>
      <para>Add the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> value to the CSIDL to ensure that the string is written to the registry exactly as provided. If the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> flag is not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be set to 0.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the folder's new path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard <b>HRESULT</b> codes, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The folder's path was successfully updated.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Several error conditions cause the return of this value, including the following:</para>
            <list type="bullet">
              <item>
                <description>The <i>csidl</i> value is not valid.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a virtual folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a system folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value refers to a folder that cannot be renamed or moved.</description>
              </item>
              <item>
                <description>The <i>dwFlags</i> value is not 0 (zero).</description>
              </item>
              <item>
                <description>The <i>pszPath</i> value is <b>NULL</b>.</description>
              </item>
              <item>
                <description>The string pointed to by <i>pszPath</i> value is an empty string ("") of length zero.</description>
              </item>
            </list>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHSetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and <b>SHSetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
      <para>
        <b>SHSetFolderPath</b> is not exported by name from Shell32.dll. To use the function, you must call <see cref="GetProcAddress" /> with ordinal 231 for <b>SHSetFolderPathA</b> (for ANSI strings) or ordinal 232 for <b>SHSetFolderPathW</b> (for Unicode strings) to obtain a function pointer.</para>
      <para>It is recommended that the paths be expressed as Unicode strings because folder names might contain Unicode characters not expressible in ANSI.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHSetFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IKnownFolder.SetPath" />
  </member>
  <member name="Windows.SHSetFolderPath">
    <summary>
      <para>Deprecated. Assigns a new path to a system folder identified by its CSIDL.</para>
    </summary>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be set. Only physical folders are valid. If a virtual folder is specified, this function fails.</para>
      <para>Add the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> value to the CSIDL to ensure that the string is written to the registry exactly as provided. If the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> flag is not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be set to 0.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the folder's new path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard <b>HRESULT</b> codes, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The folder's path was successfully updated.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Several error conditions cause the return of this value, including the following:</para>
            <list type="bullet">
              <item>
                <description>The <i>csidl</i> value is not valid.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a virtual folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a system folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value refers to a folder that cannot be renamed or moved.</description>
              </item>
              <item>
                <description>The <i>dwFlags</i> value is not 0 (zero).</description>
              </item>
              <item>
                <description>The <i>pszPath</i> value is <b>NULL</b>.</description>
              </item>
              <item>
                <description>The string pointed to by <i>pszPath</i> value is an empty string ("") of length zero.</description>
              </item>
            </list>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHSetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and <b>SHSetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
      <para>
        <b>SHSetFolderPath</b> is not exported by name from Shell32.dll. To use the function, you must call <see cref="GetProcAddress" /> with ordinal 231 for <b>SHSetFolderPathA</b> (for ANSI strings) or ordinal 232 for <b>SHSetFolderPathW</b> (for Unicode strings) to obtain a function pointer.</para>
      <para>It is recommended that the paths be expressed as Unicode strings because folder names might contain Unicode characters not expressible in ANSI.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHSetFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IKnownFolder.SetPath" />
  </member>
  <member name="Windows.SHSetFolderPathA">
    <summary>
      <para>Deprecated. Assigns a new path to a system folder identified by its CSIDL.</para>
    </summary>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be set. Only physical folders are valid. If a virtual folder is specified, this function fails.</para>
      <para>Add the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> value to the CSIDL to ensure that the string is written to the registry exactly as provided. If the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> flag is not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be set to 0.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the folder's new path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard <b>HRESULT</b> codes, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The folder's path was successfully updated.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Several error conditions cause the return of this value, including the following:</para>
            <list type="bullet">
              <item>
                <description>The <i>csidl</i> value is not valid.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a virtual folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a system folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value refers to a folder that cannot be renamed or moved.</description>
              </item>
              <item>
                <description>The <i>dwFlags</i> value is not 0 (zero).</description>
              </item>
              <item>
                <description>The <i>pszPath</i> value is <b>NULL</b>.</description>
              </item>
              <item>
                <description>The string pointed to by <i>pszPath</i> value is an empty string ("") of length zero.</description>
              </item>
            </list>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHSetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and <b>SHSetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
      <para>
        <b>SHSetFolderPath</b> is not exported by name from Shell32.dll. To use the function, you must call <see cref="GetProcAddress" /> with ordinal 231 for <b>SHSetFolderPathA</b> (for ANSI strings) or ordinal 232 for <b>SHSetFolderPathW</b> (for Unicode strings) to obtain a function pointer.</para>
      <para>It is recommended that the paths be expressed as Unicode strings because folder names might contain Unicode characters not expressible in ANSI.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHSetFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IKnownFolder.SetPath" />
  </member>
  <member name="Windows.SHSetFolderPathW">
    <summary>
      <para>Deprecated. Assigns a new path to a system folder identified by its CSIDL.</para>
    </summary>
    <param name="csidl">
      <para>Type: <b>int</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be set. Only physical folders are valid. If a virtual folder is specified, this function fails.</para>
      <para>Add the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> value to the CSIDL to ensure that the string is written to the registry exactly as provided. If the <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> flag is not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be set to 0.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the folder's new path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard <b>HRESULT</b> codes, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The folder's path was successfully updated.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Several error conditions cause the return of this value, including the following:</para>
            <list type="bullet">
              <item>
                <description>The <i>csidl</i> value is not valid.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a virtual folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value does not refer to a system folder.</description>
              </item>
              <item>
                <description>The <i>csidl</i> value refers to a folder that cannot be renamed or moved.</description>
              </item>
              <item>
                <description>The <i>dwFlags</i> value is not 0 (zero).</description>
              </item>
              <item>
                <description>The <i>pszPath</i> value is <b>NULL</b>.</description>
              </item>
              <item>
                <description>The string pointed to by <i>pszPath</i> value is an empty string ("") of length zero.</description>
              </item>
            </list>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  As of Windows Vista, this function is merely a wrapper for <see cref="SHSetKnownFolderPath" />. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and <b>SHSetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</para>
      <para>
        <b>SHSetFolderPath</b> is not exported by name from Shell32.dll. To use the function, you must call <see cref="GetProcAddress" /> with ordinal 231 for <b>SHSetFolderPathA</b> (for ANSI strings) or ordinal 232 for <b>SHSetFolderPathW</b> (for Unicode strings) to obtain a function pointer.</para>
      <para>It is recommended that the paths be expressed as Unicode strings because folder names might contain Unicode characters not expressible in ANSI.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHSetFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IKnownFolder.SetPath" />
  </member>
  <member name="Windows.SHSetInstanceExplorer">
    <summary>
      <para>Provides an interface that allows hosted Shell extensions and other components to prevent their host process from closing prematurely. The host process is typically Windows Explorer or Windows Internet Explorer, but this function can also be used by other applications.</para>
    </summary>
    <param name="punk">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to a free-threaded <see cref="IUnknown" />. Components can use this interface (through <see cref="SHGetInstanceExplorer" />) to prevent the host process from terminating. This value can be <b>NULL</b>, in which case the process reference is no longer made available to components.</para>
    </param>
    <remarks>
      <para>Windows Explorer and Internet Explorer can use <b>SHSetInstanceExplorer</b> to allow components such as Shell extensions to extend the lifetime of the process. Other applications can also use <b>SHSetInstanceExplorer</b> to allow for the same capability. For instance, the browser message loop and the proxy desktop use <b>SHSetInstanceExplorer</b> to let other threads extend their lifetime.</para>
      <para>Applications other than Windows Explorer and Internet Explorer that call this function might encounter compatibility problems because some components use <see cref="SHGetInstanceExplorer" /> to detect whether they are being hosted from within Windows Explorer or Internet Explorer.</para>
      <para>The interface pointer passed to <b>SHSetInstanceExplorer</b> must reference a free-threaded object.</para>
      <para>Each time a component calls <see cref="SHGetInstanceExplorer" />, the system calls the <see cref="AddRef" /> method before returning the interface pointer to the calling component. The component then calls the <see cref="IUnknown.Release" /> method when processing is complete. The process that calls <b>SHSetInstanceExplorer</b> must not terminate while the reference count of the provided interface pointer is nonzero.</para>
      <para>For further information on how components use the process references, see <see cref="SHGetInstanceExplorer" />.</para>
    </remarks>
    <seealso cref="SHGetInstanceExplorer" />
  </member>
  <member name="Windows.SHSetKnownFolderPath">
    <summary>
      <para>Redirects a known folder to a new location.</para>
    </summary>
    <param name="rfid">
      <para>Type: <b>REFKNOWNFOLDERID</b></para>
      <para>A <b>GUID</b> that identifies the known folder.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Either 0 or the following value.</para>
      <h4>KF_FLAG_DONT_UNEXPAND</h4>
      <para>If this flag is set, portions of the path referenced by <i>pszPath</i> may be represented by environment strings such as <code>%USERPROFILE%</code>.</para>
    </param>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-tokens">access token</a> used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.</para>
      <para>The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.</para>
      <para>Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHSetKnownFolderPath</b> to set folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to the folder's new path. This is a null-terminated Unicode string of length MAX_PATH. This path cannot be of zero length.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or an error value otherwise, including the following:</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Among other things, this value can indicate that the <i>rfid</i> parameter references a <a href="https://docs.microsoft.com//windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on all systems. Use <see cref="IKnownFolderManager.GetFolderIds" /> to retrieve the set of <b>KNOWNFOLDERID</b> values for the current system.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function replaces <see cref="SHSetFolderPath" />. That older function is now simply a wrapper for <b>SHSetKnownFolderPath</b>.</para>
      <para>The caller of this function must have Administrator privileges. To call this function on public known folders, the caller must have Administrator privileges. For per-user known folders the caller only requires User privileges.</para>
      <para>Some of the known folders, for example, the <b>Documents</b> folder, are per-user. Every user has a different path for their <b>Documents</b> folder. If <i>hToken</i> is <b>NULL</b>, the API tries to access the calling application's instance of the folder, which is that of the current user. If <i>hToken</i> is a valid user token, the API tries to impersonate the user using this token and tries to access that user's instance.</para>
      <para>This function cannot be called on folders of type <see cref="KF_CATEGORY_FIXED" /> and <see cref="KF_CATEGORY_VIRTUAL" />.</para>
      <para>To call this function on a folder of type <see cref="KF_CATEGORY_COMMON" />, the calling application must be running with elevated privileges.</para>
    </remarks>
    <seealso cref="IKnownFolder.GetPath" />
    <seealso cref="IKnownFolder.SetPath" />
    <seealso cref="IKnownFolderManager.Redirect" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd940364(v=vs.85)">Known Folders Sample</seealso>
    <seealso cref="SHGetKnownFolderIDList" />
    <seealso cref="SHGetKnownFolderPath" />
  </member>
  <member name="Windows.SHUpdateImage">
    <summary>
      <para>Notifies the Shell that an image in the system image list has changed.</para>
    </summary>
    <param name="pszHashItem">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string value that specifies the fully qualified path of the file that contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the zero-based index of the icon in the file specified by <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>An unsigned integer that specifies the flags that determine the icon attributes. Set <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of <see cref="IExtractIcon.GetIconLocation" />. The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.</para>
    </param>
    <param name="iImageIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the index in the system image list of the icon that is being updated.</para>
    </param>
    <remarks>
      <para>If you do not know the index in the system image list of the icon that you want to update, use <see cref="SHGetFileInfo" /> with the <i>uFlags</i> parameter set to <b>SHGFI_SYSICONINDEX</b>.</para>
      <para>You must use <see cref="IExtractIcon.GetIconLocation" /> with the parameters of the old icon that needs to be updated, not those of the new icon you want to replace it with.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHUpdateImage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHChangeNotify" />
  </member>
  <member name="Windows.SHUpdateImageA">
    <summary>
      <para>Notifies the Shell that an image in the system image list has changed.</para>
    </summary>
    <param name="pszHashItem">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string value that specifies the fully qualified path of the file that contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the zero-based index of the icon in the file specified by <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>An unsigned integer that specifies the flags that determine the icon attributes. Set <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of <see cref="IExtractIcon.GetIconLocation" />. The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.</para>
    </param>
    <param name="iImageIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the index in the system image list of the icon that is being updated.</para>
    </param>
    <remarks>
      <para>If you do not know the index in the system image list of the icon that you want to update, use <see cref="SHGetFileInfo" /> with the <i>uFlags</i> parameter set to <b>SHGFI_SYSICONINDEX</b>.</para>
      <para>You must use <see cref="IExtractIcon.GetIconLocation" /> with the parameters of the old icon that needs to be updated, not those of the new icon you want to replace it with.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHUpdateImage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHChangeNotify" />
  </member>
  <member name="Windows.SHUpdateImageW">
    <summary>
      <para>Notifies the Shell that an image in the system image list has changed.</para>
    </summary>
    <param name="pszHashItem">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string value that specifies the fully qualified path of the file that contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the zero-based index of the icon in the file specified by <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>An unsigned integer that specifies the flags that determine the icon attributes. Set <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of <see cref="IExtractIcon.GetIconLocation" />. The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.</para>
    </param>
    <param name="iImageIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the index in the system image list of the icon that is being updated.</para>
    </param>
    <remarks>
      <para>If you do not know the index in the system image list of the icon that you want to update, use <see cref="SHGetFileInfo" /> with the <i>uFlags</i> parameter set to <b>SHGFI_SYSICONINDEX</b>.</para>
      <para>You must use <see cref="IExtractIcon.GetIconLocation" /> with the parameters of the old icon that needs to be updated, not those of the new icon you want to replace it with.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHUpdateImage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHChangeNotify" />
  </member>
  <member name="Windows.SHUpdateImage">
    <summary>
      <para>Notifies the Shell that an image in the system image list has changed.</para>
    </summary>
    <param name="pszHashItem">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string value that specifies the fully qualified path of the file that contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the zero-based index of the icon in the file specified by <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>An unsigned integer that specifies the flags that determine the icon attributes. Set <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of <see cref="IExtractIcon.GetIconLocation" />. The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.</para>
    </param>
    <param name="iImageIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the index in the system image list of the icon that is being updated.</para>
    </param>
    <remarks>
      <para>If you do not know the index in the system image list of the icon that you want to update, use <see cref="SHGetFileInfo" /> with the <i>uFlags</i> parameter set to <b>SHGFI_SYSICONINDEX</b>.</para>
      <para>You must use <see cref="IExtractIcon.GetIconLocation" /> with the parameters of the old icon that needs to be updated, not those of the new icon you want to replace it with.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHUpdateImage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHChangeNotify" />
  </member>
  <member name="Windows.SHUpdateImageA">
    <summary>
      <para>Notifies the Shell that an image in the system image list has changed.</para>
    </summary>
    <param name="pszHashItem">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string value that specifies the fully qualified path of the file that contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the zero-based index of the icon in the file specified by <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>An unsigned integer that specifies the flags that determine the icon attributes. Set <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of <see cref="IExtractIcon.GetIconLocation" />. The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.</para>
    </param>
    <param name="iImageIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the index in the system image list of the icon that is being updated.</para>
    </param>
    <remarks>
      <para>If you do not know the index in the system image list of the icon that you want to update, use <see cref="SHGetFileInfo" /> with the <i>uFlags</i> parameter set to <b>SHGFI_SYSICONINDEX</b>.</para>
      <para>You must use <see cref="IExtractIcon.GetIconLocation" /> with the parameters of the old icon that needs to be updated, not those of the new icon you want to replace it with.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHUpdateImage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHChangeNotify" />
  </member>
  <member name="Windows.SHUpdateImageW">
    <summary>
      <para>Notifies the Shell that an image in the system image list has changed.</para>
    </summary>
    <param name="pszHashItem">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string value that specifies the fully qualified path of the file that contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="iIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the zero-based index of the icon in the file specified by <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of <see cref="IExtractIcon.GetIconLocation" />.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>An unsigned integer that specifies the flags that determine the icon attributes. Set <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of <see cref="IExtractIcon.GetIconLocation" />. The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.</para>
    </param>
    <param name="iImageIndex">
      <para>Type: <b>int</b></para>
      <para>An integer that specifies the index in the system image list of the icon that is being updated.</para>
    </param>
    <remarks>
      <para>If you do not know the index in the system image list of the icon that you want to update, use <see cref="SHGetFileInfo" /> with the <i>uFlags</i> parameter set to <b>SHGFI_SYSICONINDEX</b>.</para>
      <para>You must use <see cref="IExtractIcon.GetIconLocation" /> with the parameters of the old icon that needs to be updated, not those of the new icon you want to replace it with.</para>
      <blockquote>
        <para>[!NOTE]
The shlobj_core.h header defines SHUpdateImage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHChangeNotify" />
  </member>
  <member name="Windows.StgMakeUniqueName">
    <summary>
      <para>Creates a unique name for a stream or storage object from a template.</para>
    </summary>
    <param name="pstgParent">
      <para>Type: <b><see cref="IStorage" />*</b></para>
      <para>A pointer to an <see cref="IStorage" /> object.</para>
    </param>
    <param name="pszFileSpec">
      <para>Type: <b>PCWSTR</b></para>
      <para>The format or template for the name of the stream or storage object.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The access mode to use when opening the stream or storage object. For more information and descriptions of the possible values, see STGM Constants.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>A reference to the IID of the interface to retrieve through <i>ppv</i>, typically IID_IStorage or IID_IStream.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>void**</b></para>
      <para>When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <see cref="IStorage" /> or <see cref="IStream" />.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>It is recommended that you use the <b>IID_PPV_ARGS</b> macro, defined in Objbase.h, to package the <i>riid</i> and <i>ppv</i> parameters. This macro provides the correct IID based on the interface pointed to by the value in <i>ppv</i>, which eliminates the possibility of a coding error.</para>
    </remarks>
  </member>
</doc>