<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AddIPAddress">
    <summary>
      <para>The
<b>AddIPAddress</b> function adds the specified IPv4 address to the specified adapter.</para>
    </summary>
    <param name="Address">
      <para>The IPv4 address to add to the adapter, in the form of an <see cref="IPAddr" /> structure.</para>
    </param>
    <param name="IpMask">
      <para>The subnet mask for the IPv4 address specified in the <i>Address</i> parameter.   The <b>IPMask</b> parameter uses the same format as an <see cref="IPAddr" /> structure.</para>
    </param>
    <param name="IfIndex">
      <para>The index of the adapter on which to add the IPv4 address.</para>
    </param>
    <param name="NTEContext">
      <para>A pointer to a <b>ULONG</b> variable. On successful return, this parameter points to the Net Table Entry (NTE) context for the IPv4 address that was added. The caller can later use this context in a call to
the <see cref="DeleteIPAddress" /> function.</para>
    </param>
    <param name="NTEInstance">
      <para>A pointer to a <b>ULONG</b> variable. On successful return, this parameter points to the NTE instance for the IPv4 address that was added.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_DEV_NOT_EXIST</b>
            </para>
          </description>
          <description>
            <para>The adapter specified by the <i>IfIndex</i> parameter does not exist.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_DUP_DOMAINNAME</b>
            </para>
          </description>
          <description>
            <para>The IPv4 address to add that is specified in the <i>Address</i> parameter already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_GEN_FAILURE</b>
            </para>
          </description>
          <description>
            <para>A general failure. This error is returned for some values specified in the <i>Address</i> parameter, such as an IPv4 address normally considered to be a broadcast addresses.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_HANDLE</b>
            </para>
          </description>
          <description>
            <para>The user attempting to make the function call is not an administrator.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One or more of the parameters is invalid. This error is returned if the <i>NTEContext</i> or <i>NTEInstance</i> parameters are <b>NULL</b>. This error is also returned when the IP address specified in the <i>Address</i> parameter is inconsistent with the interface index specified in the <i>IfIndex</i> parameter (for example, a loopback address on a non-loopback interface).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The function call is not supported on the version of Windows on which it was run.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>AddIPAddress</b> function is used to add a new IPv4 address entry on a local computer. The IPv4 address added by
the <b>AddIPAddress</b> function is not persistent. The IPv4 address exists only as long as the adapter object exists. Restarting the computer destroys the IPv4 address, as does manually resetting the network interface card (NIC). Also, certain PnP events may destroy the address.</para>
      <para>To create an IPv4 address that persists, the <a href="https://docs.microsoft.com//windows/desktop/CIMWin32Prov/enablestatic-method-in-class-win32-networkadapterconfiguration">EnableStatic method of the Win32_NetworkAdapterConfiguration Class</a> in the Windows Management Instrumentation (WMI) controls may be used. The netsh commands can also be used to create a persistent IPv4 address.</para>
      <para>For more information, please see the documentation on <a href="https://docs.microsoft.com//windows/desktop/WinSock/netsh-exe">Netsh.exe</a> in the Windows Sockets documentation.</para>
      <para>On  Windows Server 2003, Windows XP, and Windows 2000, if the IPv4 address in the <i>Address</i> parameter already exists on the network, the <b>AddIPAddress</b> function returns <b>NO_ERROR</b> and  the IPv4 address added is 0.0.0.0.</para>
      <para>On  Windows Vista and later, if the IPv4 address passed in the <i>Address</i> parameter already exists on the network, the <b>AddIPAddress</b> function returns <b>NO_ERROR</b> and  the duplicate IPv4 address is added with the <b>IP_DAD_STATE</b> member in  the <see cref="IP_ADAPTER_UNICAST_ADDRESS" /> structure set to <b>IpDadStateDuplicate</b>.</para>
      <para>An IPv4 address that is added using the <b>AddIPAddress</b> function can later be deleted by calling the <see cref="DeleteIPAddress" /> function  passing the  <i>NTEContext</i> parameter returned by the <b>AddIPAddress</b> function.</para>
      <para>For information about the <b>IPAddr</b> and <b>IPMask</b> data types, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">Windows Data Types</a>. To convert an IPv4 address between dotted decimal notation and <b>IPAddr</b> format, use the
<see cref="inet_addr" /> and
<see cref="inet_ntoa" /> functions.</para>
      <para>On Windows Vista and later, the <see cref="CreateUnicastIpAddressEntry" /> function can be used to add a new unicast IPv4 or IPv6 address entry on a local computer.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the IP address table to determine the interface index for the first adapter, then adds the IP address specified on command line to the first adapter. The IP address that was added is then deleted.</para>
      <code>#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int __cdecl main(int argc, char **argv)
{

    /* Variables used by GetIpAddrTable */
    PMIB_IPADDRTABLE pIPAddrTable;
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;
    IN_ADDR IPAddr;
    DWORD ifIndex;

    /* IPv4 address and subnet mask we will be adding */
    UINT iaIPAddress;
    UINT iaIPMask;

    /* Variables where handles to the added IP are returned */
    ULONG NTEContext = 0;
    ULONG NTEInstance = 0;

    /* Variables used to return error message */
    LPVOID lpMsgBuf;

    // Validate the parameters
    if (argc != 3) {
        printf("usage: %s IPAddress SubnetMask\n", argv[0]);
        exit(1);
    }

    iaIPAddress = inet_addr(argv[1]);
    if (iaIPAddress == INADDR_NONE) {
        printf("usage: %s IPAddress SubnetMask\n", argv[0]);
        exit(1);
    }

    iaIPMask = inet_addr(argv[2]);
    if (iaIPMask == INADDR_NONE) {
        printf("usage: %s IPAddress SubnetMask\n", argv[0]);
        exit(1);
    }

    // Before calling AddIPAddress we use GetIpAddrTable to get
    // an adapter to which we can add the IP.
    pIPAddrTable = (MIB_IPADDRTABLE *) MALLOC(sizeof (MIB_IPADDRTABLE));
    if (pIPAddrTable == NULL) {
        printf("Error allocating memory needed to call GetIpAddrTable\n");
        exit (1);
    }
    else {
        dwSize = 0;
        // Make an initial call to GetIpAddrTable to get the
        // necessary size into the dwSize variable
        if (GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0) ==
            ERROR_INSUFFICIENT_BUFFER) {
            FREE(pIPAddrTable);
            pIPAddrTable = (MIB_IPADDRTABLE *) MALLOC(dwSize);

        }
        if (pIPAddrTable == NULL) {
            printf("Memory allocation failed for GetIpAddrTable\n");
            exit(1);
        }
    }
    // Make a second call to GetIpAddrTable to get the
    // actual data we want
    if ((dwRetVal = GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0)) == NO_ERROR) {
        // Save the interface index to use for adding an IP address
        ifIndex = pIPAddrTable-&gt;table[0].dwIndex;
        printf("\n\tInterface Index:\t%ld\n", ifIndex);
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[0].dwAddr;
        printf("\tIP Address:       \t%s (%lu%)\n", inet_ntoa(IPAddr),
               pIPAddrTable-&gt;table[0].dwAddr);
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[0].dwMask;
        printf("\tSubnet Mask:      \t%s (%lu%)\n", inet_ntoa(IPAddr),
               pIPAddrTable-&gt;table[0].dwMask);
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[0].dwBCastAddr;
        printf("\tBroadCast Address:\t%s (%lu%)\n", inet_ntoa(IPAddr),
               pIPAddrTable-&gt;table[0].dwBCastAddr);
        printf("\tReassembly size:  \t%lu\n\n",
               pIPAddrTable-&gt;table[0].dwReasmSize);
    } else {
        printf("Call to GetIpAddrTable failed with error %d.\n", dwRetVal);
        if (pIPAddrTable)
            FREE(pIPAddrTable);
        exit(1);
    }

    if (pIPAddrTable) {
        FREE(pIPAddrTable);
        pIPAddrTable = NULL;
    }

    if ((dwRetVal = AddIPAddress(iaIPAddress,
                                 iaIPMask,
                                 ifIndex,
                                 &amp;amp;amp;amp;amp;amp;NTEContext, &amp;amp;amp;amp;amp;amp;NTEInstance)) == NO_ERROR) {
        printf("\tIPv4 address %s was successfully added.\n", argv[1]);
    } else {
        printf("AddIPAddress failed with error: %d\n", dwRetVal);

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, dwRetVal, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),       // Default language
                          (LPTSTR) &amp;amp;amp;amp;amp;amp; lpMsgBuf, 0, NULL)) {
            printf("\tError: %s", lpMsgBuf);
            LocalFree(lpMsgBuf);
            exit(1);
        }
    }

// Delete the IP we just added using the NTEContext
// variable where the handle was returned
    if ((dwRetVal = DeleteIPAddress(NTEContext)) == NO_ERROR) {
        printf("\tIPv4 address %s was successfully deleted.\n", argv[1]);
    } else {
        printf("\tDeleteIPAddress failed with error: %d\n", dwRetVal);
        exit(1);
    }

    exit(0);
}

</code>
    </remarks>
    <seealso cref="CreateUnicastIpAddressEntry" />
    <seealso cref="DeleteIPAddress" />
    <seealso cref="GetAdapterIndex" />
    <seealso cref="GetIpAddrTable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="IPAddr" />
  </member>
  <member name="Windows.CancelIfTimestampConfigChange">
    <summary>
      <para>This function is reserved for system use, and you should not call it from your code.</para>
    </summary>
    <param name="NotificationHandle">
      <para>Reserved.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
    </returns>
  </member>
  <member name="Windows.CancelIPChangeNotify">
    <summary>
      <para>The <b>CancelIPChangeNotify</b> function cancels notification of IPv4 address and route changes previously requested with successful calls to the <see cref="NotifyAddrChange" /> or <see cref="NotifyRouteChange" /> functions.</para>
    </summary>
    <param name="notifyOverlapped">
      <para>A pointer to the <see cref="OVERLAPPED" /> structure used in the previous call to <see cref="NotifyAddrChange" />  or <see cref="NotifyRouteChange" />.</para>
    </param>
    <remarks>
      <para>The
<b>CancelIPChangeNotify</b> function deregisters for a change notification previously requested for IPv4 address or route changes on  a local computer. These requests to register for notification are made  by calling the <see cref="NotifyAddrChange" /> or <see cref="NotifyRouteChange" /> functions.</para>
      <para>The <see cref="OVERLAPPED" /> structure used in the previous call to one of these notification functions is passed to <b>CancelIPChangeNotify</b> function in the <i>notifyOverlapped</i> parameter to deregister for notifications.</para>
      <para>The <b>CancelIPChangeNotify</b> can return <b>FALSE</b> if no notification request was found or an invalid <i>notifyOverlapped</i> parameter was passed.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso cref="NotifyAddrChange" />
    <seealso cref="NotifyRouteChange" />
    <seealso cref="OVERLAPPED" />
  </member>
  <member name="Windows.CaptureInterfaceHardwareCrossTimestamp">
    <summary>
      <para>Retrieves cross timestamp info for a network adapter.</para>
      <para>For more info, and code examples, see <a href="https://docs.microsoft.com//windows/win32/iphlp/packet-timestamping">Packet timestamping</a>.</para>
      <blockquote>
        <para>[!IMPORTANT]
On Windows 10, version 2004 (10.0; Build 19041) and earlier, this function is reserved for system use, and you should not call it from your code. On later versions, this function <i>is</i> supported.</para>
      </blockquote>
    </summary>
    <param name="InterfaceLuid">
      <para>Type: _In_ <b>CONST <see cref="NET_LUID" />*</b></para>
      <para>The network locally unique identifier (LUID) of the network adapter from which a cross timestamp is to be retrieved.</para>
    </param>
    <param name="CrossTimestamp">
      <para>Type: _Inout_ <b><see cref="PINTERFACE_HARDWARE_CROSSTIMESTAMP" /></b></para>
      <para>The timestamp is returned by the network adapter in the form of an <see cref="INTERFACE_HARDWARE_CROSSTIMESTAMP" /> object.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">DWORD</a></b></para>
      <para>A <b>DWORD</b> return code indicating success or failure.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/win32/iphlp/packet-timestamping">Packet timestamping</seealso>
  </member>
  <member name="Windows.CreateIpForwardEntry">
    <summary>
      <para>The
<b>CreateIpForwardEntry</b> function creates a route in the local computer's IPv4 routing table.</para>
    </summary>
    <param name="pRoute">
      <para>A pointer to a
<see cref="MIB_IPFORWARDROW" /> structure that specifies the information for the new route. The caller must specify values for all members of this structure. The caller must specify <b>MIB_IPPROTO_NETMGMT</b> for the <b>dwForwardProto</b> member of
<b>MIB_IPFORWARDROW</b>.</para>
    </param>
    <returns>
      <para>The function returns <b>NO_ERROR</b> (zero) if the function is successful.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An input parameter is invalid, no action was taken. This error is returned if the <i>pRoute</i> parameter is <b>NULL</b>,  the  <b>dwForwardProto</b> member of
<see cref="MIB_IPFORWARDROW" /> was not set to <b>MIB_IPPROTO_NETMGMT</b>, the <b>dwForwardMask</b> member of the <b>PMIB_IPFORWARDROW</b> structure is not a valid IPv4 subnet mask, or one of the other members of the
<b>MIB_IPFORWARDROW</b> structure is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The IPv4 transport is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>dwForwardProto</b> member of
<see cref="MIB_IPFORWARDROW" /> structure pointed to by the <i>route</i> parameter must be set to <b>MIB_IPPROTO_NETMGMT</b> otherwise <b>CreateIpForwardEntry</b> will fail. Routing protocol identifiers are used to identify route information for the specified routing protocol. For example, <b>MIB_IPPROTO_NETMGMT</b> is used to identify route information for IP  routing set through network management such as the Dynamic Host Configuration Protocol (DHCP), the Simple Network Management Protocol (SNMP), or by calls to the <b>CreateIpForwardEntry</b>,  <see cref="DeleteIpForwardEntry" />, or <see cref="SetIpForwardEntry" /> functions.</para>
      <para>On Windows Vista and Windows Server 2008, the route metric specified in the <b>dwForwardMetric1</b> member of the  <see cref="MIB_IPFORWARDROW" /> structure pointed to by <i>pRoute</i> parameter represents a combination of the route metric added to the interface metric specified in the <b>Metric</b> member of the <see cref="MIB_IPINTERFACE_ROW" /> structure of the associated interface.  So the <b>dwForwardMetric1</b> member of the  <b>MIB_IPFORWARDROW</b> structure should be equal to or greater than <b>Metric</b> member of the associated <b>MIB_IPINTERFACE_ROW</b> structure. If an application would like to set the route metric to 0, then the <b>dwForwardMetric1</b> member of the <b>MIB_IPFORWARDROW</b> structure  should be set equal to the value of the interface metric specified in the <b>Metric</b> member of the associated <b>MIB_IPINTERFACE_ROW</b> structure. An application can retrieve the interface metric by calling the <see cref="GetIpInterfaceEntry" /> function.</para>
      <para>On Windows Vista and Windows Server 2008, the <b>CreateIpForwardEntry</b> only works on interfaces with a single sub-interface (where the interface LUID and subinterface LUID are the same). The <b>dwForwardIfIndex</b> member of the <see cref="MIB_IPFORWARDROW" /> structure specifies the interface.</para>
      <para>A number of members of the <see cref="MIB_IPFORWARDROW" /> structure  pointed to by the <i>route</i> parameter are not currently used by <b>CreateIpForwardEntry</b>. These members include <b>dwForwardPolicy</b>, <b>dwForwardType</b>, <b>dwForwardAge</b>, <b>dwForwardNextHopAS</b>, <b>dwForwardMetric2</b>, <b>dwForwardMetric3</b>, <b>dwForwardMetric4</b>, and <b>dwForwardMetric5</b>.</para>
      <para>A new route created by <b>CreateIpForwardEntry</b> will automatically have a default value for <b>dwForwardAge</b> of INFINITE.</para>
      <para>To modify an existing route in the IPv4 routing table, use the
<see cref="SetIpForwardEntry" /> function. To retrieve the IPv4 routing table, call the <see cref="GetIpForwardTable" /> function.</para>
      <para>On Windows Vista and later, the <b>CreateIpForwardEntry</b> function can only be called by a user logged on as a member of the Administrators group. If <b>CreateIpForwardEntry</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned.</para>
      <para>The <b>CreateIpForwardEntry</b> function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>  On Windows NT 4.0 and Windows 2000 and later, this function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
      <h4>Examples</h4>
      <para>The following example demonstrates how to change the default gateway to NewGateway. Simply calling GetIpForwardTable, changing the gateway, and then calling SetIpForwardEntry will not change the route, but rather will just add a new one. If for some reason there are multiple default gateways present, this code will delete them. Note that the new gateway must be viable; otherwise, TCP/IP will ignore the change.</para>
      <para>
        <b>Note</b>  Executing this code will change your IP routing tables and will likely cause network activity to fail.</para>
      <code>#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include &lt;windows.h&gt;
#include &lt;winsock2.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#pragma comment(lib, "iphlpapi.lib")

int main()
{
    // Declare and initialize variables

    PMIB_IPFORWARDTABLE pIpForwardTable = NULL;
    PMIB_IPFORWARDROW pRow = NULL;
    DWORD dwSize = 0;
    BOOL bOrder = FALSE;
    DWORD dwStatus = 0;
    DWORD NewGateway = 0xDDCCBBAA;  // this is in host order Ip Address AA.BB.CC.DD is DDCCBBAA

    unsigned int i;

// Find out how big our buffer needs to be.
    dwStatus = GetIpForwardTable(pIpForwardTable, &amp;amp;amp;amp;amp;amp;dwSize, bOrder);
    if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {
        // Allocate the memory for the table
        if (!(pIpForwardTable = (PMIB_IPFORWARDTABLE) malloc(dwSize))) {
            printf("Malloc failed. Out of memory.\n");
            exit(1);
        }
        // Now get the table.
        dwStatus = GetIpForwardTable(pIpForwardTable, &amp;amp;amp;amp;amp;amp;dwSize, bOrder);
    }

    if (dwStatus != ERROR_SUCCESS) {
        printf("getIpForwardTable failed.\n");
        if (pIpForwardTable)
            free(pIpForwardTable);
        exit(1);
    }
    // Search for the row in the table we want. The default gateway has a destination
    // of 0.0.0.0. Notice that we continue looking through the table, but copy only
    // one row. This is so that if there happen to be multiple default gateways, we can
    // be sure to delete them all.
    for (i = 0; i &lt; pIpForwardTable-&gt;dwNumEntries; i++) {
        if (pIpForwardTable-&gt;table[i].dwForwardDest == 0) {
            // We have found the default gateway.
            if (!pRow) {
                // Allocate some memory to store the row in; this is easier than filling
                // in the row structure ourselves, and we can be sure we change only the
                // gateway address.
                pRow = (PMIB_IPFORWARDROW) malloc(sizeof (MIB_IPFORWARDROW));
                if (!pRow) {
                    printf("Malloc failed. Out of memory.\n");
                    exit(1);
                }
                // Copy the row
                memcpy(pRow, &amp;amp;amp;amp;amp;amp;(pIpForwardTable-&gt;table[i]),
                       sizeof (MIB_IPFORWARDROW));
            }
            // Delete the old default gateway entry.
            dwStatus = DeleteIpForwardEntry(&amp;amp;amp;amp;amp;amp;(pIpForwardTable-&gt;table[i]));

            if (dwStatus != ERROR_SUCCESS) {
                printf("Could not delete old gateway\n");
                exit(1);
            }
        }
    }

    // Set the nexthop field to our new gateway - all the other properties of the route will
    // be the same as they were previously.
    pRow-&gt;dwForwardNextHop = NewGateway;

    // Create a new route entry for the default gateway.
    dwStatus = CreateIpForwardEntry(pRow);

    if (dwStatus == NO_ERROR)
        printf("Gateway changed successfully\n");
    else if (dwStatus == ERROR_INVALID_PARAMETER)
        printf("Invalid parameter.\n");
    else
        printf("Error: %d\n", dwStatus);

    // Free resources
    if (pIpForwardTable)
        free(pIpForwardTable);
    if (pRow)
        free(pRow);

    exit(0);
}

</code>
    </remarks>
    <seealso cref="DeleteIpForwardEntry" />
    <seealso cref="GetIpForwardTable" />
    <seealso cref="GetIpInterfaceEntry" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper
Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper
Start Page</seealso>
    <seealso cref="MIB_IPFORWARDROW" />
    <seealso cref="SetIpForwardEntry" />
  </member>
  <member name="Windows.CreateIpNetEntry">
    <summary>
      <para>The
<b>CreateIpNetEntry</b> function creates an Address Resolution Protocol (ARP) entry in the ARP table on the local computer.</para>
    </summary>
    <param name="pArpEntry">
      <para>A pointer to a
<see cref="MIB_IPNETROW" /> structure that specifies information for the new entry. The caller must specify values for all members of this structure.</para>
    </param>
    <returns>
      <para>The function returns <b>NO_ERROR</b> (zero) if the function is successful.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An input parameter is invalid, no action was taken. This error is returned if the <i>pArpEntry</i> parameter is <b>NULL</b>,  the  <b>dwPhysAddrLen</b> member of
<see cref="MIB_IPNETROW" /> is set to zero or a value greater than 8, the <b>&gt;dwAddr</b> member of the <b>MIB_IPNETROW</b> structure is invalid, or one of the other members of the
<b>MIB_IPNETROW</b> structure is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The IPv4 transport is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>To modify an existing ARP entry, use the
<see cref="SetIpNetEntry" /> function. To retrieve the ARP table, call the <see cref="GetIpNetTable" /> function. To delete an existing ARP entry, call the <see cref="DeleteIpNetEntry" />.</para>
      <para>On Windows Vista and later, the <b>CreateIpNetEntry</b> function can only be called by a user logged on as a member of the Administrators group. If <b>CreateIpNetEntry</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned.</para>
      <para>The <b>CreateIpNetEntry</b> function can also fail because of user account control (UAC) on Windows Vista later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>  On Windows NT 4.0 and Windows 2000 and later, this function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
    </remarks>
    <seealso cref="CreateProxyArpEntry" />
    <seealso cref="DeleteIpNetEntry" />
    <seealso cref="DeleteProxyArpEntry" />
    <seealso cref="FlushIpNetTable" />
    <seealso cref="GetIpNetTable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPNETROW" />
    <seealso cref="SetIpNetEntry" />
  </member>
  <member name="Windows.CreatePersistentTcpPortReservation">
    <summary>
      <para>The
<b>CreatePersistentTcpPortReservation</b> function creates a persistent TCP port reservation for a consecutive block of TCP ports on the local computer.</para>
    </summary>
    <param name="StartPort">
      <para>The starting TCP port number in network byte order.</para>
    </param>
    <param name="NumberOfPorts">
      <para>The number of TCP port numbers to reserve.</para>
    </param>
    <param name="Token">
      <para>A pointer to a port reservation token that is returned if the function succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function.</para>
            <para>This error is returned if zero is passed in the <i>StartPort</i>  or <i>NumberOfPorts</i> parameters. This error is also returned if the <i>NumberOfPorts</i> parameter is too large a block of ports depending on the <i>StartPort</i> parameter that the allocable block of ports would exceed the maximum port that can be allocated.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_SHARING_VIOLATION</b>
            </para>
          </description>
          <description>
            <para>The process cannot access the file because it is being used by another process. This error is returned if a TCP port in the block of TCP ports specified by the <i>StartPort</i>  and <i>NumberOfPorts</i> parameters is already being used. This error is also returned if a persistent reservation for a block of TCP ports specified by the <i>StartPort</i>  and <i>NumberOfPorts</i> parameters matches or overlaps a persistent reservation for a block of TCP ports that was already created.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CreatePersistentTcpPortReservation</b> function is defined on Windows Vista and later.</para>
      <para>The <b>CreatePersistentTcpPortReservation</b> function is used to add a persistent reservation for a block of TCP ports.</para>
      <para>Applications and services which need to reserve ports fall into two categories. The first category includes components which need a particular port as part of their operation. Such components will generally prefer to specify their required port at installation time (in an application manifest, for example). The second category includes components which need any available port or block of ports at runtime.</para>
      <para>These two categories correspond to specific and wildcard port reservation requests. Specific reservation requests may be persistent or runtime, while wildcard port reservation requests are only supported at runtime.</para>
      <para>The <b>CreatePersistentTcpPortReservation</b> function provides the ability for an application or service to reserve a persistent block of TCP ports.  Persistent TCP port reservations are recorded in a persistent store for the TCP module in Windows.</para>
      <para>A caller obtains a persistent port reservation by specifying how many ports are required and whether a specific range is needed. If the request can be satisfied, the <b>CreatePersistentTcpPortReservation</b> function returns a unique opaque ULONG64 token, which subsequently identifies the reservation. A persistent TCP port reservation may be released by calling the <see cref="DeletePersistentTcpPortReservation" /> function. Note that the token for a given persistent TCP port reservation may change each time the system is restarted.</para>
      <para>Windows does not implement inter-component security for persistent reservations obtained using these functions. This means that if a component is granted the ability to obtain any persistent port reservations, that component automatically gains the ability to consume any persistent port reservations granted to any other component on the system. Process-level security is enforced for runtime reservations, but such control cannot be extended to persistent port reservations created using the <b>CreatePersistentTcpPortReservation</b> or  <see cref="CreatePersistentUdpPortReservation" /> function.</para>
      <para>Once a persistent TCP port reservation has been obtained, an application can request port assignments from the TCP port reservation by opening a TCP socket, then calling the <see cref="WSAIoctl" /> function specifying the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699721(v=vs.85)">SIO_ASSOCIATE_PORT_RESERVATION</a> IOCTL and passing the reservation token before issuing a call to the <see cref="bind" /> function on the socket.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699720(v=vs.85)">SIO_ACQUIRE_PORT_RESERVATION</a> IOCTL can be used to request a runtime reservation for a block of TCP or UDP ports. For runtime port reservations, the port pool requires that reservations be consumed from the process on whose socket the reservation was granted. Runtime port reservations last only as long as the lifetime of the socket on which the <b>SIO_ACQUIRE_PORT_RESERVATION</b> IOCTL was called.  In contrast, persistent port reservations created using the <b>CreatePersistentTcpPortReservation</b> function may be consumed by any process with the ability to obtain persistent reservations.</para>
      <para>The <b>CreatePersistentTcpPortReservation</b> function can only be called by a user logged on as a member of the Administrators group. If <b>CreatePersistentTcpPortReservation</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <h4>Examples</h4>
      <para>The following example creates a persistent TCP port reservation, then creates a socket and allocates a port from the port reservation, and then closes the socket and deletes the TCP port reservation.</para>
      <para>This example must be run by a user that is a member of the Administrators group. The simplest way to run this example is in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
      <code>#ifndef UNICODE
#define UNICODE
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include &lt;Windows.h.&gt;
#include &lt;winsock2.h&gt;
#include &lt;mstcpip.h&gt;
#include &lt;ws2ipdef.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Need to link with iphlpapi.lib
#pragma comment(lib, "iphlpapi.lib")

// Need to link with Ws2_32.lib for Winsock functions
#pragma comment(lib, "ws2_32.lib")

int wmain(int argc, WCHAR ** argv)
{

    // Declare and initialize variables

    int startPort = 0;         // host byte order
    int numPorts = 0;
    USHORT startPortns = 0;    // Network byte order
    ULONG64 resToken = { 0 };

    unsigned long status = 0;

    WSADATA wsaData = { 0 };
    int iResult = 0;

    SOCKET sock = INVALID_SOCKET;
    int iFamily = AF_INET;
    int iType = SOCK_STREAM;
    int iProtocol = IPPROTO_TCP;

    DWORD bytesReturned = 0;


    // Note that the sockaddr_in struct works only with AF_INET not AF_INET6
    // An application needs to use the sockaddr_in6 for AF_INET6
    sockaddr_in service;
    sockaddr_in sockName;
    int nameLen = sizeof(sockName);

    // Validate the parameters
    if (argc != 3) {
        wprintf(L"usage: %s &lt;Starting Port&gt;&lt;Number of Ports&gt;\n",
             argv[0]);
        wprintf(L"Creates a persistent TCP port reservation\n");
        wprintf(L"Example usage:\n");
        wprintf(L"   %s 5000 20\n", argv[0]);
        wprintf(L"   where StartPort=5000 NumPorts=20");
        return 1;
    }

    startPort = _wtoi(argv[1]);
    if (startPort &lt; 0 || startPort &gt; 65535) {
        wprintf(L"Starting point must be either 0 or between 1 and 65,535\n");
        return 1;
    }
    startPortns = htons((USHORT) startPort);

    numPorts = _wtoi(argv[2]);
    if (numPorts &lt; 0) {
        wprintf(L"Number of ports must be a positive number\n");
        return 1;
    }

    status =
        CreatePersistentTcpPortReservation((USHORT) startPortns, (USHORT) numPorts,
                                           &amp;amp;amp;amp;amp;amp;resToken);
    if (status != NO_ERROR) {
        wprintf(L"CreatePersistentTcpPortReservation returned error: %ld\n", status);
        return 1;
    }

    wprintf(L"CreatePersistentTcpPortReservation call succeeded\n");
    wprintf(L"  Token = %I64d\n", resToken);

    // Comment out this block if you don't want to create a socket and associate it with the
    // persistent reservation

    // Initialize Winsock
    iResult = WSAStartup(MAKEWORD(2, 2), &amp;amp;amp;amp;amp;amp;wsaData);
    if (iResult != 0) {
        wprintf(L"WSAStartup failed with error = %d\n", iResult);
        // return 1;
    }

    sock = socket(iFamily, iType, iProtocol);
    if (sock == INVALID_SOCKET)
        wprintf(L"socket function failed with error = %d\n", WSAGetLastError());
    else {
        wprintf(L"socket function succeeded\n");

        iResult =
            WSAIoctl(sock, SIO_ASSOCIATE_PORT_RESERVATION, (LPVOID) &amp;amp;amp;amp;amp;amp; resToken,
                     sizeof (ULONG64), NULL, 0, &amp;amp;amp;amp;amp;amp;bytesReturned, NULL, NULL);
        if (iResult != 0) {
            wprintf
                (L"WSAIoctl(SIO_ASSOCIATE_PORT_RESERVATION) failed with error = %d\n",
                 WSAGetLastError());
        } else {
            wprintf(L"WSAIoctl(SIO_ASSOCIATE_PORT_RESERVATION) succeeded, bytesReturned = %u\n",
                bytesReturned);

            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = 0;

            iResult = bind(sock, (SOCKADDR*) &amp;amp;amp;amp;amp;amp;service, sizeof(service) );
            if (iResult == SOCKET_ERROR)
                wprintf(L"bind failed with error = %d\n", WSAGetLastError());
            else {
                wprintf(L"bind succeeded\n");
                iResult = getsockname(sock, (SOCKADDR*) &amp;amp;amp;amp;amp;amp;sockName, &amp;amp;amp;amp;amp;amp;nameLen);
                if (iResult == SOCKET_ERROR)
                    wprintf(L"getsockname failed with error = %d\n", WSAGetLastError() );
                else {
                    wprintf(L"getsockname succeeded\n");
                    wprintf(L"Port number allocated = %u\n", ntohs(sockName.sin_port) );
                }
            }
        }

        if (sock != INVALID_SOCKET) {
            iResult = closesocket(sock);
            if (iResult == SOCKET_ERROR) {
                wprintf(L"closesocket failed with error = %d\n", WSAGetLastError());
                WSACleanup();
            }
        }
    }

    // comment out this block of code if you don't want to delete the reservation just created
    status = DeletePersistentTcpPortReservation((USHORT) startPortns, (USHORT) numPorts);
    if (status != NO_ERROR) {
        wprintf(L"DeletePersistentTcpPortReservation returned error: %ld\n", status);
        return 1;
    }
    wprintf(L"DeletePersistentTcpPortReservation call succeeded\n");

    return 0;
}

</code>
    </remarks>
    <seealso cref="CreatePersistentUdpPortReservation" />
    <seealso cref="DeletePersistentTcpPortReservation" />
    <seealso cref="DeletePersistentUdpPortReservation" />
    <seealso cref="LookupPersistentTcpPortReservation" />
    <seealso cref="LookupPersistentUdpPortReservation" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699720(v=vs.85)">SIO_ACQUIRE_PORT_RESERVATION</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699721(v=vs.85)">SIO_ASSOCIATE_PORT_RESERVATION</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699722(v=vs.85)">SIO_RELEASE_PORT_RESERVATION</seealso>
    <seealso cref="WSAIoctl" />
    <seealso cref="bind" />
  </member>
  <member name="Windows.CreatePersistentUdpPortReservation">
    <summary>
      <para>The
<b>CreatePersistentUdpPortReservation</b> function creates a persistent UDP port reservation for a consecutive block of UDP ports on the local computer.</para>
    </summary>
    <param name="StartPort">
      <para>The starting UDP port number in network byte order.</para>
    </param>
    <param name="NumberOfPorts">
      <para>The number of UDP port numbers to reserve.</para>
    </param>
    <param name="Token">
      <para>A pointer to a port reservation token that is returned if the function succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function.</para>
            <para>This error is returned if zero is passed in the <i>StartPort</i>  or <i>NumberOfPorts</i> parameters. This error is also returned if the <i>NumberOfPorts</i> parameter is too large a block of ports depending on the <i>StartPort</i> parameter that the allocable block of ports would exceed the maximum port that can be allocated.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_SHARING_VIOLATION</b>
            </para>
          </description>
          <description>
            <para>The process cannot access the file because it is being used by another process. This error is returned if a UDP port in the block of UDP ports specified by the <i>StartPort</i>  and <i>NumberOfPorts</i> parameters is already being used. This error is also returned if a persistent reservation for a block of UDP ports specified by the <i>StartPort</i>  and <i>NumberOfPorts</i> parameters matches or overlaps a persistent reservation for a block of UDP ports that was already created.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CreatePersistentUdpPortReservation</b> function is defined on Windows Vista and later.</para>
      <para>The <b>CreatePersistentUdpPortReservation</b> function is used to add a persistent reservation for a block of UDP ports.</para>
      <para>Applications and services which need to reserve ports fall into two categories. The first category includes components which need a particular port as part of their operation. Such components will generally prefer to specify their required port at installation time (in an application manifest, for example). The second category includes components which need any available port or block of ports at runtime.</para>
      <para>These two categories correspond to specific and wildcard port reservation requests. Specific reservation requests may be persistent or runtime, while wildcard port reservation requests are only supported at runtime.</para>
      <para>The <b>CreatePersistentUdpPortReservation</b> function provides the ability for an application or service to reserve persistently a block of UDP ports.  Persistent TCP reservations are recorded in a persistent store for the UDP module in Windows.</para>
      <para>A caller obtains a persistent port reservation by specifying how many ports are required and whether a specific range is needed. If the request can be satisfied, the <b>CreatePersistentUdpPortReservation</b> function returns a unique opaque ULONG64 token, which subsequently identifies the reservation. A persistent UDP port reservation may be released by calling the <see cref="DeletePersistentUdpPortReservation" /> function. Note that the token for a given persistent UDP port reservation may change each time the system is restarted.</para>
      <para>Windows does not implement inter-component security for persistent reservations obtained using these functions. This means that if a component is granted the ability to obtain any persistent port reservations, that component automatically gains the ability to consume any persistent port reservations granted to any other component on the system. Process-level security is enforced for runtime reservations, but such control cannot be extended to persistent reservations created using the created using the <see cref="CreatePersistentTcpPortReservation" /> or  <b>CreatePersistentUdpPortReservation</b> function.</para>
      <para>Once a persistent UDP port reservation has been obtained, an application can request port assignments from the UDP port reservation by opening a UDP socket, then calling the <see cref="WSAIoctl" /> function specifying the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699721(v=vs.85)">SIO_ASSOCIATE_PORT_RESERVATION</a> IOCTL and passing the reservation token before issuing a call to the <see cref="bind" /> function on the socket.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699720(v=vs.85)">SIO_ACQUIRE_PORT_RESERVATION</a> IOCTL can be used to request a runtime reservation for a block of TCP or UDP ports. For runtime port reservations, the port pool requires that reservations be consumed from the process on whose socket the reservation was granted. Runtime port reservations last only as long as the lifetime of the socket on which the <b>SIO_ACQUIRE_PORT_RESERVATION</b> IOCTL was called.  In contrast, persistent port reservations created using the <b>CreatePersistentUdpPortReservation</b> function may be consumed by any process with the ability to obtain persistent reservations.</para>
      <para>The <b>CreatePersistentUdpPortReservation</b> function can only be called by a user logged on as a member of the Administrators group. If <b>CreatePersistentUdpPortReservation</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
    </remarks>
    <seealso cref="CreatePersistentTcpPortReservation" />
    <seealso cref="DeletePersistentTcpPortReservation" />
    <seealso cref="DeletePersistentUdpPortReservation" />
    <seealso cref="LookupPersistentTcpPortReservation" />
    <seealso cref="LookupPersistentUdpPortReservation" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699720(v=vs.85)">SIO_ACQUIRE_PORT_RESERVATION</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699721(v=vs.85)">SIO_ASSOCIATE_PORT_RESERVATION</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699722(v=vs.85)">SIO_RELEASE_PORT_RESERVATION</seealso>
    <seealso cref="WSAIoctl" />
    <seealso cref="bind" />
  </member>
  <member name="Windows.CreateProxyArpEntry">
    <summary>
      <para>The <b>CreateProxyArpEnry</b> function creates a Proxy Address Resolution Protocol (PARP) entry on the local computer for the specified IPv4 address.</para>
    </summary>
    <param name="dwAddress">
      <para>The IPv4 address for which this computer acts as a proxy.</para>
    </param>
    <param name="dwMask">
      <para>The subnet mask for the IPv4 address specified in <i>dwAddress</i>.</para>
    </param>
    <param name="dwIfIndex">
      <para>The index of the interface on which to proxy ARP for the IPv4 address identified by <i>dwAddress</i>. In other words, when an ARP request for <i>dwAddress</i> is received on this interface, the local computer responds with the physical address of this interface. If this interface is of a type that does not support ARP, such as PPP, then the call fails.</para>
    </param>
    <returns>
      <para>The function returns <b>NO_ERROR</b> (zero) if the function is successful.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An input parameter is invalid, no action was taken. This error is returned if the <i>dwAddress</i> parameter is <b>zero</b> or an invalid value,  one of the other parameters is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The IPv4 transport is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>To retrieve the ARP table, call the <see cref="GetIpNetTable" /> function. To delete an existing PARP entry, call the <see cref="DeleteProxyArpEntry" />.</para>
      <para>On Windows Vista and later, the <b>CreateProxyArpEnry</b> function can only be called by a user logged on as a member of the Administrators group. If <b>CreateProxyArpEnry</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application on Windows Vista and later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>  This function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
    </remarks>
    <seealso cref="DeleteProxyArpEntry" />
    <seealso cref="GetIpNetTable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_PROXYARP" />
  </member>
  <member name="Windows.DeleteIPAddress">
    <summary>
      <para>The
<b>DeleteIPAddress</b> function deletes an IP address previously added using
<see cref="AddIPAddress" />.</para>
    </summary>
    <param name="NTEContext">
      <para>The Net Table Entry (NTE) context for the IP address. This context was returned by the previous call to
<see cref="AddIPAddress" />.</para>
    </param>
    <returns>
      <para>The function returns <b>NO_ERROR</b> (zero) if the function is successful.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An input parameter is invalid, no action was taken.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The IPv4 transport is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>On Windows Vista and later, the <b>DeleteIPAddress</b> function can only be called by a user logged on as a member of the Administrators group. If <b>DeleteIPAddress</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application on Windows Vista and later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>  On Windows NT 4.0 and Windows 2000 and later, this function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the IP address table, then adds the IP address 192.168.0.27 to the first adapter. The IP address that was added is then deleted.</para>
      <code>#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include &lt;windows.h&gt;
#include &lt;winsock2.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

int main()
{
    // Declare and initialize variables
    PMIB_IPADDRTABLE pIPAddrTable;
    DWORD dwSize = 0;
    DWORD dwRetVal;

    // IP and mask we will be adding
    UINT iaIPAddress;
    UINT imIPMask;

    // Variables where handles to the added IP will be returned
    ULONG NTEContext = 0;
    ULONG NTEInstance = 0;

    LPVOID lpMsgBuf;


    // Before calling AddIPAddress we use GetIpAddrTable to get
    // an adapter to which we can add the IP.
    pIPAddrTable = (MIB_IPADDRTABLE *) malloc(sizeof (MIB_IPADDRTABLE));

    // Make an initial call to GetIpAddrTable to get the
    // necessary size into the dwSize variable
    if (GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0) == ERROR_INSUFFICIENT_BUFFER) {
        GlobalFree(pIPAddrTable);
        pIPAddrTable = (MIB_IPADDRTABLE *) malloc(dwSize);
    }
    // Make a second call to GetIpAddrTable to get the
    // actual data we want
    if ((dwRetVal = GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0)) == NO_ERROR) {
        printf("\tAddress: %ld\n", pIPAddrTable-&gt;table[0].dwAddr);
        printf("\tMask:    %ld\n", pIPAddrTable-&gt;table[0].dwMask);
        printf("\tIndex:   %ld\n", pIPAddrTable-&gt;table[0].dwIndex);
        printf("\tBCast:   %ld\n", pIPAddrTable-&gt;table[0].dwBCastAddr);
        printf("\tReasm:   %ld\n", pIPAddrTable-&gt;table[0].dwReasmSize);
    } else {
        printf("Call to GetIpAddrTable failed.\n");
    }

    // IP and mask we will be adding

    iaIPAddress = inet_addr("192.168.0.27");
    imIPMask = inet_addr("255.255.255.0");

    if ((dwRetVal = AddIPAddress(iaIPAddress,
                                 imIPMask,
                                 pIPAddrTable-&gt;table[0].dwIndex,
                                 &amp;amp;amp;amp;amp;amp;NTEContext, &amp;amp;amp;amp;amp;amp;NTEInstance)) == NO_ERROR) {
        printf("\tIP address added.\n");
    }

    else {
        printf("Error adding IP address.\n");

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, dwRetVal, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),       // Default language
                          (LPTSTR) &amp;amp;amp;amp;amp;amp; lpMsgBuf, 0, NULL)) {
            printf("\tError: %s", lpMsgBuf);
        }
        LocalFree(lpMsgBuf);
    }

    // Delete the IP we just added using the NTEContext
    // variable where the handle was returned
    if ((dwRetVal = DeleteIPAddress(NTEContext)) == NO_ERROR) {
        printf("\tIP Address Deleted.\n");
    } else {
        printf("\tCall to DeleteIPAddress failed.\n");
    }

    exit(0);

</code>
    </remarks>
    <seealso cref="AddIPAddress" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
  </member>
  <member name="Windows.DeleteIpForwardEntry">
    <summary>
      <para>The
<b>DeleteIpForwardEntry</b> function deletes an existing route in the local computer's IPv4 routing table.</para>
    </summary>
    <param name="pRoute">
      <para>A pointer to an
<see cref="MIB_IPFORWARDROW" /> structure. This structure specifies information that identifies the route to delete. The caller must specify values for the <b>dwForwardIfIndex</b>, <b>dwForwardDest</b>, <b>dwForwardMask</b>, <b>dwForwardNextHop</b>,  and <b>dwForwardProto</b> members of the structure.</para>
    </param>
    <returns>
      <para>The function returns <b>NO_ERROR</b> (zero) if the routine is successful.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b> ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An input parameter is invalid, no action was taken. This error is returned if the <b>pRoute</b> parameter is <b>NULL</b>, the <b>dwForwardMask</b> member of the <see cref="PMIB_IPFORWARDROW" /> structure is not a valid IPv4 subnet mask, the <b>dwForwardIfIndex</b> member is <b>NULL</b>, or one of the other members of the
<b>MIB_IPFORWARDROW</b> structure is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b> ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The <b>pRoute</b> parameter points to a route entry that does not exist.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The IPv4 transport is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>(other)</b>
            </para>
          </description>
          <description>
            <para>The function may return other error codes.</para>
          </description>
        </item>
      </list>
      <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
    </returns>
    <remarks>
      <para>The <b>dwForwardProto</b> member of
<see cref="MIB_IPFORWARDROW" /> structure pointer to by the <i>route</i> parameter must be set to <b>MIB_IPPROTO_NETMGMT</b> otherwise <b>DeleteIpForwardEntry</b> will fail. Routing protocol identifiers are used to identify route information for the specified routing protocol. For example, <b>MIB_IPPROTO_NETMGMT</b> is used to identify route information for IP  routing set through network management such as the Dynamic Host Configuration Protocol (DHCP), the Simple Network Management Protocol (SNMP), or by calls to the <see cref="CreateIpForwardEntry" />,  <b>DeleteIpForwardEntry</b></para>
      <para>, or <see cref="SetIpForwardEntry" /> functions.</para>
      <para>On Windows Vista and Windows Server 2008, the <b>DeleteIpForwardEntry</b> only works on interfaces with a single sub-interface (where the interface LUID and subinterface LUID are the same). The <b>dwForwardIfIndex</b> member of the <see cref="MIB_IPFORWARDROW" /> structure specifies the interface.</para>
      <para>A number of members of the <see cref="MIB_IPFORWARDROW" /> structure  pointed to by the <i>route</i> parameter are not currently used by <see cref="CreateIpForwardEntry" />. These members include <b>dwForwardPolicy</b>, <b>dwForwardType</b>, <b>dwForwardAge</b>, <b>dwForwardNextHopAS</b>, <b>dwForwardMetric1</b>, <b>dwForwardMetric2</b>, <b>dwForwardMetric3</b>, <b>dwForwardMetric4</b>, and <b>dwForwardMetric5</b>.</para>
      <para>To modify an existing route in the IPv4 routing table, use the
<see cref="SetIpForwardEntry" /> function. To retrieve the IPv4 routing table, call the <see cref="GetIpForwardTable" /> function.</para>
      <para>On Windows Vista and later, the <b>DeleteIpForwardEntry</b> function can only be called by a user logged on as a member of the Administrators group. If <b>DeleteIpForwardEntry</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned.</para>
      <para>The <b>DeleteIpForwardEntry</b> function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>   On Windows NT 4.0 and Windows 2000 and later, this function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
      <h4>Examples</h4>
      <para>The following code example shows how to change the default gateway to NewGateway. By calling GetIpForwardTable, changing the gateway, and then calling SetIpForwardEntry will not change the route, but will add a new one. If multiple default gateways exist, this code will delete them. Be aware that the new gateway must be viable; otherwise, TCP/IP will ignore the change.</para>
      <para>
        <b>Note</b>  Executing this code will change your IP routing tables and will likely cause network activity to fail.</para>
      <code>#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include &lt;windows.h&gt;
#include &lt;winsock2.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#pragma comment(lib, "iphlpapi.lib")

int main()
{
    // Declare and initialize variables
    PMIB_IPFORWARDTABLE pIpForwardTable = NULL;
    PMIB_IPFORWARDROW pRow = NULL;
    DWORD dwSize = 0;
    BOOL bOrder = FALSE;
    DWORD dwStatus = 0;
    DWORD NewGateway = 0xDDBBCCAA;      // this is in host order Ip Address AA.BB.CC.DD is DDCCBBAA

    unsigned int i;

// Identify the required size of the buffer.
    dwStatus = GetIpForwardTable(pIpForwardTable, &amp;amp;amp;amp;amp;amp;dwSize, bOrder);
    if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {
        // Allocate memory for the table.
        if (!(pIpForwardTable = (PMIB_IPFORWARDTABLE) malloc(dwSize))) {
            printf("Malloc failed. Out of memory.\n");
            exit(1);
        }
        // Retrieve the table.
        dwStatus = GetIpForwardTable(pIpForwardTable, &amp;amp;amp;amp;amp;amp;dwSize, bOrder);
    }

    if (dwStatus != ERROR_SUCCESS) {
        printf("getIpForwardTable failed.\n");
        if (pIpForwardTable)
            free(pIpForwardTable);
        exit(1);
    }
// Search for the required row in the table. The default gateway has a destination
// of 0.0.0.0. Be aware the table continues to be searched, but only
// one row is copied. This is to ensure that, if multiple gateways exist, all of them are deleted.
//
    for (i = 0; i &lt; pIpForwardTable-&gt;dwNumEntries; i++) {
        if (pIpForwardTable-&gt;table[i].dwForwardDest == 0) {
            // The default gateway was found.
            if (!pRow) {
                // Allocate memory to store the row. This is easier than manually filling
                // the row structure; only the gateway address is changed.
                //
                pRow = (PMIB_IPFORWARDROW) malloc(sizeof (MIB_IPFORWARDROW));
                if (!pRow) {
                    printf("Malloc failed. Out of memory.\n");
                    exit(1);
                }
                // Copy the row.
                memcpy(pRow, &amp;amp;amp;amp;amp;amp;(pIpForwardTable-&gt;table[i]),
                       sizeof (MIB_IPFORWARDROW));
            }
            // Delete the old default gateway entry.
            dwStatus = DeleteIpForwardEntry(&amp;amp;amp;amp;amp;amp;(pIpForwardTable-&gt;table[i]));

            if (dwStatus != ERROR_SUCCESS) {
                printf("Could not delete old gateway\n");
                exit(1);
            }
        }
    }

// Set the nexthop field to our new gateway. All other properties of the route will
// remain the same.
    pRow-&gt;dwForwardNextHop = NewGateway;

// Create a new route entry for the default gateway.
    dwStatus = CreateIpForwardEntry(pRow);

    if (dwStatus == NO_ERROR)
        printf("Gateway changed successfully\n");
    else if (dwStatus == ERROR_INVALID_PARAMETER)
        printf("Invalid parameter.\n");
    else
        printf("Error: %d\n", dwStatus);

// Free the memory.
    if (pIpForwardTable)
        free(pIpForwardTable);
    if (pRow)
        free(pRow);

    exit(0);
}

</code>
    </remarks>
    <seealso cref="CreateIpForwardEntry" />
    <seealso cref="FormatMessage" />
    <seealso cref="GetIpForwardTable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPFORWARDROW" />
    <seealso cref="SetIpForwardEntry" />
  </member>
  <member name="Windows.DeleteIpNetEntry">
    <summary>
      <para>The
<b>DeleteIpNetEntry</b> function deletes an ARP entry from the ARP table on the local computer.</para>
    </summary>
    <param name="pArpEntry">
      <para>A pointer to a
<see cref="MIB_IPNETROW" /> structure. The information in this structure specifies the entry to delete. The caller must specify values for at least the <b>dwIndex</b> and <b>dwAddr</b> members of this structure.</para>
    </param>
    <returns>
      <para>The function returns <b>NO_ERROR</b> (zero) if the function is successful.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An input parameter is invalid, no action was taken.  This error is returned if the <i>pArpEntry</i> parameter is <b>NULL</b> or a member in the <see cref="MIB_IPNETROW" /> structure pointed to by the <i>pArpEntry</i> parameter is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The IPv4 transport is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>To retrieve the ARP table, call the <see cref="GetIpNetTable" /> function.</para>
      <para>On Windows Vista and later, the <b>DeleteIpNetEntry</b> function can only be called by a user logged on as a member of the Administrators group. If <b>DeleteIpNetEntry</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned.</para>
      <para>The <b>DeleteIpNetEntry</b> function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>  On Windows NT 4.0 and Windows 2000 and later, this function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
    </remarks>
    <seealso cref="CreateIpNetEntry" />
    <seealso cref="FlushIpNetTable" />
    <seealso cref="GetIpNetTable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPNETROW" />
    <seealso cref="SetIpNetEntry" />
  </member>
  <member name="Windows.DeletePersistentTcpPortReservation">
    <summary>
      <para>The
<b>DeletePersistentTcpPortReservation</b> function deletes a persistent TCP port reservation for a consecutive block of TCP ports on the local computer.</para>
    </summary>
    <param name="StartPort">
      <para>The starting TCP port number in network byte order.</para>
    </param>
    <param name="NumberOfPorts">
      <para>The number of TCP port numbers to delete.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if zero is passed in the <i>StartPort</i>  or <i>NumberOfPorts</i> parameters.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The element was not found. This error is returned if persistent port block specified by the <i>StartPort</i>  and <i>NumberOfPorts</i> parameters could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>DeletePersistentTcpPortReservation</b> function is defined on Windows Vista and later.</para>
      <para>The <b>DeletePersistentTcpPortReservation</b> function is used to delete a persistent reservation for a block of TCP ports.</para>
      <para>The <b>DeletePersistentTcpPortReservation</b> function can only be called by a user logged on as a member of the Administrators group. If <b>DeletePersistentTcpPortReservation</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <h4>Examples</h4>
      <para>The following example deletes a persistent TCP port reservation.</para>
      <para>This example must be run by a user that is a member of the Administrators group. The simplest way to run this example is in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
      <code>#ifndef UNICODE
#define UNICODE
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include &lt;Windows.h.&gt;
#include &lt;winsock2.h&gt;
#include &lt;ws2ipdef.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Need to link with iphlpapi.lib
#pragma comment(lib, "iphlpapi.lib")

// Need to link with ws2_32.lib for htons
#pragma comment(lib, "ws2_32.lib")

int wmain(int argc, WCHAR **argv)  {

    // Declare and initialize variables

    int startPort = 0;         // host byte order
    int numPorts = 0;
    USHORT startPortns = 0;    // Network byte order

    unsigned long status = 0;

    // Validate the parameters
    if (argc != 3) {
        wprintf(L"usage: %s &lt;Starting Port&gt;&lt;Number of Ports&gt;\n", argv[0]);
        wprintf(L"Delete a persistent TCP port reservation\n");
        wprintf(L"Example usage:\n");
        wprintf(L"   %s 5000 20\n", argv[0]);
        wprintf(L"   where StartPort=5000 NumPorts=20");
        return 1;
    }

    startPort = _wtoi(argv[1]);
    if ( startPort &lt; 0 || startPort&gt; 65535) {
        wprintf(L"Starting point must be either 0 or between 1 and 65,535\n");
        return 1;
    }
    startPortns = htons((u_short) startPort);

    numPorts = _wtoi(argv[2]);
    if (numPorts &lt; 0) {
        wprintf(L"Number of ports must be a positive number\n");
        return 1;
    }

    status = DeletePersistentTcpPortReservation((USHORT) startPortns, (USHORT) numPorts);
    if( status != NO_ERROR )
    {
        wprintf(L"DeletePersistentTcpPortReservation returned error: %ld\n",
            status);
        return 1;
    }

    wprintf(L"DeletePersistentTcpPortReservation call succeeded\n");

    return 0;
}

</code>
    </remarks>
    <seealso cref="CreatePersistentTcpPortReservation" />
    <seealso cref="CreatePersistentUdpPortReservation" />
    <seealso cref="DeletePersistentUdpPortReservation" />
    <seealso cref="LookupPersistentTcpPortReservation" />
    <seealso cref="LookupPersistentUdpPortReservation" />
  </member>
  <member name="Windows.DeletePersistentUdpPortReservation">
    <summary>
      <para>The
<b>DeletePersistentUdpPortReservation</b> function deletes a persistent TCP port reservation for a consecutive block of TCP ports on the local computer.</para>
    </summary>
    <param name="StartPort">
      <para>The starting UDP port number in network byte order.</para>
    </param>
    <param name="NumberOfPorts">
      <para>The number of UDP port numbers to delete.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if zero is passed in the <i>StartPort</i>  or <i>NumberOfPorts</i> parameters.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The element was not found. This error is returned if persistent port block specified by the <i>StartPort</i>  and <i>NumberOfPorts</i> parameters could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>DeletePersistentUdpPortReservation</b> function is defined on Windows Vista and later.</para>
      <para>The <b>DeletePersistentUdpPortReservation</b> function is used to delete a persistent reservation for a block of UDP ports.</para>
      <para>The <b>DeletePersistentUdpPortReservation</b> function can only be called by a user logged on as a member of the Administrators group. If <b>DeletePersistentUdpPortReservation</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
    </remarks>
    <seealso cref="CreatePersistentTcpPortReservation" />
    <seealso cref="CreatePersistentUdpPortReservation" />
    <seealso cref="DeletePersistentTcpPortReservation" />
    <seealso cref="LookupPersistentTcpPortReservation" />
    <seealso cref="LookupPersistentUdpPortReservation" />
  </member>
  <member name="Windows.DeleteProxyArpEntry">
    <summary>
      <para>The
<b>DeleteProxyArpEntry</b> function deletes the PARP entry on the local computer specified by the <i>dwAddress</i> and <i>dwIfIndex</i> parameters.</para>
    </summary>
    <param name="dwAddress">
      <para>The IPv4 address for which this computer is acting as a proxy.</para>
    </param>
    <param name="dwMask">
      <para>The subnet mask for the IPv4 address specified in the <i>dwAddress</i> parameter.</para>
    </param>
    <param name="dwIfIndex">
      <para>The index of the interface on which this computer is supporting proxy ARP for the IP address specified by the <i>dwAddress</i> parameter.</para>
    </param>
    <returns>
      <para>The function returns <b>NO_ERROR</b> (zero) if the function is successful.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An input parameter is invalid, no action was taken.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The IPv4 transport is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>To retrieve the ARP table, call the <see cref="GetIpNetTable" /> function.</para>
      <para>On Windows Vista and later, the <b>DeleteProxyArpEntry</b> function can only be called by a user logged on as a member of the Administrators group. If <b>DeleteProxyArpEntry</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application on Windows Vista and later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>  This function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
    </remarks>
    <seealso cref="CreateProxyArpEntry" />
    <seealso cref="GetIpNetTable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_PROXYARP" />
  </member>
  <member name="Windows.DisableMediaSense">
    <summary>
      <para>The <b>DisableMediaSense</b> function disables the media sensing capability of the TCP/IP stack on a local computer.</para>
    </summary>
    <param name="pHandle">
      <para>A pointer to a variable that is used to store a handle. If the <i>pOverlapped</i> parameter is not <b>NULL</b>, this variable will be used internally to store a handle required to call the IP driver and disable the media sensing capability.</para>
      <para>An application should not use the value pointed to by this variable. This handle is for internal use and should not be closed.</para>
    </param>
    <param name="pOverLapped">
      <para>A pointer to an
<see cref="OVERLAPPED" /> structure. Except for the <b>hEvent</b> member, all members of this structure must be set to zero. The <b>hEvent</b> member requires a handle to a valid event object. Use the
<see cref="CreateEvent" /> function to create this event object.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if an <i>pOverlapped</i> parameter is a bad pointer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_IO_PENDING</b>
            </para>
          </description>
          <description>
            <para>The operation is in progress. This value is returned by a successful asynchronous call to <see cref="DisableMediaSense" />.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_OPEN_FAILED</b>
            </para>
          </description>
          <description>
            <para>The handle pointed to by the <i>pHandle</i> parameter was invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the <i>pHandle</i> or <i>pOverlapped</i> parameters are <b>NULL</b>, the <b>DisableMediaSense</b> function is  executed synchronously.</para>
      <para>If both the <i>pHandle</i> and  <i>pOverlapped</i> parameters are not <b>NULL</b>, the <b>DisableMediaSense</b> function is  executed asynchronously using the <see cref="OVERLAPPED" /> structure pointed to by the <i>pOverlapped</i> parameter.</para>
      <para>The <b>DisableMediaSense</b> function does not complete until the <see cref="RestoreMediaSense" /> function is called later to restore the media sensing capability. Until then, an I/O request packet (IRP) remains queued up. Alternatively, when the process that called <b>DisableMediaSense</b> exits, the IRP is canceled and a cancel routine is called that would again restore the media sensing capability.</para>
      <para>To call <b>DisableMediaSense</b> synchronously, an application needs to create a separate thread for this call. Otherwise it would keep waiting for IRP completion and the function will block.</para>
      <para>To call <b>DisableMediaSense</b> asynchronously, an application needs to allocate an <see cref="OVERLAPPED" /> structure. Except for the <b>hEvent</b> member, all members of this structure must be set to zero. The <b>hEvent</b> member requires a handle to a valid event object. Use the
<see cref="CreateEvent" /> function to create this event. When called asynchronously, <b>DisableMediaSense</b> always returns ERROR_IO_PENDING. The IRP will be completed only when <see cref="RestoreMediaSense" /> is called later.   Use the <see cref="CloseHandle" /> function to close the handle to the event object when it is no longer needed. The system closes the handle automatically when the process terminates. The event object is destroyed when its last handle has been closed.</para>
      <para>On Windows Server 2003and Windows XP, the TCP/IP stack implements a policy of deleting all IP addresses on an interface in response to a media sense disconnect event from an underlying network interface. If a network switch or hub that the local computer is connected to is powered off, or a network cable is disconnected, the network interface will deliver disconnection events. IP configuration information associated with the network interface is lost. As a result, the TCP/IP stack implements a policy of hiding disconnected interfaces so these interfaces and their associated IP addresses do not show up in configuration information retrieved through IP helper. This policy prevents some applications from easily detecting that a network interface is merely disconnected, rather than removed from the system.</para>
      <para>This behavior does not normally impact a local client computer if it is using DHCP requests to a DHCP server for IP configuration information. But this can have a serious impact on server computers, particularly computers used as part of clusters. The <b>DisableMediaSense</b> function can be used to temporarily disable the media sensing capability for these cases. At some later time, the <see cref="RestoreMediaSense" /> function would be called to restore the media sensing capability.</para>
      <para>The following registry setting is related to the <b>DisableMediaSense</b> and <see cref="RestoreMediaSense" /> functions:</para>
      <para>
        <b>System</b>\<b>CurrentControlSet</b>\<b>Services</b>\<b>Tcpip</b>\<b>Parameters</b>\<b>DisableDHCPMediaSense</b></para>
      <para>There is an internal flag in Windows that is set if this registry key exists when the machine first boots up. The same internal flag also gets set and reset by calling <b>DisableMediaSense</b> and <see cref="RestoreMediaSense" />. However with registry setting, you need to reboot the machine for the changes to take place.</para>
      <para>The TCP/IP stack on Windows Vista and later was changed to not hide disconnected interfaces when a disconnect event occurs. So on Windows Vista and later, the <b>DisableMediaSense</b> and <see cref="RestoreMediaSense" /> functions don't do anything and always returns NO_ERROR.</para>
      <h4>Examples</h4>
      <para>The following example shows how to call the <b>DisableMediaSense</b> and <see cref="RestoreMediaSense" /> functions asynchronously. This sample is only useful on Windows Server 2003and Windows XP where the <b>DisableMediaSense</b> and <b>RestoreMediaSense</b> functions do something useful.</para>
      <para>The sample first calls the <b>DisableMediaSense</b> function, sleeps for 60 seconds to allow the user to disconnect a network cable, retrieves the IP address table and prints some members of the IP address entries in the table, calls the <see cref="RestoreMediaSense" /> function, retrieves the IP address table again, and prints some members of the IP address entries in the table.  The impact of disabling the media sensing capability can be seen in the difference in the IP address table entries.</para>
      <para>For an example that shows how to call the <b>DisableMediaSense</b> and <see cref="RestoreMediaSense" /> functions synchronously, see the <b>RestoreMediaSense</b> function reference.</para>
      <code>#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int __cdecl main()
{

    int i;

    /* Variables used by GetIpAddrTable */
    PMIB_IPADDRTABLE pIPAddrTable;
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;
    IN_ADDR IPAddr;

    /* Variables used to return error message */
    LPVOID lpMsgBuf;

    // Variables to call DisableMediaSense
    //  and RestoreMediaSense asynchronously
    HANDLE IpDriverHandle = INVALID_HANDLE_VALUE;
    OVERLAPPED Overlapped;
    HANDLE DriverHandle;
    DWORD dwEnableCount = 0;

    memset(&amp;amp;amp;amp;amp;amp;Overlapped, 0, sizeof (Overlapped));
    Overlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    dwRetVal = DisableMediaSense(&amp;amp;amp;amp;amp;amp;DriverHandle, &amp;amp;amp;amp;amp;amp;Overlapped);
    if (dwRetVal != ERROR_IO_PENDING) {
        printf("DisableMediaSense failed with error %d\n", dwRetVal);
        exit(1);
    } else {
        printf(" === DisableMediaSense called ===\n\n");
        // Sleep for 60 seconds so we can disconnect a cable
        Sleep(60000);
    }

    // Before calling AddIPAddress we use GetIpAddrTable to get
    // an adapter to which we can add the IP.
    pIPAddrTable = (MIB_IPADDRTABLE *) MALLOC(sizeof (MIB_IPADDRTABLE));

    if (pIPAddrTable) {
        // Make an initial call to GetIpAddrTable to get the
        // necessary size into the dwSize variable
        if (GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0) ==
            ERROR_INSUFFICIENT_BUFFER) {
            FREE(pIPAddrTable);
            pIPAddrTable = (MIB_IPADDRTABLE *) MALLOC(dwSize);

        }
        if (pIPAddrTable == NULL) {
            printf("Memory allocation failed for GetIpAddrTable\n");
            exit(1);
        }
    }
    // Make a second call to GetIpAddrTable to get the
    // actual data we want
    if ((dwRetVal = GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0)) != NO_ERROR) {
        printf("GetIpAddrTable failed with error %d\n", dwRetVal);
        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    dwRetVal,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR) &amp;amp;amp;amp;amp;amp; lpMsgBuf, 0, NULL)) {
            printf("\tError: %s", lpMsgBuf);
            LocalFree(lpMsgBuf);
        }
        exit(1);
    }

    printf("\tNum Entries: %ld\n", pIPAddrTable-&gt;dwNumEntries);
    for (i = 0; i &lt; (int) pIPAddrTable-&gt;dwNumEntries; i++) {
        printf("\n\tInterface Index[%d]:\t%ld\n", i,
               pIPAddrTable-&gt;table[i].dwIndex);
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwAddr;
        printf("\tIP Address[%d]:     \t%s\n", i, inet_ntoa(IPAddr));
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwMask;
        printf("\tSubnet Mask[%d]:    \t%s\n", i, inet_ntoa(IPAddr));
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwBCastAddr;
        printf("\tBroadCast[%d]:      \t%s (%ld%)\n", i, inet_ntoa(IPAddr),
               pIPAddrTable-&gt;table[i].dwBCastAddr);
        printf("\tReassembly size[%d]:\t%ld\n", i,
               pIPAddrTable-&gt;table[i].dwReasmSize);
        printf("\tType and State[%d]:", i);
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_PRIMARY)
            printf("\tPrimary IP Address");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DYNAMIC)
            printf("\tDynamic IP Address");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DISCONNECTED)
            printf("\tAddress is on disconnected interface");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DELETED)
            printf("\tAddress is being deleted");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_TRANSIENT)
            printf("\tTransient address");
        printf("\n");
    }

    // Call RestoreMediaSense asynchronously to enable mediasense
    dwRetVal = RestoreMediaSense(&amp;amp;amp;amp;amp;amp;Overlapped, &amp;amp;amp;amp;amp;amp;dwEnableCount);
    if (dwRetVal &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; dwRetVal != ERROR_IO_PENDING) {
        printf("RestoreMediaSense failed with error %d\n", dwRetVal);
        exit(1);
    } else {
        printf(" === RestoreMediaSense called ===\n");
        printf("  EnableCount returned was %ld\n\n", dwEnableCount);
    }

    if (pIPAddrTable) {
        // Make an initial call to GetIpAddrTable to get the
        // necessary size into the dwSize variable
        if (GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0) ==
            ERROR_INSUFFICIENT_BUFFER) {
            FREE(pIPAddrTable);
            pIPAddrTable = (MIB_IPADDRTABLE *) MALLOC(dwSize);

        }
        if (pIPAddrTable == NULL) {
            printf("Memory allocation failed for GetIpAddrTable\n");
            exit(1);
        }
    }
    // Make a second call to GetIpAddrTable to get the
    // actual data we want
    if ((dwRetVal = GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0)) != NO_ERROR) {
        printf("GetIpAddrTable failed with error %d\n", dwRetVal);
        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL, dwRetVal,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),  // Default language
                    (LPTSTR) &amp;amp;amp;amp;amp;amp; lpMsgBuf, 0, NULL)) {
            printf("\tError: %s", lpMsgBuf);
            LocalFree(lpMsgBuf);
        }
        exit(1);
    }

    printf("\tNum Entries: %ld\n", pIPAddrTable-&gt;dwNumEntries);
    for (i = 0; i &lt; (int) pIPAddrTable-&gt;dwNumEntries; i++) {
        printf("\n\tInterface Index[%d]:\t%ld\n", i,
               pIPAddrTable-&gt;table[i].dwIndex);
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwAddr;
        printf("\tIP Address[%d]:     \t%s\n", i, inet_ntoa(IPAddr));
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwMask;
        printf("\tSubnet Mask[%d]:    \t%s\n", i, inet_ntoa(IPAddr));
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwBCastAddr;
        printf("\tBroadCast[%d]:      \t%s (%ld%)\n", i, inet_ntoa(IPAddr),
               pIPAddrTable-&gt;table[i].dwBCastAddr);
        printf("\tReassembly size[%d]:\t%ld\n", i,
               pIPAddrTable-&gt;table[i].dwReasmSize);
        printf("\tType and State[%d]:", i);
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_PRIMARY)
            printf("\tPrimary IP Address");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DYNAMIC)
            printf("\tDynamic IP Address");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DISCONNECTED)
            printf("\tAddress is on disconnected interface");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DELETED)
            printf("\tAddress is being deleted");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_TRANSIENT)
            printf("\tTransient address");
        printf("\n");
    }

    if (pIPAddrTable) {
        FREE(pIPAddrTable);
        pIPAddrTable = NULL;
    }

    exit(0);
}

</code>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEvent" />
    <seealso cref="EnableRouter" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="OVERLAPPED" />
    <seealso cref="RestoreMediaSense" />
    <seealso cref="UnenableRouter" />
  </member>
  <member name="Windows.EnableRouter">
    <summary>
      <para>The
<b>EnableRouter</b> function turns on IPv4 forwarding on the local computer.
<b>EnableRouter</b> also increments a reference count that tracks the number of requests to enable IPv4 forwarding.</para>
    </summary>
    <param name="pHandle">
      <para>A pointer to a handle. This parameter is currently unused.</para>
    </param>
    <param name="pOverlapped">
      <para>A pointer to an
<see cref="OVERLAPPED" /> structure. Except for the <b>hEvent</b> member, all members of this structure should be set to zero. The <b>hEvent</b> member should contain a handle to a valid event object. Use the
<see cref="CreateEvent" /> function to create this event object.</para>
    </param>
    <returns>
      <para>If the <b>EnableRouter</b> function succeeds, the return value is ERROR_IO_PENDING.</para>
      <para>If the function fails, use <see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is invalid. This error is returned if the <i>pOverlapped</i> parameter is <b>NULL</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>EnableRouter</b> function is specific to IPv4 forwarding. If the process that calls
<b>EnableRouter</b> terminates without calling
<see cref="UnenableRouter" />, the system  decrements the reference count that tracks the number of requests to enable IPv4 forwarding as though the process had called
<b>UnenableRouter</b>.</para>
    </remarks>
    <seealso cref="CreateEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="OVERLAPPED" />
    <seealso cref="UnenableRouter" />
  </member>
  <member name="Windows.FlushIpNetTable">
    <summary>
      <para>The
<b>FlushIpNetTable</b> function deletes all ARP entries for the specified interface from the ARP table on the local computer.</para>
    </summary>
    <param name="dwIfIndex">
      <para>The index of the interface for which to delete all ARP entries.</para>
    </param>
    <returns>
      <para>The function returns <b>NO_ERROR</b> (zero) if the function is successful.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An input parameter is invalid, no action was taken.  This error is returned if the <i>dwIfIndex</i> parameter is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The IPv4 transport is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>To retrieve the ARP table, call the <see cref="GetIpNetTable" /> function.</para>
      <para>On Windows Vista and later, the <b>FlushIpNetTable</b> function can only be called by a user logged on as a member of the Administrators group. If <b>FlushIpNetTable</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application on Windows Vista and later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>  This function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
    </remarks>
    <seealso cref="CreateIpNetEntry" />
    <seealso cref="GetIfTable" />
    <seealso cref="GetIpNetTable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
  </member>
  <member name="Windows.GetAdapterIndex">
    <summary>
      <para>The
<b>GetAdapterIndex</b> function obtains the index of an adapter, given its name.</para>
    </summary>
    <param name="AdapterName">
      <para>A pointer to a Unicode string that specifies the name of the adapter.</para>
    </param>
    <param name="IfIndex">
      <para>A pointer to a <b>ULONG</b> variable that points to the index of the adapter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
    </returns>
    <remarks>
      <para>Until an adapter is fully disabled, the <b>GetAdapterIndex</b> function reports the adapter as present. For example, the <see cref="NotifyAddrChange" /> function may indicate a recently disabled adapter's IP address is removed, but <b>GetAdapterIndex</b> continues to report an adapter  index until the process of disabling the adapter is complete.</para>
      <para>When one or more adapters are present on the system, <b>GetAdapterIndex</b>  returns ERROR_DEV_NOT_EXIST when the adapter being queried does not exist. When no adapters are present, the <b>GetAdapterIndex</b> function returns ERROR_NO_DATA.</para>
      <para>The adapter index  may change when an adapter is disabled and then enabled, or under other circumstances, and should not be considered persistent.</para>
    </remarks>
    <seealso cref="GetAdaptersInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="IP_ADAPTER_INFO" />
    <seealso cref="MprConfigGetFriendlyName" />
    <seealso cref="MprConfigGetGuidName" />
    <seealso cref="NotifyAddrChange" />
  </member>
  <member name="Windows.GetAdapterOrderMap">
    <summary>
      <para>The <b>GetAdapterOrderMap</b> function obtains an adapter order map that indicates priority for interfaces on the local computer.</para>
    </summary>
    <returns>
      <para>Returns an <see cref="IP_ADAPTER_ORDER_MAP" /> structure filled with adapter priority information.  See the <b>IP_ADAPTER_ORDER_MAP</b> structure for more information.</para>
    </returns>
    <remarks>
      <para>Interface indices appear in the order specified in the Adapters and Bindings dialog box in the Advanced Settings property sheet. This ordering is used as a tie breaker controlling the sequence in which interfaces are used on multihomed systems for situations including route selection, DNS name resolution, and other network related operations.</para>
      <para>This function should not be called directly. Instead, use the <see cref="IP_ADAPTER_INFO" /> structure returned in a <see cref="GetAdaptersInfo" /> function call.</para>
      <para>
        <b>Note</b>  The caller is responsible for calling the <see cref="LocalFree" /> function to free the array returned by <b>GetAdapterOrderMap</b>.</para>
    </remarks>
    <seealso cref="GetAdaptersInfo" />
    <seealso cref="IP_ADAPTER_INFO" />
    <seealso cref="IP_ADAPTER_ORDER_MAP" />
    <seealso cref="LocalFree" />
  </member>
  <member name="Windows.GetAdaptersAddresses">
    <summary>
      <para>The
<b>GetAdaptersAddresses</b> function retrieves the addresses associated with the adapters on the local computer.</para>
    </summary>
    <param name="Family">
      <para>The address family of the addresses to retrieve. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>AF_UNSPEC</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return both IPv4 and IPv6 addresses associated with adapters with IPv4 or IPv6 enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>AF_INET</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return only IPv4 addresses associated with adapters with IPv4 enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>AF_INET6</b>
                </description>
              </item>
              <item>
                <description>23</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return only IPv6 addresses associated with adapters with IPv6 enabled.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="Flags">
      <para>The type of addresses to retrieve. The possible values are defined in the <i>Iptypes.h</i> header file. Note that the <i>Iptypes.h</i> header file is automatically included in <i>Iphlpapi.h</i>, and should never be used directly.</para>
      <para>This parameter is a combination of the following values. If this parameter is zero, then unicast, anycast, and multicast IP addresses will be returned.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GAA_FLAG_SKIP_UNICAST</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not return unicast addresses.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GAA_FLAG_SKIP_ANYCAST</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not return IPv6 anycast addresses.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GAA_FLAG_SKIP_MULTICAST</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not return multicast addresses.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GAA_FLAG_SKIP_DNS_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not return addresses of DNS servers.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GAA_FLAG_INCLUDE_PREFIX</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return a list of IP address prefixes on this adapter. When this flag is set, IP address prefixes are returned for both IPv6 and IPv4 addresses.</para>
            <para>This flag is supported on Windows XP with SP1 and later.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GAA_FLAG_SKIP_FRIENDLY_NAME</b>
                </description>
              </item>
              <item>
                <description>0x0020</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not return the adapter friendly name.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GAA_FLAG_INCLUDE_WINS_INFO</b>
                </description>
              </item>
              <item>
                <description>0x0040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return addresses of Windows Internet Name Service (WINS) servers.</para>
            <para>This flag is supported on Windows Vista and later.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GAA_FLAG_INCLUDE_GATEWAYS</b>
                </description>
              </item>
              <item>
                <description>0x0080</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the addresses of default gateways.</para>
            <para>This flag is supported on Windows Vista and later.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GAA_FLAG_INCLUDE_ALL_INTERFACES</b>
                </description>
              </item>
              <item>
                <description>0x0100</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return addresses for all NDIS interfaces.</para>
            <para>This flag is supported on Windows Vista and later.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GAA_FLAG_INCLUDE_ALL_COMPARTMENTS</b>
                </description>
              </item>
              <item>
                <description>0x0200</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return addresses in all routing compartments.</para>
            <para>This flag is not currently supported and reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GAA_FLAG_INCLUDE_TUNNEL_BINDINGORDER</b>
                </description>
              </item>
              <item>
                <description>0x0400</description>
              </item>
            </list>
          </description>
          <description>
            <para>Return the adapter addresses sorted in tunnel binding order. This flag is supported on Windows Vista and later.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="Reserved">
      <para>This parameter is not currently used, but is reserved for future system use. The calling application should pass <b>NULL</b> for this parameter.</para>
    </param>
    <param name="AdapterAddresses">
      <para>A pointer to a buffer that contains a linked list of <see cref="IP_ADAPTER_ADDRESSES" /> structures on successful return.</para>
    </param>
    <param name="SizePointer">
      <para>A pointer to a variable that specifies the size of the buffer pointed to by <i>AdapterAddresses</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b> (defined to the same value as <b>NO_ERROR</b>).</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ADDRESS_NOT_ASSOCIATED</b>
            </para>
          </description>
          <description>
            <para>An address has not yet been associated with the network endpoint. DHCP lease information was available.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The buffer size indicated by the <i>SizePointer</i> parameter is too small to hold the adapter information or the <i>AdapterAddresses</i> parameter is <b>NULL</b>. The <i>SizePointer</i> parameter returned points to the required size of the buffer to hold the adapter information.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is invalid. This error is returned for any of the following conditions: the <i>SizePointer</i> parameter is <b>NULL</b>, the <i>Address</i> parameter is not <b>AF_INET</b>, <b>AF_INET6</b>, or <b>AF_UNSPEC</b>, or the address information for the parameters requested is greater than <b>ULONG_MAX</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory resources are available to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NO_DATA</b>
            </para>
          </description>
          <description>
            <para>No addresses were found for the requested parameters.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>GetAdaptersAddresses</b> function can retrieve information for IPv4 and IPv6 addresses.</para>
      <para>Addresses are returned as a linked list of <see cref="IP_ADAPTER_ADDRESSES" /> structures in the buffer pointed to by the <i>AdapterAddresses</i> parameter. The application that calls the <b>GetAdaptersAddresses</b> function must allocate the amount of memory needed to return the <b>IP_ADAPTER_ADDRESSES</b> structures pointed to by the <i>AdapterAddresses</i> parameter. When these returned structures are no longer required, the application should free the memory allocated. This can be accomplished by calling the <see cref="HeapAlloc" /> function to allocate memory and later calling the <see cref="HeapFree" /> function to free the allocated memory, as shown in the example code. Other memory allocation and free functions can be used as long as the same family of functions are used for both the allocation and the free function.</para>
      <para>
        <b>GetAdaptersAddresses</b> is implemented only as a synchronous function call.  The <b>GetAdaptersAddresses</b> function requires a significant amount of network resources and time to complete since all of the low-level network interface tables must be traversed.</para>
      <para>One method that can be used to determine the memory needed to return the <see cref="IP_ADAPTER_ADDRESSES" /> structures pointed to by the <i>AdapterAddresses</i> parameter is to pass too small a buffer size as indicated in the <i>SizePointer</i> parameter in the first call to the <b>GetAdaptersAddresses</b> function,  so the function will fail with <b>ERROR_BUFFER_OVERFLOW</b>. When the return value is <b>ERROR_BUFFER_OVERFLOW</b>, the <i>SizePointer</i> parameter returned points to the required size of the buffer to hold the adapter information. Note that it is possible for the buffer size required for the <b>IP_ADAPTER_ADDRESSES</b> structures pointed to by the <i>AdapterAddresses</i> parameter to change between subsequent calls to the <b>GetAdaptersAddresses</b> function if an adapter address is added or removed.   However, this method of using the <b>GetAdaptersAddresses</b> function is strongly discouraged. This method requires calling the <b>GetAdaptersAddresses</b> function multiple times.</para>
      <para>The recommended method of calling the <b>GetAdaptersAddresses</b> function is to pre-allocate a 15KB working buffer pointed to by the <i>AdapterAddresses</i> parameter. On typical computers, this dramatically reduces the chances that the <b>GetAdaptersAddresses</b> function returns <b>ERROR_BUFFER_OVERFLOW</b>, which would require calling  <b>GetAdaptersAddresses</b> function multiple times. The example code illustrates this method of use.</para>
      <para>In versions prior to Windows 10, the order in which adapters appear in the list returned by this function can be controlled from the Network Connections folder: select the Advanced Settings menu item from the Advanced menu. Starting with Windows 10, the order in which adapters appear in the list is determined by the IPv4 or IPv6 route metric.</para>
      <para>If the GAA_FLAG_INCLUDE_ALL_INTERFACES is set, then all NDIS adapters will be retrieved even those addresses associated with adapters not bound to an address family specified in the <i>Family</i> parameter. When this flag is not set, then only the addresses that are bound to an adapter enabled for the address family specified in the <i>Family</i> parameter are returned.</para>
      <para>The size of the <see cref="IP_ADAPTER_ADDRESSES" /> structure was changed on Windows XP with Service Pack 1 (SP1) and later. Several additional members were added to this structure. The size of the <b>IP_ADAPTER_ADDRESSES</b> structure was also changed on Windows Vista and later. A number of additional members were added to this structure. The size of the
<b>IP_ADAPTER_ADDRESSES</b> structure also changed on
Windows Vista with Service Pack 1 (SP1)and later and onWindows Server 2008 and later. One additional member was added to this structure. The <b>Length</b> member of the <b>IP_ADAPTER_ADDRESSES</b> structure returned in the linked list of structures in the buffer pointed to by the <i>AdapterAddresses</i> parameter should be used to determine which version of the <b>IP_ADAPTER_ADDRESSES</b> structure is being used.</para>
      <para>The <see cref="GetIpAddrTable" /> function retrieves the interface–to–IPv4 address mapping table on a local computer and returns this information in an <see cref="MIB_IPADDRTABLE" /> structure.</para>
      <para>On the Platform Software Development Kit (SDK) released for Windows Server 2003 and earlier, the return value for the <b>GetAdaptersAddresses</b> function was defined as a <b>DWORD</b>, rather than a <b>ULONG</b>.</para>
      <para>The <see cref="SOCKET_ADDRESS" /> structure is used in the <see cref="IP_ADAPTER_ADDRESSES" /> structure pointed to by the <i>AdapterAddresses</i> parameter. On the Microsoft Windows Software Development Kit (SDK) released for Windows Vista and later, the organization of header files has changed and the <b>SOCKET_ADDRESS</b> structure is defined in the <i>Ws2def.h</i> header file which is automatically included by the <i>Winsock2.h</i> header file. On the Platform SDK released for Windows Server 2003 and Windows XP, the <b>SOCKET_ADDRESS</b> structure is declared in the <i>Winsock2.h</i> header file. In order to use the <b>IP_ADAPTER_ADDRESSES</b> structure, the <i>Winsock2.h</i> header file must be included before the <i>Iphlpapi.h</i> header file.</para>
      <h4>Examples</h4>
      <para>This example retrieves the <see cref="IP_ADAPTER_ADDRESSES" /> structure for the adapters associated with the system and prints some members  for each adapter interface.</para>
      <code>#include &lt;winsock2.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Link with Iphlpapi.lib
#pragma comment(lib, "IPHLPAPI.lib")

#define WORKING_BUFFER_SIZE 15000
#define MAX_TRIES 3

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int __cdecl main(int argc, char **argv)
{

    /* Declare and initialize variables */

    DWORD dwSize = 0;
    DWORD dwRetVal = 0;

    unsigned int i = 0;

    // Set the flags to pass to GetAdaptersAddresses
    ULONG flags = GAA_FLAG_INCLUDE_PREFIX;

    // default to unspecified address family (both)
    ULONG family = AF_UNSPEC;

    LPVOID lpMsgBuf = NULL;

    PIP_ADAPTER_ADDRESSES pAddresses = NULL;
    ULONG outBufLen = 0;
    ULONG Iterations = 0;

    PIP_ADAPTER_ADDRESSES pCurrAddresses = NULL;
    PIP_ADAPTER_UNICAST_ADDRESS pUnicast = NULL;
    PIP_ADAPTER_ANYCAST_ADDRESS pAnycast = NULL;
    PIP_ADAPTER_MULTICAST_ADDRESS pMulticast = NULL;
    IP_ADAPTER_DNS_SERVER_ADDRESS *pDnServer = NULL;
    IP_ADAPTER_PREFIX *pPrefix = NULL;

    if (argc != 2) {
        printf(" Usage: getadapteraddresses family\n");
        printf("        getadapteraddresses 4 (for IPv4)\n");
        printf("        getadapteraddresses 6 (for IPv6)\n");
        printf("        getadapteraddresses A (for both IPv4 and IPv6)\n");
        exit(1);
    }

    if (atoi(argv[1]) == 4)
        family = AF_INET;
    else if (atoi(argv[1]) == 6)
        family = AF_INET6;

    printf("Calling GetAdaptersAddresses function with family = ");
    if (family == AF_INET)
        printf("AF_INET\n");
    if (family == AF_INET6)
        printf("AF_INET6\n");
    if (family == AF_UNSPEC)
        printf("AF_UNSPEC\n\n");

    // Allocate a 15 KB buffer to start with.
    outBufLen = WORKING_BUFFER_SIZE;

    do {

        pAddresses = (IP_ADAPTER_ADDRESSES *) MALLOC(outBufLen);
        if (pAddresses == NULL) {
            printf
                ("Memory allocation failed for IP_ADAPTER_ADDRESSES struct\n");
            exit(1);
        }

        dwRetVal =
            GetAdaptersAddresses(family, flags, NULL, pAddresses, &amp;amp;amp;amp;amp;amp;outBufLen);

        if (dwRetVal == ERROR_BUFFER_OVERFLOW) {
            FREE(pAddresses);
            pAddresses = NULL;
        } else {
            break;
        }

        Iterations++;

    } while ((dwRetVal == ERROR_BUFFER_OVERFLOW) &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; (Iterations &lt; MAX_TRIES));

    if (dwRetVal == NO_ERROR) {
        // If successful, output some information from the data we received
        pCurrAddresses = pAddresses;
        while (pCurrAddresses) {
            printf("\tLength of the IP_ADAPTER_ADDRESS struct: %ld\n",
                   pCurrAddresses-&gt;Length);
            printf("\tIfIndex (IPv4 interface): %u\n", pCurrAddresses-&gt;IfIndex);
            printf("\tAdapter name: %s\n", pCurrAddresses-&gt;AdapterName);

            pUnicast = pCurrAddresses-&gt;FirstUnicastAddress;
            if (pUnicast != NULL) {
                for (i = 0; pUnicast != NULL; i++)
                    pUnicast = pUnicast-&gt;Next;
                printf("\tNumber of Unicast Addresses: %d\n", i);
            } else
                printf("\tNo Unicast Addresses\n");

            pAnycast = pCurrAddresses-&gt;FirstAnycastAddress;
            if (pAnycast) {
                for (i = 0; pAnycast != NULL; i++)
                    pAnycast = pAnycast-&gt;Next;
                printf("\tNumber of Anycast Addresses: %d\n", i);
            } else
                printf("\tNo Anycast Addresses\n");

            pMulticast = pCurrAddresses-&gt;FirstMulticastAddress;
            if (pMulticast) {
                for (i = 0; pMulticast != NULL; i++)
                    pMulticast = pMulticast-&gt;Next;
                printf("\tNumber of Multicast Addresses: %d\n", i);
            } else
                printf("\tNo Multicast Addresses\n");

            pDnServer = pCurrAddresses-&gt;FirstDnsServerAddress;
            if (pDnServer) {
                for (i = 0; pDnServer != NULL; i++)
                    pDnServer = pDnServer-&gt;Next;
                printf("\tNumber of DNS Server Addresses: %d\n", i);
            } else
                printf("\tNo DNS Server Addresses\n");

            printf("\tDNS Suffix: %wS\n", pCurrAddresses-&gt;DnsSuffix);
            printf("\tDescription: %wS\n", pCurrAddresses-&gt;Description);
            printf("\tFriendly name: %wS\n", pCurrAddresses-&gt;FriendlyName);

            if (pCurrAddresses-&gt;PhysicalAddressLength != 0) {
                printf("\tPhysical address: ");
                for (i = 0; i &lt; (int) pCurrAddresses-&gt;PhysicalAddressLength;
                     i++) {
                    if (i == (pCurrAddresses-&gt;PhysicalAddressLength - 1))
                        printf("%.2X\n",
                               (int) pCurrAddresses-&gt;PhysicalAddress[i]);
                    else
                        printf("%.2X-",
                               (int) pCurrAddresses-&gt;PhysicalAddress[i]);
                }
            }
            printf("\tFlags: %ld\n", pCurrAddresses-&gt;Flags);
            printf("\tMtu: %lu\n", pCurrAddresses-&gt;Mtu);
            printf("\tIfType: %ld\n", pCurrAddresses-&gt;IfType);
            printf("\tOperStatus: %ld\n", pCurrAddresses-&gt;OperStatus);
            printf("\tIpv6IfIndex (IPv6 interface): %u\n",
                   pCurrAddresses-&gt;Ipv6IfIndex);
            printf("\tZoneIndices (hex): ");
            for (i = 0; i &lt; 16; i++)
                printf("%lx ", pCurrAddresses-&gt;ZoneIndices[i]);
            printf("\n");

            printf("\tTransmit link speed: %I64u\n", pCurrAddresses-&gt;TransmitLinkSpeed);
            printf("\tReceive link speed: %I64u\n", pCurrAddresses-&gt;ReceiveLinkSpeed);

            pPrefix = pCurrAddresses-&gt;FirstPrefix;
            if (pPrefix) {
                for (i = 0; pPrefix != NULL; i++)
                    pPrefix = pPrefix-&gt;Next;
                printf("\tNumber of IP Adapter Prefix entries: %d\n", i);
            } else
                printf("\tNumber of IP Adapter Prefix entries: 0\n");

            printf("\n");

            pCurrAddresses = pCurrAddresses-&gt;Next;
        }
    } else {
        printf("Call to GetAdaptersAddresses failed with error: %d\n",
               dwRetVal);
        if (dwRetVal == ERROR_NO_DATA)
            printf("\tNo addresses were found for the requested parameters\n");
        else {

            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL, dwRetVal, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    // Default language
                    (LPTSTR) &amp;amp;amp;amp;amp;amp; lpMsgBuf, 0, NULL)) {
                printf("\tError: %s", lpMsgBuf);
                LocalFree(lpMsgBuf);
                if (pAddresses)
                    FREE(pAddresses);
                exit(1);
            }
        }
    }

    if (pAddresses) {
        FREE(pAddresses);
    }

    return 0;
}

</code>
    </remarks>
    <seealso cref="GetIpAddrTable" />
    <seealso cref="HeapAlloc" />
    <seealso cref="HeapFree" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="IP_ADAPTER_ADDRESSES" />
    <seealso cref="MIB_IPADDRTABLE" />
    <seealso cref="SOCKET_ADDRESS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/WinSock/windows-sockets-start-page-2">Windows Sockets</seealso>
  </member>
  <member name="Windows.GetAdaptersInfo">
    <summary>
      <para>The
<b>GetAdaptersInfo</b> function retrieves adapter information for the local computer.</para>
      <para>
        <b>On Windows XP and later:  </b>Use the <see cref="GetAdaptersAddresses" /> function instead of <b>GetAdaptersInfo</b>.</para>
    </summary>
    <param name="AdapterInfo">
      <para>A pointer to a buffer that receives a linked list of
<see cref="IP_ADAPTER_INFO" /> structures.</para>
    </param>
    <param name="SizePointer">
      <para>A pointer to a <b>ULONG</b> variable that specifies the size of the buffer pointed to by the <i>pAdapterInfo</i> parameter. If this size is insufficient to hold the adapter information,
<b>GetAdaptersInfo</b> fills in this variable with the required size, and returns an error code of <b>ERROR_BUFFER_OVERFLOW</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b> (defined to the same value as <b>NO_ERROR</b>).</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The buffer to receive the adapter information is too small. This value is returned if the buffer size indicated by the <i>pOutBufLen</i> parameter is too small to hold the adapter information or the <i>pAdapterInfo</i> parameter was a <b>NULL</b> pointer. When this error code is returned, the <i>pOutBufLen</i> parameter points to the required buffer size.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_DATA</b>
            </para>
          </description>
          <description>
            <para>Invalid adapter information was retrieved.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is invalid. This error is returned if the  <i>pOutBufLen</i> parameter is a <b>NULL</b> pointer, or the calling process does not have read/write access to the memory pointed to by <i>pOutBufLen</i> or the calling process does not have write access to the memory pointed to by the <i>pAdapterInfo</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NO_DATA</b>
            </para>
          </description>
          <description>
            <para>No adapter information exists for the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The <see cref="GetAdaptersInfo" /> function is not supported by the operating system running on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetAdaptersInfo</b> function can retrieve information only for IPv4 addresses.</para>
      <para>In versions prior to Windows 10, the order in which adapters appear in the list returned by this function can be controlled from the Network Connections folder: select the Advanced Settings menu item from the Advanced menu. Starting with Windows 10, the order is unspecified.</para>
      <para>The
<b>GetAdaptersInfo</b> and
<see cref="GetInterfaceInfo" /> functions do not return information about the IPv4 loopback interface. Information on the loopback interface is returned by the <see cref="GetIpAddrTable" /> function.</para>
      <para>
        <b>On Windows XP and later:  </b>The list of adapters returned by
<b>GetAdaptersInfo</b> includes unidirectional adapters. To generate a list of adapters that can both send and receive data, call
<see cref="GetUniDirectionalAdapterInfo" />, and exclude the returned adapters from the list returned by
<b>GetAdaptersInfo</b>.</para>
      <h4>Examples</h4>
      <para>This example retrieves the adapter information and prints various properties of each adapter.</para>
      <code>#include &lt;winsock2.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#pragma comment(lib, "IPHLPAPI.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int __cdecl main()
{

    /* Declare and initialize variables */

// It is possible for an adapter to have multiple
// IPv4 addresses, gateways, and secondary WINS servers
// assigned to the adapter.
//
// Note that this sample code only prints out the
// first entry for the IP address/mask, and gateway, and
// the primary and secondary WINS server for each adapter.

    PIP_ADAPTER_INFO pAdapterInfo;
    PIP_ADAPTER_INFO pAdapter = NULL;
    DWORD dwRetVal = 0;
    UINT i;

/* variables used to print DHCP time info */
    struct tm newtime;
    char buffer[32];
    errno_t error;

    ULONG ulOutBufLen = sizeof (IP_ADAPTER_INFO);
    pAdapterInfo = (IP_ADAPTER_INFO *) MALLOC(sizeof (IP_ADAPTER_INFO));
    if (pAdapterInfo == NULL) {
        printf("Error allocating memory needed to call GetAdaptersinfo\n");
        return 1;
    }
// Make an initial call to GetAdaptersInfo to get
// the necessary size into the ulOutBufLen variable
    if (GetAdaptersInfo(pAdapterInfo, &amp;amp;amp;amp;amp;amp;ulOutBufLen) == ERROR_BUFFER_OVERFLOW) {
        FREE(pAdapterInfo);
        pAdapterInfo = (IP_ADAPTER_INFO *) MALLOC(ulOutBufLen);
        if (pAdapterInfo == NULL) {
            printf("Error allocating memory needed to call GetAdaptersinfo\n");
            return 1;
        }
    }

    if ((dwRetVal = GetAdaptersInfo(pAdapterInfo, &amp;amp;amp;amp;amp;amp;ulOutBufLen)) == NO_ERROR) {
        pAdapter = pAdapterInfo;
        while (pAdapter) {
            printf("\tComboIndex: \t%d\n", pAdapter-&gt;ComboIndex);
            printf("\tAdapter Name: \t%s\n", pAdapter-&gt;AdapterName);
            printf("\tAdapter Desc: \t%s\n", pAdapter-&gt;Description);
            printf("\tAdapter Addr: \t");
            for (i = 0; i &lt; pAdapter-&gt;AddressLength; i++) {
                if (i == (pAdapter-&gt;AddressLength - 1))
                    printf("%.2X\n", (int) pAdapter-&gt;Address[i]);
                else
                    printf("%.2X-", (int) pAdapter-&gt;Address[i]);
            }
            printf("\tIndex: \t%d\n", pAdapter-&gt;Index);
            printf("\tType: \t");
            switch (pAdapter-&gt;Type) {
            case MIB_IF_TYPE_OTHER:
                printf("Other\n");
                break;
            case MIB_IF_TYPE_ETHERNET:
                printf("Ethernet\n");
                break;
            case MIB_IF_TYPE_TOKENRING:
                printf("Token Ring\n");
                break;
            case MIB_IF_TYPE_FDDI:
                printf("FDDI\n");
                break;
            case MIB_IF_TYPE_PPP:
                printf("PPP\n");
                break;
            case MIB_IF_TYPE_LOOPBACK:
                printf("Lookback\n");
                break;
            case MIB_IF_TYPE_SLIP:
                printf("Slip\n");
                break;
            default:
                printf("Unknown type %ld\n", pAdapter-&gt;Type);
                break;
            }

            printf("\tIP Address: \t%s\n",
                   pAdapter-&gt;IpAddressList.IpAddress.String);
            printf("\tIP Mask: \t%s\n", pAdapter-&gt;IpAddressList.IpMask.String);

            printf("\tGateway: \t%s\n", pAdapter-&gt;GatewayList.IpAddress.String);
            printf("\t***\n");

            if (pAdapter-&gt;DhcpEnabled) {
                printf("\tDHCP Enabled: Yes\n");
                printf("\t  DHCP Server: \t%s\n",
                       pAdapter-&gt;DhcpServer.IpAddress.String);

                printf("\t  Lease Obtained: ");
                /* Display local time */
                error = _localtime32_s(&amp;amp;amp;amp;amp;amp;newtime, (__time32_t*) &amp;amp;amp;amp;amp;amp;pAdapter-&gt;LeaseObtained);
                if (error)
                    printf("Invalid Argument to _localtime32_s\n");
                else {
                    // Convert to an ASCII representation
                    error = asctime_s(buffer, 32, &amp;amp;amp;amp;amp;amp;newtime);
                    if (error)
                        printf("Invalid Argument to asctime_s\n");
                    else
                        /* asctime_s returns the string terminated by \n\0 */
                        printf("%s", buffer);
                }

                printf("\t  Lease Expires:  ");
                error = _localtime32_s(&amp;amp;amp;amp;amp;amp;newtime, (__time32_t*) &amp;amp;amp;amp;amp;amp;pAdapter-&gt;LeaseExpires);
                if (error)
                    printf("Invalid Argument to _localtime32_s\n");
                else {
                    // Convert to an ASCII representation
                    error = asctime_s(buffer, 32, &amp;amp;amp;amp;amp;amp;newtime);
                    if (error)
                        printf("Invalid Argument to asctime_s\n");
                    else
                        /* asctime_s returns the string terminated by \n\0 */
                        printf("%s", buffer);
                }
            } else
                printf("\tDHCP Enabled: No\n");

            if (pAdapter-&gt;HaveWins) {
                printf("\tHave Wins: Yes\n");
                printf("\t  Primary Wins Server:    %s\n",
                       pAdapter-&gt;PrimaryWinsServer.IpAddress.String);
                printf("\t  Secondary Wins Server:  %s\n",
                       pAdapter-&gt;SecondaryWinsServer.IpAddress.String);
            } else
                printf("\tHave Wins: No\n");
            pAdapter = pAdapter-&gt;Next;
            printf("\n");
        }
    } else {
        printf("GetAdaptersInfo failed with error: %d\n", dwRetVal);

    }
    if (pAdapterInfo)
        FREE(pAdapterInfo);

    return 0;
}

</code>
    </remarks>
    <seealso cref="GetAdaptersAddresses" />
    <seealso cref="GetInterfaceInfo" />
    <seealso cref="GetIpAddrTable" />
    <seealso cref="GetNumberOfInterfaces" />
    <seealso cref="GetUniDirectionalAdapterInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="IP_ADAPTER_INFO" />
  </member>
  <member name="Windows.GetBestInterface">
    <summary>
      <para>The
<b>GetBestInterface</b> function retrieves the index of the interface that has the best route to the specified IPv4 address.</para>
    </summary>
    <param name="dwDestAddr">
      <para>The destination IPv4 address for which to retrieve the interface that has the best route, in the form of an <see cref="IPAddr" /> structure.</para>
    </param>
    <param name="pdwBestIfIndex">
      <para>A pointer to a <b>DWORD</b> variable that receives the index of the interface that has the best route to the IPv4 address specified by <i>dwDestAddr</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_CAN_NOT_COMPLETE</b>
            </para>
          </description>
          <description>
            <para>The operation could not be completed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>pdwBestIfIndex</i> parameter or if the <i>pdwBestIfIndex</i> points to memory that cannot be written.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported. This error is returned if no IPv4 stack is on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
the <see cref="FormatMessage" /> function to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetBestInterface</b> function only works with IPv4 addresses. For use with IPv6 addresses, the <see cref="GetBestInterfaceEx" /> must be used.</para>
      <para>For information about the <b>IPAddr</b> data type, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">Windows Data Types</a>. To convert an IP address between dotted decimal notation and <b>IPAddr</b> format, use the
<see cref="inet_addr" /> and
<see cref="inet_ntoa" /> functions.</para>
      <para>On Windows Vista and later, the <i>pdwBestIfIndex</i> parameter is treated internally by IP Helper as a pointer to a <b>NET_IFINDEX</b> datatype.</para>
    </remarks>
    <seealso cref="GetBestInterfaceEx" />
    <seealso cref="GetBestRoute" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="IPAddr" />
    <seealso cref="MIB_BEST_IF" />
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">Windows Data Types</seealso>
  </member>
  <member name="Windows.GetBestInterfaceEx">
    <summary>
      <para>The
<b>GetBestInterfaceEx</b> function retrieves the index of the interface that has the best route to the specified IPv4 or IPv6 address.</para>
    </summary>
    <param name="pDestAddr">
      <para>The destination IPv6 or IPv4 address for which to retrieve the interface with the best route, in the form of a <a href="https://docs.microsoft.com//windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure.</para>
    </param>
    <param name="pdwBestIfIndex">
      <para>A pointer to the index of the interface with the best route to the IPv6 or IPv4 address specified by <i>pDestAddr</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_CAN_NOT_COMPLETE</b>
            </para>
          </description>
          <description>
            <para>The operation could not be completed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>pdwBestIfIndex</i> parameter or if the <i>pDestAddr </i> or <i>pdwBestIfIndex</i> parameters point to memory that cannot be accessed. This error can also be returned if the <i>pdwBestIfIndex</i> parameter points to memory that can't be written to.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported. This error is returned if no IPv4 stack is on the local computer and an IPv4 address was specified in the <i>pDestAddr</i> parameter or no IPv6 stack is on the local computer and an IPv6 address was specified in the <i>pDestAddr</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
the <see cref="FormatMessage" /> function to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetBestInterfaceEx</b> function differs from the <see cref="GetBestInterface" /> function in that it can be used with either IPv4 or IPv6 addresses.</para>
      <para>The <b>Family</b> member of the sockaddr structure pointed to by the <i>pDestAddr</i> parameter must be set to one of the following values: <b>AF_INET</b> or <b>AF_INET6</b>.</para>
      <para>On Windows Vista and later, the <i>pdwBestIfIndex</i> parameter is treated internally by IP Helper as a pointer to a <b>NET_IFINDEX</b> datatype.</para>
    </remarks>
    <seealso cref="GetBestInterface" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_BEST_IF" />
    <seealso href="https://docs.microsoft.com//windows/desktop/WinSock/sockaddr-2">sockaddr</seealso>
  </member>
  <member name="Windows.GetBestRoute">
    <summary>
      <para>The
<b>GetBestRoute</b> function retrieves the best route to the specified destination IP address.</para>
    </summary>
    <param name="dwDestAddr">
      <para>Destination IP address for which to obtain the best route.</para>
    </param>
    <param name="dwSourceAddr">
      <para>Source IP address. This IP address corresponds to an interface on the local computer. If multiple best routes to the destination address exist, the function selects the route that uses this interface.</para>
      <para>This parameter is optional. The caller may specify zero for this parameter.</para>
    </param>
    <param name="pBestRoute">
      <para>Pointer to a
<see cref="MIB_IPFORWARDROW" /> structure containing the best route for the IP address specified by <i>dwDestAddr</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
    </returns>
    <seealso cref="GetBestInterface" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPFORWARDROW" />
  </member>
  <member name="Windows.GetFriendlyIfIndex">
    <summary>
      <para>The
<b>GetFriendlyIfIndex</b> function takes an interface index and returns a backward-compatible interface index, that is, an index that uses only the lower 24 bits.</para>
    </summary>
    <param name="IfIndex">
      <para>The interface index from which the backward-compatible or "friendly" interface index is derived.</para>
    </param>
    <returns>
      <para>A backward-compatible interface index that uses only the lower 24 bits.</para>
    </returns>
    <seealso cref="GetIfEntry" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IFROW" />
  </member>
  <member name="Windows.GetIcmpStatistics">
    <summary>
      <para>The
<b>GetIcmpStatistics</b> function retrieves the Internet Control Message Protocol (ICMP) for IPv4 statistics for the local computer.</para>
    </summary>
    <param name="Statistics">
      <para>A pointer to a
<see cref="MIB_ICMP" /> structure that receives the ICMP statistics for the local computer.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pStats</i> parameter is <b>NULL</b>, or
<see cref="GetIcmpStatistics" /> is unable to write to the memory pointed to by the <i>pStats</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
the <see cref="FormatMessage" /> function to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>GetIcmpStatistics</b> function returns the ICMP statistics for IPv4 on the local computer.     On Windows XP and later, the <see cref="GetIpStatisticsEx" /> can be used to obtain the ICMP statistics for either IPv4 or IPv6 on the local computer.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the ICMP for IPv4 statistics for the local computer and prints some information from the returned data.</para>
      <code>#ifndef UNICODE
#define UNICODE
#endif

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "iphlpapi.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int main()
{

    DWORD dwRetVal = 0;
    PMIB_ICMP pIcmpStats;

    pIcmpStats = (MIB_ICMP *) MALLOC(sizeof (MIB_ICMP));
    if (pIcmpStats == NULL) {
        wprintf(L"Error allocating memory\n");
        return 1;
    }

    dwRetVal = GetIcmpStatistics(pIcmpStats);
    if (dwRetVal == NO_ERROR) {
        wprintf(L"Number of incoming ICMP messages: %ld\n",
                pIcmpStats-&gt;stats.icmpInStats.dwMsgs);
        wprintf(L"Number of incoming ICMP errors received: %ld\n",
                pIcmpStats-&gt;stats.icmpInStats.dwErrors);
        wprintf(L"Number of outgoing ICMP messages: %ld\n",
                pIcmpStats-&gt;stats.icmpOutStats.dwMsgs);
        wprintf(L"Number of outgoing ICMP errors sent: %ld\n",
                pIcmpStats-&gt;stats.icmpOutStats.dwErrors);
    } else {
        wprintf(L"GetIcmpStatistics failed with error: %ld\n", dwRetVal);
    }

    if (pIcmpStats)
        FREE(pIcmpStats);

    return 0;
}

</code>
    </remarks>
    <seealso cref="GetIpStatistics" />
    <seealso cref="GetIpStatisticsEx" />
    <seealso cref="GetTcpStatistics" />
    <seealso cref="GetUdpStatistics" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_ICMP" />
  </member>
  <member name="Windows.GetIcmpStatisticsEx">
    <summary>
      <para>The <b>GetIcmpStatisticsEx</b> function retrieves  Internet Control Message Protocol (ICMP) statistics for the local computer. The <b>GetIcmpStatisticsEx</b> function is capable of retrieving IPv6 ICMP statistics.</para>
    </summary>
    <param name="Statistics">
      <para>A pointer to a
<see cref="MIB_ICMP_EX" /> structure that contains ICMP statistics for the local computer.</para>
    </param>
    <param name="Family">
      <para>The protocol family for which to retrieve ICMP statistics. Must be one of the following:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>AF_INET</b>
          </description>
          <description>
            <para>Internet Protocol version 4 (IPv4).</para>
          </description>
        </item>
        <item>
          <description>
            <b>AF_INET6</b>
          </description>
          <description>
            <para>Internet Protocol version 6 (IPv6).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pStats</i> parameter is <b>NULL</b> or does not point to valid memory, or the <i>dwFamily</i> parameter is not a valid value.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system on which the function call was made.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <see cref="GetIpStatisticsEx" /> can be used to obtain the ICMP statistics for either IPv4 or IPv6 on the local computer.</para>
      <para>The
<see cref="GetIcmpStatistics" /> function returns the ICMP statistics for only IPv4 on the local computer.</para>
    </remarks>
    <seealso cref="GetIcmpStatistics" />
    <seealso cref="GetTcpStatisticsEx" />
    <seealso cref="GetUdpStatisticsEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_ICMP_EX" />
  </member>
  <member name="Windows.GetIfEntry">
    <summary>
      <para>The
<b>GetIfEntry</b> function retrieves information for the specified interface on the local computer.</para>
    </summary>
    <param name="pIfRow">
      <para>A pointer to a
<see cref="MIB_IFROW" /> structure that, on successful return, receives information for an interface on the local computer. On input, set the <b>dwIndex</b> member of <b>MIB_IFROW</b> to the index of the interface for which to retrieve information. The value for the <b>dwIndex</b> must be retrieved by a previous call to the <see cref="GetIfTable" />, <see cref="GetIfTable2" />, or <see cref="GetIfTable2Ex" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_CAN_NOT_COMPLETE</b>
            </para>
          </description>
          <description>
            <para>The request could not be completed. This is an internal error.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_DATA</b>
            </para>
          </description>
          <description>
            <para>The data is invalid. This error is returned if the  network interface index specified by the <b>dwIndex</b>  member of the <see cref="MIB_IFROW" /> structure pointed to by the <i>pIfRow</i> parameter is not a valid interface index on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>pIfRow</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified interface could not be found. This error is returned if the  network interface index specified by the <b>dwIndex</b>  member of the <see cref="MIB_IFROW" /> structure pointed to by the <i>pIfRow</i> parameter could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported. This error is returned if IPv4 is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetIfEntry</b> function retrieves information for an interface on a local computer.</para>
      <para>The <b>dwIndex</b> member in the <see cref="MIB_IFROW" /> structure pointed to by the <i>pIfRow</i> parameter must be initialized to a valid network interface index retrieved by a previous call to the <see cref="GetIfTable" />, <see cref="GetIfTable2" />, or <see cref="GetIfTable2Ex" /> function.</para>
      <para>The <b>GetIfEntry</b> function will fail if the  <b>dwIndex</b>  member of the <see cref="MIB_IFROW" /> pointed to by the <i>pIfRow</i> parameter does not match an existing interface index on the local computer.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the entries from the interface table and prints some of the information available for that  entry.</para>
      <code>#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#pragma comment(lib, "IPHLPAPI.lib")

#include &lt;iphlpapi.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int main()
{

    // Declare and initialize variables.

    // Declare and initialize variables.
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;

    unsigned int i, j;

    /* variables used for GetIfTable and GetIfEntry */
    MIB_IFTABLE *pIfTable;
    MIB_IFROW *pIfRow;

    // Allocate memory for our pointers.
    pIfTable = (MIB_IFTABLE *) MALLOC(sizeof (MIB_IFTABLE));
    if (pIfTable == NULL) {
        printf("Error allocating memory needed to call GetIfTable\n");
        exit (1);
    }
    // Before calling GetIfEntry, we call GetIfTable to make
    // sure there are entries to get and retrieve the interface index.

    // Make an initial call to GetIfTable to get the
    // necessary size into dwSize
    dwSize = sizeof (MIB_IFTABLE);
    if (GetIfTable(pIfTable, &amp;amp;amp;amp;amp;amp;dwSize, 0) == ERROR_INSUFFICIENT_BUFFER) {
        FREE(pIfTable);
        pIfTable = (MIB_IFTABLE *) MALLOC(dwSize);
        if (pIfTable == NULL) {
            printf("Error allocating memory\n");
            exit (1);
        }
    }
    // Make a second call to GetIfTable to get the actual
    // data we want.
    if ((dwRetVal = GetIfTable(pIfTable, &amp;amp;amp;amp;amp;amp;dwSize, 0)) == NO_ERROR) {
        if (pIfTable-&gt;dwNumEntries &gt; 0) {
            pIfRow = (MIB_IFROW *) MALLOC(sizeof (MIB_IFROW));
            if (pIfRow == NULL) {
                printf("Error allocating memory\n");
                if (pIfTable != NULL) {
                    FREE(pIfTable);
                    pIfTable = NULL;
                }
                exit (1);
            }

            printf("\tNum Entries: %ld\n\n", pIfTable-&gt;dwNumEntries);
            for (i = 0; i &lt; pIfTable-&gt;dwNumEntries; i++) {
                pIfRow-&gt;dwIndex = pIfTable-&gt;table[i].dwIndex;
                if ((dwRetVal = GetIfEntry(pIfRow)) == NO_ERROR) {
                    printf("\tIndex:\t %ld\n", pIfRow-&gt;dwIndex);
                    printf("\tInterfaceName[%d]:\t ", i);
                    if (pIfRow-&gt;wszName != NULL)
                        printf("%ws", pIfRow-&gt;wszName);
                    printf("\n");

                    printf("\tDescription[%d]:\t ", i);
                    for (j = 0; j &lt; pIfRow-&gt;dwDescrLen; j++)
                        printf("%c", pIfRow-&gt;bDescr[j]);
                    printf("\n");

                    printf("\tIndex[%d]:\t\t %d\n", i, pIfRow-&gt;dwIndex);

                    printf("\tType[%d]:\t\t ", i);
                    switch (pIfRow-&gt;dwType) {
                    case IF_TYPE_OTHER:
                        printf("Other\n");
                        break;
                    case IF_TYPE_ETHERNET_CSMACD:
                        printf("Ethernet\n");
                        break;
                    case IF_TYPE_ISO88025_TOKENRING:
                        printf("Token Ring\n");
                        break;
                    case IF_TYPE_PPP:
                        printf("PPP\n");
                        break;
                    case IF_TYPE_SOFTWARE_LOOPBACK:
                        printf("Software Lookback\n");
                        break;
                    case IF_TYPE_ATM:
                        printf("ATM\n");
                        break;
                    case IF_TYPE_IEEE80211:
                        printf("IEEE 802.11 Wireless\n");
                        break;
                    case IF_TYPE_TUNNEL:
                        printf("Tunnel type encapsulation\n");
                        break;
                    case IF_TYPE_IEEE1394:
                        printf("IEEE 1394 Firewire\n");
                        break;
                    default:
                        printf("Unknown type %ld\n", pIfRow-&gt;dwType);
                        break;
                    }

                    printf("\tMtu[%d]:\t\t %ld\n", i, pIfRow-&gt;dwMtu);

                    printf("\tSpeed[%d]:\t\t %ld\n", i, pIfRow-&gt;dwSpeed);

                    printf("\tPhysical Addr:\t\t ");
                    if (pIfRow-&gt;dwPhysAddrLen == 0)
                        printf("\n");
//                    for (j = 0; j &lt; (int) pIfRow-&gt;dwPhysAddrLen; j++) {
                    for (j = 0; j &lt; pIfRow-&gt;dwPhysAddrLen; j++) {
                        if (j == (pIfRow-&gt;dwPhysAddrLen - 1))
                            printf("%.2X\n", (int) pIfRow-&gt;bPhysAddr[j]);
                        else
                            printf("%.2X-", (int) pIfRow-&gt;bPhysAddr[j]);
                    }
                    printf("\tAdmin Status[%d]:\t %ld\n", i,
                           pIfRow-&gt;dwAdminStatus);

                    printf("\tOper Status[%d]:\t ", i);
                    switch (pIfRow-&gt;dwOperStatus) {
                    case IF_OPER_STATUS_NON_OPERATIONAL:
                        printf("Non Operational\n");
                        break;
                    case IF_OPER_STATUS_UNREACHABLE:
                        printf("Unreasonable\n");
                        break;
                    case IF_OPER_STATUS_DISCONNECTED:
                        printf("Disconnected\n");
                        break;
                    case IF_OPER_STATUS_CONNECTING:
                        printf("Connecting\n");
                        break;
                    case IF_OPER_STATUS_CONNECTED:
                        printf("Connected\n");
                        break;
                    case IF_OPER_STATUS_OPERATIONAL:
                        printf("Operational\n");
                        break;
                    default:
                        printf("Unknown status %ld\n",
                            pIfRow-&gt;dwOperStatus);
                        break;
                    }
                    printf("\n");
                }

                else {
                    printf("GetIfEntry failed for index %d with error: %ld\n",
                           i, dwRetVal);
                    // Here you can use FormatMessage to find out why
                    // it failed.

                }
            }
        } else {
            printf("\tGetIfTable failed with error: %ld\n", dwRetVal);
        }

    }

    exit (0);
}

</code>
    </remarks>
    <seealso cref="GetIfEntry2" />
    <seealso cref="GetIfTable" />
    <seealso cref="GetIfTable2" />
    <seealso cref="GetIfTable2Ex" />
    <seealso cref="GetNumberOfInterfaces" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso cref="MIB_IFROW" />
    <seealso cref="MIB_IFTABLE" />
    <seealso cref="MIB_IF_ROW2" />
    <seealso cref="MIB_IF_TABLE2" />
  </member>
  <member name="Windows.GetIfTable">
    <summary>
      <para>The
<b>GetIfTable</b> function retrieves the MIB-II interface table.</para>
    </summary>
    <param name="pIfTable">
      <para>A pointer to a buffer that receives the interface table as a
<see cref="MIB_IFTABLE" /> structure.</para>
    </param>
    <param name="pdwSize">
      <para>On input, specifies the size in bytes of the buffer pointed to by the <i>pIfTable</i> parameter.</para>
      <para>On output, if the buffer is not large enough to hold the returned interface table, the function sets this parameter equal to the required buffer size in bytes.</para>
    </param>
    <param name="bOrder">
      <para>A Boolean value that specifies whether the returned interface table should be sorted in ascending order by interface index. If this parameter is <b>TRUE</b>, the table is sorted.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer pointed to by the <i>pIfTable</i> parameter is not large enough. The required size is returned in the <b>DWORD</b> variable pointed to by the <i>pdwSize</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pdwSize</i> parameter is <b>NULL</b>, or
<see cref="GetIfTable" /> is unable to write to the memory pointed to by the <i>pdwSize</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system in use on the local system.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
the <see cref="FormatMessage" /> function to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>GetIfTable</b> function enumerates physical interfaces on a local system and returns this information in a <see cref="MIB_IFTABLE" /> structure. The physical interfaces include the software loopback interface.</para>
      <para>The <see cref="GetIfTable2" /> and <see cref="GetIfTable2Ex" /> functions available on Windows Vista and later are an enhanced version of the <b>GetIfTable</b> function that enumerate both the physical and logical interfaces on a local system. Logical interfaces include various WAN Miniport interfaces used for L2TP, PPTP, PPOE, and other tunnel encapsulations.</para>
      <para>Interfaces are returned in a <see cref="MIB_IFTABLE" /> structure in the buffer pointed to by the <i>pIfTable</i> parameter. The <b>MIB_IFTABLE</b> structure contains an interface count and an array of <see cref="MIB_IFROW" /> structures for each interface.</para>
      <para>Note that the returned <see cref="MIB_IFTABLE" /> structure pointed to by the <i>pIfTable</i> parameter may contain padding for alignment between the <b>dwNumEntries</b> member and the first <see cref="MIB_IFROW" /> array entry in the <b>table</b> member of the <b>MIB_IFTABLE</b> structure. Padding for alignment may also be present between the <b>MIB_IFROW</b> array entries. Any access to a <b>MIB_IFROW</b> array entry should assume  padding may exist.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the interface table and prints the number of entries in the table and some data on each entry.</para>
      <code>#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#pragma comment(lib, "IPHLPAPI.lib")

#include &lt;iphlpapi.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int main()
{

    // Declare and initialize variables.

    DWORD dwSize = 0;
    DWORD dwRetVal = 0;

    unsigned int i, j;

    /* variables used for GetIfTable and GetIfEntry */
    MIB_IFTABLE *pIfTable;
    MIB_IFROW *pIfRow;

    // Allocate memory for our pointers.
    pIfTable = (MIB_IFTABLE *) MALLOC(sizeof (MIB_IFTABLE));
    if (pIfTable == NULL) {
        printf("Error allocating memory needed to call GetIfTable\n");
        return 1;
    }
    // Make an initial call to GetIfTable to get the
    // necessary size into dwSize
    dwSize = sizeof (MIB_IFTABLE);
    if (GetIfTable(pIfTable, &amp;amp;amp;amp;amp;amp;dwSize, FALSE) == ERROR_INSUFFICIENT_BUFFER) {
        FREE(pIfTable);
        pIfTable = (MIB_IFTABLE *) MALLOC(dwSize);
        if (pIfTable == NULL) {
            printf("Error allocating memory needed to call GetIfTable\n");
            return 1;
        }
    }
    // Make a second call to GetIfTable to get the actual
    // data we want.
    if ((dwRetVal = GetIfTable(pIfTable, &amp;amp;amp;amp;amp;amp;dwSize, FALSE)) == NO_ERROR) {
        printf("\tNum Entries: %ld\n\n", pIfTable-&gt;dwNumEntries);
        for (i = 0; i &lt; pIfTable-&gt;dwNumEntries; i++) {
            pIfRow = (MIB_IFROW *) &amp;amp;amp;amp;amp;amp; pIfTable-&gt;table[i];
            printf("\tIndex[%d]:\t %ld\n", i, pIfRow-&gt;dwIndex);
            printf("\tInterfaceName[%d]:\t %ws", i, pIfRow-&gt;wszName);
            printf("\n");
            printf("\tDescription[%d]:\t ", i);
            for (j = 0; j &lt; pIfRow-&gt;dwDescrLen; j++)
                printf("%c", pIfRow-&gt;bDescr[j]);
            printf("\n");
            printf("\tType[%d]:\t ", i);
            switch (pIfRow-&gt;dwType) {
            case IF_TYPE_OTHER:
                printf("Other\n");
                break;
            case IF_TYPE_ETHERNET_CSMACD:
                printf("Ethernet\n");
                break;
            case IF_TYPE_ISO88025_TOKENRING:
                printf("Token Ring\n");
                break;
            case IF_TYPE_PPP:
                printf("PPP\n");
                break;
            case IF_TYPE_SOFTWARE_LOOPBACK:
                printf("Software Lookback\n");
                break;
            case IF_TYPE_ATM:
                printf("ATM\n");
                break;
            case IF_TYPE_IEEE80211:
                printf("IEEE 802.11 Wireless\n");
                break;
            case IF_TYPE_TUNNEL:
                printf("Tunnel type encapsulation\n");
                break;
            case IF_TYPE_IEEE1394:
                printf("IEEE 1394 Firewire\n");
                break;
            default:
                printf("Unknown type %ld\n", pIfRow-&gt;dwType);
                break;
            }
            printf("\tMtu[%d]:\t\t %ld\n", i, pIfRow-&gt;dwMtu);
            printf("\tSpeed[%d]:\t %ld\n", i, pIfRow-&gt;dwSpeed);
            printf("\tPhysical Addr:\t ");
            if (pIfRow-&gt;dwPhysAddrLen == 0)
                printf("\n");
            for (j = 0; j &lt; pIfRow-&gt;dwPhysAddrLen; j++) {
                if (j == (pIfRow-&gt;dwPhysAddrLen - 1))
                    printf("%.2X\n", (int) pIfRow-&gt;bPhysAddr[j]);
                else
                    printf("%.2X-", (int) pIfRow-&gt;bPhysAddr[j]);
            }
            printf("\tAdmin Status[%d]:\t %ld\n", i, pIfRow-&gt;dwAdminStatus);
            printf("\tOper Status[%d]:\t ", i);
            switch (pIfRow-&gt;dwOperStatus) {
            case IF_OPER_STATUS_NON_OPERATIONAL:
                printf("Non Operational\n");
                break;
            case IF_OPER_STATUS_UNREACHABLE:
                printf("Unreachable\n");
                break;
            case IF_OPER_STATUS_DISCONNECTED:
                printf("Disconnected\n");
                break;
            case IF_OPER_STATUS_CONNECTING:
                printf("Connecting\n");
                break;
            case IF_OPER_STATUS_CONNECTED:
                printf("Connected\n");
                break;
            case IF_OPER_STATUS_OPERATIONAL:
                printf("Operational\n");
                break;
            default:
                printf("Unknown status %ld\n", pIfRow-&gt;dwAdminStatus);
                break;
            }
            printf("\n");
        }
    } else {
        printf("GetIfTable failed with error: \n", dwRetVal);
        if (pIfTable != NULL) {
            FREE(pIfTable);
            pIfTable = NULL;
        }
        return 1;
        // Here you can use FormatMessage to find out why
        // it failed.
    }
    if (pIfTable != NULL) {
        FREE(pIfTable);
        pIfTable = NULL;
    }
    return 0;
}


</code>
    </remarks>
    <seealso cref="GetIfEntry" />
    <seealso cref="GetIfEntry2" />
    <seealso cref="GetIfTable2" />
    <seealso cref="GetIfTable2Ex" />
    <seealso cref="GetNumberOfInterfaces" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso cref="MIB_IFROW" />
    <seealso cref="MIB_IFTABLE" />
    <seealso cref="MIB_IF_ROW2" />
    <seealso cref="MIB_IF_TABLE2" />
  </member>
  <member name="Windows.GetInterfaceActiveTimestampCapabilities">
    <summary>
      <para>Retrieves the currently enabled timestamp capabilities of a network adapter.</para>
      <para>For more info, and code examples, see <a href="https://docs.microsoft.com//windows/win32/iphlp/packet-timestamping">Packet timestamping</a>.</para>
    </summary>
    <param name="InterfaceLuid">
      <para>Type: _In_ <b>CONST <see cref="NET_LUID" />*</b></para>
      <para>The network locally unique identifier (LUID) of the network adapter for which currently enabled timestamp capabilities are to be retrieved.</para>
    </param>
    <param name="TimestampCapabilites">
      <para>Type: _Out_ <b><see cref="PINTERFACE_TIMESTAMP_CAPABILITIES" /></b></para>
      <para>If the function succeeds, then <i>TimestampCapabilites</i> returns a structure that describes the currently enabled timestamp capabilities.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">DWORD</a></b></para>
      <para>If the function succeeds, then it returns <b>NO_ERROR</b>. If the network card corresponding to <i>InterfaceLuid</i> isn't timestamp-aware, then the function returns <b>ERROR_NOT_SUPPORTED</b>. If the network card driver advertises an unsupported timestamp configuration, then the function returns <b>ERROR_BAD_DRIVER</b>.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/win32/iphlp/packet-timestamping">Packet timestamping</seealso>
  </member>
  <member name="Windows.GetInterfaceCurrentTimestampCapabilities">
    <summary>
      <para>This function is reserved for system use, and you should not call it from your code.</para>
    </summary>
    <param name="InterfaceLuid">
      <para>Reserved.</para>
    </param>
    <param name="TimestampCapabilites">
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Reserved.</para>
    </returns>
  </member>
  <member name="Windows.GetInterfaceHardwareTimestampCapabilities">
    <summary>
      <para>This function is reserved for system use, and you should not call it from your code.</para>
    </summary>
    <param name="InterfaceLuid">
      <para>Reserved.</para>
    </param>
    <param name="TimestampCapabilites">
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Reserved.</para>
    </returns>
  </member>
  <member name="Windows.GetInterfaceInfo">
    <summary>
      <para>The
<b>GetInterfaceInfo</b> function obtains the list of the network interface adapters with IPv4 enabled on the local system.</para>
    </summary>
    <param name="pIfTable">
      <para>A pointer to a buffer that specifies an
<see cref="IP_INTERFACE_INFO" /> structure that receives the list of adapters. This buffer must be allocated by the caller.</para>
    </param>
    <param name="dwOutBufLen">
      <para>A pointer to a <b>DWORD</b> variable that specifies the size of the
buffer pointed to by <i>pIfTable</i> parameter to receive the <see cref="IP_INTERFACE_INFO" /> structure. If this size is insufficient to hold the IPv4 interface information,
<b>GetInterfaceInfo</b> fills in this variable with the required size, and returns an error code of <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>NO_ERROR</b>.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer to receive the IPv4 adapter information is too small. This value is returned if the  <i>dwOutBufLen</i> parameter indicates that the buffer pointed to by the <i>pIfTable</i> parameter is too small to retrieve the IPv4 interface information. The required size is returned in the <b>DWORD</b> variable pointed to by the <i>dwOutBufLen</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if the <i>dwOutBufLen</i> parameter is <b>NULL</b>, or <see cref="GetInterfaceInfo" /> is unable to write to the memory pointed to by the <i>dwOutBufLen</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NO_DATA</b>
            </para>
          </description>
          <description>
            <para>There are no network adapters enabled for IPv4 on the local system. This value is also returned if all network adapters on the local system are disabled.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system in use on the local system.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>GetInterfaceInfo</b> function is specific to network adapters with IPv4 enabled. The function returns an <see cref="IP_INTERFACE_INFO" /> structure pointed to by the <i>pIfTable</i> parameter that contains the number of network adapters with IPv4 enabled on the local system and an array of <see cref="IP_ADAPTER_INDEX_MAP" /> structures with information on each network adapter with IPv4 enabled. The <b>IP_INTERFACE_INFO</b> structure returned by <b>GetInterfaceInfo</b> contains at least one <b>IP_ADAPTER_INDEX_MAP</b> structure even if the <b>NumAdapters</b> member of the <b>IP_INTERFACE_INFO</b> structure indicates that no network adapters with IPv4 are enabled. When the <b>NumAdapters</b> member of the <b>IP_INTERFACE_INFO</b> structure returned by <b>GetInterfaceInfo</b> is zero, the value of the members of the single  <b>IP_ADAPTER_INDEX_MAP</b> structure returned in the <b>IP_INTERFACE_INFO</b> structure is undefined.</para>
      <para>If the  <b>GetInterfaceInfo</b> function is called with too small a buffer to retrieve the IPv4 interface information  (the  <i>dwOutBufLen</i> parameter indicates that the buffer pointed to by the <i>pIfTable</i> parameter is too small), the function returns  <b>ERROR_INSUFFICIENT_BUFFER</b>. The required size is returned in the <b>DWORD</b> variable pointed to by the <i>dwOutBufLen</i> parameter.</para>
      <para>The  correct way to use the <b>GetInterfaceInfo</b> function is to call this function twice. In the first call, pass a <b>NULL</b> pointer in the <i>pIfTable</i> parameter and zero in the variable pointed to by the <i>dwOutBufLen</i> parameter. The call with fail with <b>ERROR_INSUFFICIENT_BUFFER</b> and the required size for this buffer is returned in the <b>DWORD</b> variable pointed to by the <i>dwOutBufLen</i> parameter. A buffer can then  be allocated of the required size using the value pointed by the <i>dwOutBufLen</i>. Then  the <b>GetInterfaceInfo</b> function can be called a second time with a pointer to this buffer passed in the <i>pIfTable</i> parameter and the length of the buffer set to the size of this buffer.</para>
      <para>The
<see cref="GetAdaptersInfo" /> and
<b>GetInterfaceInfo</b> functions do not return information about the loopback interface. Information on the loopback interface is returned by the <see cref="GetIpAddrTable" /> function.</para>
      <para>On Windows Vista and later, the <b>Name</b> member of the <see cref="IP_ADAPTER_INDEX_MAP" /> structure returned in the <see cref="IP_INTERFACE_INFO" /> structure may be a Unicode string of the GUID for the network interface (the string begins with the '{' character).</para>
      <h4>Examples</h4>
      <para>The following example retrieves the list of network adapters with IPv4 enabled on the local system and prints various properties of the first network adapter.</para>
      <code>#include &lt;winsock2.h&gt;
#include &lt;ws2ipdef.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "iphlpapi.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int main()
{

// Declare and initialize variables
    PIP_INTERFACE_INFO pInfo = NULL;
    ULONG ulOutBufLen = 0;

    DWORD dwRetVal = 0;
    int iReturn = 1;

    int i;

// Make an initial call to GetInterfaceInfo to get
// the necessary size in the ulOutBufLen variable
    dwRetVal = GetInterfaceInfo(NULL, &amp;amp;amp;amp;amp;amp;ulOutBufLen);
    if (dwRetVal == ERROR_INSUFFICIENT_BUFFER) {
        pInfo = (IP_INTERFACE_INFO *) MALLOC(ulOutBufLen);
        if (pInfo == NULL) {
            printf
                ("Unable to allocate memory needed to call GetInterfaceInfo\n");
            return 1;
        }
    }
// Make a second call to GetInterfaceInfo to get
// the actual data we need
    dwRetVal = GetInterfaceInfo(pInfo, &amp;amp;amp;amp;amp;amp;ulOutBufLen);
    if (dwRetVal == NO_ERROR) {
        printf("Number of Adapters: %ld\n\n", pInfo-&gt;NumAdapters);
        for (i = 0; i &lt; pInfo-&gt;NumAdapters; i++) {
            printf("Adapter Index[%d]: %ld\n", i,
                   pInfo-&gt;Adapter[i].Index);
            printf("Adapter Name[%d]: %ws\n\n", i,
                   pInfo-&gt;Adapter[i].Name);
        }
        iReturn = 0;
    } else if (dwRetVal == ERROR_NO_DATA) {
        printf
            ("There are no network adapters with IPv4 enabled on the local system\n");
        iReturn = 0;
    } else {
        printf("GetInterfaceInfo failed with error: %d\n", dwRetVal);
        iReturn = 1;
    }

    FREE(pInfo);
    return (iReturn);
}


</code>
    </remarks>
    <seealso cref="GetAdaptersInfo" />
    <seealso cref="GetIpAddrTable" />
    <seealso cref="GetNumberOfInterfaces" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="IP_ADAPTER_INDEX_MAP" />
    <seealso cref="IP_INTERFACE_INFO" />
  </member>
  <member name="Windows.GetInterfaceSupportedTimestampCapabilities">
    <summary>
      <para>Retrieves the supported timestamp capabilities of a network adapter.</para>
      <para>For more info, and code examples, see <a href="https://docs.microsoft.com//windows/win32/iphlp/packet-timestamping">Packet timestamping</a>.</para>
    </summary>
    <param name="InterfaceLuid">
      <para>Type: _In_ <b>CONST <see cref="NET_LUID" />*</b></para>
      <para>The network locally unique identifier (LUID) of the network adapter for which supported timestamp capabilities are to be retrieved.</para>
    </param>
    <param name="TimestampCapabilites">
      <para>Type: _Out_ <b><see cref="PINTERFACE_TIMESTAMP_CAPABILITIES" /></b></para>
      <para>If the function succeeds, then <i>TimestampCapabilites</i> returns a structure that describes the supported timestamp capabilities.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">DWORD</a></b></para>
      <para>If the function succeeds, then it returns <b>NO_ERROR</b>. If the network card corresponding to <i>InterfaceLuid</i> isn't timestamp-aware, then the function returns <b>ERROR_NOT_SUPPORTED</b>.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/win32/iphlp/packet-timestamping">Packet timestamping</seealso>
  </member>
  <member name="Windows.GetIpAddrTable">
    <summary>
      <para>The
<b>GetIpAddrTable</b> function retrieves the interface–to–IPv4 address mapping table.</para>
    </summary>
    <param name="pIpAddrTable">
      <para>A pointer to a buffer that receives the interface–to–IPv4 address mapping table as a
<see cref="MIB_IPADDRTABLE" /> structure.</para>
    </param>
    <param name="pdwSize">
      <para>On input, specifies the size in bytes  of the buffer pointed to by the <i>pIpAddrTable</i> parameter.</para>
      <para>On output, if the buffer is not large enough to hold the returned mapping table, the function sets this parameter equal to the required buffer size in bytes.</para>
    </param>
    <param name="bOrder">
      <para>If this parameter is <b>TRUE</b>, then
the returned mapping table
is sorted in ascending order by IPv4 address.
The sorting is performed in network byte order.
For example, 10.0.0.255 comes immediately before 10.0.1.0.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer pointed to by the <i>pIpAddrTable</i> parameter is not large enough. The required size is returned in the <b>DWORD</b> variable pointed to by the <i>pdwSize</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pdwSize</i> parameter is <b>NULL</b>, or
<see cref="GetIpAddrTable" /> is unable to write to the memory pointed to by the <i>pdwSize</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system in use on the local system.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetIpAddrTable</b> function retrieves the interface–to–IPv4 address mapping table on a local computer and returns this information in an <see cref="MIB_IPADDRTABLE" /> structure.</para>
      <para>The IPv4 addresses returned by the <b>GetIpAddrTable</b> function are affected by the status of the network interfaces on a local computer. Manually resetting a network interface card (NIC) and certain PnP events may result in an IP address being removed or changed.</para>
      <para>On Windows Server 2003 and Windows XP, the IPv4 addresses returned by the <b>GetIpAddrTable</b> function are also affected if the media sensing capability of the TCP/IP stack on a local computer has been disabled by calling the <see cref="DisableMediaSense" /> function. When media sensing has been disabled, the <b>GetIpAddrTable</b> function may return IPv4 addresses associated with disconnected interfaces. These Ipv4 addresses for disconnected interfaces are not valid for use.</para>
      <para>On Windows Server 2008 and Windows Vista, the IPv4 addresses returned by the <b>GetIpAddrTable</b> function are not affected by the media sensing capability of the TCP/IP stack on a local computer. The <b>GetIpAddrTable</b> function returns only valid IPv4 addresses.</para>
      <para>The <see cref="GetAdaptersAddresses" /> function available on Windows XP can be used to retrieve both IPv6 and IPv4 addresses and interface information.</para>
      <para>The <see cref="MIB_IPADDRTABLE" /> structure returned by the <b>GetIpAddrTable</b> function may contain padding for alignment between the <b>dwNumEntries</b> member and the first <see cref="MIB_IPADDRROW" /> array entry in the <b>table</b> member. Padding for alignment may also be present between the <b>MIB_IPADDRROW</b> array entries in the <b>table</b> member. Any access to a <b>MIB_IPADDRROW</b> array entry should assume  padding may exist.</para>
      <para>On the Microsoft Windows Software Development Kit (SDK) released for Windows Vista and later, the organization of header files has changed and the <see cref="MIB_IPADDRROW" /> is defined in the <i>Ipmib.h</i> header file not in the <i>Iprtrmib.h</i> header file. Note that the <i>Ipmib.h</i> header file is automatically included in <i>Iprtrmib.h</i> which is automatically included in the <i>Iphlpapi.h</i> header file. The <i>Ipmib.h</i> and <i>Iprtrmib.h</i> header files should never be used directly.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the IP address table, then prints some members of the IP address entries in the table.</para>
      <code>#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int __cdecl main()
{

    int i;

    /* Variables used by GetIpAddrTable */
    PMIB_IPADDRTABLE pIPAddrTable;
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;
    IN_ADDR IPAddr;

    /* Variables used to return error message */
    LPVOID lpMsgBuf;

    // Before calling AddIPAddress we use GetIpAddrTable to get
    // an adapter to which we can add the IP.
    pIPAddrTable = (MIB_IPADDRTABLE *) MALLOC(sizeof (MIB_IPADDRTABLE));

    if (pIPAddrTable) {
        // Make an initial call to GetIpAddrTable to get the
        // necessary size into the dwSize variable
        if (GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0) ==
            ERROR_INSUFFICIENT_BUFFER) {
            FREE(pIPAddrTable);
            pIPAddrTable = (MIB_IPADDRTABLE *) MALLOC(dwSize);

        }
        if (pIPAddrTable == NULL) {
            printf("Memory allocation failed for GetIpAddrTable\n");
            exit(1);
        }
    }
    // Make a second call to GetIpAddrTable to get the
    // actual data we want
    if ( (dwRetVal = GetIpAddrTable( pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0 )) != NO_ERROR ) {
        printf("GetIpAddrTable failed with error %d\n", dwRetVal);
        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, dwRetVal, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),       // Default language
                          (LPTSTR) &amp;amp;amp;amp;amp;amp; lpMsgBuf, 0, NULL)) {
            printf("\tError: %s", lpMsgBuf);
            LocalFree(lpMsgBuf);
        }
        exit(1);
    }

    printf("\tNum Entries: %ld\n", pIPAddrTable-&gt;dwNumEntries);
    for (i=0; i &lt; (int) pIPAddrTable-&gt;dwNumEntries; i++) {
        printf("\n\tInterface Index[%d]:\t%ld\n", i, pIPAddrTable-&gt;table[i].dwIndex);
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwAddr;
        printf("\tIP Address[%d]:     \t%s\n", i, inet_ntoa(IPAddr) );
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwMask;
        printf("\tSubnet Mask[%d]:    \t%s\n", i, inet_ntoa(IPAddr) );
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwBCastAddr;
        printf("\tBroadCast[%d]:      \t%s (%ld%)\n", i, inet_ntoa(IPAddr), pIPAddrTable-&gt;table[i].dwBCastAddr);
        printf("\tReassembly size[%d]:\t%ld\n", i, pIPAddrTable-&gt;table[i].dwReasmSize);
        printf("\tType and State[%d]:", i);
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_PRIMARY)
            printf("\tPrimary IP Address");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DYNAMIC)
            printf("\tDynamic IP Address");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DISCONNECTED)
            printf("\tAddress is on disconnected interface");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DELETED)
            printf("\tAddress is being deleted");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_TRANSIENT)
            printf("\tTransient address");
        printf("\n");
    }

    if (pIPAddrTable) {
        FREE(pIPAddrTable);
        pIPAddrTable = NULL;
    }

    exit(0);
}


</code>
    </remarks>
    <seealso cref="AddIPAddress" />
    <seealso cref="DisableMediaSense" />
    <seealso cref="GetAdaptersAddresses" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso cref="IP_ADAPTER_ADDRESSES" />
    <seealso cref="MIB_IPADDRROW" />
    <seealso cref="MIB_IPADDRTABLE" />
    <seealso cref="RestoreMediaSense" />
  </member>
  <member name="Windows.GetIpErrorString">
    <summary>
      <para>The <b>GetIpErrorString</b> function retrieves an IP Helper error string.</para>
    </summary>
    <param name="ErrorCode">
      <para>The error code to be retrieved. The possible values for this parameter are defined in the <i>Ipexport.h</i> header file.</para>
    </param>
    <param name="Buffer">
      <para>A pointer to the buffer that contains the error code string if the function returns with NO_ERROR.</para>
    </param>
    <param name="Size">
      <para>A pointer to a <b>DWORD</b> that specifies the length, in characters, of the buffer pointed to by <i>Buffer</i> parameter, excluding the terminating null (i.e. the size of Buffer in characters, minus one).</para>
    </param>
    <returns>
      <para>Returns NO_ERROR upon success.</para>
      <para>If the function fails, use <see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
    </returns>
    <remarks>
      <para>The <b>GetIpErrorString</b> function can be used to retrieve an IP Helper error string for an IP error code. The <b>IP_STATUS</b> error code passed in the <i>ErrorCode</i> parameter is returned in the <b>Status</b> member of the <see cref="ICMP_ECHO_REPLY" />, <see cref="ICMP_ECHO_REPLY32" />, and  <see cref="ICMPV6_ECHO_REPLY" /> structures used by the ICMP and ICMPv6 functions.   The functions that use these structures include <see cref="Icmp6ParseReplies" />, <see cref="Icmp6SendEcho2" />, <see cref="IcmpParseReplies" />,
<see cref="IcmpSendEcho" />, <see cref="IcmpSendEcho2" />, and <see cref="IcmpSendEcho2Ex" />.</para>
      <para>The syntax for the <b>GetIpErrorString</b> function was slightly changed on the Microsoft Windows Software Development Kit (SDK) released for Windows Vista and later. The data type for the <i>Buffer</i> parameter was changed from <b>PWCHAR</b> to <b>PWSTR</b>.</para>
    </remarks>
    <seealso cref="ICMPV6_ECHO_REPLY" />
    <seealso cref="ICMP_ECHO_REPLY" />
    <seealso cref="ICMP_ECHO_REPLY32" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="Icmp6ParseReplies" />
    <seealso cref="Icmp6SendEcho2" />
    <seealso cref="IcmpParseReplies" />
    <seealso cref="IcmpSendEcho" />
    <seealso cref="IcmpSendEcho2" />
    <seealso cref="IcmpSendEcho2Ex" />
  </member>
  <member name="Windows.GetIpForwardTable">
    <summary>
      <para>The
<b>GetIpForwardTable</b> function retrieves the IPv4 routing table.</para>
    </summary>
    <param name="pIpForwardTable">
      <para>A pointer to a buffer that receives the IPv4 routing table as a
<see cref="MIB_IPFORWARDTABLE" /> structure.</para>
    </param>
    <param name="pdwSize">
      <para>On input, specifies the size in bytes  of the buffer pointed to by the <i>pIpForwardTable</i> parameter.</para>
      <para>On output, if the buffer is not large enough to hold the returned routing table, the function sets this parameter equal to the required buffer size in bytes.</para>
    </param>
    <param name="bOrder">
      <para>A Boolean value that specifies whether the returned table should be sorted. If this parameter is <b>TRUE</b>, the table is sorted in the order of:</para>
      <list type="number">
        <item>
          <description>Destination address</description>
        </item>
        <item>
          <description>Protocol that generated the route</description>
        </item>
        <item>
          <description>Multipath routing policy</description>
        </item>
        <item>
          <description>Next-hop address</description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>NO_ERROR</b> (zero).</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer pointed to by the <i>pIpForwardTable</i> parameter is not large enough. The required size is returned in the <b>DWORD</b> variable pointed to by the <i>pdwSize</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pdwSize</i> parameter is <b>NULL</b>, or
<see cref="GetIpForwardTable" /> is unable to write to the memory pointed to by the <i>pdwSize</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NO_DATA</b>
            </para>
          </description>
          <description>
            <para>No data is available. This error is returned if there are no routes present on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system in use on the local system. This error is returned if there is no IP stack installed on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The  <b>dwForwardProto</b> member of the
<see cref="MIB_IPFORWARDROW" /> structure specifies the protocol or routing mechanism that generated the route. See
<a href="https://docs.microsoft.com//windows/desktop/RRAS/protocol-identifiers">Protocol Identifiers</a> for a list of possible protocols and routing mechanisms.</para>
      <para>The  <b>dwForwardDest</b>, <b>dwForwardMask</b>, and <b>dwForwardNextHop</b> members of the
<see cref="MIB_IPFORWARDROW" /> structure represent an IPv4 address in network byte order.</para>
      <para>An IPv4 address of 0.0.0.0 in the  <b>dwForwardDest</b> member of the
<see cref="MIB_IPFORWARDROW" /> structure is considered a
default route. The <see cref="MIB_IPFORWARDTABLE" /> may contain multiple <b>MIB_IPFORWARDROW</b> entries with the <b>dwForwardDest</b> member set to 0.0.0.0 when there are multiple network adapters installed.</para>
      <para>When <b>dwForwardAge</b> is set to <b>INFINITE</b>, the route will not be removed based on a timeout</para>
      <para>value. Any other value for <b>dwForwardAge</b> specifies the number of seconds since the route was added or modified in the network routing table.</para>
      <para>On Windows Server 2003 or
Windows 2000 Server when the Routing and Remote Access Service (RRAS) is running, the  <see cref="MIB_IPFORWARDROW" /> entries returned have the <b>dwForwardType</b> and <b>dwForwardAge</b> members set to zero.</para>
      <para>On Windows Vista and Windows Server 2008, the route metric specified in the <b>dwForwardMetric1</b> member of the  <see cref="MIB_IPFORWARDROW" /> structure represents a combination of the route metric added to the interface metric specified in the <b>Metric</b> member of the <see cref="MIB_IPINTERFACE_ROW" /> structure of the associated interface.  So the <b>dwForwardMetric1</b> member of the  <b>MIB_IPFORWARDROW</b> structure should be equal to or greater than <b>Metric</b> member of the associated <b>MIB_IPINTERFACE_ROW</b> structure. If an application would like to set the route metric to 0 on Windows Vista and Windows Server 2008, then the <b>dwForwardMetric1</b> member of the <b>MIB_IPFORWARDROW</b> structure  should be set equal to the value of the interface metric specified in the <b>Metric</b> member of the associated <b>MIB_IPINTERFACE_ROW</b> structure. An application can retrieve the interface metric by calling the <see cref="GetIpInterfaceEntry" /> function.</para>
      <para>A number of members of the <see cref="MIB_IPFORWARDROW" /> structure  entries returned by <b>GetIpForwardTable</b> are not currently used by IPv4 routing. These members include <b>dwForwardPolicy</b>, <b>dwForwardNextHopAS</b>, <b>dwForwardMetric2</b>, <b>dwForwardMetric3</b>, <b>dwForwardMetric4</b>, and <b>dwForwardMetric5</b>.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the IP routing table then prints some fields for each route in the table.</para>
      <code>// Need to link with Ws2_32.lib and Iphlpapi.lib
#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int main()
{

    // Declare and initialize variables.

    /* variables used for GetIfForwardTable */
    PMIB_IPFORWARDTABLE pIpForwardTable;
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;

    char szDestIp[128];
    char szMaskIp[128];
    char szGatewayIp[128];

    struct in_addr IpAddr;

    int i;

    pIpForwardTable =
        (MIB_IPFORWARDTABLE *) MALLOC(sizeof (MIB_IPFORWARDTABLE));
    if (pIpForwardTable == NULL) {
        printf("Error allocating memory\n");
        return 1;
    }

    if (GetIpForwardTable(pIpForwardTable, &amp;amp;amp;amp;amp;amp;dwSize, 0) ==
        ERROR_INSUFFICIENT_BUFFER) {
        FREE(pIpForwardTable);
        pIpForwardTable = (MIB_IPFORWARDTABLE *) MALLOC(dwSize);
        if (pIpForwardTable == NULL) {
            printf("Error allocating memory\n");
            return 1;
        }
    }

    /* Note that the IPv4 addresses returned in
     * GetIpForwardTable entries are in network byte order
     */
    if ((dwRetVal = GetIpForwardTable(pIpForwardTable, &amp;amp;amp;amp;amp;amp;dwSize, 0)) == NO_ERROR) {
        printf("\tNumber of entries: %d\n",
               (int) pIpForwardTable-&gt;dwNumEntries);
        for (i = 0; i &lt; (int) pIpForwardTable-&gt;dwNumEntries; i++) {
            /* Convert IPv4 addresses to strings */
            IpAddr.S_un.S_addr =
                (u_long) pIpForwardTable-&gt;table[i].dwForwardDest;
            strcpy_s(szDestIp, sizeof (szDestIp), inet_ntoa(IpAddr));
            IpAddr.S_un.S_addr =
                (u_long) pIpForwardTable-&gt;table[i].dwForwardMask;
            strcpy_s(szMaskIp, sizeof (szMaskIp), inet_ntoa(IpAddr));
            IpAddr.S_un.S_addr =
                (u_long) pIpForwardTable-&gt;table[i].dwForwardNextHop;
            strcpy_s(szGatewayIp, sizeof (szGatewayIp), inet_ntoa(IpAddr));

            printf("\n\tRoute[%d] Dest IP: %s\n", i, szDestIp);
            printf("\tRoute[%d] Subnet Mask: %s\n", i, szMaskIp);
            printf("\tRoute[%d] Next Hop: %s\n", i, szGatewayIp);
            printf("\tRoute[%d] If Index: %ld\n", i,
                   pIpForwardTable-&gt;table[i].dwForwardIfIndex);
            printf("\tRoute[%d] Type: %ld - ", i,
                   pIpForwardTable-&gt;table[i].dwForwardType);
            switch (pIpForwardTable-&gt;table[i].dwForwardType) {
            case MIB_IPROUTE_TYPE_OTHER:
                printf("other\n");
                break;
            case MIB_IPROUTE_TYPE_INVALID:
                printf("invalid route\n");
                break;
            case MIB_IPROUTE_TYPE_DIRECT:
                printf("local route where next hop is final destination\n");
                break;
            case MIB_IPROUTE_TYPE_INDIRECT:
                printf
                    ("remote route where next hop is not final destination\n");
                break;
            default:
                printf("UNKNOWN Type value\n");
                break;
            }
            printf("\tRoute[%d] Proto: %ld - ", i,
                   pIpForwardTable-&gt;table[i].dwForwardProto);
            switch (pIpForwardTable-&gt;table[i].dwForwardProto) {
            case MIB_IPPROTO_OTHER:
                printf("other\n");
                break;
            case MIB_IPPROTO_LOCAL:
                printf("local interface\n");
                break;
            case MIB_IPPROTO_NETMGMT:
                printf("static route set through network management \n");
                break;
            case MIB_IPPROTO_ICMP:
                printf("result of ICMP redirect\n");
                break;
            case MIB_IPPROTO_EGP:
                printf("Exterior Gateway Protocol (EGP)\n");
                break;
            case MIB_IPPROTO_GGP:
                printf("Gateway-to-Gateway Protocol (GGP)\n");
                break;
            case MIB_IPPROTO_HELLO:
                printf("Hello protocol\n");
                break;
            case MIB_IPPROTO_RIP:
                printf("Routing Information Protocol (RIP)\n");
                break;
            case MIB_IPPROTO_IS_IS:
                printf
                    ("Intermediate System-to-Intermediate System (IS-IS) protocol\n");
                break;
            case MIB_IPPROTO_ES_IS:
                printf("End System-to-Intermediate System (ES-IS) protocol\n");
                break;
            case MIB_IPPROTO_CISCO:
                printf("Cisco Interior Gateway Routing Protocol (IGRP)\n");
                break;
            case MIB_IPPROTO_BBN:
                printf("BBN Internet Gateway Protocol (IGP) using SPF\n");
                break;
            case MIB_IPPROTO_OSPF:
                printf("Open Shortest Path First (OSPF) protocol\n");
                break;
            case MIB_IPPROTO_BGP:
                printf("Border Gateway Protocol (BGP)\n");
                break;
            case MIB_IPPROTO_NT_AUTOSTATIC:
                printf("special Windows auto static route\n");
                break;
            case MIB_IPPROTO_NT_STATIC:
                printf("special Windows static route\n");
                break;
            case MIB_IPPROTO_NT_STATIC_NON_DOD:
                printf
                    ("special Windows static route not based on Internet standards\n");
                break;
            default:
                printf("UNKNOWN Proto value\n");
                break;
            }

            printf("\tRoute[%d] Age: %ld\n", i,
                   pIpForwardTable-&gt;table[i].dwForwardAge);
            printf("\tRoute[%d] Metric1: %ld\n", i,
                   pIpForwardTable-&gt;table[i].dwForwardMetric1);
        }
        FREE(pIpForwardTable);
        return 0;
    } else {
        printf("\tGetIpForwardTable failed.\n");
        FREE(pIpForwardTable);
        return 1;
    }

}


</code>
    </remarks>
    <seealso cref="CreateIpForwardEntry" />
    <seealso cref="DeleteIpForwardEntry" />
    <seealso cref="GetIpInterfaceEntry" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPFORWARDTABLE" />
    <seealso cref="MIB_IPINTERFACE_ROW" />
    <seealso href="https://docs.microsoft.com//windows/desktop/RRAS/protocol-identifiers">Protocol Identifiers</seealso>
    <seealso cref="SetIpForwardEntry" />
  </member>
  <member name="Windows.GetIpNetTable">
    <summary>
      <para>The
<b>GetIpNetTable</b> function retrieves the IPv4 to physical address mapping table.</para>
    </summary>
    <param name="IpNetTable">
      <para>A pointer to a buffer that receives the IPv4 to physical address mapping table as a
<see cref="MIB_IPNETTABLE" /> structure.</para>
    </param>
    <param name="SizePointer">
      <para>On input, specifies the size in bytes of the buffer pointed to by the <i>pIpNetTable</i> parameter.</para>
      <para>On output, if the buffer is not large enough to hold the returned mapping table, the function sets this parameter equal to the required buffer size in bytes.</para>
    </param>
    <param name="Order">
      <para>A Boolean value that specifies whether the returned mapping table should be sorted in ascending order by IP address. If this parameter is <b>TRUE</b>, the table is sorted.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR or ERROR_NO_DATA.</para>
      <para>If the function fails or does not return any data, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer pointed to by the <i>pIpNetTable</i> parameter is not large enough. The required size is returned in the <b>DWORD</b> variable pointed to by the <i>pdwSize</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if the <i>pdwSize</i> parameter is <b>NULL</b>, or
<see cref="GetIpNetTable" /> is unable to write to the memory pointed to by the <i>pdwSize</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NO_DATA</b>
            </para>
          </description>
          <description>
            <para>There is no data to return. The IPv4 to physical address mapping table is empty. This return value indicates that the call to the <see cref="GetIpNetTable" /> function succeeded, but there was no data to return.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The IPv4 transport is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>GetIpNetTable</b> function enumerates the Address Resolution Protocol (ARP) entries for IPv4 on a local system from the IPv4 to physical address mapping table and returns this information in a <see cref="MIB_IPNETTABLE" /> structure.</para>
      <para>The IPv4 address entries are returned in a <see cref="MIB_IPNETTABLE" /> structure in the buffer pointed to by the <i>pIpNetTable</i> parameter. The <b>MIB_IPNETTABLE</b> structure contains a count of ARP entries and an array of <see cref="MIB_IPNETROW" /> structures for each IPv4 address entry.</para>
      <para>Note that the returned <see cref="MIB_IPNETTABLE" /> structure pointed to by the <i>pIpNetTable</i> parameter may contain padding for alignment between the <b>dwNumEntries</b> member and the first <see cref="MIB_IPNETROW" /> array entry in the <b>table</b> member of the <b>MIB_IPNETTABLE</b> structure. Padding for alignment may also be present between the <b>MIB_IPNETROW</b> array entries. Any access to a <b>MIB_IPNETROW</b> array entry should assume  padding may exist.</para>
      <para>on Windows Vista and later, the <see cref="GetIpNetTable2" /> function can be used to retrieve the neighbor IP addresses for both IPv6 and IPv4.</para>
    </remarks>
    <seealso cref="CreateIpNetEntry" />
    <seealso cref="DeleteIpNetEntry" />
    <seealso cref="FlushIpNetTable" />
    <seealso cref="GetIpNetTable2" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPNETROW" />
    <seealso cref="MIB_IPNETTABLE" />
    <seealso cref="SetIpNetEntry" />
  </member>
  <member name="Windows.GetIpStatistics">
    <summary>
      <para>The
<b>GetIpStatistics</b> function retrieves the IP statistics for the current computer.</para>
    </summary>
    <param name="Statistics">
      <para>A pointer to a
<see cref="MIB_IPSTATS" /> structure that receives the IP statistics for the local computer.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pStats</i> parameter is <b>NULL</b>, or
<see cref="GetIpStatistics" /> is unable to write to the memory pointed to by the <i>pStats</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
the <see cref="FormatMessage" /> function to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>GetIpStatistics</b> function returns the statistics for IPv4 on the current computer.     On Windows XP and later, the <see cref="GetIpStatisticsEx" /> can be used to obtain the IP statistics for either IPv4 or IPv6.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the IPv4 statistics for the local computer and prints values from the returned data.</para>
      <code>#ifndef UNICODE
#define UNICODE
#endif

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "iphlpapi.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int main()
{

    DWORD dwRetval;
    MIB_IPSTATS *pStats;

    pStats = (MIB_IPSTATS *) MALLOC(sizeof (MIB_IPSTATS));

    if (pStats == NULL) {
        wprintf(L"Unable to allocate memory for MIB_IPSTATS\n");
        exit(1);
    }
    dwRetval = GetIpStatistics(pStats);
    if (dwRetval != NO_ERROR) {
        wprintf(L"GetIpStatistics call failed with %d\n", dwRetval);
        exit(1);
    } else {

        wprintf(L"IP forwarding: \t\t" );
        switch (pStats-&gt;dwForwarding) {
        case MIB_IP_FORWARDING:
            wprintf(L"Enabled\n");
            break;
        case MIB_IP_NOT_FORWARDING:
            wprintf(L"Disabled\n");
            break;
        default:
            wprintf(L"unknown value = %d\n", pStats-&gt;dwForwarding);
            break;
        }

        wprintf(L"Default initial TTL: \t\t\t\t\t%u\n", pStats-&gt;dwDefaultTTL);

        wprintf(L"Number of received datagrams: \t\t\t\t%u\n", pStats-&gt;dwInReceives);
        wprintf(L"Number of received datagrams with header errors: \t%u\n", pStats-&gt;dwInHdrErrors);
        wprintf(L"Number of received datagrams with address errors: \t%u\n", pStats-&gt;dwInAddrErrors);

        wprintf(L"Number of datagrams forwarded: \t\t\t\t%ld\n", pStats-&gt;dwForwDatagrams);

        wprintf(L"Number of received datagrams with an unknown protocol: \t%u\n", pStats-&gt;dwInUnknownProtos);
        wprintf(L"Number of received datagrams discarded: \t\t%u\n", pStats-&gt;dwInDiscards);
        wprintf(L"Number of received datagrams delivered: \t\t%u\n", pStats-&gt;dwInDelivers);

        wprintf(L"Number of outgoing datagrams requested to transmit: \t%u\n", pStats-&gt;dwOutRequests);
        wprintf(L"Number of outgoing datagrams discarded for routing: \t%u\n", pStats-&gt;dwRoutingDiscards);
        wprintf(L"Number of outgoing datagrams discarded: \t\t%u\n", pStats-&gt;dwOutDiscards);
        wprintf(L"Number of outgoing datagrams with no route to destination discarded: %u\n", pStats-&gt;dwOutNoRoutes);

        wprintf(L"Fragment reassembly timeout: \t\t\t\t%u\n", pStats-&gt;dwReasmTimeout);
        wprintf(L"Number of datagrams that required reassembly: \t\t%u\n", pStats-&gt;dwReasmReqds);
        wprintf(L"Number of datagrams successfully reassembled: \t\t%u\n", pStats-&gt;dwReasmOks);
        wprintf(L"Number of datagrams that could not be reassembled: \t%u\n", pStats-&gt;dwReasmFails);

        wprintf(L"Number of datagrams fragmented successfully: \t\t%u\n", pStats-&gt;dwFragOks);
        wprintf(L"Number of datagrams not fragmented and discarded: \t%u\n", pStats-&gt;dwFragFails);
        wprintf(L"Number of fragments created: \t\t\t\t%u\n", pStats-&gt;dwFragCreates);

        wprintf(L"Number of interfaces: \t\t\t\t\t%u\n", pStats-&gt;dwNumIf);
        wprintf(L"Number of IP addresses: \t\t\t\t%u\n", pStats-&gt;dwNumAddr);
        wprintf(L"Number of routes: \t\t\t\t\t%u\n", pStats-&gt;dwNumRoutes);
    }

// Free memory allocated for the MIB_IPSTATS structure
    if (pStats)
        FREE(pStats);

    return 0;
}

</code>
    </remarks>
    <seealso cref="GetIcmpStatistics" />
    <seealso cref="GetIpStatisticsEx" />
    <seealso cref="GetTcpStatistics" />
    <seealso cref="GetUdpStatistics" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPSTATS" />
  </member>
  <member name="Windows.GetIpStatisticsEx">
    <summary>
      <para>The
<b>GetIpStatisticsEx</b> function retrieves the Internet Protocol (IP) statistics for the current computer. The
<b>GetIpStatisticsEx</b> function differs from the
<see cref="GetIpStatistics" /> function in that
<b>GetIpStatisticsEx</b> also supports the Internet Protocol version 6 (IPv6) protocol family.</para>
    </summary>
    <param name="Statistics">
      <para>A pointer to a
<see cref="MIB_IPSTATS" /> structure that receives the IP statistics for the local computer.</para>
    </param>
    <param name="Family">
      <para>The protocol family for which to retrieve statistics. This parameter must be one of the following values:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>AF_INET</b>
          </description>
          <description>
            <para>Internet Protocol version 4 (IPv4).</para>
          </description>
        </item>
        <item>
          <description>
            <b>AF_INET6</b>
          </description>
          <description>
            <para>Internet Protocol version 6 (IPv6).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pStats</i> parameter is <b>NULL</b> or does not point to valid memory, or the <i>dwFamily</i> parameter is not a valid value.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system on which the function call was made.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetIpStatisticsEx</b> can be used to obtain the IP statistics for either IPv4 or IPv6 on the local computer.</para>
      <para>The
<see cref="GetIpStatistics" /> function returns the statistics for only IPv4 on the local computer.</para>
    </remarks>
    <seealso cref="GetIpStatistics" />
    <seealso cref="GetTcpStatisticsEx" />
    <seealso cref="GetUdpStatisticsEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPSTATS" />
  </member>
  <member name="Windows.GetNetworkParams">
    <summary>
      <para>The
<b>GetNetworkParams</b> function retrieves network parameters for the local computer.</para>
    </summary>
    <param name="pFixedInfo">
      <para>A pointer to a
buffer that contains a <see cref="FIXED_INFO" /> structure that receives the network parameters for the local computer, if the function was successful. This buffer must be allocated by the caller prior to calling the <b>GetNetworkParams</b> function.</para>
    </param>
    <param name="pOutBufLen">
      <para>A pointer to a <b>ULONG</b> variable that specifies the size of the
<see cref="FIXED_INFO" /> structure. If this size is insufficient to hold the information,
<b>GetNetworkParams</b> fills in this variable with the required size, and returns an error code of <b>ERROR_BUFFER_OVERFLOW</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The buffer to receive the network parameter information is too small. This value is returned if the <i>pOutBufLen</i> parameter is too small to hold the network parameter information or the <i>pFixedInfo</i> parameter was a <b>NULL</b> pointer. When this error code is returned, the <i>pOutBufLen</i> parameter points to the required buffer size.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if the  <i>pOutBufLen</i> parameter is a <b>NULL</b> pointer, the calling process does not have read/write access to the memory pointed to by <i>pOutBufLen</i>, or the calling process does not have write access to the memory pointed to by the <i>pFixedInfo</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NO_DATA</b>
            </para>
          </description>
          <description>
            <para>No network parameter information exists for the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The <b>GetNetworkParams</b> function is not supported by the operating system running on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetNetworkParams</b> function is used to retrieve  network parameters for the local computer. Network parameters are returned  in a <see cref="FIXED_INFO" /> structure. The  memory for the <b>FIXED_INFO</b> structure must be allocated by the application. It is the responsibility of the application to free this memory when it is no longer needed.</para>
      <para>In the Microsoft Windows Software Development Kit (SDK), the <see cref="FIXED_INFO_WIN2KSP1" /> structure is defined.   When compiling an
application if the target platform is Windows 2000 with Service Pack 1 (SP1) and later (<code>NTDDI_VERSION &gt;= NTDDI_WIN2KSP1</code>,
<code>_WIN32_WINNT &gt;= 0x0501</code>, or
<code>WINVER &gt;= 0x0501</code>), the <b>FIXED_INFO_WIN2KSP1</b> struct is typedefed to the <b>FIXED_INFO</b> structure. When compiling an application if the target
platform is not Windows 2000 with SP1 and later, the
<b>FIXED_INFO</b> structure is undefined.</para>
      <para>The <b>GetNetworkParams</b> function and the
<see cref="FIXED_INFO" /> structure are supported on  Windows 98and later. But to build an application for a target platform earlier than Windows 2000 with Service Pack 1 (SP1), an earlier version of the Platform Software Development Kit (SDK)  must be used.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the network parameters for the local computer and prints information from the returned data.</para>
      <code>//
// Link with IPHlpAPI.lib
//
#include &lt;winsock2.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#pragma comment(lib, "IPHLPAPI.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int __cdecl main()
{

    FIXED_INFO *pFixedInfo;
    ULONG ulOutBufLen;
    DWORD dwRetVal;
    IP_ADDR_STRING *pIPAddr;

    pFixedInfo = (FIXED_INFO *) MALLOC(sizeof (FIXED_INFO));
    if (pFixedInfo == NULL) {
        printf("Error allocating memory needed to call GetNetworkParams\n");
        return 1;
    }
    ulOutBufLen = sizeof (FIXED_INFO);

// Make an initial call to GetAdaptersInfo to get
// the necessary size into the ulOutBufLen variable
    if (GetNetworkParams(pFixedInfo, &amp;amp;amp;amp;amp;amp;ulOutBufLen) == ERROR_BUFFER_OVERFLOW) {
        FREE(pFixedInfo);
        pFixedInfo = (FIXED_INFO *) MALLOC(ulOutBufLen);
        if (pFixedInfo == NULL) {
            printf("Error allocating memory needed to call GetNetworkParams\n");
            return 1;
        }
    }

    if (dwRetVal = GetNetworkParams(pFixedInfo, &amp;amp;amp;amp;amp;amp;ulOutBufLen) == NO_ERROR) {

        printf("Host Name: %s\n", pFixedInfo-&gt;HostName);
        printf("Domain Name: %s\n", pFixedInfo-&gt;DomainName);

        printf("DNS Servers:\n");
        printf("\t%s\n", pFixedInfo-&gt;DnsServerList.IpAddress.String);

        pIPAddr = pFixedInfo-&gt;DnsServerList.Next;
        while (pIPAddr) {
            printf("\t%s\n", pIPAddr-&gt;IpAddress.String);
            pIPAddr = pIPAddr-&gt;Next;
        }

        printf("Node Type: ");
        switch (pFixedInfo-&gt;NodeType) {
        case BROADCAST_NODETYPE:
            printf("Broadcast node\n");
            break;
        case PEER_TO_PEER_NODETYPE:
            printf("Peer to Peer node\n");
            break;
        case MIXED_NODETYPE:
            printf("Mixed node\n");
            break;
        case HYBRID_NODETYPE:
            printf("Hybrid node\n");
            break;
        default:
            printf("Unknown node type %0lx\n", pFixedInfo-&gt;NodeType);
            break;
        }

        printf("DHCP scope name: %s\n", pFixedInfo-&gt;ScopeId);

        if (pFixedInfo-&gt;EnableRouting)
            printf("Routing: enabled\n");
        else
            printf("Routing: disabled\n");

        if (pFixedInfo-&gt;EnableProxy)
            printf("ARP proxy: enabled\n");
        else
            printf("ARP Proxy: disabled\n");

        if (pFixedInfo-&gt;EnableDns)
            printf("DNS: enabled\n");
        else
            printf("DNS: disabled\n");

    } else {
        printf("GetNetworkParams failed with error: %d\n", dwRetVal);
        return 1;
    }

    if (pFixedInfo)
        FREE(pFixedInfo);

    return 0;
}


</code>
    </remarks>
    <seealso cref="FIXED_INFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
  </member>
  <member name="Windows.GetNumberOfInterfaces">
    <summary>
      <para>The
<b>GetNumberOfInterfaces</b> functions retrieves the number of interfaces on the local computer.</para>
    </summary>
    <param name="pdwNumIf">
      <para>Pointer to a <b>DWORD</b> variable that receives the number of interfaces on the local computer.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
    </returns>
    <remarks>
      <para>The
<b>GetNumberOfInterfaces</b> function returns the number of interfaces on the local computer, including the loopback interface. This number is one more than the number of adapters returned by the
<see cref="GetAdaptersInfo" /> and
<see cref="GetInterfaceInfo" /> functions because these functions do not return information about the loopback interface.</para>
    </remarks>
    <seealso cref="GetAdaptersInfo" />
    <seealso cref="GetIfEntry" />
    <seealso cref="GetInterfaceInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
  </member>
  <member name="Windows.GetOwnerModuleFromTcp6Entry">
    <summary>
      <para>The <b>GetOwnerModuleFromTcp6Entry</b> function retrieves data about the module that issued the context bind for a specific IPv6 TCP endpoint in a MIB table row.</para>
    </summary>
    <param name="pTcpEntry">
      <para>A pointer to a <see cref="MIB_TCP6ROW_OWNER_MODULE" /> structure that contains the IPv6 TCP endpoint entry used to obtain the owner module.</para>
    </param>
    <param name="Class">
      <para>A <see cref="TCPIP_OWNER_MODULE_INFO_CLASS" /> enumeration value that indicates the type of data to obtain regarding the owner module. The <b>TCPIP_OWNER_MODULE_INFO_CLASS</b> enumeration is defined in the <i>Iprtrmib.h</i> header file.</para>
      <para>This parameter must be set to <b>TCPIP_OWNER_MODULE_INFO_BASIC</b>.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that contains a <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure with the owner module data. The type of data returned in this buffer is indicated by the value of the <i>Class</i> parameter.</para>
      <para>The following structures are used for the data in <i>Buffer</i> when  <i>Class</i> is set to the corresponding value.</para>
      <list type="table">
        <listheader>
          <description>
            <i>Class</i> enumeration value</description>
          <description>
            <i>Buffer</i> data format</description>
        </listheader>
        <item>
          <description>TCPIP_OWNER_MODULE_BASIC_INFO</description>
          <description>
            <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" />
          </description>
        </item>
      </list>
    </param>
    <param name="pdwSize">
      <para>The estimated size of the structure returned in <i>Buffer</i>, in bytes. If this value is set too small, <b>ERROR_INSUFFICIENT_BUFFER</b> is returned by this function, and this field will contain the correct structure size.</para>
    </param>
    <returns>
      <para>If the function call is successful, the value <b>NO_ERROR</b> is returned.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>Insufficient space was allocated for the table. The size of the table is returned in the <i>pdwSize</i> parameter, and must be used in a subsequent call to this function in order to successfully retrieve the table.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>A parameter is incorrect. This value is returned if either of the <i>pTcpEntry</i> or <i>pdwSize</i> parameters are <b>NULL</b>. This value is also returned if the <i>Class</i> parameter is not equal to <b>TCPIP_OWNER_MODULE_INFO_BASIC</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory is available to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The element was not found. This value is returned if the  <b>dwOwningPid</b> member of the <see cref="MIB_TCP6ROW_OWNER_MODULE" /> pointed to by the <i>pTcpEntry</i> parameter was zero or could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PARTIAL_COPY</b>
            </para>
          </description>
          <description>
            <para>Only part of a request was completed.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <i>Buffer</i> parameter contains not only a structure with pointers to specific data,  for example, pointers to the zero-terminated strings that contain the name and path of the owner module, but the actual data itself; that is the name and path strings. Therefore, when calculating the size of the buffer, ensure that you have enough space for both the structure as well as the data the members of the structure point to.</para>
      <para>The resolution of TCP table entries to owner modules is a best practice. In a few cases, the owner module name returned in the <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure can be a process name (such as "svchost.exe"), a service name (such as "RPC"), or a component name (such as "timer.dll").</para>
      <para>For computers running on Windows Vista or later, the <b>pModuleName</b> and <b>pModulePath</b> members of the <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> retrieved by  <see cref="GetOwnerModuleFromTcpEntry" /> function may point to an empty string for some TCP connections. Applications that start TCP connections located in the Windows system folder (C:\Windows\System32, by default) are considered protected. If the <b>GetOwnerModuleFromTcpEntry</b> function is called by a user that is not a member of the Administrators group, the function call will succeed but the <b>pModuleName</b> and <b>pModulePath</b> members will point to memory that contains an empty string for the TCP connections started by protected applications.</para>
      <para>For computers running on Windows Vista or later, accessing the <b>pModuleName</b> and <b>pModulePath</b> members of the <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure is limited  by user account control (UAC). If an application that calls this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will succeed but access to these members returns an empty string unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application on Windows Vista or later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for access to the protected <b>pModuleName</b> and <b>pModulePath</b> members to be allowed.</para>
    </remarks>
    <seealso cref="MIB_TCP6ROW_OWNER_MODULE" />
    <seealso cref="TCPIP_OWNER_MODULE_INFO_CLASS" />
  </member>
  <member name="Windows.GetOwnerModuleFromTcpEntry">
    <summary>
      <para>The <b>GetOwnerModuleFromTcpEntry</b> function retrieves data about the module that issued the context bind for a specific IPv4 TCP endpoint in a MIB table row.</para>
    </summary>
    <param name="pTcpEntry">
      <para>A pointer to a <see cref="MIB_TCPROW_OWNER_MODULE" /> structure that contains the IPv4 TCP endpoint entry used to obtain the owner module.</para>
    </param>
    <param name="Class">
      <para>A <see cref="TCPIP_OWNER_MODULE_INFO_CLASS" /> enumeration value that indicates the type of data to obtain regarding the owner module. The <b>TCPIP_OWNER_MODULE_INFO_CLASS</b> enumeration is defined in the <i>Iprtrmib.h</i> header file.</para>
      <para>This parameter must be set to <b>TCPIP_OWNER_MODULE_INFO_BASIC</b>.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer a buffer that contains a <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure with the owner module data. The type of data returned in this buffer is indicated by the value of the <i>Class</i> parameter.</para>
      <para>The following structures are used for the data in <i>Buffer</i> when  <i>Class</i> is set to the corresponding value.</para>
      <list type="table">
        <listheader>
          <description>
            <i>Class</i> enumeration value</description>
          <description>
            <i>Buffer</i> data format</description>
        </listheader>
        <item>
          <description>TCPIP_OWNER_MODULE_BASIC_INFO</description>
          <description>
            <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" />
          </description>
        </item>
      </list>
    </param>
    <param name="pdwSize">
      <para>The estimated size, in  bytes, of the structure returned in <i>Buffer</i>. If this value is set too small, <b>ERROR_INSUFFICIENT_BUFFER</b> is returned by this function, and this field will contain the correct size of the buffer. The size required is the size of the corresponding structure plus an additional number of bytes equal to the length of data pointed to in the structure (for example, the name and path strings).</para>
    </param>
    <returns>
      <para>If the function call is successful, the value <b>NO_ERROR</b> is returned.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>Insufficient space was allocated for the table. The size of the table is returned in the <i>pdwSize</i> parameter, and must be used in a subsequent call to this function in order to successfully retrieve the table.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>A parameter is incorrect. This value is returned if either of the <i>pTcpEntry</i> or <i>pdwSize</i> parameters are <b>NULL</b>. This value is also returned if the <i>Class</i> parameter is not equal to <b>TCPIP_OWNER_MODULE_INFO_BASIC</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory is available to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>A element was no found. This value is returned if the <b>dwOwningPid</b> member of the <see cref="MIB_TCPROW_OWNER_MODULE" /> structure pointed to by the <i>pTcpEntry</i> parameter was zero or could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PARTIAL_COPY</b>
            </para>
          </description>
          <description>
            <para>Only part of a request was completed.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <i>Buffer</i> parameter contains not only a structure with pointers to specific data,  for example, pointers to the zero-terminated strings that contain the name and path of the owner module, but the actual data itself; that is the name and path strings. Therefore, when calculating the buffer size, ensure that you have enough space for both the structure as well as the data the members of the structure point to.</para>
      <para>The resolution of TCP table entries to owner modules is a best practice. In a few cases, the owner module name returned in the <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure can be a process name, such as "svchost.exe", a service name (such as "RPC"), or a component name, such as "timer.dll".</para>
      <para>For computers running on Windows Vista or later, the <b>pModuleName</b> and <b>pModulePath</b> members of the <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> retrieved by  <b>GetOwnerModuleFromTcpEntry</b> function may point to an empty string for some TCP connections. Applications that start TCP connections located in the Windows system folder (C:\Windows\System32, by default) are considered protected. If the <b>GetOwnerModuleFromTcpEntry</b> function is called by a user that is not a member of the Administrators group, the function call will succeed but the <b>pModuleName</b> and <b>pModulePath</b> members will point to memory that contains an empty string for the TCP connections started by protected applications.</para>
      <para>For computers running on Windows Vista or later, accessing the <b>pModuleName</b> and <b>pModulePath</b> members of the <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure is limited  by user account control (UAC). If an application that calls this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will succeed but access to these members returns an empty string unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application on Windows Vista or later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for access to the protected <b>pModuleName</b> and <b>pModulePath</b> members to be allowed.</para>
    </remarks>
    <seealso cref="MIB_TCPROW_OWNER_MODULE" />
    <seealso cref="TCPIP_OWNER_MODULE_BASIC_INFO" />
  </member>
  <member name="Windows.GetOwnerModuleFromUdp6Entry">
    <summary>
      <para>The <b>GetOwnerModuleFromUdp6Entry</b> function retrieves data about the module that issued the context bind for a specific IPv6 UDP endpoint in a MIB table row.</para>
    </summary>
    <param name="pUdpEntry">
      <para>A pointer to a <see cref="MIB_UDP6ROW_OWNER_MODULE" /> structure that contains the IPv6 UDP endpoint entry used to obtain the owner module.</para>
    </param>
    <param name="Class">
      <para>
        <see cref="TCPIP_OWNER_MODULE_INFO_CLASS" /> enumeration value that indicates the type of data to obtain regarding the owner module.</para>
    </param>
    <param name="pBuffer">
      <para>The buffer that contains a <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure with the owner module data. The type of data returned in this buffer is indicated by the value of the <i>Class</i> parameter.</para>
      <para>The following structures are used for the data in <i>Buffer</i> when  <i>Class</i> is set to the corresponding value.</para>
      <list type="table">
        <listheader>
          <description>
            <i>Class</i> enumeration value</description>
          <description>
            <i>Buffer</i> data format</description>
        </listheader>
        <item>
          <description>TCPIP_OWNER_MODULE_BASIC_INFO</description>
          <description>
            <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" />
          </description>
        </item>
      </list>
    </param>
    <param name="pdwSize">
      <para>The estimated size, in bytes, of the structure returned in <i>Buffer</i>. If this value is set too small, <b>ERROR_INSUFFICIENT_BUFFER</b> is returned by this function, and this field will contain the correct size of the structure.</para>
    </param>
    <returns>
      <para>If the call is successful, the value <b>NO_ERROR</b> is returned. Otherwise, the following error is returned.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>An insufficient amount of space was allocated for the table. The size of the table is returned in the <i>pdwSize</i> parameter, and must be used in a subsequent call to this function in order to successfully retrieve the table.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <i>Buffer</i> parameter contains not only a structure with pointers to specific data, for example, pointers to the zero-terminated strings that contain the name and path of the owner module, but the actual data itself; that is the name and path strings. Therefore, when calculating the buffer size, ensure that you have enough space for both the structure as well as the data the members of the structure point to.</para>
      <para>The resolution of UDP table entries to owner modules is a best practice. In a few cases, the owner module name returned in the <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure can be a process name, such as "svchost.exe", a service name, such as "RPC", or a component name, such as "timer.dll".</para>
      <para>For computers running on Windows Vista or later, accessing the <b>pModuleName</b> and <b>pModulePath</b> members of the <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure is limited  by user account control (UAC). If an application that calls this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will succeed but access to these members returns an empty string unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application on Windows Vista or later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for access to the protected <b>pModuleName</b> and <b>pModulePath</b> members to be allowed.</para>
    </remarks>
  </member>
  <member name="Windows.GetOwnerModuleFromUdpEntry">
    <summary>
      <para>The <b>GetOwnerModuleFromUdpEntry</b> function retrieves data about the module that issued the context bind for a specific IPv4 UDP endpoint in a MIB table row.</para>
    </summary>
    <param name="pUdpEntry">
      <para>A pointer to a <see cref="MIB_UDPROW_OWNER_MODULE" /> structure that contains the IPv4 UDP endpoint entry used to obtain the owner module.</para>
    </param>
    <param name="Class">
      <para>A <see cref="TCPIP_OWNER_MODULE_INFO_CLASS" /> enumeration value that indicates the type of data to obtain regarding the owner module.</para>
    </param>
    <param name="pBuffer">
      <para>The buffer that contains a <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure with the owner module data. The type of data returned in this buffer is indicated by the value of the <i>Class</i> parameter.</para>
      <para>The following structures are used for the data in <i>Buffer</i> when  <i>Class</i> is set to the corresponding value.</para>
      <list type="table">
        <listheader>
          <description>
            <i>Class</i> enumeration value</description>
          <description>
            <i>Buffer</i> data format</description>
        </listheader>
        <item>
          <description>TCPIP_OWNER_MODULE_BASIC_INFO</description>
          <description>
            <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" />
          </description>
        </item>
      </list>
    </param>
    <param name="pdwSize">
      <para>The estimated size, in bytes, of the structure returned in <i>Buffer</i>. If this value is set too small, <b>ERROR_INSUFFICIENT_BUFFER</b> is returned by this function, and this field will contain the correct structure size.</para>
    </param>
    <returns>
      <para>If the call is successful, the value <b>NO_ERROR</b> is returned. Otherwise, the following error is returned.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>Insufficient space was allocated for the table. The size of the table is returned in the <i>pdwSize</i> parameter, and must be used in a subsequent call to this function in order to successfully retrieve the table.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <i>Buffer</i> parameter contains not only a structure with pointers to specific data, for example, pointers to the zero-terminated strings that contain the name and path of the owner module, but also the actual data itself; that is the name and path strings. Therefore, when calculating the buffer size, ensure that you have enough space for both the structure as well as the data the members of the structure point to.</para>
      <para>The resolution of UDP table entries to owner modules is a best practice. In a few cases, the owner module name returned in the <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure can be a process name, such as "svchost.exe", a service name, such as "RPC", or a component name, such as "timer.dll".</para>
      <para>For computers running on Windows Vista or later, accessing the <b>pModuleName</b> and <b>pModulePath</b> members of the <see cref="TCPIP_OWNER_MODULE_BASIC_INFO" /> structure is limited  by user account control (UAC). If an application that calls this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will succeed but access to these members returns an empty string unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application on Windows Vista or later lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for access to the protected <b>pModuleName</b> and <b>pModulePath</b> members to be allowed.</para>
    </remarks>
  </member>
  <member name="Windows.GetPerAdapterInfo">
    <summary>
      <para>The
<b>GetPerAdapterInfo</b> function retrieves information about the adapter corresponding to the specified interface.</para>
    </summary>
    <param name="IfIndex">
      <para>Index of an interface.
The <b>GetPerAdapterInfo</b> function retrieves information for the adapter corresponding to this interface.</para>
    </param>
    <param name="pPerAdapterInfo">
      <para>Pointer to an
<see cref="IP_PER_ADAPTER_INFO" /> structure that receives information about the adapter.</para>
    </param>
    <param name="pOutBufLen">
      <para>Pointer to a <b>ULONG</b> variable that specifies the size of the
<see cref="IP_PER_ADAPTER_INFO" /> structure. If this size is insufficient to hold the information,
<b>GetPerAdapterInfo</b> fills in this variable with the required size, and returns an error code of ERROR_BUFFER_OVERFLOW.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is ERROR_SUCCESS.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The buffer size indicated by the <i>pOutBufLen</i> parameter is too small to hold the adapter information. The <i>pOutBufLen</i> parameter points to the required size.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pOutBufLen</i> parameter is <b>NULL</b>, or the calling process does not have read/write access to the memory pointed to by <i>pOutBufLen</i>, or the calling process does not have write access to the memory pointed to by the <i>pAdapterInfo</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>
              <see cref="GetPerAdapterInfo" /> is not supported by the operating system running on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>An  adapter index  may change when the adapter is disabled and then enabled, or under other circumstances, and should not be considered persistent.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="IP_PER_ADAPTER_INFO" />
  </member>
  <member name="Windows.GetPerTcp6ConnectionEStats">
    <summary>
      <para>The
<b>GetPerTcp6ConnectionEStats</b> function retrieves extended statistics for an IPv6 TCP connection.</para>
    </summary>
    <param name="Row">
      <para>A pointer to a <see cref="MIB_TCP6ROW" /> structure for an IPv6 TCP connection.</para>
    </param>
    <param name="EstatsType">
      <para>The type of extended statistics for TCP requested. This parameter determines the data and format of information that is returned in the <i>Rw</i>, <i>Rod</i>, and <i>Ros</i> parameters if the call is successful.</para>
      <para>This parameter can be one of the values from the <see cref="TCP_ESTATS_TYPE" /> enumeration type defined in the <i>Tcpestats.h</i> header file.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>TcpConnectionEstatsSynOpts</b>
          </description>
          <description>
            <para>This value requests SYN exchange information for a TCP connection.</para>
            <para>Only read-only static information is available for this enumeration value.</para>
            <para>If the <i>Ros</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Ros</i> parameter should contain a <see cref="TCP_ESTATS_SYN_OPTS_ROS_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsData</b>
          </description>
          <description>
            <para>This value requests extended data transfer information for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_DATA_RW_v0" /> structure.</para>
            <para>If extended data transfer information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_DATA_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsSndCong</b>
          </description>
          <description>
            <para>This value requests sender congestion for a TCP connection.</para>
            <para>All three types of information (read-only static, read-only dynamic,  and read/write information) are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_SND_CONG_RW_v0" /> structure.</para>
            <para>If the <i>Ros</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Ros</i> parameter should contain a <see cref="TCP_ESTATS_SND_CONG_ROS_v0" /> structure.</para>
            <para>If sender congestion information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_SND_CONG_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsPath</b>
          </description>
          <description>
            <para>This value requests extended path measurement information for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_PATH_RW_v0" /> structure.</para>
            <para>If extended path measurement information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_PATH_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsSendBuff</b>
          </description>
          <description>
            <para>This value requests extended output-queuing information for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_SEND_BUFF_RW_v0" /> structure.</para>
            <para>If extended output-queuing information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_SEND_BUFF_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsRec</b>
          </description>
          <description>
            <para>This value requests extended local-receiver information for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_REC_RW_v0" /> structure.</para>
            <para>If extended local-receiver information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_REC_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsObsRec</b>
          </description>
          <description>
            <para>This value requests extended remote-receiver information for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_OBS_REC_RW_v0" /> structure.</para>
            <para>If extended remote-receiver information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_OBS_REC_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsBandwidth</b>
          </description>
          <description>
            <para>This value requests bandwidth estimation statistics for a TCP connection on bandwidth.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_BANDWIDTH_RW_v0" /> structure.</para>
            <para>If bandwidth estimation statistics was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_BANDWIDTH_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsFineRtt</b>
          </description>
          <description>
            <para>This value requests fine-grained round-trip time (RTT) estimation statistics for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_FINE_RTT_RW_v0" /> structure.</para>
            <para>If fine-grained RTT estimation statistics was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_FINE_RTT_ROD_v0" /> structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="Rw">
      <para>A pointer to a buffer to receive the read/write information. This parameter may be a <b>NULL</b> pointer if an application does not want to retrieve read/write information for the TCP connection.</para>
    </param>
    <param name="RwVersion">
      <para>The version of the read/write information requested. The current supported value is a version of zero.</para>
    </param>
    <param name="RwSize">
      <para>The size, in bytes, of the buffer pointed to by <i>Rw</i> parameter.</para>
    </param>
    <param name="Ros">
      <para>A pointer to a buffer to receive read-only static information. This parameter may be a <b>NULL</b> pointer if an application does not want to retrieve read-only static information for the TCP connection.</para>
    </param>
    <param name="RosVersion">
      <para>The version of the read-only static information requested. The current supported value is a version of zero.</para>
    </param>
    <param name="RosSize">
      <para>The size, in bytes, of the buffer pointed to by the <i>Ros</i> parameter.</para>
    </param>
    <param name="Rod">
      <para>A pointer to a buffer to receive read-only dynamic information. This parameter may be a <b>NULL</b> pointer if an application does not want to retrieve read-only dynamic information  for the TCP connection.</para>
    </param>
    <param name="RodVersion">
      <para>The version of the read-only dynamic information requested. The current supported value is a version of zero..</para>
    </param>
    <param name="RodSize">
      <para>The size, in bytes, of the buffer pointed to by the <i>Rod</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>A buffer passed to a function is too small. This error is returned if the buffer pointed to by the <i>Rw</i>, <i>Ros</i>,  or <i>Rod</i> parameters is not large enough to receive the data.  This error also returned if one of the given buffers pointed to by the <i>Rw</i>, <i>Ros</i>,  or <i>Rod</i> parameters is <b>NULL</b>,
but a length was specified in the associated <i>RwSize</i>, <i>RosSize</i>,  or <i>RodSize</i>.</para>
            <para>This error value is returned on Windows Vista and Windows Server 2008.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The parameter is incorrect. This error is returned if the <i>Row</i> parameter is a <b>NULL</b> pointer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_USER_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The supplied user buffer is not valid for the requested operation. This error is returned if one of the given buffers pointed to by the <i>Rw</i>, <i>Ros</i>,  or <i>Rod</i> parameters is <b>NULL</b>,
but a length was specified in the associated <i>RwSize</i>, <i>RosSize</i>,  or <i>RodSize</i>. As a result, this error is returned if any of the following conditions are met:</para>
            <list type="bullet">
              <item>
                <description>The <i>Row</i> parameter is a <b>NULL</b> pointer and the <i>RwSize</i> parameter is nonzero.</description>
              </item>
              <item>
                <description>The <i>Ros</i> parameter is a <b>NULL</b> pointer and the <i>RosSize</i> parameter is nonzero.</description>
              </item>
              <item>
                <description>The <i>Rod</i> parameter is a <b>NULL</b> pointer and the <i>RodSize</i> parameter is nonzero.</description>
              </item>
            </list>
            <para>This error value is returned on Windows 7 and Windows Server 2008 R2.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>This requested entry was not found. This error is returned if the TCP connection specified in the <i>Row</i> parameter could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported. This error is returned if the <i>RwVersion</i>, <i>RosVersion</i>, or <i>RodVersion</i> parameter is not set to zero.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetPerTcp6ConnectionEStats</b> function is defined on Windows Vista and later.</para>
      <para>The <b>GetPerTcp6ConnectionEStats</b> function is designed to use TCP to diagnose performance
problems in both the network and the application.  If a network based
application is performing poorly, TCP can determine if the bottleneck
is in the sender, the receiver or the network itself.  If the
bottleneck is in the network, TCP can provide specific information
about its nature.</para>
      <para>The <b>GetPerTcp6ConnectionEStats</b> function retrieves extended statistics for the IPv6 TCP connection passed in the <i>Row</i> parameter. The type of extended statistics that is retrieved is specified in the <i>EstatsType</i> parameter. Extended statistics on this TCP connection must have previously been enabled by calls to the <see cref="SetPerTcp6ConnectionEStats" /> function for all <see cref="TCP_ESTATS_TYPE" /> values except when <b>TcpConnectionEstatsSynOpts</b> is passed in the <i>EstatsType</i> parameter.</para>
      <para>The <see cref="GetTcp6Table" /> function is used to retrieve the IPv6 TCP connection table on the local computer. This function returns a <see cref="MIB_TCP6TABLE" /> structure that contain an array of <see cref="MIB_TCP6ROW" /> entries. The <i>Row</i> parameter passed to the <b>GetPerTcp6ConnectionEStats</b> function must be an entry for an existing IPv6 TCP connection.</para>
      <para>The only version of TCP connection statistics currently supported is version zero. So the <i>RwVersion</i>, <i>RosVersion</i>, and <i>RodVersion</i> parameters passed to <b>GetPerTcp6ConnectionEStats</b> should be set to 0.</para>
      <para>For information on extended TCP statistics on an IPv4 connection, see the <see cref="GetPerTcpConnectionEStats" /> and <see cref="SetPerTcpConnectionEStats" /> functions.</para>
      <para>The <see cref="SetPerTcp6ConnectionEStats" /> function can only be called by a user logged on as a member of the Administrators group. If <b>SetPerTcp6ConnectionEStats</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>The caller of <b>GetPerTcp6ConnectionEStats</b> should check the <i>EnableCollection</i> field in the returned <i>Rw</i> struct, and if it is not <code>TRUE</code>, then the caller should ignore the data in the <i>Ros</i> and <i>Rod</i> structs. If <i>EnableCollection</i> is set to <code>FALSE</code>, then the data returned in <i>Ros</i> and <i>Rod</i> are undefined. For example, one condition under which this can happen is when you're using <b>GetPerTcp6ConnectionEStats</b> to retrieve extended statistics for an IPv6 TCP connection, and you've previously called <see cref="SetPerTcp6ConnectionEStats" /> to enable extended statistics. If the <b>SetPerTcp6ConnectionEStats</b> call fails then subsequent calls to <b>GetPerTcp6ConnectionEStats</b> will return meaningless random data, and not extended TCP statistics. You can observe that example by running the example below as both an administrator, and as a normal user.</para>
    </remarks>
    <seealso cref="GetPerTcpConnectionEStats" />
    <seealso cref="GetTcp6Table" />
    <seealso cref="MIB_TCP6ROW" />
    <seealso cref="MIB_TCP6TABLE" />
    <seealso cref="SetPerTcp6ConnectionEStats" />
    <seealso cref="SetPerTcpConnectionEStats" />
    <seealso cref="TCP_ESTATS_BANDWIDTH_ROD_v0" />
    <seealso cref="TCP_ESTATS_BANDWIDTH_RW_v0" />
    <seealso cref="TCP_ESTATS_DATA_ROD_v0" />
    <seealso cref="TCP_ESTATS_DATA_RW_v0" />
    <seealso cref="TCP_ESTATS_FINE_RTT_ROD_v0" />
    <seealso cref="TCP_ESTATS_FINE_RTT_RW_v0" />
    <seealso cref="TCP_ESTATS_OBS_REC_ROD_v0" />
    <seealso cref="TCP_ESTATS_OBS_REC_RW_v0" />
    <seealso cref="TCP_ESTATS_PATH_ROD_v0" />
    <seealso cref="TCP_ESTATS_PATH_RW_v0" />
    <seealso cref="TCP_ESTATS_REC_ROD_v0" />
    <seealso cref="TCP_ESTATS_REC_RW_v0" />
    <seealso cref="TCP_ESTATS_SEND_BUFF_ROD_v0" />
    <seealso cref="TCP_ESTATS_SEND_BUFF_RW_v0" />
    <seealso cref="TCP_ESTATS_SND_CONG_ROD_v0" />
    <seealso cref="TCP_ESTATS_SND_CONG_ROS_v0" />
    <seealso cref="TCP_ESTATS_SND_CONG_RW_v0" />
    <seealso cref="TCP_ESTATS_SYN_OPTS_ROS_v0" />
    <seealso cref="TCP_ESTATS_TYPE" />
    <seealso cref="TCP_SOFT_ERROR" />
  </member>
  <member name="Windows.GetPerTcpConnectionEStats">
    <summary>
      <para>The
<b>GetPerTcpConnectionEStats</b> function retrieves extended statistics for an IPv4 TCP connection.</para>
    </summary>
    <param name="Row">
      <para>A pointer to a <see cref="MIB_TCPROW" /> structure for an IPv4 TCP connection.</para>
    </param>
    <param name="EstatsType">
      <para>The type of extended statistics for TCP requested. This parameter determines the data and format of information that is returned in the <i>Rw</i>, <i>Rod</i>, and <i>Ros</i> parameters if the call is successful.</para>
      <para>This parameter can be one of the values from the <see cref="TCP_ESTATS_TYPE" /> enumeration type defined in the <i>Tcpestats.h</i> header file.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>TcpConnectionEstatsSynOpts</b>
          </description>
          <description>
            <para>This value requests SYN exchange information for a TCP connection.</para>
            <para>Only read-only static information is available for this enumeration value.</para>
            <para>If the <i>Ros</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Ros</i> parameter should contain a <see cref="TCP_ESTATS_SYN_OPTS_ROS_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsData</b>
          </description>
          <description>
            <para>This value requests extended data transfer information for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_DATA_RW_v0" /> structure.</para>
            <para>If extended data transfer information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_DATA_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsSndCong</b>
          </description>
          <description>
            <para>This value requests sender congestion for a TCP connection.</para>
            <para>All three types of information (read-only static, read-only dynamic,  and read/write information) are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_SND_CONG_RW_v0" /> structure.</para>
            <para>If the <i>Ros</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Ros</i> parameter should contain a <see cref="TCP_ESTATS_SND_CONG_ROS_v0" /> structure.</para>
            <para>If sender congestion information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_SND_CONG_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsPath</b>
          </description>
          <description>
            <para>This value requests extended path measurement information for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_PATH_RW_v0" /> structure.</para>
            <para>If extended path measurement information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_PATH_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsSendBuff</b>
          </description>
          <description>
            <para>This value requests extended output-queuing information for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_SEND_BUFF_RW_v0" /> structure.</para>
            <para>If extended output-queuing information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_SEND_BUFF_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsRec</b>
          </description>
          <description>
            <para>This value requests extended local-receiver information for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_REC_RW_v0" /> structure.</para>
            <para>If extended local-receiver information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_REC_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsObsRec</b>
          </description>
          <description>
            <para>This value requests extended remote-receiver information for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_OBS_REC_RW_v0" /> structure.</para>
            <para>If extended remote-receiver information was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_OBS_REC_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsBandwidth</b>
          </description>
          <description>
            <para>This value requests bandwidth estimation statistics for a TCP connection on bandwidth.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_BANDWIDTH_RW_v0" /> structure.</para>
            <para>If bandwidth estimation statistics was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_BANDWIDTH_ROD_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsFineRtt</b>
          </description>
          <description>
            <para>This value requests fine-grained round-trip time (RTT) estimation statistics for a TCP connection.</para>
            <para>Only read-only dynamic information and read/write information are available for this enumeration value.</para>
            <para>If the <i>Rw</i> parameter was not <b>NULL</b> and the function succeeds, the buffer pointed to by the <i>Rw</i> parameter should contain a <see cref="TCP_ESTATS_FINE_RTT_RW_v0" /> structure.</para>
            <para>If fine-grained RTT estimation statistics was enabled  for this TCP connection, the <i>Rod</i> parameter was not <b>NULL</b>, and the function succeeds, the buffer pointed to by the <i>Rod</i> parameter should contain a <see cref="TCP_ESTATS_FINE_RTT_ROD_v0" /> structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="Rw">
      <para>A pointer to a buffer to receive the read/write information. This parameter may be a <b>NULL</b> pointer if an application does not want to retrieve read/write information for the TCP connection.</para>
    </param>
    <param name="RwVersion">
      <para>The version of the read/write information requested. The current supported value is a version of zero.</para>
    </param>
    <param name="RwSize">
      <para>The size, in bytes, of the buffer pointed to by <i>Rw</i> parameter.</para>
    </param>
    <param name="Ros">
      <para>A pointer to a buffer to receive read-only static information. This parameter may be a <b>NULL</b> pointer if an application does not want to retrieve read-only static information for the TCP connection.</para>
    </param>
    <param name="RosVersion">
      <para>The version of the read-only static information requested. The current supported value is a version of zero.</para>
    </param>
    <param name="RosSize">
      <para>The size, in bytes, of the buffer pointed to by the <i>Ros</i> parameter.</para>
    </param>
    <param name="Rod">
      <para>A pointer to a buffer to receive read-only dynamic information. This parameter may be a <b>NULL</b> pointer if an application does not want to retrieve read-only dynamic information  for the TCP connection.</para>
    </param>
    <param name="RodVersion">
      <para>The version of the read-only dynamic information requested. The current supported value is a version of zero.</para>
    </param>
    <param name="RodSize">
      <para>The size, in bytes, of the buffer pointed to by the <i>Rod</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>A buffer passed to a function is too small. This error is returned if the buffer pointed to by the <i>Rw</i>, <i>Ros</i>,  or <i>Rod</i> parameters is not large enough to receive the data.  This error also returned if one of the given buffers pointed to by the <i>Rw</i>, <i>Ros</i>,  or <i>Rod</i> parameters is <b>NULL</b>,
but a length was specified in the associated <i>RwSize</i>, <i>RosSize</i>,  or <i>RodSize</i>.</para>
            <para>This error value is returned on Windows Vista and Windows Server 2008.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The parameter is incorrect. This error is returned if the <i>Row</i> parameter is a <b>NULL</b> pointer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_USER_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The supplied user buffer is not valid for the requested operation. This error is returned if one of the given buffers pointed to by the <i>Rw</i>, <i>Ros</i>,  or <i>Rod</i> parameters is <b>NULL</b>,
but a length was specified in the associated <i>RwSize</i>, <i>RosSize</i>,  or <i>RodSize</i>. As a result, this error is returned if any of the following conditions are met:</para>
            <list type="bullet">
              <item>
                <description>The <i>Row</i> parameter is a <b>NULL</b> pointer and the <i>RwSize</i> parameter is nonzero.</description>
              </item>
              <item>
                <description>The <i>Ros</i> parameter is a <b>NULL</b> pointer and the <i>RosSize</i> parameter is nonzero.</description>
              </item>
              <item>
                <description>The <i>Rod</i> parameter is a <b>NULL</b> pointer and the <i>RodSize</i> parameter is nonzero.</description>
              </item>
            </list>
            <para>This error value is returned on Windows 7 and Windows Server 2008 R2.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>This requested entry was not found. This error is returned if the TCP connection specified in the <i>Row</i> parameter could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported. This error is returned if the <i>RwVersion</i>, <i>RosVersion</i>, or <i>RodVersion</i> parameter is not set to zero.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetPerTcpConnectionEStats</b> function is defined on Windows Vista and later.</para>
      <para>The <b>GetPerTcpConnectionEStats</b> function is designed to use TCP to diagnose performance
problems in both the network and the application.  If a network based
application is performing poorly, TCP can determine if the bottleneck
is in the sender, the receiver or the network itself.  If the
bottleneck is in the network, TCP can provide specific information
about its nature.</para>
      <para>The <b>GetPerTcpConnectionEStats</b> function retrieves extended statistics for the IPv4 TCP connection passed in the <i>Row</i> parameter. The type of extended statistics that is retrieved is specified in the <i>EstatsType</i> parameter. Extended statistics on this TCP connection must have previously been enabled by calls to the <see cref="SetPerTcpConnectionEStats" /> function for all <see cref="TCP_ESTATS_TYPE" /> values except when <b>TcpConnectionEstatsSynOpts</b> is passed in the <i>EstatsType</i> parameter.</para>
      <para>The <see cref="GetTcpTable" /> function is used to retrieve the IPv4 TCP connection table on the local computer. This function returns a <see cref="MIB_TCPTABLE" /> structure that contain an array of <see cref="MIB_TCPROW" /> entries. The <i>Row</i> parameter passed to the <b>GetPerTcpConnectionEStats</b> function must be an entry for an existing IPv4 TCP connection.</para>
      <para>The only version of TCP connection statistics currently supported is version zero. So the <i>RwVersion</i>, <i>RosVersion</i>, and <i>RodVersion</i> parameters passed to <b>GetPerTcpConnectionEStats</b> should be set to 0.</para>
      <para>For information on extended TCP statistics on an IPv6 connection, see the <see cref="GetPerTcp6ConnectionEStats" /> and <see cref="SetPerTcp6ConnectionEStats" /> functions.</para>
      <para>The <see cref="SetPerTcpConnectionEStats" /> function can only be called by a user logged on as a member of the Administrators group. If <b>SetPerTcpConnectionEStats</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>The caller of <b>GetPerTcpConnectionEStats</b> should check the <i>EnableCollection</i> field in the returned <i>Rw</i> struct, and if it is not <code>TRUE</code>, then the caller should ignore the data in the <i>Ros</i> and <i>Rod</i> structs. If <i>EnableCollection</i> is set to <code>FALSE</code>, then the data returned in <i>Ros</i> and <i>Rod</i> are undefined. For example, one condition under which this can happen is when you're using <b>GetPerTcpConnectionEStats</b> to retrieve extended statistics for an IPv4 TCP connection, and you've previously called <see cref="SetPerTcpConnectionEStats" /> to enable extended statistics. If the <b>SetPerTcpConnectionEStats</b> call fails then subsequent calls to <b>GetPerTcpConnectionEStats</b> will return meaningless random data, and not extended TCP statistics. You can observe that example by running the example below as both an administrator, and as a normal user.</para>
    </remarks>
    <seealso cref="GetPerTcp6ConnectionEStats" />
    <seealso cref="GetTcpTable" />
    <seealso cref="MIB_TCPROW" />
    <seealso cref="MIB_TCPTABLE" />
    <seealso cref="SetPerTcp6ConnectionEStats" />
    <seealso cref="SetPerTcpConnectionEStats" />
    <seealso cref="TCP_ESTATS_BANDWIDTH_ROD_v0" />
    <seealso cref="TCP_ESTATS_BANDWIDTH_RW_v0" />
    <seealso cref="TCP_ESTATS_DATA_ROD_v0" />
    <seealso cref="TCP_ESTATS_DATA_RW_v0" />
    <seealso cref="TCP_ESTATS_FINE_RTT_ROD_v0" />
    <seealso cref="TCP_ESTATS_FINE_RTT_RW_v0" />
    <seealso cref="TCP_ESTATS_OBS_REC_ROD_v0" />
    <seealso cref="TCP_ESTATS_OBS_REC_RW_v0" />
    <seealso cref="TCP_ESTATS_PATH_ROD_v0" />
    <seealso cref="TCP_ESTATS_PATH_RW_v0" />
    <seealso cref="TCP_ESTATS_REC_ROD_v0" />
    <seealso cref="TCP_ESTATS_REC_RW_v0" />
    <seealso cref="TCP_ESTATS_SEND_BUFF_ROD_v0" />
    <seealso cref="TCP_ESTATS_SEND_BUFF_RW_v0" />
    <seealso cref="TCP_ESTATS_SND_CONG_ROD_v0" />
    <seealso cref="TCP_ESTATS_SND_CONG_ROS_v0" />
    <seealso cref="TCP_ESTATS_SND_CONG_RW_v0" />
    <seealso cref="TCP_ESTATS_SYN_OPTS_ROS_v0" />
    <seealso cref="TCP_ESTATS_TYPE" />
    <seealso cref="TCP_SOFT_ERROR" />
  </member>
  <member name="Windows.GetRTTAndHopCount">
    <summary>
      <para>The
<b>GetRTTAndHopCount</b> function determines the round-trip time (RTT) and hop count to the specified destination.</para>
    </summary>
    <param name="DestIpAddress">
      <para>IP address of the destination for which to determine the RTT and hop count, in the form of an <see cref="IPAddr" /> structure.</para>
    </param>
    <param name="HopCount">
      <para>Pointer to a <b>ULONG</b> variable. This variable receives the hop count to the destination specified by the <i>DestIpAddress</i> parameter.</para>
    </param>
    <param name="MaxHops">
      <para>Maximum number of hops to search for the destination. If the number of hops to the destination exceeds this number, the function terminates the search and returns <b>FALSE</b>.</para>
    </param>
    <param name="RTT">
      <para>Round-trip time, in milliseconds, to the destination specified by <i>DestIpAddress</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. Call
<see cref="GetLastError" /> to obtain the error code for the failure.</para>
    </returns>
    <remarks>
      <para>For information about the <b>IPAddr</b> data type, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">Windows Data Types</a>. To convert an IP address between dotted decimal notation and <b>IPAddr</b> format, use the
<see cref="inet_addr" /> and
<see cref="inet_ntoa" /> functions.</para>
      <h4>Examples</h4>
      <para>The following example retrieves and prints the round trip time and hop count to the destination IP address 127.0.0.1.</para>
      <code>UINT ip = inet_addr("127.0.0.1");
ULONG hopCount = 0;
ULONG RTT = 0;

if(GetRTTAndHopCount(ip, &amp;amp;amp;amp;amp;amp;hopCount, 30, &amp;amp;amp;amp;amp;amp;RTT) == TRUE) {
  printf("Hops: %ld\n", hopCount);
  printf("RTT: %ld\n", RTT);
}
else {
  printf("Error: %ld\n", GetLastError());
}

</code>
    </remarks>
    <seealso cref="GetBestInterface" />
    <seealso cref="GetBestRoute" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="IPAddr" />
  </member>
  <member name="Windows.GetTcp6Table">
    <summary>
      <para>The
<b>GetTcp6Table</b> function retrieves the TCP connection table for IPv6.</para>
    </summary>
    <param name="TcpTable">
      <para>A pointer to a buffer that receives the TCP connection table for IPv6 as a
<see cref="MIB_TCP6TABLE" /> structure.</para>
    </param>
    <param name="SizePointer">
      <para>On input, specifies the size in bytes of the buffer pointed to by the <i>TcpTable</i> parameter.</para>
      <para>On output, if the buffer is not large enough to hold the returned TCP connection table, the function sets this parameter equal to the required buffer size in bytes.</para>
    </param>
    <param name="Order">
      <para>A Boolean value that specifies whether the TCP connection table should be sorted. If this parameter is <b>TRUE</b>, the table is sorted in ascending order, starting with the lowest local IP address.  If this parameter is <b>FALSE</b>, the table appears in the order in which they were retrieved.</para>
      <para>The following values are compared (as listed) when ordering the TCP endpoints:</para>
      <list type="number">
        <item>
          <description>Local IPv6 address</description>
        </item>
        <item>
          <description>Local scope ID</description>
        </item>
        <item>
          <description>Local port</description>
        </item>
        <item>
          <description>Remote IPv6 address</description>
        </item>
        <item>
          <description>Remote scope ID</description>
        </item>
        <item>
          <description>Remote port</description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer pointed to by the <i>TcpTable</i> parameter is not large enough. The required size is returned in the variable pointed to by the <i>SizePointer</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>SizePointer</i> parameter is <b>NULL</b>, or
<see cref="GetTcp6Table" /> is unable to write to the memory pointed to by the <i>SizePointer</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system in use on the local system.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTcp6Table</b> function is defined on Windows Vista and later.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the TCP connection table for IPv6 and prints the state of each connection.</para>
      <code>#ifndef UNICODE
#define UNICODE
#endif

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

// Need to link with Iphlpapi.lib and Ws2_32.lib
#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))
/* Note: could also use malloc() and free() */

int wmain()
{

    // Declare and initialize variables
    PMIB_TCP6TABLE pTcpTable;
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;

    wchar_t ipstringbuffer[46];

    int i;

    pTcpTable = (MIB_TCP6TABLE *) MALLOC(sizeof (MIB_TCP6TABLE));
    if (pTcpTable == NULL) {
        wprintf(L"Error allocating memory\n");
        return 1;
    }

    dwSize = sizeof (MIB_TCP6TABLE);
// Make an initial call to GetTcp6Table to
// get the necessary size into the dwSize variable
    if ((dwRetVal = GetTcp6Table(pTcpTable, &amp;amp;amp;amp;amp;amp;dwSize, TRUE)) ==
        ERROR_INSUFFICIENT_BUFFER) {
        FREE(pTcpTable);
        pTcpTable = (MIB_TCP6TABLE *) MALLOC(dwSize);
        if (pTcpTable == NULL) {
            wprintf(L"Error allocating memory\n");
            return 1;
        }
    }
// Make a second call to GetTcp6Table to get
// the actual data we require
    if ((dwRetVal = GetTcp6Table(pTcpTable, &amp;amp;amp;amp;amp;amp;dwSize, TRUE)) == NO_ERROR) {
        wprintf(L"\tNumber of entries: %d\n", (int) pTcpTable-&gt;dwNumEntries);
        for (i = 0; i &lt; (int) pTcpTable-&gt;dwNumEntries; i++) {
            wprintf(L"\n\tTCP[%d] State: %ld - ", i,
                   pTcpTable-&gt;table[i].State);
            switch (pTcpTable-&gt;table[i].State) {
            case MIB_TCP_STATE_CLOSED:
                wprintf(L"CLOSED\n");
                break;
            case MIB_TCP_STATE_LISTEN:
                wprintf(L"LISTEN\n");
                break;
            case MIB_TCP_STATE_SYN_SENT:
                wprintf(L"SYN-SENT\n");
                break;
            case MIB_TCP_STATE_SYN_RCVD:
                wprintf(L"SYN-RECEIVED\n");
                break;
            case MIB_TCP_STATE_ESTAB:
                wprintf(L"ESTABLISHED\n");
                break;
            case MIB_TCP_STATE_FIN_WAIT1:
                wprintf(L"FIN-WAIT-1\n");
                break;
            case MIB_TCP_STATE_FIN_WAIT2:
                wprintf(L"FIN-WAIT-2 \n");
                break;
            case MIB_TCP_STATE_CLOSE_WAIT:
                wprintf(L"CLOSE-WAIT\n");
                break;
            case MIB_TCP_STATE_CLOSING:
                wprintf(L"CLOSING\n");
                break;
            case MIB_TCP_STATE_LAST_ACK:
                wprintf(L"LAST-ACK\n");
                break;
            case MIB_TCP_STATE_TIME_WAIT:
                wprintf(L"TIME-WAIT\n");
                break;
            case MIB_TCP_STATE_DELETE_TCB:
                wprintf(L"DELETE-TCB\n");
                break;
            default:
                wprintf(L"UNKNOWN dwState value\n");
                break;
            }

            if (InetNtop(AF_INET6, &amp;amp;amp;amp;amp;amp;pTcpTable-&gt;table[i].LocalAddr, ipstringbuffer, 46) == NULL)
                wprintf(L"  InetNtop function failed for local IPv6 address\n");
            else
                wprintf(L"\tTCP[%d] Local Addr: %s\n", i, ipstringbuffer);
            wprintf(L"\tTCP[%d] Local Scope ID: %d \n", i,
                   ntohl (pTcpTable-&gt;table[i].dwLocalScopeId));
            wprintf(L"\tTCP[%d] Local Port: %d \n", i,
                   ntohs((u_short)pTcpTable-&gt;table[i].dwLocalPort));

            if (InetNtop(AF_INET6, &amp;amp;amp;amp;amp;amp;pTcpTable-&gt;table[i].RemoteAddr, ipstringbuffer, 46) == NULL)
                wprintf(L"  InetNtop function failed for remote IPv6 address\n");
            else
                wprintf(L"\tTCP[%d] Remote Addr: %s\n", i, ipstringbuffer);
            wprintf(L"\tTCP[%d] Remote Scope ID: %d \n", i,
                   ntohl(pTcpTable-&gt;table[i].dwRemoteScopeId));
            wprintf(L"\tTCP[%d] Remote Port: %d\n", i,
                   ntohs((u_short)pTcpTable-&gt;table[i].dwRemotePort));
        }
    } else {
        wprintf(L"\tGetTcp6Table failed with %d\n", dwRetVal);
        FREE(pTcpTable);
        return 1;
    }

    if (pTcpTable != NULL) {
        FREE(pTcpTable);
        pTcpTable = NULL;
    }

    return 0;
}

</code>
    </remarks>
    <seealso cref="GetExtendedTcpTable" />
    <seealso cref="GetOwnerModuleFromTcp6Entry" />
    <seealso cref="GetTcp6Table2" />
    <seealso cref="GetTcpStatisticsEx" />
    <seealso cref="GetTcpTable2" />
    <seealso cref="MIB_TCP6ROW" />
    <seealso cref="MIB_TCP6ROW_OWNER_MODULE" />
    <seealso cref="MIB_TCP6ROW_OWNER_PID" />
    <seealso cref="MIB_TCP6TABLE" />
    <seealso cref="MIB_TCP6TABLE_OWNER_MODULE" />
    <seealso cref="MIB_TCP6TABLE_OWNER_PID" />
  </member>
  <member name="Windows.GetTcp6Table2">
    <summary>
      <para>The
<b>GetTcp6Table2</b> function retrieves the TCP connection table for IPv6.</para>
    </summary>
    <param name="TcpTable">
      <para>A pointer to a buffer that receives the TCP connection table for IPv6 as a
<see cref="MIB_TCP6TABLE2" /> structure.</para>
    </param>
    <param name="SizePointer">
      <para>On input, specifies the size of the buffer pointed to by the <i>TcpTable</i> parameter.</para>
      <para>On output, if the buffer is not large enough to hold the returned TCP connection table, the function sets this parameter equal to the required buffer size.</para>
    </param>
    <param name="Order">
      <para>A value that specifies whether the TCP connection table should be sorted. If this parameter is <b>TRUE</b>, the table is sorted in ascending order, starting with the lowest local IP address.  If this parameter is <b>FALSE</b>, the table appears in the order in which they were retrieved.</para>
      <para>The following values are compared (as listed) when ordering the TCP endpoints:</para>
      <list type="number">
        <item>
          <description>Local IPv6 address</description>
        </item>
        <item>
          <description>Local scope ID</description>
        </item>
        <item>
          <description>Local port</description>
        </item>
        <item>
          <description>Remote IPv6 address</description>
        </item>
        <item>
          <description>Remote scope ID</description>
        </item>
        <item>
          <description>Remote port</description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer pointed to by the <i>TcpTable</i> parameter is not large enough. The required size is returned in the variable pointed to by the <i>SizePointer</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>SizePointer</i> parameter is <b>NULL</b>, or
<see cref="GetTcp6Table2" /> is unable to write to the memory pointed to by the <i>SizePointer</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system in use on the local system.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTcp6Table2</b> function is defined on Windows Vista and later.</para>
      <para>The <b>GetTcp6Table2</b> function is an enhanced version of the <see cref="GetTcp6Table" /> function that also retrieves information on the TCP offload state of the TCP connection.</para>
    </remarks>
    <seealso cref="GetExtendedTcpTable" />
    <seealso cref="GetOwnerModuleFromTcp6Entry" />
    <seealso cref="GetTcp6Table" />
    <seealso cref="GetTcpStatisticsEx" />
    <seealso cref="GetTcpTable" />
    <seealso cref="MIB_TCP6ROW" />
    <seealso cref="MIB_TCP6ROW2" />
    <seealso cref="MIB_TCP6ROW_OWNER_MODULE" />
    <seealso cref="MIB_TCP6ROW_OWNER_PID" />
    <seealso cref="MIB_TCP6TABLE" />
    <seealso cref="MIB_TCP6TABLE2" />
    <seealso cref="MIB_TCP6TABLE_OWNER_MODULE" />
    <seealso cref="MIB_TCP6TABLE_OWNER_PID" />
  </member>
  <member name="Windows.GetTcpStatistics">
    <summary>
      <para>The
<b>GetTcpStatistics</b> function retrieves the TCP statistics for the local computer.</para>
    </summary>
    <param name="Statistics">
      <para>A pointer to a
<see cref="MIB_TCPSTATS" /> structure that receives the TCP statistics for the local computer.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pStats</i> parameter is <b>NULL</b>, or
<see cref="GetTcpStatistics" /> is unable to write to the memory pointed to by the <i>pStats</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
the <see cref="FormatMessage" /> function to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>GetTcpStatistics</b> function returns the TCP statistics for IPv4 on the current computer.     On Windows XP and later, the <see cref="GetTcpStatisticsEx" /> can be used to obtain the TCP statistics for either IPv4 or IPv6.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the TCP statistics for the local computer and prints some values from the returned data.</para>
      <code>//#include &lt;windows.h&gt;
#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "iphlpapi.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int main()
{
    PMIB_TCPSTATS pTCPStats;
    DWORD dwRetVal = 0;

    pTCPStats = (MIB_TCPSTATS*) MALLOC (sizeof(MIB_TCPSTATS));
    if (pTCPStats == NULL) {
        printf("Error allocating memory\n");
        return 1;
    }

    if ((dwRetVal = GetTcpStatistics(pTCPStats)) == NO_ERROR) {
      printf("\tActive Opens: %ld\n", pTCPStats-&gt;dwActiveOpens);
      printf("\tPassive Opens: %ld\n", pTCPStats-&gt;dwPassiveOpens);
      printf("\tSegments Recv: %ld\n", pTCPStats-&gt;dwInSegs);
      printf("\tSegments Xmit: %ld\n", pTCPStats-&gt;dwOutSegs);
      printf("\tTotal # Conxs: %ld\n", pTCPStats-&gt;dwNumConns);
    }
    else {
      printf("GetTcpStatistics failed with error: %ld\n", dwRetVal);

      LPVOID lpMsgBuf;
      if (FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwRetVal,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &amp;amp;amp;amp;amp;amp;lpMsgBuf,
        0,
        NULL )) {
        printf("\tError: %s", lpMsgBuf);
      }
      LocalFree( lpMsgBuf );
    }

    if (pTCPStats)
        FREE (pTCPStats);
}

</code>
    </remarks>
    <seealso cref="GetIcmpStatistics" />
    <seealso cref="GetIpStatistics" />
    <seealso cref="GetTcpStatisticsEx" />
    <seealso cref="GetUdpStatistics" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_TCPSTATS" />
  </member>
  <member name="Windows.GetTcpStatisticsEx">
    <summary>
      <para>The
<b>GetTcpStatisticsEx</b> function retrieves the Transmission Control Protocol (TCP) statistics for the current computer. The
<b>GetTcpStatisticsEx</b> function differs from the
<b>GetTcpStatistics</b> function in that
<b>GetTcpStatisticsEx</b> also supports the Internet Protocol version 6 (IPv6) protocol family.</para>
    </summary>
    <param name="Statistics">
      <para>A pointer to a
<see cref="MIB_TCPSTATS" /> structure that receives the TCP statistics for the local computer.</para>
    </param>
    <param name="Family">
      <para>The protocol family for which to retrieve statistics. This parameter must be one of the following values:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>AF_INET</b>
          </description>
          <description>
            <para>Internet Protocol version 4 (IPv4).</para>
          </description>
        </item>
        <item>
          <description>
            <b>AF_INET6</b>
          </description>
          <description>
            <para>Internet Protocol version 6 (IPv6).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pStats</i> parameter is <b>NULL</b> or does not point to valid memory, or the <i>dwFamily</i> parameter is not a valid value.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system on which the function call was made.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso cref="GetIpStatisticsEx" />
    <seealso cref="GetTcpStatistics" />
    <seealso cref="GetUdpStatisticsEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_TCPSTATS" />
  </member>
  <member name="Windows.GetTcpStatisticsEx2">
    <summary>
      <para>The
<b>GetTcpStatisticsEx2</b> function retrieves the Transmission Control Protocol (TCP) statistics for the current computer. The
<b>GetTcpStatisticsEx2</b> function differs from the
<see cref="GetTcpStatisticsEx" /> function in that
it uses a new output structure that contains 64-bit counters, rather than 32-bit counters.</para>
    </summary>
    <param name="Statistics">
      <para>A pointer to a
<see cref="MIB_TCPSTATS2" /> structure that receives the TCP statistics for the local computer.</para>
    </param>
    <param name="Family">
      <para>The protocol family for which to retrieve statistics. This parameter must be one of the following values:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>AF_INET</b>
          </description>
          <description>
            <para>Internet Protocol version 4 (IPv4).</para>
          </description>
        </item>
        <item>
          <description>
            <b>AF_INET6</b>
          </description>
          <description>
            <para>Internet Protocol version 6 (IPv6).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pStats</i> parameter is <b>NULL</b> or does not point to valid memory, or the <i>dwFamily</i> parameter is not a valid value.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system on which the function call was made.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
  </member>
  <member name="Windows.GetTcpTable">
    <summary>
      <para>The
<b>GetTcpTable</b> function retrieves the IPv4 TCP connection table.</para>
    </summary>
    <param name="TcpTable">
      <para>A pointer to a buffer that receives the TCP connection table as a
<see cref="MIB_TCPTABLE" /> structure.</para>
    </param>
    <param name="SizePointer">
      <para>On input, specifies the size in  bytes  of the buffer pointed to by the <i>pTcpTable</i> parameter.</para>
      <para>On output, if the buffer is not large enough to hold the returned connection table, the function sets this parameter equal to the required buffer size in bytes.</para>
      <para>On the Windows SDK released for Windows Vista and later, the data type for this parameter is changed to a <b>PULONG</b> which is equivalent to a <b>PDWORD</b>.</para>
    </param>
    <param name="Order">
      <para>A Boolean value that specifies whether the TCP connection table should be sorted. If this parameter is <b>TRUE</b>, the table is sorted in the order of:</para>
      <list type="number">
        <item>
          <description>Local IP address</description>
        </item>
        <item>
          <description>Local port</description>
        </item>
        <item>
          <description>Remote IP address</description>
        </item>
        <item>
          <description>Remote port</description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer pointed to by the <i>pTcpTable</i> parameter is not large enough. The required size is returned in the <b>DWORD</b> variable pointed to by the <i>pdwSize</i> parameter.</para>
            <para>This error is also returned if the <i>pTcpTable</i> parameter is <b>NULL</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pdwSize</i> parameter is <b>NULL</b>, or
<see cref="GetTcpTable" /> is unable to write to the memory pointed to by the <i>pdwSize</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system in use on the local system.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>STATUS_UNSUCCESSFUL</b>
            </para>
          </description>
          <description>
            <para>If you receive this return code then calling the function again is usually enough to clear the issue and get the desired result. This return code can be a consequence of the system being under high load. For example, if the size of the TCP connection table changes by more than 2 additional items 3 consecutive times.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>On the Windows SDK released for Windows Vista and later, the return value from the <b>GetTcpTable</b> function is changed to a data type of <b>ULONG</b> which is equivalent to a <b>DWORD</b>.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the TCP connection table for IPv4 and prints the state of each connection.</para>
      <code>// Need to link with Iphlpapi.lib and Ws2_32.lib
#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int main()
{

    // Declare and initialize variables
    PMIB_TCPTABLE pTcpTable;
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;

    char szLocalAddr[128];
    char szRemoteAddr[128];

    struct in_addr IpAddr;

    int i;

    pTcpTable = (MIB_TCPTABLE *) MALLOC(sizeof (MIB_TCPTABLE));
    if (pTcpTable == NULL) {
        printf("Error allocating memory\n");
        return 1;
    }

    dwSize = sizeof (MIB_TCPTABLE);
// Make an initial call to GetTcpTable to
// get the necessary size into the dwSize variable
    if ((dwRetVal = GetTcpTable(pTcpTable, &amp;amp;amp;amp;amp;amp;dwSize, TRUE)) ==
        ERROR_INSUFFICIENT_BUFFER) {
        FREE(pTcpTable);
        pTcpTable = (MIB_TCPTABLE *) MALLOC(dwSize);
        if (pTcpTable == NULL) {
            printf("Error allocating memory\n");
            return 1;
        }
    }
// Make a second call to GetTcpTable to get
// the actual data we require
    if ((dwRetVal = GetTcpTable(pTcpTable, &amp;amp;amp;amp;amp;amp;dwSize, TRUE)) == NO_ERROR) {
        printf("\tNumber of entries: %d\n", (int) pTcpTable-&gt;dwNumEntries);
        for (i = 0; i &lt; (int) pTcpTable-&gt;dwNumEntries; i++) {
            IpAddr.S_un.S_addr = (u_long) pTcpTable-&gt;table[i].dwLocalAddr;
            strcpy_s(szLocalAddr, sizeof (szLocalAddr), inet_ntoa(IpAddr));
            IpAddr.S_un.S_addr = (u_long) pTcpTable-&gt;table[i].dwRemoteAddr;
            strcpy_s(szRemoteAddr, sizeof (szRemoteAddr), inet_ntoa(IpAddr));

            printf("\n\tTCP[%d] State: %ld - ", i,
                   pTcpTable-&gt;table[i].dwState);
            switch (pTcpTable-&gt;table[i].dwState) {
            case MIB_TCP_STATE_CLOSED:
                printf("CLOSED\n");
                break;
            case MIB_TCP_STATE_LISTEN:
                printf("LISTEN\n");
                break;
            case MIB_TCP_STATE_SYN_SENT:
                printf("SYN-SENT\n");
                break;
            case MIB_TCP_STATE_SYN_RCVD:
                printf("SYN-RECEIVED\n");
                break;
            case MIB_TCP_STATE_ESTAB:
                printf("ESTABLISHED\n");
                break;
            case MIB_TCP_STATE_FIN_WAIT1:
                printf("FIN-WAIT-1\n");
                break;
            case MIB_TCP_STATE_FIN_WAIT2:
                printf("FIN-WAIT-2 \n");
                break;
            case MIB_TCP_STATE_CLOSE_WAIT:
                printf("CLOSE-WAIT\n");
                break;
            case MIB_TCP_STATE_CLOSING:
                printf("CLOSING\n");
                break;
            case MIB_TCP_STATE_LAST_ACK:
                printf("LAST-ACK\n");
                break;
            case MIB_TCP_STATE_TIME_WAIT:
                printf("TIME-WAIT\n");
                break;
            case MIB_TCP_STATE_DELETE_TCB:
                printf("DELETE-TCB\n");
                break;
            default:
                printf("UNKNOWN dwState value\n");
                break;
            }
            printf("\tTCP[%d] Local Addr: %s\n", i, szLocalAddr);
            printf("\tTCP[%d] Local Port: %d \n", i,
                   ntohs((u_short)pTcpTable-&gt;table[i].dwLocalPort));
            printf("\tTCP[%d] Remote Addr: %s\n", i, szRemoteAddr);
            printf("\tTCP[%d] Remote Port: %d\n", i,
                   ntohs((u_short)pTcpTable-&gt;table[i].dwRemotePort));
        }
    } else {
        printf("\tGetTcpTable failed with %d\n", dwRetVal);
        FREE(pTcpTable);
        return 1;
    }

    if (pTcpTable != NULL) {
        FREE(pTcpTable);
        pTcpTable = NULL;
    }

    return 0;
}


</code>
    </remarks>
    <seealso cref="GetExtendedTcpTable" />
    <seealso cref="GetOwnerModuleFromTcpEntry" />
    <seealso cref="GetTcp6Table" />
    <seealso cref="GetTcp6Table2" />
    <seealso cref="GetTcpStatistics" />
    <seealso cref="GetTcpStatisticsEx" />
    <seealso cref="GetTcpTable2" />
    <seealso cref="MIB_TCPROW" />
    <seealso cref="MIB_TCPROW_OWNER_MODULE" />
    <seealso cref="MIB_TCPROW_OWNER_PID" />
    <seealso cref="MIB_TCPTABLE" />
    <seealso cref="MIB_TCPTABLE_OWNER_MODULE" />
    <seealso cref="MIB_TCPTABLE_OWNER_PID" />
    <seealso cref="SetTcpEntry" />
  </member>
  <member name="Windows.GetTcpTable2">
    <summary>
      <para>The
<b>GetTcpTable2</b> function retrieves the IPv4 TCP connection table.</para>
    </summary>
    <param name="TcpTable">
      <para>A pointer to a buffer that receives the TCP connection table as a
<see cref="MIB_TCPTABLE2" /> structure.</para>
    </param>
    <param name="SizePointer">
      <para>On input, specifies the size of the buffer pointed to by the <i>TcpTable</i> parameter.</para>
      <para>On output, if the buffer is not large enough to hold the returned connection table, the function sets this parameter equal to the required buffer size.</para>
    </param>
    <param name="Order">
      <para>A value that specifies whether the TCP connection table should be sorted. If this parameter is <b>TRUE</b>, the table is sorted in the order of:</para>
      <list type="number">
        <item>
          <description>Local IP address</description>
        </item>
        <item>
          <description>Local port</description>
        </item>
        <item>
          <description>Remote IP address</description>
        </item>
        <item>
          <description>Remote port</description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer pointed to by the <i>TcpTable</i> parameter is not large enough. The required size is returned in the <b>PULONG</b> variable pointed to by the <i>SizePointer</i> parameter.</para>
            <para>This error is also returned if the <i>pTcpTable</i> parameter is <b>NULL</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>SizePointer</i> parameter is <b>NULL</b>, or
<see cref="GetTcpTable2" /> is unable to write to the memory pointed to by the <i>SizePointer</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system in use on the local system.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTcpTable2</b> function is defined on Windows Vista and later.</para>
      <para>The <b>GetTcpTable2</b> function is an enhanced version of the <see cref="GetTcpTable" /> function that also retrieves information on the TCP offload state of the TCP connection.</para>
      <h4>Examples</h4>
      <para>The following example retrieves the TCP connection table for IPv4 and prints the state of each connection.</para>
      <code>#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

// Need to link with Iphlpapi.lib and Ws2_32.lib
#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))
/* Note: could also use malloc() and free() */

int main()
{

    // Declare and initialize variables
    PMIB_TCPTABLE2 pTcpTable;
    ULONG ulSize = 0;
    DWORD dwRetVal = 0;

    char szLocalAddr[128];
    char szRemoteAddr[128];

    struct in_addr IpAddr;

    int i;

    pTcpTable = (MIB_TCPTABLE2 *) MALLOC(sizeof (MIB_TCPTABLE2));
    if (pTcpTable == NULL) {
        printf("Error allocating memory\n");
        return 1;
    }

    ulSize = sizeof (MIB_TCPTABLE);
// Make an initial call to GetTcpTable2 to
// get the necessary size into the ulSize variable
    if ((dwRetVal = GetTcpTable2(pTcpTable, &amp;amp;amp;amp;amp;amp;ulSize, TRUE)) ==
        ERROR_INSUFFICIENT_BUFFER) {
        FREE(pTcpTable);
        pTcpTable = (MIB_TCPTABLE2 *) MALLOC(ulSize);
        if (pTcpTable == NULL) {
            printf("Error allocating memory\n");
            return 1;
        }
    }
// Make a second call to GetTcpTable2 to get
// the actual data we require
    if ((dwRetVal = GetTcpTable2(pTcpTable, &amp;amp;amp;amp;amp;amp;ulSize, TRUE)) == NO_ERROR) {
        printf("\tNumber of entries: %d\n", (int) pTcpTable-&gt;dwNumEntries);
        for (i = 0; i &lt; (int) pTcpTable-&gt;dwNumEntries; i++) {
            printf("\n\tTCP[%d] State: %ld - ", i,
                   pTcpTable-&gt;table[i].dwState);
            switch (pTcpTable-&gt;table[i].dwState) {
            case MIB_TCP_STATE_CLOSED:
                printf("CLOSED\n");
                break;
            case MIB_TCP_STATE_LISTEN:
                printf("LISTEN\n");
                break;
            case MIB_TCP_STATE_SYN_SENT:
                printf("SYN-SENT\n");
                break;
            case MIB_TCP_STATE_SYN_RCVD:
                printf("SYN-RECEIVED\n");
                break;
            case MIB_TCP_STATE_ESTAB:
                printf("ESTABLISHED\n");
                break;
            case MIB_TCP_STATE_FIN_WAIT1:
                printf("FIN-WAIT-1\n");
                break;
            case MIB_TCP_STATE_FIN_WAIT2:
                printf("FIN-WAIT-2 \n");
                break;
            case MIB_TCP_STATE_CLOSE_WAIT:
                printf("CLOSE-WAIT\n");
                break;
            case MIB_TCP_STATE_CLOSING:
                printf("CLOSING\n");
                break;
            case MIB_TCP_STATE_LAST_ACK:
                printf("LAST-ACK\n");
                break;
            case MIB_TCP_STATE_TIME_WAIT:
                printf("TIME-WAIT\n");
                break;
            case MIB_TCP_STATE_DELETE_TCB:
                printf("DELETE-TCB\n");
                break;
            default:
                printf("UNKNOWN dwState value\n");
                break;
            }
            IpAddr.S_un.S_addr = (u_long) pTcpTable-&gt;table[i].dwLocalAddr;
            strcpy_s(szLocalAddr, sizeof (szLocalAddr), inet_ntoa(IpAddr));
            printf("\tTCP[%d] Local Addr: %s\n", i, szLocalAddr);
            printf("\tTCP[%d] Local Port: %d \n", i,
                   ntohs((u_short)pTcpTable-&gt;table[i].dwLocalPort));

            IpAddr.S_un.S_addr = (u_long) pTcpTable-&gt;table[i].dwRemoteAddr;
            strcpy_s(szRemoteAddr, sizeof (szRemoteAddr), inet_ntoa(IpAddr));
            printf("\tTCP[%d] Remote Addr: %s\n", i, szRemoteAddr);
            printf("\tTCP[%d] Remote Port: %d\n", i,
                   ntohs((u_short)pTcpTable-&gt;table[i].dwRemotePort));

            printf("\tTCP[%d] Owning PID: %d\n", i, pTcpTable-&gt;table[i].dwOwningPid);
            printf("\tTCP[%d] Offload State: %ld - ", i,
                   pTcpTable-&gt;table[i].dwOffloadState);
            switch (pTcpTable-&gt;table[i].dwOffloadState) {
            case TcpConnectionOffloadStateInHost:
                printf("Owned by the network stack and not offloaded \n");
                break;
            case TcpConnectionOffloadStateOffloading:
                printf("In the process of being offloaded\n");
                break;
            case TcpConnectionOffloadStateOffloaded:
                printf("Offloaded to the network interface control\n");
                break;
            case TcpConnectionOffloadStateUploading:
                printf("In the process of being uploaded back to the network stack \n");
                break;
            default:
                printf("UNKNOWN Offload state value\n");
                break;
            }

        }
    } else {
        printf("\tGetTcpTable2 failed with %d\n", dwRetVal);
        FREE(pTcpTable);
        return 1;
    }

    if (pTcpTable != NULL) {
        FREE(pTcpTable);
        pTcpTable = NULL;
    }

    return 0;
}

</code>
    </remarks>
    <seealso cref="GetExtendedTcpTable" />
    <seealso cref="GetOwnerModuleFromTcpEntry" />
    <seealso cref="GetTcp6Table" />
    <seealso cref="GetTcpStatistics" />
    <seealso cref="GetTcpStatisticsEx" />
    <seealso cref="GetTcpTable" />
    <seealso cref="MIB_TCP6ROW2" />
    <seealso cref="MIB_TCP6TABLE" />
    <seealso cref="MIB_TCP6TABLE2" />
    <seealso cref="MIB_TCP6TABLE_OWNER_MODULE" />
    <seealso cref="MIB_TCP6TABLE_OWNER_PID" />
    <seealso cref="MIB_TCPROW" />
    <seealso cref="MIB_TCPROW2" />
    <seealso cref="MIB_TCPROW_OWNER_MODULE" />
    <seealso cref="MIB_TCPROW_OWNER_PID" />
    <seealso cref="MIB_TCPTABLE" />
    <seealso cref="MIB_TCPTABLE2" />
    <seealso cref="MIB_TCPTABLE_OWNER_MODULE" />
    <seealso cref="MIB_TCPTABLE_OWNER_PID" />
    <seealso cref="SetTcpEntry" />
  </member>
  <member name="Windows.GetUdp6Table">
    <summary>
      <para>The
<b>GetUdp6Table</b> function retrieves the IPv6 User Datagram Protocol (UDP) listener table.</para>
    </summary>
    <param name="Udp6Table">
      <para>A pointer to a buffer that receives the IPv6 UDP listener table as a
<see cref="MIB_UDP6TABLE" /> structure.</para>
    </param>
    <param name="SizePointer">
      <para>On input, specifies the size in bytes of the buffer pointed to by the <i>Udp6Table</i> parameter.</para>
      <para>On output, if the buffer is not large enough to hold the returned listener table, the function sets this parameter equal to the required buffer size in bytes.</para>
    </param>
    <param name="Order">
      <para>A Boolean value that specifies whether the returned UDP listener table should be sorted. If this parameter is <b>TRUE</b>, the table is sorted in the order of:</para>
      <list type="number">
        <item>
          <description>Local IPv6 address</description>
        </item>
        <item>
          <description>Local scope ID</description>
        </item>
        <item>
          <description>Local port</description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer pointed to by the <i>Udp6Table</i> parameter is not large enough. The required size is returned in the <b>ULONG</b> variable pointed to by the <i>SizePointer</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>SizePointer</i> parameter is <b>NULL</b>, or
<see cref="GetUdp6Table" /> is unable to write to the memory pointed to by the <i>SizePointer</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system in use on the local system.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetUdp6Table</b> function is defined on Windows Vista and later.</para>
    </remarks>
    <seealso cref="GetExtendedUdpTable" />
    <seealso cref="GetOwnerModuleFromUdp6Entry" />
    <seealso cref="GetOwnerModuleFromUdpEntry" />
    <seealso cref="GetUdp6Table" />
    <seealso cref="GetUdpStatistics" />
    <seealso cref="GetUdpStatisticsEx" />
    <seealso cref="MIB_UDP6ROW" />
    <seealso cref="MIB_UDP6ROW_OWNER_MODULE" />
    <seealso cref="MIB_UDP6ROW_OWNER_PID" />
    <seealso cref="MIB_UDP6TABLE" />
    <seealso cref="MIB_UDP6TABLE_OWNER_MODULE" />
    <seealso cref="MIB_UDP6TABLE_OWNER_PID" />
    <seealso cref="MIB_UDPROW" />
    <seealso cref="MIB_UDPROW_OWNER_MODULE" />
    <seealso cref="MIB_UDPROW_OWNER_PID" />
    <seealso cref="MIB_UDPTABLE" />
    <seealso cref="MIB_UDPTABLE_OWNER_MODULE" />
    <seealso cref="MIB_UDPTABLE_OWNER_PID" />
  </member>
  <member name="Windows.GetUdpStatistics">
    <summary>
      <para>The
<b>GetUdpStatistics</b> function retrieves the User Datagram Protocol (UDP) statistics for the local computer.</para>
    </summary>
    <param name="Stats">
      <para>Pointer to a
<see cref="MIB_UDPSTATS" /> structure that receives the UDP statistics for the local computer.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>Use the
<see cref="GetUdpStatisticsEx" /> function to obtain the UDP statistics for the IPv6 protocol.</para>
    </remarks>
    <seealso cref="GetIcmpStatistics" />
    <seealso cref="GetIpStatistics" />
    <seealso cref="GetTcpStatistics" />
    <seealso cref="GetUdpStatisticsEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_UDPSTATS" />
  </member>
  <member name="Windows.GetUdpStatisticsEx">
    <summary>
      <para>The
<b>GetUdpStatisticsEx</b> function retrieves the User Datagram Protocol (UDP) statistics for the current computer. The
<b>GetUdpStatisticsEx</b> function differs from the
<b>GetUdpStatistics</b> function in that
<b>GetUdpStatisticsEx</b> also supports the Internet Protocol version 6 (IPv6) protocol family.</para>
    </summary>
    <param name="Statistics">
      <para>A pointer to a
<see cref="MIB_UDPSTATS" /> structure that receives the UDP statistics for the local computer.</para>
    </param>
    <param name="Family">
      <para>The protocol family for which to retrieve statistics. This parameter must be one of the following values:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>AF_INET</b>
          </description>
          <description>
            <para>Internet Protocol version 4 (IPv4).</para>
          </description>
        </item>
        <item>
          <description>
            <b>AF_INET6</b>
          </description>
          <description>
            <para>Internet Protocol version 6 (IPv6).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pStats</i> parameter is <b>NULL</b> or does not point to valid memory, or the <i>dwFamily</i> parameter is not a valid value.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system on which the function call was made.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso cref="GetIpStatisticsEx" />
    <seealso cref="GetTcpStatisticsEx" />
    <seealso cref="GetUdpStatistics" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_UDPSTATS" />
  </member>
  <member name="Windows.GetUdpStatisticsEx2">
    <summary>
      <para>The
<b>GetUdpStatisticsEx2</b> function retrieves the User Datagram Protocol (UDP) statistics for the current computer. The
<b>GetUdpStatisticsEx2</b> function differs from the
<see cref="GetUdpStatisticsEx" /> function in that
<b>GetUdpStatisticsEx2</b> uses a new output structure that contains 64-bit counters, rather than 32-bit counters.</para>
    </summary>
    <param name="Statistics">
      <para>A pointer to a
<see cref="MIB_UDPSTATS2" /> structure that receives the UDP statistics for the local computer.</para>
    </param>
    <param name="Family">
      <para>The protocol family for which to retrieve statistics. This parameter must be one of the following values:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>AF_INET</b>
          </description>
          <description>
            <para>Internet Protocol version 4 (IPv4).</para>
          </description>
        </item>
        <item>
          <description>
            <b>AF_INET6</b>
          </description>
          <description>
            <para>Internet Protocol version 6 (IPv6).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>Statistics</i> parameter is <b>NULL</b> or does not point to valid memory, or the <i>Family</i> parameter is not a valid value.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system on which the function call was made.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso cref="GetIpStatisticsEx" />
    <seealso cref="GetTcpStatisticsEx" />
    <seealso cref="GetUdpStatistics" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_UDPSTATS" />
  </member>
  <member name="Windows.GetUdpTable">
    <summary>
      <para>The
<b>GetUdpTable</b> function retrieves the IPv4 User Datagram Protocol (UDP) listener table.</para>
    </summary>
    <param name="UdpTable">
      <para>A pointer to a buffer that receives the IPv4 UDP listener table as a
<see cref="MIB_UDPTABLE" /> structure.</para>
    </param>
    <param name="SizePointer">
      <para>On input, specifies the size in bytes of the buffer pointed to by the <i>UdpTable</i> parameter.</para>
      <para>On output, if the buffer is not large enough to hold the returned listener table, the function sets this parameter equal to the required buffer size in bytes.</para>
      <para>On the Windows SDK released for Windows Vista and later, the data type for this parameter is changed to a <b>PULONG</b> which is equivalent to a <b>PDWORD</b>.</para>
    </param>
    <param name="Order">
      <para>A Boolean value that specifies whether the returned UDP listener table should be sorted. If this parameter is <b>TRUE</b>, the table is sorted in the order of:</para>
      <list type="number">
        <item>
          <description>Local IP address</description>
        </item>
        <item>
          <description>Local port</description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer pointed to by the <i>pUdpTable</i> parameter is not large enough. The required size is returned in the <b>ULONG</b> variable pointed to by the <i>pdwSize</i> parameter.</para>
            <para>This error is also returned if the <i>pUdpTable</i> parameter is <b>NULL</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pdwSize</i> parameter is <b>NULL</b>, or
<see cref="GetUdpTable" /> is unable to write to the memory pointed to by the <i>pdwSize</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>This function is not supported on the operating system in use on the local system.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>On the Windows SDK released for Windows Vista and later, the return value from the <b>GetUdpTable</b> function is changed to a data type of <b>ULONG</b> which is equivalent to a <b>DWORD</b>.</para>
    </remarks>
    <seealso cref="GetExtendedUdpTable" />
    <seealso cref="GetOwnerModuleFromUdp6Entry" />
    <seealso cref="GetOwnerModuleFromUdpEntry" />
    <seealso cref="GetUdp6Table" />
    <seealso cref="GetUdpStatistics" />
    <seealso cref="GetUdpStatisticsEx" />
    <seealso cref="MIB_UDPROW" />
    <seealso cref="MIB_UDPROW_OWNER_MODULE" />
    <seealso cref="MIB_UDPROW_OWNER_PID" />
    <seealso cref="MIB_UDPTABLE" />
    <seealso cref="MIB_UDPTABLE_OWNER_MODULE" />
    <seealso cref="MIB_UDPTABLE_OWNER_PID" />
  </member>
  <member name="Windows.GetUniDirectionalAdapterInfo">
    <summary>
      <para>The
<b>GetUniDirectionalAdapterInfo</b> function retrieves information about the unidirectional adapters installed on the local computer. A unidirectional adapter is an adapter that can receive datagrams, but not transmit them.</para>
    </summary>
    <param name="pIPIfInfo">
      <para>Pointer to an
<see cref="IP_UNIDIRECTIONAL_ADAPTER_ADDRESS" /> structure that receives information about the unidirectional adapters installed on the local computer.</para>
    </param>
    <param name="dwOutBufLen">
      <para>Pointer to a <b>ULONG</b> variable that receives the size of the structure pointed to by the <i>pIPIfInfo</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="IP_UNIDIRECTIONAL_ADAPTER_ADDRESS" />
  </member>
  <member name="Windows.IpReleaseAddress">
    <summary>
      <para>The
<b>IpReleaseAddress</b> function releases an IPv4 address previously obtained through the Dynamic Host Configuration Protocol (DHCP).</para>
    </summary>
    <param name="AdapterInfo">
      <para>A pointer to an
<see cref="IP_ADAPTER_INDEX_MAP" /> structure that specifies the adapter associated with the IPv4 address to release.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is invalid. This error is returned if the <i>AdapterInfo</i> parameter is <b>NULL</b> or if the <b>Name</b> member of the <b>PIP_ADAPTER_INDEX_MAP</b> structure pointed to by the <i>AdapterInfo</i> parameter is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PROC_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>An exception occurred during the request to DHCP for the release of the IPv4 address.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>IpReleaseAddress</b> function is specific to IPv4 and releases only an IPv4 address previously obtained through the Dynamic Host Configuration Protocol (DHCP). The <b>Name</b> member of the <see cref="IP_ADAPTER_INDEX_MAP" /> structure pointed to by the <i>AdapterInfo</i> parameter is the only member used to determine the DHCP address to release.</para>
      <para>An array of <see cref="IP_ADAPTER_INDEX_MAP" /> structures is returned in the <see cref="IP_INTERFACE_INFO" /> structure by the <see cref="GetInterfaceInfo" /> function.  The <b>IP_INTERFACE_INFO</b> structure returned by <b>GetInterfaceInfo</b> contains at least one <b>IP_ADAPTER_INDEX_MAP</b> structure even if the <b>NumAdapters</b> member of the <b>IP_INTERFACE_INFO</b> structure indicates that no network adapters with IPv4 are enabled. When the <b>NumAdapters</b> member of the <b>IP_INTERFACE_INFO</b> structure returned by <b>GetInterfaceInfo</b> is zero, the value of the members of the single  <b>IP_ADAPTER_INDEX_MAP</b> structure returned in the <b>IP_INTERFACE_INFO</b> structure is undefined.</para>
      <para>If the <b>Name</b> member of the <see cref="IP_ADAPTER_INDEX_MAP" /> structure pointed to by the <i>AdapterInfo</i> parameter is <b>NULL</b>, the
<b>IpReleaseAddress</b> function returns <b>ERROR_INVALID_PARAMETER</b>.</para>
      <para>There are no functions available for releasing or renewing an IPv6 address. This can only be done by executing the Ipconfig command:</para>
      <para>
        <b>ipconfig /release6
</b>
      </para>
      <para>
        <b>ipconfig /renew6</b>
      </para>
      <h4>Examples</h4>
      <para>The following example retrieves the list of network adapters with IPv4 enabled on the local system, then releases and renews the IPv4 address for the first adapter in the list.</para>
      <code>#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include &lt;winsock2.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "iphlpapi.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

// Before calling IpReleaseAddress and IpRenewAddress we use
// GetInterfaceInfo to retrieve a handle to the adapter

void __cdecl main()
{
    ULONG ulOutBufLen = 0;
    DWORD dwRetVal = 0;
    PIP_INTERFACE_INFO pInfo;

    pInfo = (IP_INTERFACE_INFO *) MALLOC(sizeof(IP_INTERFACE_INFO));

    // Make an initial call to GetInterfaceInfo to get
    // the necessary size into the ulOutBufLen variable
    if (GetInterfaceInfo(pInfo, &amp;amp;amp;amp;amp;amp;ulOutBufLen) == ERROR_INSUFFICIENT_BUFFER) {
        FREE(pInfo);
        pInfo = (IP_INTERFACE_INFO *) MALLOC (ulOutBufLen);
    }

    // Make a second call to GetInterfaceInfo to get the
    // actual data we want
    if ((dwRetVal = GetInterfaceInfo(pInfo, &amp;amp;amp;amp;amp;amp;ulOutBufLen)) == NO_ERROR ) {
        printf("\tAdapter Name: %ws\n", pInfo-&gt;Adapter[0].Name);
        printf("\tAdapter Index: %ld\n", pInfo-&gt;Adapter[0].Index);
        printf("\tNum Adapters: %ld\n", pInfo-&gt;NumAdapters);
    }
    else if (dwRetVal == ERROR_NO_DATA) {
        printf("There are no network adapters with IPv4 enabled on the local system\n");
        return;
    }
    else {
        LPVOID lpMsgBuf;
        printf("GetInterfaceInfo failed.\n");

        if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwRetVal,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &amp;amp;amp;amp;amp;amp;lpMsgBuf,
            0,
            NULL )) {
            printf("\tError: %s", lpMsgBuf);
        }
        LocalFree( lpMsgBuf );
        return;
    }

// Call IpReleaseAddress and IpRenewAddress to release and renew
// the IP address on the first network adapter returned
// by the call to GetInterfaceInfo.
    if ((dwRetVal = IpReleaseAddress(&amp;amp;amp;amp;amp;amp;pInfo-&gt;Adapter[0])) == NO_ERROR) {
        printf("IP release succeeded.\n");
    }
    else {
        printf("IP release failed: %ld\n", dwRetVal);
    }

    if ((dwRetVal = IpRenewAddress(&amp;amp;amp;amp;amp;amp;pInfo-&gt;Adapter[0])) == NO_ERROR) {
        printf("IP renew succeeded.\n");
    }
    else {
        printf("IP renew failed: %ld\n", dwRetVal);
    }

    // Free memory for IP_INTERFACE_INFO
    if (pInfo != NULL) {
        FREE(pInfo);
    }
    return;
}

</code>
    </remarks>
    <seealso cref="GetInterfaceInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="IP_ADAPTER_INDEX_MAP" />
    <seealso cref="IP_INTERFACE_INFO" />
    <seealso cref="IpRenewAddress" />
  </member>
  <member name="Windows.IpRenewAddress">
    <summary>
      <para>The
<b>IpRenewAddress</b> function renews a lease on an IPv4 address previously obtained through Dynamic Host Configuration Protocol (DHCP).</para>
    </summary>
    <param name="AdapterInfo">
      <para>A pointer to an
<see cref="IP_ADAPTER_INDEX_MAP" /> structure that specifies the adapter associated with the IP address to renew.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is invalid. This error is returned if the <i>AdapterInfo</i> parameter is <b>NULL</b> or if the <b>Name</b> member of the <b>PIP_ADAPTER_INDEX_MAP</b> structure pointed to by the <i>AdapterInfo</i> parameter is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PROC_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>An exception occurred during the request to DHCP for the renewal of the IPv4 address.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>IpRenewAddress</b> function is specific to IPv4 and renews only an IPv4 address previously obtained through the Dynamic Host Configuration Protocol (DHCP). The <b>Name</b> member of the <see cref="IP_ADAPTER_INDEX_MAP" /> structure pointed to by the <i>AdapterInfo</i> parameter is the only member used to determine the DHCP address to renew.</para>
      <para>An array of  <see cref="IP_ADAPTER_INDEX_MAP" /> structures are returned in the <see cref="IP_INTERFACE_INFO" /> structure by the <see cref="GetInterfaceInfo" /> function.  The <b>IP_INTERFACE_INFO</b> structure returned by <b>GetInterfaceInfo</b> contains at least one <b>IP_ADAPTER_INDEX_MAP</b> structure even if the <b>NumAdapters</b> member of the <b>IP_INTERFACE_INFO</b> structure indicates that no network adapters with IPv4 are enabled. When the <b>NumAdapters</b> member of the <b>IP_INTERFACE_INFO</b> structure returned by <b>GetInterfaceInfo</b> is zero, the value of the members of the single  <b>IP_ADAPTER_INDEX_MAP</b> structure returned in the <b>IP_INTERFACE_INFO</b> structure is undefined.</para>
      <para>If the <b>Name</b> member of the <see cref="IP_ADAPTER_INDEX_MAP" /> structure pointed to by the <i>AdapterInfo</i> parameter is <b>NULL</b>, the
<b>IpRenewAddress</b> function returns <b>ERROR_INVALID_PARAMETER</b>.</para>
      <para>There are no functions available for releasing or renewing an IPv6 address. This can only be done by executing the Ipconfig command:</para>
      <para>
        <b>ipconfig /release6
</b>
      </para>
      <para>
        <b>ipconfig /renew6</b>
      </para>
      <h4>Examples</h4>
      <para>The following example retrieves the list of network adapters with IPv4 enabled on the local system, then releases and renews the IPv4 address for the first adapter in the list.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "iphlpapi.lib")

/* Note: could also use malloc() and free() */
#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

void main()
{

    // Before calling IpReleaseAddress and IpRenewAddress we use
    // GetInterfaceInfo to retrieve a handle to the adapter

    PIP_INTERFACE_INFO pInfo;
    pInfo = (IP_INTERFACE_INFO *) MALLOC( sizeof(IP_INTERFACE_INFO) );
    ULONG ulOutBufLen = 0;
    DWORD dwRetVal = 0;

    // Make an initial call to GetInterfaceInfo to get
    // the necessary size into the ulOutBufLen variable
    if ( GetInterfaceInfo(pInfo, &amp;amp;amp;amp;amp;amp;ulOutBufLen) == ERROR_INSUFFICIENT_BUFFER) {
      FREE(pInfo);
      pInfo = (IP_INTERFACE_INFO *) MALLOC (ulOutBufLen);
    }

    // Make a second call to GetInterfaceInfo to get the
    // actual data we want
    if ((dwRetVal = GetInterfaceInfo(pInfo, &amp;amp;amp;amp;amp;amp;ulOutBufLen)) == NO_ERROR ) {
      printf("\tAdapter Name: %ws\n", pInfo-&gt;Adapter[0].Name);
      printf("\tAdapter Index: %ld\n", pInfo-&gt;Adapter[0].Index);
      printf("\tNum Adapters: %ld\n", pInfo-&gt;NumAdapters);
    }
    else if (dwRetVal == ERROR_NO_DATA) {
      printf("There are no network adapters with IPv4 enabled on the local system\n");
      FREE(pInfo);
      pInfo = NULL;
      return;
    }
    else {
      printf("GetInterfaceInfo failed.\n");
      LPVOID lpMsgBuf;

      if (FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwRetVal,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &amp;amp;amp;amp;amp;amp;lpMsgBuf,
        0,
        NULL )) {
        printf("\tError: %s", lpMsgBuf);
      }
      LocalFree( lpMsgBuf );
      return;
    }

    // Call IpReleaseAddress and IpRenewAddress to release and renew
    // the IP address on the first network adapter returned
    // by the call to GetInterfaceInfo.
    if ((dwRetVal = IpReleaseAddress(&amp;amp;amp;amp;amp;amp;pInfo-&gt;Adapter[0])) == NO_ERROR) {
      printf("IP release succeeded.\n");
    }
    else {
      printf("IP release failed.\n");
    }

    if ((dwRetVal = IpRenewAddress(&amp;amp;amp;amp;amp;amp;pInfo-&gt;Adapter[0])) == NO_ERROR) {
      printf("IP renew succeeded.\n");
    }
    else {
      printf("IP renew failed.\n");
    }

    /* Free allocated memory no longer needed */
    if (pInfo) {
        FREE(pInfo);
        pInfo = NULL;
    }
}


</code>
    </remarks>
    <seealso cref="GetInterfaceInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="IP_ADAPTER_INDEX_MAP" />
    <seealso cref="IP_INTERFACE_INFO" />
    <seealso cref="IpReleaseAddress" />
  </member>
  <member name="Windows.LookupPersistentTcpPortReservation">
    <summary>
      <para>The
<b>LookupPersistentTcpPortReservation</b> function looks up the token for a persistent TCP port reservation for a consecutive block of TCP ports on the local computer.</para>
    </summary>
    <param name="StartPort">
      <para>The starting TCP port number in network byte order.</para>
    </param>
    <param name="NumberOfPorts">
      <para>The number of TCP port numbers  that were reserved.</para>
    </param>
    <param name="Token">
      <para>A pointer to a port reservation token that is returned if the function succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if zero is passed in the <i>StartPort</i>  or <i>NumberOfPorts</i> parameters.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The element was not found. This error is returned if persistent port block specified by the <i>StartPort</i>  and <i>NumberOfPorts</i> parameters could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>LookupPersistentTcpPortReservation</b>  function is defined on Windows Vista and later.</para>
      <para>The <b>LookupPersistentTcpPortReservation</b>  function is used to lookup the token for a persistent reservation for a block of TCP ports.</para>
      <para>A persistent reservation for a block of TCP ports is  created by a call to the <see cref="CreatePersistentTcpPortReservation" /> function. The <i>StartPort</i>  or <i>NumberOfPorts</i> parameters passed to the <b>LookupPersistentTcpPortReservation</b>  function must match the values used when the persistent reservation for a block of TCP ports was created by  the <b>CreatePersistentTcpPortReservation</b> function.</para>
      <para>If the <b>LookupPersistentTcpPortReservation</b> function succeeds, the <i>Token</i> parameter returned will point to the token for the persistent port reservation for the block of TCP ports. Note that the token for a given persistent reservation for a block of TCP ports may change each time the system is restarted.</para>
      <para>An application can request port assignments from the TCP port reservation by opening a TCP socket, then calling the <see cref="WSAIoctl" /> function specifying the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699721(v=vs.85)">SIO_ASSOCIATE_PORT_RESERVATION</a> IOCTL and passing the reservation token before issuing a call to the <see cref="bind" /> function on the socket.</para>
      <h4>Examples</h4>
      <para>The following example looks up a persistent TCP port reservation and then creates a socket and allocates a port from the port reservation.</para>
      <code>#ifndef UNICODE
#define UNICODE
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include &lt;Windows.h.&gt;
#include &lt;winsock2.h&gt;
#include &lt;mstcpip.h&gt;
#include &lt;ws2ipdef.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Need to link with iphlpapi.lib
#pragma comment(lib, "iphlpapi.lib")

// Need to link with Ws2_32.lib for Winsock functions
#pragma comment(lib, "ws2_32.lib")

int wmain(int argc, WCHAR **argv)  {

    // Declare and initialize variables

    int startPort = 0;         // host byte order
    int numPorts = 0;
    USHORT startPortns = 0;    // Network byte order
    ULONG64 resToken = {0};

    unsigned long status = 0;

    WSADATA wsaData = { 0 };
    int iResult = 0;

    SOCKET sock = INVALID_SOCKET;
    int iFamily = AF_INET;
    int iType = SOCK_STREAM;
    int iProtocol = IPPROTO_TCP;

    DWORD bytesReturned = 0;

    // Note that the sockaddr_in struct works only with AF_INET not AF_INET6
    // An application needs to use the sockaddr_in6 for AF_INET6
    sockaddr_in service;
    sockaddr_in sockName;
    int nameLen = sizeof(sockName);

    // Validate the parameters
    if (argc != 3) {
        wprintf(L"usage: %s &lt;Starting Port&gt;&lt;Number of Ports&gt;\n",
            argv[0]);
        wprintf(L"Look up a persistent TCP port reservation\n");
        wprintf(L"Example usage:\n");
        wprintf(L"   %s 5000 20\n", argv[0]);
        wprintf(L"   where StartPort=5000 NumPorts=20");
        return 1;
    }

    startPort = _wtoi(argv[1]);
    if ( startPort &lt; 0 || startPort&gt; 65535) {
        wprintf(L"Starting point must be either 0 or between 1 and 65,535\n");
        return 1;
    }
    startPortns = htons((USHORT) startPort);

    numPorts = _wtoi(argv[2]);
    if (numPorts &lt; 0) {
        wprintf(L"Number of ports must be a positive number\n");
        return 1;
    }

    status = LookupPersistentTcpPortReservation((USHORT) startPortns, (USHORT) numPorts, &amp;amp;amp;amp;amp;amp;resToken);
    if( status != NO_ERROR )
    {
        wprintf(L"LookupPersistentTcpPortReservation returned error: %ld\n",
            status);
        return 1;
    }

    wprintf(L"LookupPersistentTcpPortReservation call succeeded\n");
    wprintf(L"  Token = %I64d\n", resToken);

    // Comment out this block if you don't want to create a socket and associate it with the
    // persistent reservation

    // Initialize Winsock
    iResult = WSAStartup(MAKEWORD(2, 2), &amp;amp;amp;amp;amp;amp;wsaData);
    if (iResult != 0) {
        wprintf(L"WSAStartup failed with error = %d\n", iResult);
        return 1;
    }

    sock = socket(iFamily, iType, iProtocol);
    if (sock == INVALID_SOCKET)
        wprintf(L"socket function failed with error = %d\n", WSAGetLastError());
    else {
        wprintf(L"socket function succeeded\n");

        iResult =
            WSAIoctl(sock, SIO_ASSOCIATE_PORT_RESERVATION, (LPVOID) &amp;amp;amp;amp;amp;amp; resToken,
                     sizeof (ULONG64), NULL, 0, &amp;amp;amp;amp;amp;amp;bytesReturned, NULL, NULL);
        if (iResult != 0) {
            wprintf
                (L"WSAIoctl(SIO_ASSOCIATE_PORT_RESERVATION) failed with error = %d\n",
                 WSAGetLastError());
        } else {
            wprintf(L"WSAIoctl(SIO_ASSOCIATE_PORT_RESERVATION) succeeded, bytesReturned = %u\n",
                bytesReturned);

            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = 0;

            iResult = bind(sock, (SOCKADDR*) &amp;amp;amp;amp;amp;amp;service, sizeof(service) );
            if (iResult == SOCKET_ERROR)
                wprintf(L"bind failed with error = %d\n", WSAGetLastError());
            else {
                wprintf(L"bind succeeded\n");
                iResult = getsockname(sock, (SOCKADDR*) &amp;amp;amp;amp;amp;amp;sockName, &amp;amp;amp;amp;amp;amp;nameLen);
                if (iResult == SOCKET_ERROR)
                    wprintf(L"getsockname failed with error = %d\n", WSAGetLastError() );
                else {
                    wprintf(L"getsockname succeeded\n");
                    wprintf(L"Port number allocated = %u\n", ntohs(sockName.sin_port) );
                }
            }
        }

        if (sock != INVALID_SOCKET) {
            iResult = closesocket(sock);
            if (iResult == SOCKET_ERROR) {
                wprintf(L"closesocket failed with error = %d\n", WSAGetLastError());
            }
        }
    }
    WSACleanup();

    return 0;
}

</code>
    </remarks>
    <seealso cref="CreatePersistentTcpPortReservation" />
    <seealso cref="CreatePersistentUdpPortReservation" />
    <seealso cref="DeletePersistentTcpPortReservation" />
    <seealso cref="DeletePersistentUdpPortReservation" />
    <seealso cref="LookupPersistentUdpPortReservation" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699721(v=vs.85)">SIO_ASSOCIATE_PORT_RESERVATION</seealso>
  </member>
  <member name="Windows.LookupPersistentUdpPortReservation">
    <summary>
      <para>The
<b>LookupPersistentUdpPortReservation</b> function looks up the token for a persistent UDP port reservation for a consecutive block of TCP ports on the local computer.</para>
    </summary>
    <param name="StartPort">
      <para>The starting UDP port number in network byte order.</para>
    </param>
    <param name="NumberOfPorts">
      <para>The number of UDP port numbers that were reserved.</para>
    </param>
    <param name="Token">
      <para>A pointer to a port reservation token that is returned if the function succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if zero is passed in the <i>StartPort</i>  or <i>NumberOfPorts</i> parameters.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The element was not found. This error is returned if persistent port block specified by the <i>StartPort</i>  and <i>NumberOfPorts</i> parameters could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>LookupPersistentUdpPortReservation</b>  function is defined on Windows Vista and later.</para>
      <para>The <b>LookupPersistentUdpPortReservation</b>  function is used to lookup the token for a persistent reservation for a block of UDP ports.</para>
      <para>A persistent reservation for a block of UDP ports is  created by a call to the <see cref="CreatePersistentUdpPortReservation" /> function. The <i>StartPort</i>  or <i>NumberOfPorts</i> parameters passed to the <b>LookupPersistentUdpPortReservation</b>  function must match the values used when the persistent reservation for a block of TCP ports was created by  the <b>CreatePersistentUdpPortReservation</b> function.</para>
      <para>If the <b>LookupPersistentUdpPortReservation</b> function succeeds, the <i>Token</i> parameter returned will point to the token for the persistent port reservation for the block of UDP ports. Note that the token for a given persistent reservation for a block of TCP ports may change each time the system is restarted.</para>
      <para>An application can request port assignments from the UDP port reservation by opening a UDP socket, then calling the <see cref="WSAIoctl" /> function specifying the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699721(v=vs.85)">SIO_ASSOCIATE_PORT_RESERVATION</a> IOCTL and passing the reservation token before issuing a call to the <see cref="bind" /> function on the socket.</para>
    </remarks>
    <seealso cref="CreatePersistentTcpPortReservation" />
    <seealso cref="CreatePersistentUdpPortReservation" />
    <seealso cref="DeletePersistentTcpPortReservation" />
    <seealso cref="DeletePersistentUdpPortReservation" />
    <seealso cref="LookupPersistentTcpPortReservation" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/gg699721(v=vs.85)">SIO_ASSOCIATE_PORT_RESERVATION</seealso>
  </member>
  <member name="Windows.NotifyIfTimestampConfigChange">
    <summary>
      <para>This function is reserved for system use, and you should not call it from your code.</para>
    </summary>
    <param name="CallerContext">
      <para>Reserved.</para>
    </param>
    <param name="Callback">
      <para>Reserved.</para>
    </param>
    <param name="NotificationHandle">
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Reserved.</para>
    </returns>
  </member>
  <member name="Windows.ParseNetworkString">
    <summary>
      <para>The
<b>ParseNetworkString</b> function  parses the input network string and checks whether it
is a legal representation of the specified IP network string type. If the string matches a type and its specification,
the function can optionally return the parsed result.</para>
    </summary>
    <param name="NetworkString">
      <para>A pointer to the NULL-terminated network string to parse.</para>
    </param>
    <param name="Types">
      <para>The type of IP network string to parse. This parameter consists of one of network string types as defined in the <i>Iphlpapi.h</i></para>
      <para>header file.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IPV4_ADDRESS</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 address using Internet standard dotted-decimal notation.
A network port or prefix must not be present in the network string.</para>
            <para>An example network string is the following:</para>
            <para>
              <b>192.168.100.10</b>
            </para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IPV4_SERVICE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 service using Internet standard dotted-decimal notation.
A network port is required as part of the network string. A prefix must not be present in the network string.</para>
            <para>An example network string is the following:</para>
            <para>
              <b>192.168.100.10:80</b>
            </para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IPV4_NETWORK</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 network using Internet standard dotted-decimal notation.
A network prefix that uses the Classless Inter-Domain Routing (CIDR) notation is required as part of the network string. A network port must not be present in the network string.</para>
            <para>An example network string is the following:</para>
            <para>
              <b>192.168.100/24</b>
            </para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IPV6_ADDRESS</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv6 address using Internet standard hexadecimal encoding.
An IPv6 scope ID may be present in the network string. A network port or prefix must not be present in the network string.</para>
            <para>An example network string is the following:</para>
            <para>
              <b>21DA:00D3:0000:2F3B:02AA:00FF:FE28:9C5A%2</b>
            </para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IPV6_ADDRESS_NO_SCOPE</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv6 address using Internet standard hexadecimal encoding. An IPv6 scope ID must not be  present in the network string. A network port or prefix must not be present in the network string.</para>
            <para>An example network string is the following:</para>
            <para>
              <b>21DA:00D3:0000:2F3B:02AA:00FF:FE28:9C5A</b>
            </para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IPV6_SERVICE</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv6 service using Internet standard hexadecimal encoding.
A network port is required as part of the network string. An IPv6 scope ID may be present in the network string. A prefix must not be present in the network string.</para>
            <para>An example network string with a scope ID is the following:</para>
            <para>
              <b>[21DA:00D3:0000:2F3B:02AA:00FF:FE28:9C5A%2]:8080</b>
            </para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IPV6_SERVICE_NO_SCOPE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv6 service using Internet standard hexadecimal encoding.
A network port is required as part of the network string. An IPv6 scope ID must not be present in the network string. A prefix must not be present in the network string.</para>
            <para>An example network string is the following:</para>
            <para>
              <b>21DA:00D3:0000:2F3B:02AA:00FF:FE28:9C5A:8080</b>
            </para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IPV6_NETWORK</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv6 network using Internet standard hexadecimal encoding.
A network prefix in CIDR notation is required as part of the network string. A network port or scope ID must not be present in the network string.</para>
            <para>An example network string is the following:</para>
            <para>
              <b>21DA:D3./48</b>
            </para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_NAMED_ADDRESS</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an Internet address using a Domain Name System (DNS) name.
A network port or prefix must not be present in the network string.</para>
            <para>An example network string is the following:</para>
            <para>
              <b>www.microsoft.com</b>
            </para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_NAMED_SERVICE</b>
                </description>
              </item>
              <item>
                <description>0x00000200</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an Internet service using a DNS name.
A network port must be present in the network string.</para>
            <para>An example network string is the following:</para>
            <para>
              <b>www.microsoft.com:80</b>
            </para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IP_ADDRESS</b>
                </description>
              </item>
              <item>
                <description>0x00000009</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 address using Internet standard dotted-decimal notation or an IPv6 address using the Internet standard hexadecimal encoding.
An IPv6 scope ID may be present in the network string. A network port or prefix must not be present in the network string.</para>
            <para>This type matches either the <b>NET_STRING_IPV4_ADDRESS</b> or <b>NET_STRING_IPV6_ADDRESS</b> types.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IP_ADDRESS_NO_SCOPE</b>
                </description>
              </item>
              <item>
                <description>0x00000011</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 address using Internet standard dotted-decimal notation or an IPv6 address using Internet standard hexadecimal encoding.
An IPv6 scope ID must not be present in the network string. A network port or prefix must not be present in the network string.</para>
            <para>This type matches either the <b>NET_STRING_IPV4_ADDRESS</b> or <b>NET_STRING_IPV6_ADDRESS_NO_SCOPE</b> types.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IP_SERVICE</b>
                </description>
              </item>
              <item>
                <description>0x00000022</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 service or IPv6 service.
A network port is required as part of the network string. An IPv6 scope ID may be present in the network string. A prefix must not be present in the network string.</para>
            <para>This type matches either the <b>NET_STRING_IPV4_SERVICE</b> or <b>NET_STRING_IPV6_SERVICE</b> types.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IP_SERVICE_NO_SCOPE</b>
                </description>
              </item>
              <item>
                <description>0x00000042</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 service or IPv6 service.
A network port is required as part of the network string. An IPv6 scope ID must not be present in the network string. A prefix must not be present in the network string.</para>
            <para>This type matches either the <b>NET_STRING_IPV4_SERVICE</b> or <b>NET_STRING_IPV6_SERVICE_NO_SCOPE</b> types.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_IP_NETWORK</b>
                </description>
              </item>
              <item>
                <description>0x00000084</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 or IPv6 network.
A network prefix in CIDR notation is required as part of the network string. A network port or scope ID must not be present in the network.</para>
            <para>This type matches either the <b>NET_STRING_IPV4_NETWORK</b> or <b>NET_STRING_IPV6_NETWORK</b> types.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_ANY_ADDRESS</b>
                </description>
              </item>
              <item>
                <description>0x00000209</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 address in Internet standard dotted-decimal notation, an IPv6 address in Internet standard hexadecimal encoding, or a DNS name.
An IPv6 scope ID may be present in the network string for an IPv6 address. A network port or prefix must not be present in the network string.</para>
            <para>This type matches either the <b>NET_STRING_NAMED_ADDRESS</b> or <b>NET_STRING_IP_ADDRESS</b> types.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_ANY_ADDRESS_NO_SCOPE</b>
                </description>
              </item>
              <item>
                <description>0x00000211</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 address in Internet standard dotted-decimal notation, an IPv6 address in Internet standard hexadecimal encoding, or a DNS name.
An IPv6 scope ID must not be present in the network string for an IPv6 address. A network port or prefix must not be present in the network string.</para>
            <para>This type matches either the <b>NET_STRING_NAMED_ADDRESS</b> or <b>NET_STRING_IP_ADDRESS_NO_SCOPE</b> types.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_ANY_SERVICE</b>
                </description>
              </item>
              <item>
                <description>0x00000222</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 service or IPv6 service using IP address notation or a DNS name.
A network port is required as part of the network string. An IPv6 scope ID may be present in the network string. A prefix must not be present in the network string.</para>
            <para>This type matches either the <b>NET_STRING_NAMED_SERVICE</b> or <b>NET_STRING_IP_SERVICE</b> types.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NET_STRING_ANY_SERVICE_NO_SCOPE</b>
                </description>
              </item>
              <item>
                <description>0x00000242</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>NetworkString</i> parameter  points to an IPv4 service or IPv6 service using IP address notation or a DNS name.
A network port is required as part of the network string. An IPv6 scope ID must not be present in the network string. A prefix must not be present in the network string.</para>
            <para>This type matches either the <b>NET_STRING_NAMED_SERVICE</b> or <b>NET_STRING_IP_SERVICE_NO_SCOPE</b> types.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="AddressInfo">
      <para>On success, the function returns a pointer to a <b>NET_ADDRESS_INFO</b> structure that contains the parsed IP address information if a <b>NULL</b> pointer was not passed in this parameter.</para>
    </param>
    <param name="PortNumber">
      <para>On success, the function returns a pointer to the parsed network port in host order if a <b>NULL</b> pointer was not passed in this parameter. If a network port was not present in the <i>NetworkString</i> parameter, then a pointer to a value of zero is returned.</para>
    </param>
    <param name="PrefixLength">
      <para>On success, the function returns a pointer to the parsed prefix length if a <b>NULL</b> pointer was not passed in this parameter. If a prefix was not present in the <i>NetworkString</i> parameter, then a pointer to a value of -1 is returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is ERROR_SUCCESS.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The buffer passed to the function is too small. This error is returned if the buffer pointed to by the <i>AddressInfo</i> parameter is too small to hold the parsed
network address.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>NetworkString</i> parameter</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>ParseNetworkString</b> function parses the input network string passed in the <i>NetworkString</i> parameter and checks whether it
is a legal representation of one of the string types as specified in
the <i>Types</i> argument. If the string matches a type and its specification,
the function succeeds and can optionally return the parsed result
to the caller in the optional <i>AddressInfo</i>, <i>PortNumber</i>, and <i>PrefixLength</i> parameters when these parameters are not <b>NULL</b> pointers.</para>
      <para>The <b>ParseNetworkString</b> function can parse representations of IPv4 or IPv6 addresses,
services, and networks, as well as named Internet addresses and
services using DNS names.</para>
      <para>The <see cref="NET_ADDRESS_INFO" /> structure pointed to by the <i>AddressInfo</i> parameter. The SOCKADDR_IN and SOCKADDR structures are defined in the  <i>Ws2def.h</i> header file which is automatically included by the <i>Winsock2.h</i> header file. The SOCKADDR_IN6 structure is defined in the <i>Ws2ipdef.h</i> header file which is automatically included by the <i>Ws2tcpip.h</i> header file. In order to use the <b>ParseNetworkString</b> function  and the <b>NET_ADDRESS_INFO</b> structure, the <i>Winsock2.h</i> and <i>Ws2tcpip.h</i> header files must be included before the <i>Iphlpapi.h</i> header file.</para>
    </remarks>
    <seealso cref="NET_ADDRESS_FORMAT" />
    <seealso cref="NET_ADDRESS_INFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/WinSock/sockaddr-2">SOCKADDR</seealso>
  </member>
  <member name="Windows.RegisterInterfaceTimestampConfigChange">
    <summary>
      <para>Registers a user-implemented callback function, which the system calls to notify you of a timestamp capability change. You can cancel the registration by calling <see cref="UnregisterInterfaceTimestampConfigChange" />.</para>
      <para>For more info, and code examples, see <a href="https://docs.microsoft.com//windows/win32/iphlp/packet-timestamping">Packet timestamping</a>.</para>
    </summary>
    <param name="Callback">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/api/iphlpapi/nc-iphlpapi-interface_timestamp_config_change_callback">PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK</a></b></para>
      <para>Your callback function, to be invoked when a timestamp capability change happens.</para>
    </param>
    <param name="CallerContext">
      <para>Type: _In_opt_ <b>PVOID</b></para>
      <para>An optional caller-allocated context.</para>
    </param>
    <param name="NotificationHandle">
      <para>Type: _Out_ <b>HIFTIMESTAMPCHANGE</b></para>
      <para>A handle, returned by the function, that identifies the registration.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">DWORD</a></b></para>
      <para>A <b>DWORD</b> return code indicating success or failure.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/win32/iphlp/packet-timestamping">Packet timestamping</seealso>
    <seealso cref="UnregisterInterfaceTimestampConfigChange" />
  </member>
  <member name="Windows.RestoreMediaSense">
    <summary>
      <para>The <b>RestoreMediaSense</b> function restores the media sensing capability of the TCP/IP stack on a local computer on which the <see cref="DisableMediaSense" /> function was previously called.</para>
    </summary>
    <param name="pOverlapped">
      <para>A pointer to an
<see cref="OVERLAPPED" /> structure. Except for the <b>hEvent</b> member, all members of this structure must be set to zero. The <b>hEvent</b> member should contain a handle to a valid event object. Use the
<see cref="CreateEvent" /> function to create this event object.</para>
    </param>
    <param name="lpdwEnableCount">
      <para>An optional pointer to a DWORD variable that receives the number of references remaining if the <b>RestoreMediaSense</b> function succeeds. The variable is also used by the <see cref="EnableRouter" /> and <see cref="UnenableRouter" /> functions.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if an <i>pOverlapped</i> parameter is a bad pointer.  This error is also returned if the <see cref="DisableMediaSense" /> function was not called prior to calling the <see cref="RestoreMediaSense" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_IO_PENDING</b>
            </para>
          </description>
          <description>
            <para>The operation is in progress. This value may be returned by a successful asynchronous call to <see cref="RestoreMediaSense" />.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_OPEN_FAILED</b>
            </para>
          </description>
          <description>
            <para>An internal handle to the driver was invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the <i>pOverlapped</i> parameter is <b>NULL</b>, the <b>RestoreMediaSense</b> function is  executed synchronously.</para>
      <para>If the <i>pOverlapped</i> parameter is not <b>NULL</b>, the <b>RestoreMediaSense</b> function is  executed asynchronously using the <see cref="OVERLAPPED" /> structure pointed to by the <i>pOverlapped</i> parameter.</para>
      <para>The <see cref="DisableMediaSense" /> function does not complete until the <b>RestoreMediaSense</b> function is called later to restore the media sensing capability. Until then, an I/O request packet (IRP) remains queued up. Alternatively, when the process that called <b>DisableMediaSense</b> exits, the IRP is canceled and a cancel routine is called that would again restore the media sensing capability.</para>
      <para>To call <b>RestoreMediaSense</b> synchronously, an application needs to pass a <b>NULL</b> pointer in the <i>pOverlapped</i> parameter. When <b>RestoreMediaSense</b> is called synchronously, the function returns when the I/O request packet (IRP) to restore the media sense has completed.</para>
      <para>To call <b>RestoreMediaSense</b> asynchronously, an application needs to allocate an <see cref="OVERLAPPED" /> structure. Except for the <b>hEvent</b> member, all members of this structure must be set to zero. The <b>hEvent</b> member requires a handle to a valid event object. Use the
<see cref="CreateEvent" /> function to create this event. When called asynchronously, <b>RestoreMediaSense</b> can return return ERROR_IO_PENDING. The IRP completes when the media sensing capability has been restored. Use the <see cref="CloseHandle" /> function to close the handle to the event object when it is no longer needed. The system closes the handle automatically when the process terminates. The event object is destroyed when its last handle has been closed.</para>
      <para>If <see cref="DisableMediaSense" /> was not called prior to calling <b>RestoreMediaSense</b>, then <b>RestoreMediaSense</b> returns ERROR_INVALID_PARAMETER.</para>
      <para>On Windows Server 2003and Windows XP, the TCP/IP stack implements a policy of deleting all IP addresses on an interface in response to a media sense disconnect event from an underlying network interface. If a network switch or hub that the local computer is connected to is powered off, or a network cable is disconnected, the network interface will deliver disconnection events. IP configuration information associated with the network interface is lost. As a result, the TCP/IP stack implements a policy of hiding disconnected interfaces so these interfaces and their associated IP addresses do not show up in configuration information retrieved through IP helper. This policy prevents some applications from easily detecting that a network interface is merely disconnected, rather than removed from the system.</para>
      <para>This behavior does not normally impact a local client computer if it is using DHCP requests to a DHCP server for IP configuration information. But this can have a serious impact on server computers, particularly computers used as part of clusters. The <see cref="DisableMediaSense" /> function can be used to temporarily disable the media sense capability for these cases. At some later time, the <b>RestoreMediaSense</b> function would be called to restore the media sensing capability.</para>
      <para>The following registry setting is related to the <see cref="DisableMediaSense" /> and <b>RestoreMediaSense</b> functions:</para>
      <para>
        <b>System</b>\<b>CurrentControlSet</b>\<b>Services</b>\<b>Tcpip</b>\<b>Parameters</b>\<b>DisableDHCPMediaSense</b></para>
      <para>There is an internal flag in Windows that is set if this registry key exists when the machine first boots up. The same internal flag also gets set and reset by calling <see cref="DisableMediaSense" /> and <b>RestoreMediaSense</b>. However with registry setting, you need to reboot the machine for the changes to take place.</para>
      <para>The TCP/IP stack on Windows Vista and later was changed to not hide disconnected interfaces when a disconnect event occurs. So on Windows Vista and later, the <see cref="DisableMediaSense" /> and <b>RestoreMediaSense</b> functions don't do anything and always returns NO_ERROR.</para>
      <h4>Examples</h4>
      <para>The following example shows how to call the <see cref="DisableMediaSense" /> and <b>RestoreMediaSense</b> functions synchronously. This sample is only useful on Windows Server 2003and Windows XP where the <b>DisableMediaSense</b> and <b>RestoreMediaSense</b> functions do something useful.</para>
      <para>The sample first creates a separate thread that calls the <see cref="DisableMediaSense" /> function synchronously, the main thread sleeps for 60 seconds to allow the user to disconnect a network cable, retrieves the IP address table and prints some members of the IP address entries in the table, calls the <b>RestoreMediaSense</b> function synchronously, retrieves the IP address table again, and prints some members of the IP address entries in the table.  The impact of disabling the media sensing capability can be seen in the difference in the IP address table entries.</para>
      <para>For an example that shows how to call the <see cref="DisableMediaSense" /> and <b>RestoreMediaSense</b> functions asynchronously, see the <b>DisableMediaSense</b> function reference.</para>
      <code>#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

// The thread proc to call DisableMediaSense
DWORD WINAPI ThreadProc(LPVOID lpParam)
{
    if (*((DWORD *) lpParam)) {
        DWORD dwRetVal;
        dwRetVal = DisableMediaSense(NULL, NULL);
        if (dwRetVal &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; dwRetVal != ERROR_IO_PENDING) {
            printf("DisableMediaSense failed with error %d\n", dwRetVal);
            return 0;
        } else {
            Sleep(1000);
            printf(" === DisableMediaSense Returned now. ===\n\n");
        }
    }
    return 0;
}

int __cdecl main()
{

    int i;

    /* Variables used by GetIpAddrTable */
    PMIB_IPADDRTABLE pIPAddrTable;
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;
    IN_ADDR IPAddr;

    /* Variables used to return error message */
    LPVOID lpMsgBuf;

    /* Variable to use with RestoreMediaSense */
    DWORD dwEnableCount = 0;

    // Variables used to create a separate thread to call
    // the DisableMediaSense function
    DWORD ThreadID;
    DWORD IsDisable = TRUE;
    HANDLE Disable_THandle;

    // Create the thread to call Disable MediaSense synchronously
    Disable_THandle =
        CreateThread(NULL, 0, ThreadProc, (LPVOID) &amp;amp;amp;amp;amp;amp; IsDisable, 0, &amp;amp;amp;amp;amp;amp;ThreadID);
    if (!Disable_THandle) {
        printf("CreateTread Failed:%d", GetLastError());
        exit(1);
    }

    printf(" === DisableMediaSense called on separate thread ===\n\n");
// Sleep for 60 seconds so we can disconnect a cable
    Sleep(60000);

    // Before calling AddIPAddress we use GetIpAddrTable to get
    // an adapter to which we can add the IP.
    pIPAddrTable = (MIB_IPADDRTABLE *) MALLOC(sizeof (MIB_IPADDRTABLE));

    if (pIPAddrTable) {
        // Make an initial call to GetIpAddrTable to get the
        // necessary size into the dwSize variable
        if (GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0) ==
            ERROR_INSUFFICIENT_BUFFER) {
            FREE(pIPAddrTable);
            pIPAddrTable = (MIB_IPADDRTABLE *) MALLOC(dwSize);

        }
        if (pIPAddrTable == NULL) {
            printf("Memory allocation failed for GetIpAddrTable\n");
            exit(1);
        }
    }
    // Make a second call to GetIpAddrTable to get the
    // actual data we want
    if ((dwRetVal = GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0)) != NO_ERROR) {
        printf("GetIpAddrTable failed with error %d\n", dwRetVal);
        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    dwRetVal,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR) &amp;amp;amp;amp;amp;amp; lpMsgBuf, 0, NULL)) {
            printf("\tError: %s", lpMsgBuf);
            LocalFree(lpMsgBuf);
        }
        exit(1);
    }

    printf("\tNum Entries: %ld\n", pIPAddrTable-&gt;dwNumEntries);
    for (i = 0; i &lt; (int) pIPAddrTable-&gt;dwNumEntries; i++) {
        printf("\n\tInterface Index[%d]:\t%ld\n", i,
               pIPAddrTable-&gt;table[i].dwIndex);
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwAddr;
        printf("\tIP Address[%d]:     \t%s\n", i, inet_ntoa(IPAddr));
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwMask;
        printf("\tSubnet Mask[%d]:    \t%s\n", i, inet_ntoa(IPAddr));
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwBCastAddr;
        printf("\tBroadCast[%d]:      \t%s (%ld%)\n", i, inet_ntoa(IPAddr),
               pIPAddrTable-&gt;table[i].dwBCastAddr);
        printf("\tReassembly size[%d]:\t%ld\n", i,
               pIPAddrTable-&gt;table[i].dwReasmSize);
        printf("\tType and State[%d]:", i);
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_PRIMARY)
            printf("\tPrimary IP Address");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DYNAMIC)
            printf("\tDynamic IP Address");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DISCONNECTED)
            printf("\tAddress is on disconnected interface");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DELETED)
            printf("\tAddress is being deleted");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_TRANSIENT)
            printf("\tTransient address");
        printf("\n");
    }

    // Call RestoreMediaSense synchronously to enable mediasense
    dwRetVal = RestoreMediaSense(NULL, &amp;amp;amp;amp;amp;amp;dwEnableCount);
    if (dwRetVal &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; dwRetVal != ERROR_IO_PENDING) {
        printf("RestoreMediaSense failed with error %d\n", dwRetVal);
        exit(1);
    } else {
        printf(" === RestoreMediaSense called ===\n");
        printf("  EnableCount returned was %ld\n\n", dwEnableCount);
    }

    if (pIPAddrTable) {
        // Make an initial call to GetIpAddrTable to get the
        // necessary size into the dwSize variable
        if (GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0) ==
            ERROR_INSUFFICIENT_BUFFER) {
            FREE(pIPAddrTable);
            pIPAddrTable = (MIB_IPADDRTABLE *) MALLOC(dwSize);

        }
        if (pIPAddrTable == NULL) {
            printf("Memory allocation failed for GetIpAddrTable\n");
            exit(1);
        }
    }
    // Make a second call to GetIpAddrTable to get the
    // actual data we want
    if ((dwRetVal = GetIpAddrTable(pIPAddrTable, &amp;amp;amp;amp;amp;amp;dwSize, 0)) != NO_ERROR) {
        printf("GetIpAddrTable failed with error %d\n", dwRetVal);
        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    dwRetVal,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR) &amp;amp;amp;amp;amp;amp; lpMsgBuf, 0, NULL)) {
            printf("\tError: %s", lpMsgBuf);
            LocalFree(lpMsgBuf);
        }
        exit(1);
    }

    printf("\tNum Entries: %ld\n", pIPAddrTable-&gt;dwNumEntries);
    for (i = 0; i &lt; (int) pIPAddrTable-&gt;dwNumEntries; i++) {
        printf("\n\tInterface Index[%d]:\t%ld\n", i,
               pIPAddrTable-&gt;table[i].dwIndex);
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwAddr;
        printf("\tIP Address[%d]:     \t%s\n", i, inet_ntoa(IPAddr));
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwMask;
        printf("\tSubnet Mask[%d]:    \t%s\n", i, inet_ntoa(IPAddr));
        IPAddr.S_un.S_addr = (u_long) pIPAddrTable-&gt;table[i].dwBCastAddr;
        printf("\tBroadCast[%d]:      \t%s (%ld%)\n", i, inet_ntoa(IPAddr),
               pIPAddrTable-&gt;table[i].dwBCastAddr);
        printf("\tReassembly size[%d]:\t%ld\n", i,
               pIPAddrTable-&gt;table[i].dwReasmSize);
        printf("\tType and State[%d]:", i);
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_PRIMARY)
            printf("\tPrimary IP Address");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DYNAMIC)
            printf("\tDynamic IP Address");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DISCONNECTED)
            printf("\tAddress is on disconnected interface");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_DELETED)
            printf("\tAddress is being deleted");
        if (pIPAddrTable-&gt;table[i].wType &amp;amp;amp;amp;amp;amp; MIB_IPADDR_TRANSIENT)
            printf("\tTransient address");
        printf("\n");
    }

    if (pIPAddrTable) {
        FREE(pIPAddrTable);
        pIPAddrTable = NULL;
    }

    exit(0);
}


</code>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEvent" />
    <seealso cref="DisableMediaSense" />
    <seealso cref="EnableRouter" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="OVERLAPPED" />
    <seealso cref="UnenableRouter" />
  </member>
  <member name="Windows.SendARP">
    <summary>
      <para>The
<b>SendARP</b> function sends an Address Resolution Protocol (ARP) request to obtain the physical address that corresponds to the specified destination IPv4 address.</para>
    </summary>
    <param name="DestIP">
      <para>The destination IPv4 address, in the form of an <see cref="IPAddr" /> structure. The ARP request attempts to obtain the physical address that corresponds to this IPv4 address.</para>
    </param>
    <param name="SrcIP">
      <para>The source IPv4 address of the sender, in the form of an <see cref="IPAddr" /> structure. This parameter is optional and is used to select the interface to send the request on for the ARP entry. The caller may specify zero corresponding to the <b>INADDR_ANY</b> IPv4 address for this parameter.</para>
    </param>
    <param name="pMacAddr">
      <para>A pointer to an array of <b>ULONG</b> variables. This array must have at least two <b>ULONG</b> elements to hold an  Ethernet or token ring physical address. The first six bytes of this array receive the physical address that corresponds to the IPv4 address specified by the <i>DestIP</i> parameter.</para>
    </param>
    <param name="PhyAddrLen">
      <para>On input, a pointer to a <b>ULONG</b> value that specifies the maximum buffer size, in bytes, the application has set aside to receive the physical address or MAC address. The buffer size should be at least 6 bytes for an Ethernet or token ring physical address</para>
      <para>The buffer to receive the physical address is pointed to by the <i>pMacAddr</i> parameter.</para>
      <para>On successful output, this parameter points to a value that specifies the number of bytes written to the buffer pointed to by the <i>pMacAddr</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BAD_NET_NAME</b>
            </para>
          </description>
          <description>
            <para>The network name cannot be found. This error is returned on Windows Vista and later when an ARP reply to the <see cref="SendARP" /> request was not received. This error occurs  if the destination IPv4 address could not be reached because it is not on the same subnet or  the destination computer is not operating.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The file name is too long. This error is returned on Windows Vista if the  <b>ULONG</b> value pointed to by the <i>PhyAddrLen</i> parameter is less than 6, the size required to store a complete physical address.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_GEN_FAILURE</b>
            </para>
          </description>
          <description>
            <para>A device attached to the system is not functioning. This error is returned on Windows Server 2003 and earlier when an ARP reply to the <see cref="SendARP" /> request was not received. This error can occur if destination IPv4 address could not be reached because it is not on the same subnet or  the destination computer is not operating.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is invalid. This error is returned on Windows Server 2003 and earlier if either the  <i>pMacAddr</i> or <i>PhyAddrLen</i> parameter is a <b>NULL</b> pointer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_USER_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The supplied user buffer is not valid for the requested operation. This error is returned on Windows Server 2003 and earlier if the  <b>ULONG</b> value pointed to by the <i>PhyAddrLen</i> parameter is zero.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>Element not found. This error is returned on Windows Vista if the  the <i>SrcIp</i> parameter does not specify a source IPv4 address on an interface on the local computer or the <b>INADDR_ANY</b> IP address (an IPv4 address of 0.0.0.0).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The <see cref="SendARP" /> function is not supported by the operating system running on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>SendARP</b> function is used to request the physical hardware address (sometimes referred to as the MAC address) that corresponds to a specified destination IPv4 address. If the information requested is not in the ARP table on the local computer, then the <b>SendARP</b> function will cause an ARP request to be sent to obtain the physical address. If the function is successful, the physical address that corresponds to the specified destination IPv4 address is returned in the array pointed to by the <i>pMacAddr</i> parameter.</para>
      <para>The physical address of an IPv4 address is only available if the destination IPv4 address is on the local subnet (the IPv4 address can be reached directly without going through any routers). The <b>SendARP</b> function will fail if the destination IPv4 address is not on the local subnet.</para>
      <para>If the <b>SendARP</b> function is successful on Windows Vista and later, the ARP table on the local computer is updated with the results.  If the <b>SendARP</b> function is successful on Windows Server 2003 and earlier, the ARP table on the local computer is not affected.</para>
      <para>The <b>SendARP</b> function on Windows Vista and later returns different error return values  than the  <b>SendARP</b> function on    Windows Server 2003 and earlier.</para>
      <para>On Windows Vista and later, a <b>NULL</b> pointer passed as the <i>pMacAddr</i> or <i>PhyAddrLen</i> parameter to the <b>SendARP</b> function causes an access violation and the application is terminated. If an error occurs on Windows Vista and later and <b>ERROR_BAD_NET_NAME</b>,  <b>ERROR_BUFFER_OVERFLOW</b>, or <b>ERROR_NOT_FOUND</b> is returned, the <b>ULONG</b> value pointed to by the <i>PhyAddrLen</i> parameter is set to zero. If the <b>ULONG</b> value pointed to by the <i>PhyAddrLen</i> parameter is less than 6 on  Windows Vista and later, <b>SendARP</b> function returns  <b>ERROR_BUFFER_OVERFLOW</b> indicating the buffer to receive the physical address is too small. If the <i>SrcIp</i> parameter specifies an IPv4 address that is not an interface on the local computer, the <b>SendARP</b> function on    Windows Vista and later  returns <b>ERROR_NOT_FOUND</b>.</para>
      <para>On Windows Server 2003 and earlier, a <b>NULL</b> pointer passed as the <i>pMacAddr</i> or <i>PhyAddrLen</i> parameter to the <b>SendARP</b> function returns <b>ERROR_INVALID_PARAMETER</b>. If an error occurs on Windows Server 2003 and earlier and <b>ERROR_GEN_FAILURE</b> or   <b>ERROR_INVALID_USER_BUFFER</b> is returned, the <b>ULONG</b> value pointed to by the <i>PhyAddrLen</i> parameter is set to zero. If the <b>ULONG</b> value pointed to by the <i>PhyAddrLen</i> parameter is less than 6 on  Windows Server 2003 and earlier, the <b>SendARP</b> function does not return an error but only returns part of the hardware address in the array pointed to by the <i>pMacAddr</i> parameter. So if the value pointed to by the <i>PhyAddrLen</i> parameter is 4, then only the first 4 bytes of the hardware address are returned in the array pointed to by the <i>pMacAddr</i> parameter. If the <i>SrcIp</i> parameter specifies an IPv4 address that is not an interface on the local computer, the <b>SendARP</b> function on    Windows Server 2003 and  earlier ignores the <i>SrcIp</i> parameter and uses an IPv4 address on the local computer for the source IPv4 address.</para>
      <para>The <see cref="GetIpNetTable" /> function retrieves the ARP table on the local computer that maps IPv4 addresses to physical addresses.</para>
      <para>The <see cref="CreateIpNetEntry" /> function creates an ARP entry in the ARP table on the local computer.</para>
      <para>The <see cref="DeleteIpNetEntry" /> function deletes an ARP entry from the ARP table on the local computer.</para>
      <para>The <see cref="SetIpNetEntry" /> function modifies an existing ARP entry in the ARP table on the local computer.</para>
      <para>The <see cref="FlushIpNetTable" /> function deletes all ARP entries for the specified interface from the ARP table on the local computer.</para>
      <para>On Windows Vista and later, the <see cref="ResolveIpNetEntry2" /> function can used to replace the <b>SendARP</b> function. An ARP request is sent if the <b>Address</b> member of the <see cref="MIB_IPNET_ROW2" /> structure passed to the <b>ResolveIpNetEntry2</b> function is an IPv4 address.</para>
      <para>On Windows Vista, a new group of functions can be used to access, modify, and delete the ARP table entries when the <b>Address</b> member of the <see cref="MIB_IPNET_ROW2" /> structure passed to these functions is an IPv4 address.  The new functions include the following: <see cref="GetIpNetTable2" />, <see cref="CreateIpNetEntry2" />, <see cref="DeleteIpNetEntry2" />,  <see cref="FlushIpNetTable2" />, and <see cref="SetIpNetEntry2" />.</para>
      <para>For information about the <b>IPAddr</b> data type, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">Windows Data Types</a>. To convert an IP address between dotted decimal notation and <b>IPAddr</b> format, use the
<see cref="inet_addr" /> and
<see cref="inet_ntoa" /> functions.</para>
      <h4>Examples</h4>
      <para>The following code demonstrates how to obtain the hardware or media access control (MAC) address associated with a specified IPv4 address.</para>
      <code>#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include &lt;winsock2.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

void usage(char *pname)
{
    printf("Usage: %s [options] ip-address\n", pname);
    printf("\t -h \t\thelp\n");
    printf("\t -l length \tMAC physical address length to set\n");
    printf("\t -s src-ip \tsource IP address\n");
    exit(1);
}

int __cdecl main(int argc, char **argv)
{
    DWORD dwRetVal;
    IPAddr DestIp = 0;
    IPAddr SrcIp = 0;       /* default for src ip */
    ULONG MacAddr[2];       /* for 6-byte hardware addresses */
    ULONG PhysAddrLen = 6;  /* default to length of six bytes */

    char *DestIpString = NULL;
    char *SrcIpString = NULL;

    BYTE *bPhysAddr;
    unsigned int i;

    if (argc &gt; 1) {
        for (i = 1; i &lt; (unsigned int) argc; i++) {
            if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
                switch (tolower(argv[i][1])) {
                case 'l':
                    PhysAddrLen = (ULONG) atol(argv[++i]);
                    break;
                case 's':
                    SrcIpString = argv[++i];
                    SrcIp = inet_addr(SrcIpString);
                    break;
                case 'h':
                default:
                    usage(argv[0]);
                    break;
                }               /* end switch */
            } else
                DestIpString = argv[i];
        }                       /* end for */
    } else
        usage(argv[0]);

    if (DestIpString == NULL || DestIpString[0] == '\0')
        usage(argv[0]);

    DestIp = inet_addr(DestIpString);

    memset(&amp;amp;amp;amp;amp;amp;MacAddr, 0xff, sizeof (MacAddr));

    printf("Sending ARP request for IP address: %s\n", DestIpString);

    dwRetVal = SendARP(DestIp, SrcIp, &amp;amp;amp;amp;amp;amp;MacAddr, &amp;amp;amp;amp;amp;amp;PhysAddrLen);

    if (dwRetVal == NO_ERROR) {
        bPhysAddr = (BYTE *) &amp;amp;amp;amp;amp;amp; MacAddr;
        if (PhysAddrLen) {
            for (i = 0; i &lt; (int) PhysAddrLen; i++) {
                if (i == (PhysAddrLen - 1))
                    printf("%.2X\n", (int) bPhysAddr[i]);
                else
                    printf("%.2X-", (int) bPhysAddr[i]);
            }
        } else
            printf
                ("Warning: SendArp completed successfully, but returned length=0\n");

    } else {
        printf("Error: SendArp failed with error: %d", dwRetVal);
        switch (dwRetVal) {
        case ERROR_GEN_FAILURE:
            printf(" (ERROR_GEN_FAILURE)\n");
            break;
        case ERROR_INVALID_PARAMETER:
            printf(" (ERROR_INVALID_PARAMETER)\n");
            break;
        case ERROR_INVALID_USER_BUFFER:
            printf(" (ERROR_INVALID_USER_BUFFER)\n");
            break;
        case ERROR_BAD_NET_NAME:
            printf(" (ERROR_GEN_FAILURE)\n");
            break;
        case ERROR_BUFFER_OVERFLOW:
            printf(" (ERROR_BUFFER_OVERFLOW)\n");
            break;
        case ERROR_NOT_FOUND:
            printf(" (ERROR_NOT_FOUND)\n");
            break;
        default:
            printf("\n");
            break;
        }
    }

    return 0;
}


</code>
    </remarks>
    <seealso cref="CreateIpNetEntry" />
    <seealso cref="CreateIpNetEntry2" />
    <seealso cref="CreateProxyArpEntry" />
    <seealso cref="DeleteIpNetEntry" />
    <seealso cref="DeleteIpNetEntry2" />
    <seealso cref="DeleteProxyArpEntry" />
    <seealso cref="FlushIpNetTable" />
    <seealso cref="FlushIpNetTable2" />
    <seealso cref="GetIpNetEntry2" />
    <seealso cref="GetIpNetTable2" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper
Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper
Start Page</seealso>
    <seealso cref="IPAddr" />
    <seealso cref="ResolveIpNetEntry2" />
    <seealso cref="SetIpNetEntry" />
    <seealso cref="SetIpNetEntry2" />
  </member>
  <member name="Windows.SetIfEntry">
    <summary>
      <para>The
<b>SetIfEntry</b> function sets the administrative status of an interface.</para>
    </summary>
    <param name="pIfRow">
      <para>A pointer to a
<see cref="MIB_IFROW" /> structure. The <b>dwIndex</b> member of this structure specifies the interface on which to set administrative status. The <b>dwAdminStatus</b> member specifies the new administrative status. The <b>dwAdminStatus</b> member can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>MIB_IF_ADMIN_STATUS_UP</b>
          </description>
          <description>
            <para>The interface is administratively enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>MIB_IF_ADMIN_STATUS_DOWN</b>
          </description>
          <description>
            <para>The interface is administratively disabled.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and later under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_FILE_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The system cannot find the file specified. This error is returned on Windows Vista and later if the  network interface specified by the <b>dwIndex</b>  member of the <see cref="MIB_IFROW" /> structure pointed to by the <i>pIfRow</i> parameter could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>pIfRow</i> parameter, or the <b>dwIndex</b>  member of the <see cref="MIB_IFROW" /> pointed to by the <i>pIfRow</i> parameter was unspecified. This error is also returned on Windows Server 2003 and earlier if the  network interface specified by the <b>dwIndex</b>  member of the <b>MIB_IFROW</b> structure pointed to by the <i>pIfRow</i> parameter could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported. This error is returned on Windows Server 2003 and earlier if no TCP/IP stack is configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>SetIfEntry</b> function is used to set the administrative status of an interface on a local computer.</para>
      <para>The <b>dwIndex</b> member in the <see cref="MIB_IFROW" /> structure pointed to by the <i>pIfRow</i> parameter must be initialized to the interface index.</para>
      <para>The <b>SetIfEntry</b> function will fail if the  <b>dwIndex</b>  member of the <see cref="MIB_IFROW" /> pointed to by the <i>pIfRow</i> parameter does not match an existing interface on the local computer.</para>
      <para>On Windows Vista and later, the <b>SetIfEntry</b> function can only be called by a user logged on as a member of the Administrators group. If <b>SetIfEntry</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned.</para>
      <para>The <b>SetIfEntry</b> function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>   On Windows NT 4.0 and Windows 2000 and later, this function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
    </remarks>
    <seealso cref="GetIfEntry" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IFROW" />
    <seealso cref="MIB_IFTABLE" />
  </member>
  <member name="Windows.SetIpForwardEntry">
    <summary>
      <para>The
<b>SetIpForwardEntry</b> function modifies an existing route in the local computer's IPv4 routing table.</para>
    </summary>
    <param name="pRoute">
      <para>A pointer to a
<see cref="MIB_IPFORWARDROW" /> structure that specifies the new information for the existing route. The caller must specify <b>MIB_IPPROTO_NETMGMT</b> for the <b>dwForwardProto</b> member of this structure. The caller must also specify values for the <b>dwForwardIfIndex</b>, <b>dwForwardDest</b>, <b>dwForwardMask</b>, <b>dwForwardNextHop</b>, and <b>dwForwardPolicy</b> members of the structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_FILE_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The system cannot find the file specified. This error is returned on Windows Vista and later if the  network interface specified by the <b>dwForwardIfIndex</b>  member of the <see cref="MIB_IPFORWARDROW" /> structure pointed to by the <i>pRoute</i> parameter could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pRoute</i> parameter is <b>NULL</b>, or <see cref="SetIpForwardEntry" /> is unable to read from the memory pointed to by <i>pRoute</i>, or one of the members of the
<see cref="MIB_IPFORWARDROW" /> structure is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The element is not found. The error is returned on Windows Vista and later when the <see cref="DeleteIpForwardEntry" /> function and then the <see cref="SetIpForwardEntry" /> function are called for the same IPv4 route table entry.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported. This value is returned if the IPv4 transport is not configured on the local computer. This error is also returned on Windows Server 2003 and earlier if no TCP/IP stack is configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>dwForwardProto</b> member of
<see cref="MIB_IPFORWARDROW" /> structure pointed to by the <i>route</i> parameter must be set to <b>MIB_IPPROTO_NETMGMT</b> otherwise <b>SetIpForwardEntry</b> will fail. Routing protocol identifiers are used to identify route information for the specified routing protocol. For example, <b>MIB_IPPROTO_NETMGMT</b> is used to identify route information for IP  routing set through network management such as the Dynamic Host Configuration Protocol (DHCP), the Simple Network Management Protocol (SNMP), or by calls to the <see cref="CreateIpForwardEntry" />,  <see cref="DeleteIpForwardEntry" />, or <b>SetIpForwardEntry</b> functions.</para>
      <para>On Windows Vista and Windows Server 2008, the route metric specified in the <b>dwForwardMetric1</b> member of the  <see cref="MIB_IPFORWARDROW" /> structure pointed to by <i>pRoute</i> parameter represents a combination of the route metric added to the interface metric specified in the <b>Metric</b> member of the <see cref="MIB_IPINTERFACE_ROW" /> structure of the associated interface.  So the <b>dwForwardMetric1</b> member of the  <b>MIB_IPFORWARDROW</b> structure should be equal to or greater than <b>Metric</b> member of the associated <b>MIB_IPINTERFACE_ROW</b> structure. If an application would like to set the route metric to 0, then the <b>dwForwardMetric1</b> member of the <b>MIB_IPFORWARDROW</b> structure  should be set equal to the value of the interface metric specified in the <b>Metric</b> member of the associated <b>MIB_IPINTERFACE_ROW</b> structure. An application can retrieve the interface metric by calling the <see cref="GetIpInterfaceEntry" /> function.</para>
      <para>On Windows Vista and Windows Server 2008, the <b>SetIpForwardEntry</b> function only works on interfaces with a single sub-interface (where the interface LUID and subinterface LUID are the same). The <b>dwForwardIfIndex</b> member of the <see cref="MIB_IPFORWARDROW" /> structure specifies the interface.</para>
      <para>The <b>dwForwardAge</b> member the <see cref="MIB_IPFORWARDROW" /> structure  pointed to by the <i>route</i> parameter is not currently used by <b>SetIpForwardEntry</b>. The <b>dwForwardAge</b> member is used only if the Routing and Remote Access Service (RRAS)is running, and then only for routes of type <b>MIB_IPPROTO_NETMGMT</b> as defined on the <a href="https://docs.microsoft.com//windows/desktop/RRAS/protocol-identifiers">Protocol Identifiers</a> reference page. When <b>dwForwardAge</b> is set to <b>INFINITE</b>, the route will not be removed based on a timeout</para>
      <para>value. Any other value for <b>dwForwardAge</b> specifies the number of seconds until the TCP/IP stack will remove the route from the network routing table.</para>
      <para>A route modified by <b>SetIpForwardEntry</b> will automatically have a default value for <b>dwForwardAge</b> of INFINITE.</para>
      <para>A number of members of the <see cref="MIB_IPFORWARDROW" /> structure  pointed to by the <i>route</i> parameter are not currently used by <b>SetIpForwardEntry</b>. These members include <b>dwForwardPolicy</b>, <b>dwForwardType</b>, <b>dwForwardAge</b>, <b>dwForwardNextHopAS</b>, <b>dwForwardMetric1</b>, <b>dwForwardMetric2</b>, <b>dwForwardMetric3</b>, <b>dwForwardMetric4</b>, and <b>dwForwardMetric5</b>.</para>
      <para>To create a new route in the IP routing table, use the
<see cref="CreateIpForwardEntry" /> function. To retrieve the IP routing table, call the <see cref="GetIpForwardTable" /> function.</para>
      <para>On Windows Vista and later, the <b>SetIpForwardEntry</b> function can only be called by a user logged on as a member of the Administrators group. If <b>SetIpForwardEntry</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned.</para>
      <para>This function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>  On Windows NT 4.0 and Windows 2000 and later, this function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
      <h4>Examples</h4>
      <para>The following example demonstrates how to change the default gateway to NewGateway. Simply calling <see cref="GetIpForwardTable" />, changing the gateway and then calling <b>SetIpForwardEntry</b> will not change the route, but rather will just add a new one. If for some reason there are multiple default gateways present, this code will delete them. Note that the new gateway must be viable; otherwise, TCP/IP will ignore the change.</para>
      <para>
        <b>Note</b>  Executing this code will change your IP routing tables and will likely cause network activity to fail.</para>
      <para>
        <b>Windows Vista and later:  </b>When the <see cref="DeleteIpForwardEntry" /> function and then <b>SetIpForwardEntry</b> function are called for the same route table entry on Windows Vista and later, ERROR_NOT_FOUND is returned. The proper way to replicate this example on Windows Vista and later is to use the <see cref="CreateIpForwardEntry" /> function to create the new route table entry and then delete the old route table entry by calling the <b>DeleteIpForwardEntry</b> function.</para>
      <code>#pragma comment(lib, "IPHLPAPI.lib")

// #ifndef WIN32_LEAN_AND_MEAN
// #define WIN32_LEAN_AND_MEAN
// #endif

// #pragma warning(push)
// #pragma warning(disable: 4127)

// #include &lt;windows.h&gt;

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;iphlpapi.h&gt;
#include &lt;stdio.h&gt;

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))
/* Note: could also use malloc() and free() */

int main()
{

    // Declare and initialize variables.

    /* variables used for SetIfForwardEntry */

    PMIB_IPFORWARDTABLE pIpForwardTable = NULL;
    PMIB_IPFORWARDROW pRow = NULL;
    DWORD dwSize = 0;
    BOOL bOrder = FALSE;
    DWORD dwStatus = 0;
    DWORD NewGateway = 0xDDBBCCAA;      // this is in host order Ip Address AA.BB.CC.DD is DDCCBBAA
    DWORD i;

// Find out how big our buffer needs to be.
    dwStatus = GetIpForwardTable(pIpForwardTable, &amp;amp;amp;amp;amp;amp;dwSize, bOrder);
    if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {
        // Allocate the memory for the table
        pIpForwardTable = (PMIB_IPFORWARDTABLE) malloc(dwSize);
        if (pIpForwardTable == NULL) {
            printf("Unable to allocate memory for the IPFORWARDTALE\n");
            exit(1);
        }
        // Now get the table.
        dwStatus = GetIpForwardTable(pIpForwardTable, &amp;amp;amp;amp;amp;amp;dwSize, bOrder);
    }

    if (dwStatus != ERROR_SUCCESS) {
        printf("getIpForwardTable failed.\n");
        if (pIpForwardTable)
            free(pIpForwardTable);
        exit(1);
    }
// Search for the row in the table we want. The default gateway has a destination
// of 0.0.0.0. Notice that we continue looking through the table, but copy only
// one row. This is so that if there happen to be multiple default gateways, we can
// be sure to delete them all.
    for (i = 0; i &lt; pIpForwardTable-&gt;dwNumEntries; i++) {
        if (pIpForwardTable-&gt;table[i].dwForwardDest == 0) {
            // We have found the default gateway.
            if (!pRow) {
                // Allocate some memory to store the row in. This is easier than filling
                // in the row structure ourselves, and we can be sure to change only the
                // gateway address.
                pRow = (PMIB_IPFORWARDROW) malloc(sizeof (MIB_IPFORWARDROW));
                if (!pRow) {
                    printf("Malloc failed. Out of memory.\n");
                    exit(1);
                }
                // Copy the row.
                memcpy(pRow, &amp;amp;amp;amp;amp;amp;(pIpForwardTable-&gt;table[i]),
                       sizeof (MIB_IPFORWARDROW));
            }
            // Delete the old default gateway entry.
            dwStatus = DeleteIpForwardEntry(&amp;amp;amp;amp;amp;amp;(pIpForwardTable-&gt;table[i]));

            if (dwStatus != ERROR_SUCCESS) {
                printf("Could not delete old gateway\n");
                exit(1);
            }
        }
    }

// Set the nexthop field to our new gateway. All the other properties of the route will
// be the same as they were previously.
    pRow-&gt;dwForwardNextHop = NewGateway;

// Create a new route entry for the default gateway.
    dwStatus = SetIpForwardEntry(pRow);

    if (dwStatus == NO_ERROR)
        printf("Gateway changed successfully\n");
    else if (dwStatus == ERROR_INVALID_PARAMETER)
        printf("Invalid parameter.\n");
    else
        printf("Error: %d\n", dwStatus);

// Free resources.
    if (pIpForwardTable)
        free(pIpForwardTable);
    if (pRow)
        free(pRow);
}


</code>
    </remarks>
    <seealso cref="CreateIpForwardEntry" />
    <seealso cref="DeleteIpForwardEntry" />
    <seealso cref="GetIpForwardTable" />
    <seealso cref="GetIpInterfaceEntry" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPFORWARDROW" />
    <seealso cref="MIB_IPINTERFACE_ROW" />
  </member>
  <member name="Windows.SetIpNetEntry">
    <summary>
      <para>The
<b>SetIpNetEntry</b> function modifies an existing ARP entry in the ARP table on the local computer.</para>
    </summary>
    <param name="pArpEntry">
      <para>A pointer to a
<see cref="MIB_IPNETROW" /> structure. The information in this structure specifies the entry to modify and the new information for the entry. The caller must specify values for all members of this structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>pArpEntry</i> parameter is <b>NULL</b>, or <b>SetIpNetEntry</b> is unable to read from the memory pointed to by <i>pArpEntry</i>, or one of the members of the
<see cref="MIB_IPNETROW" /> structure is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The IPv4 transport is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>On Windows Vista and later , the <b>SetIpNetEntry</b> function can only be called by a user logged on as a member of the Administrators group. If <b>SetIpNetEntry</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned.</para>
      <para>The <b>SetIpNetEntry</b> function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>  On Windows NT 4.0 and Windows 2000 and later, this function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
    </remarks>
    <seealso cref="CreateIpNetEntry" />
    <seealso cref="DeleteIpNetEntry" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPNETROW" />
  </member>
  <member name="Windows.SetIpStatistics">
    <summary>
      <para>The
<b>SetIpStatistics</b> function toggles IP forwarding on or off and sets the default time-to-live (TTL) value for the local computer.</para>
    </summary>
    <param name="pIpStats">
      <para>A pointer to a
<see cref="MIB_IPSTATS" /> structure. The caller should set the <b>dwForwarding</b> and <b>dwDefaultTTL</b> members of this structure to the new values. To keep one of the members at its current value, use MIB_USE_CURRENT_TTL or MIB_USE_CURRENT_FORWARDING.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>pIpStats</i> parameter. This error is also returned if the <b>dwForwarding</b> member in the <see cref="MIB_IPSTATS" /> structure pointed to by the <i>pIpStats</i> parameter contains a value other than <b>MIB_IP_NOT_FORWARDING</b>, <b>MIB_IP_FORWARDING</b>, or <b>MIB_USE_CURRENT_FORWARDING</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>To set only the default TTL, the caller can also use the
<see cref="SetIpTTL" /> function.</para>
      <para>On Windows Vista and later, the <b>SetIpStatistics</b> function can only be called by a user logged on as a member of the Administrators group. If <b>SetIpStatistics</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned.</para>
      <para>The <b>SetIpStatistics</b> function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>   On Windows NT 4.0 and Windows 2000 and later, this function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPSTATS" />
    <seealso cref="SetIpStatisticsEx" />
    <seealso cref="SetIpTTL" />
  </member>
  <member name="Windows.SetIpStatisticsEx">
    <summary>
      <para>The
<b>SetIpStatisticsEx</b> function toggles IP forwarding on or off and sets the default time-to-live (TTL) value for the local computer.</para>
    </summary>
    <param name="Statistics">
      <para>A pointer to a
<see cref="MIB_IPSTATS" /> structure. The caller should set the <b>dwForwarding</b> and <b>dwDefaultTTL</b> members of this structure to the new values. To keep one of the members at its current value, use MIB_USE_CURRENT_TTL or MIB_USE_CURRENT_FORWARDING.</para>
    </param>
    <param name="Family">
      <para>The address family for which forwarding and TTL is to be set.</para>
      <para>Possible values for the address family are listed in the <i>Winsock2.h</i> header file. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.</para>
      <para>On the Windows SDK released for Windows Vista and later, the organization of header files has changed and possible values for this member are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.</para>
      <para>The values currently supported are <b>AF_INET</b>, and <b>AF_INET6</b>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>AF_INET</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  sets forwarding and TTL options for IPv4 entries.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>AF_INET6</b>
                </description>
              </item>
              <item>
                <description>23</description>
              </item>
            </list>
          </description>
          <description>
            <para>The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  sets forwarding and TTL options for IPv6 entries.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>pIpStats</i> parameter or the <i>Family</i> parameter was not set to <b>AF_INET</b>, and <b>AF_INET6</b>. This error is also returned if the <b>dwForwarding</b> member in the <see cref="MIB_IPSTATS" /> structure pointed to by the <i>pIpStats</i> parameter contains a value other than <b>MIB_IP_NOT_FORWARDING</b>, <b>MIB_IP_FORWARDING</b>, or <b>MIB_USE_CURRENT_FORWARDING</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported. This error is returned if no IPv4 stack is on the local computer and AF_INET was specified in the <i>Family</i> parameter or no IPv6 stack is on the local computer and AF_INET6 was specified in the <i>Family</i> member.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>To set only the default TTL, the caller can also use the
<see cref="SetIpTTL" /> function.</para>
      <para>The <b>SetIpStatisticsEx</b> function can only be called by a user logged on as a member of the Administrators group. If <b>SetIpStatisticsEx</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned.</para>
      <para>The <b>SetIpStatisticsEx</b> function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application on lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPSTATS" />
    <seealso cref="SetIpStatistics" />
    <seealso cref="SetIpTTL" />
  </member>
  <member name="Windows.SetIpTTL">
    <summary>
      <para>The
<b>SetIpTTL</b> function sets the default time-to-live (TTL) value for the local computer.</para>
    </summary>
    <param name="nTTL">
      <para>The new TTL value for the local computer.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An invalid parameter was passed to the function. This error is returned if the  <i>nTTL</i> parameter is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The default TTL can also be set using the
<see cref="SetIpStatistics" /> function.</para>
      <para>On Windows Vista and later, the <b>SetIpTTL</b> function can only be called by a user logged on as a member of the Administrators group. If <b>SetIpTTL</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned.</para>
      <para>The <see cref="SetIpStatistics" /> function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>
        <b>Note</b>   On Windows NT 4.0 and Windows 2000 and later, this function executes a privileged operation. For this function to execute successfully, the caller must be logged on as a member of the Administrators group or the NetworkConfigurationOperators group.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_IPSTATS" />
    <seealso cref="SetIpStatistics" />
    <seealso cref="SetIpStatisticsEx" />
  </member>
  <member name="Windows.SetPerTcp6ConnectionEStats">
    <summary>
      <para>The
<b>SetPerTcp6ConnectionEStats</b> function sets a value in the read/write information for an IPv6 TCP connection. This function is used to enable or disable extended statistics for an IPv6 TCP connection.</para>
    </summary>
    <param name="Row">
      <para>A pointer to a <see cref="MIB_TCP6ROW" /> structure for an IPv6 TCP connection.</para>
    </param>
    <param name="EstatsType">
      <para>The type of extended statistics for TCP to set. This parameter determines the data and format of information that is expected in the <i>Rw</i> parameter.</para>
      <para>This parameter can be one of the values from the <see cref="TCP_ESTATS_TYPE" /> enumeration type defined in the <i>Tcpestats.h</i> header file.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>TcpConnectionEstatsData</b>
          </description>
          <description>
            <para>This value specifies extended data transfer information for a TCP connection.</para>
            <para>When this value is specified, the buffer pointed to by the <i>Rw</i> parameter should point to a <see cref="TCP_ESTATS_DATA_RW_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsSndCong</b>
          </description>
          <description>
            <para>This value specifies sender congestion for a TCP connection.</para>
            <para>When this value is specified, the buffer pointed to by the <i>Rw</i> parameter should point to a <see cref="TCP_ESTATS_SND_CONG_RW_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsPath</b>
          </description>
          <description>
            <para>This value specifies extended path measurement information for a TCP connection.</para>
            <para>When this value is specified, the buffer pointed to by the <i>Rw</i> parameter should point to a <see cref="TCP_ESTATS_PATH_RW_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsSendBuff</b>
          </description>
          <description>
            <para>This value specifies extended output-queuing information for a TCP connection.</para>
            <para>When this value is specified, the buffer pointed to by the <i>Rw</i> parameter should point to a <see cref="TCP_ESTATS_SEND_BUFF_RW_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsRec</b>
          </description>
          <description>
            <para>This value specifies extended local-receiver information for a TCP connection.</para>
            <para>When this value is specified, the buffer pointed to by the <i>Rw</i> parameter should point to a <see cref="TCP_ESTATS_REC_RW_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsObsRec</b>
          </description>
          <description>
            <para>This value specifies extended remote-receiver information for a TCP connection.</para>
            <para>When this value is specified, the buffer pointed to by the <i>Rw</i> parameter should point to a <see cref="TCP_ESTATS_OBS_REC_RW_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsBandwidth</b>
          </description>
          <description>
            <para>This value specifies bandwidth estimation statistics for a TCP connection on bandwidth.</para>
            <para>When this value is specified, the buffer pointed to by the <i>Rw</i> parameter should point to a <see cref="TCP_ESTATS_BANDWIDTH_RW_v0" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsFineRtt</b>
          </description>
          <description>
            <para>This value specifies fine-grained round-trip time (RTT) estimation statistics for a TCP connection.</para>
            <para>When this value is specified, the buffer pointed to by the <i>Rw</i> parameter should point to a <see cref="TCP_ESTATS_FINE_RTT_RW_v0" /> structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="Rw">
      <para>A pointer to a buffer that contains the read/write information to set. The buffer should contain a value from the <see cref="TCP_BOOLEAN_OPTIONAL" /> enumeration for each structure member that specifies how each member should be updated.</para>
    </param>
    <param name="RwVersion">
      <para>The version of the read/write information to be set. This parameter should be set to zero for Windows Vista, Windows Server 2008, and Windows 7.</para>
    </param>
    <param name="RwSize">
      <para>The size, in bytes, of the buffer pointed to by the <i>Rw</i> parameter.</para>
    </param>
    <param name="Offset">
      <para>The offset, in bytes, to the member in the structure pointed to by the <i>Rw</i> parameter to be set.  This parameter is currently unused and must be set to zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The parameter is incorrect. This error is returned if the <i>Row</i> parameter is a <b>NULL</b> pointer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_USER_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The supplied user buffer is not valid for the requested operation. This error is returned if the <i>Row</i> parameter is a <b>NULL</b> pointer and the <i>RwSize</i> parameter is nonzero.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>This requested entry was not found. This error is returned if the TCP connection specified in the <i>Row</i> parameter could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported. This error is returned if the <i>RwVersion</i> or the <i>Offset</i> parameter is not set to 0.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>SetPerTcp6ConnectionEStats</b> function is defined on Windows Vista and later.</para>
      <para>The <b>SetPerTcp6ConnectionEStats</b> function is used to enable or disable extended statistics for the IPv6 TCP connection passed in the <i>Row</i> parameter. Extended statistics on a TCP connection are disabled by default.</para>
      <para>The <b>SetPerTcp6ConnectionEStats</b> function is used to set the value of a member in the read/write information for extended statistics for an IPv6 TCP connection. The type and format of the structure to be set is specified by the <i>EstatsType</i> parameter. The <i>Rw</i> parameter contains a pointer to the structure being passed. The member to set in this structure is specified by the <i>Offset</i> parameter. All members in the structure pointed to by <i>Rw</i> parameter must be specified.</para>
      <para>The only version of TCP connection statistics currently supported is version zero. So the <i>RwVersion</i> parameter passed to <b>SetPerTcp6ConnectionEStats</b> should be set to 0.</para>
      <para>The structure pointed to by the <i>Rw</i> parameter passed this function depends on the enumeration value passed in the <i>EstatsType</i> parameter. The following table below indicates the structure type that should be passed in the <i>Rw</i> parameter for each possible <i>EstatsType</i> parameter type.</para>
      <list type="table">
        <listheader>
          <description>
            <i>EstatsType</i>
          </description>
          <description>Structure pointed to by <i>Rw</i></description>
        </listheader>
        <item>
          <description>
            <b>TcpConnectionEstatsData</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_DATA_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsSndCong</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_SND_CONG_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsPath</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_PATH_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsSendBuff</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_SEND_BUFF_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsRec</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_REC_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsObsRec</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_OBS_REC_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsBandwidth</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_BANDWIDTH_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsFineRtt</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_FINE_RTT_RW_v0" />
          </description>
        </item>
      </list>
      <para>The <i>Offset</i> parameter is currently unused. The possible structures pointed to by the <i>Rw</i> parameter all have a single member except for the <see cref="TCP_ESTATS_BANDWIDTH_RW_v0" /> structure.  When the <i>EstatsType</i> parameter is set to <b>TcpConnectionEstatsBandwidth</b>, the <b>TCP_ESTATS_BANDWIDTH_RW_v0</b> structure pointed to by the <i>Rw</i> parameter must have both structure members set to the preferred values in a single call to the  <b>SetPerTcp6ConnectionEStats</b> function.</para>
      <para>If the <i>RwSize</i> parameter is set to 0, the <b>SetPerTcp6ConnectionEStats</b> function returns NO_ERROR and makes no changes to the extended statistics status.</para>
      <para>The <see cref="GetTcp6Table" /> function is used to retrieve the IPv6 TCP connection table on the local computer. This function returns a <see cref="MIB_TCP6TABLE" /> structure that contain an array of <see cref="MIB_TCP6ROW" /> entries. The <i>Row</i> parameter passed to the <b>SetPerTcp6ConnectionEStats</b> function must be an entry for an existing IPv6 TCP connection.</para>
      <para>Once extended statistics are enabled on a TCP connection for IPv6, an application calls the <see cref="GetPerTcp6ConnectionEStats" /> function to retrieve extended statistics on the TCP connection.</para>
      <para>The <see cref="GetPerTcp6ConnectionEStats" /> function is designed to use TCP to diagnose performance
problems in both the network and the application.  If a network based
application is performing poorly, TCP can determine if the bottleneck
is in the sender, the receiver or the network itself.  If the
bottleneck is in the network, TCP can provide specific information
about its nature.</para>
      <para>For information on extended TCP statistics on an IPv4 connection, see the <see cref="GetPerTcpConnectionEStats" /> and <see cref="SetPerTcpConnectionEStats" /> functions.</para>
      <para>The <b>SetPerTcp6ConnectionEStats</b> function can only be called by a user logged on as a member of the Administrators group. If <b>SetPerTcp6ConnectionEStats</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and Windows Server 2008. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
    </remarks>
    <seealso cref="GetPerTcp6ConnectionEStats" />
    <seealso cref="GetPerTcpConnectionEStats" />
    <seealso cref="GetTcp6Table" />
    <seealso cref="MIB_TCP6ROW" />
    <seealso cref="MIB_TCP6TABLE" />
    <seealso cref="SetPerTcpConnectionEStats" />
    <seealso cref="TCP_BOOLEAN_OPTIONAL" />
    <seealso cref="TCP_ESTATS_BANDWIDTH_RW_v0" />
    <seealso cref="TCP_ESTATS_DATA_RW_v0" />
    <seealso cref="TCP_ESTATS_FINE_RTT_RW_v0" />
    <seealso cref="TCP_ESTATS_OBS_REC_RW_v0" />
    <seealso cref="TCP_ESTATS_PATH_RW_v0" />
    <seealso cref="TCP_ESTATS_REC_RW_v0" />
    <seealso cref="TCP_ESTATS_SEND_BUFF_RW_v0" />
    <seealso cref="TCP_ESTATS_SND_CONG_RW_v0" />
    <seealso cref="TCP_ESTATS_TYPE" />
  </member>
  <member name="Windows.SetPerTcpConnectionEStats">
    <summary>
      <para>The <b>SetPerTcpConnectionEStats</b> function sets a value in the read/write information for an IPv4 TCP connection. This function is used to enable or disable extended statistics for an IPv4 TCP connection.</para>
    </summary>
    <param name="Row">
      <para>A pointer to a <see cref="MIB_TCPROW" /> structure for an IPv4 TCP connection.</para>
    </param>
    <param name="EstatsType">
      <para>The type of extended statistics for TCP to set. This parameter determines the data and format of information that is expected in the <i>Rw</i> parameter.</para>
      <para>This parameter can be one of the values from the <see cref="TCP_ESTATS_TYPE" /> enumeration type defined in the <i>Tcpestats.h</i> header file.</para>
    </param>
    <param name="Rw">
      <para>A pointer to a buffer that contains the read/write information to set. The buffer should contain a value from the <see cref="TCP_BOOLEAN_OPTIONAL" /> enumeration for each structure member that specifies how each member should be updated.</para>
    </param>
    <param name="RwVersion">
      <para>The version of the read/write information to be set. This parameter should be set to zero for Windows Vista, Windows Server 2008, and Windows 7.</para>
    </param>
    <param name="RwSize">
      <para>The size, in bytes, of the buffer pointed to by the <i>Rw</i> parameter.</para>
    </param>
    <param name="Offset">
      <para>The offset, in bytes, to the member in the structure pointed to by the <i>Rw</i> parameter to be set. This parameter is currently unused and must be set to zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_USER_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The supplied user buffer is not valid for the requested operation. This error is returned if the <i>Row</i> parameter is a <b>NULL</b> pointer and the <i>RwSize</i> parameter is nonzero.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The parameter is incorrect. This error is returned if the <i>Row</i> parameter is a <b>NULL</b> pointer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>This requested entry was not found. This error is returned if the TCP connection specified in the <i>Row</i> parameter could not be found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The request is not supported. This error is returned if the <i>RwVersion</i> or the <i>Offset</i> parameter is not set to 0.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>SetPerTcpConnectionEStats</b> function is defined on Windows Vista and later.</para>
      <para>The <b>SetPerTcpConnectionEStats</b> function is used to enable or disable extended statistics on an IPv4 TCP connection passed in the <i>Row</i> parameter. Extended statistics on a TCP connection are disabled by default. The <b>SetPerTcpConnectionEStats</b> function is used to set the value of a member in the read/write information for extended statistics for an IPv4 TCP connection. The type and format of the structure to be set is specified by the <i>EstatsType</i> parameter. The <i>Rw</i> parameter contains a pointer to the structure being passed.  All members in the structure pointed to by <i>Rw</i> parameter must be specified.</para>
      <para>The only version of TCP connection statistics currently supported is version zero. So the <i>RwVersion</i> parameter passed to <b>SetPerTcpConnectionEStats</b> should be set to 0.</para>
      <para>The structure pointed to by the <i>Rw</i> parameter passed this function depends on the enumeration value passed in the <i>EstatsType</i> parameter. The following table below indicates the structure type that should be passed in the <i>Rw</i> parameter for each possible <i>EstatsType</i> parameter type.</para>
      <list type="table">
        <listheader>
          <description>
            <i>EstatsType</i>
          </description>
          <description>Structure pointed to by <i>Rw</i></description>
        </listheader>
        <item>
          <description>
            <b>TcpConnectionEstatsData</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_DATA_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsSndCong</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_SND_CONG_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsPath</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_PATH_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsSendBuff</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_SEND_BUFF_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsRec</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_REC_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsObsRec</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_OBS_REC_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsBandwidth</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_BANDWIDTH_RW_v0" />
          </description>
        </item>
        <item>
          <description>
            <b>TcpConnectionEstatsFineRtt</b>
          </description>
          <description>
            <see cref="TCP_ESTATS_FINE_RTT_RW_v0" />
          </description>
        </item>
      </list>
      <para>The <i>Offset</i> parameter is currently unused and must be set to 0. The possible structures pointed to by the <i>Rw</i> parameter all have a single member except for the <see cref="TCP_ESTATS_BANDWIDTH_RW_v0" /> structure.  When the <i>EstatsType</i> parameter is set to <b>TcpConnectionEstatsBandwidth</b>, the <b>TCP_ESTATS_BANDWIDTH_RW_v0</b> structure pointed to by the <i>Rw</i> parameter must have both structure members set  to the preferred values in a single call to the  <b>SetPerTcpConnectionEStats</b> function.</para>
      <para>If the <i>RwSize</i> parameter is set to 0, the <b>SetPerTcpConnectionEStats</b> function  returns NO_ERROR and makes no changes to the extended statistics status.</para>
      <para>The <see cref="GetTcpTable" /> function is used to retrieve the IPv4 TCP connection table on the local computer. This function returns a <see cref="MIB_TCPTABLE" /> structure that contain an array of <see cref="MIB_TCPROW" /> entries. The <i>Row</i> parameter passed to the <b>SetPerTcpConnectionEStats</b> function must be an entry for an existing IPv4 TCP connection.</para>
      <para>Once extended statistics are enabled on a TCP connection for IPv4, applications call the <see cref="GetPerTcpConnectionEStats" /> function to retrieve extended statistics on the TCP connection.</para>
      <para>The <see cref="GetPerTcpConnectionEStats" /> function is designed to use TCP to diagnose performance
problems in both the network and the application.  If a network based
application is performing poorly, TCP can determine if the bottleneck
is in the sender, the receiver or the network itself.  If the
bottleneck is in the network, TCP can provide specific information
about its nature.</para>
      <para>For information on extended TCP statistics on an IPv6 connection, see the <see cref="GetPerTcp6ConnectionEStats" /> and <see cref="SetPerTcp6ConnectionEStats" /> functions.</para>
      <para>The <b>SetPerTcpConnectionEStats</b> function can only be called by a user logged on as a member of the Administrators group. If <b>SetPerTcpConnectionEStats</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned. This function can also fail because of user account control (UAC) on Windows Vista and Windows Server 2008. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
      <para>In Windows versions prior to Windows 10, version 1709 (Fall Creators Update), you can use <b>SetPerTcpConnectionEStats</b> to disable and reenable statistics on a connection, causing any statistics counters to be reset to zero. As of Windows 10, version 1709 (Fall Creators Update), some statistics counters don't reset when statistics are disabled and reenabled. Also, if two applications are monitoring statistics for the same connection, then one application can confuse the other by disabling statistics. For these reasons, we recommend that your application refrains from disabling statistics on connections. To detect changes over time, you should save the counter values read by a previous call to <see cref="GetPerTcpConnectionEStats" />, and subtract them from those read by a subsequent call.</para>
    </remarks>
    <seealso cref="GetPerTcp6ConnectionEStats" />
    <seealso cref="GetPerTcpConnectionEStats" />
    <seealso cref="GetTcpTable" />
    <seealso cref="MIB_TCPROW" />
    <seealso cref="SetPerTcp6ConnectionEStats" />
    <seealso cref="TCP_BOOLEAN_OPTIONAL" />
    <seealso cref="TCP_ESTATS_BANDWIDTH_RW_v0" />
    <seealso cref="TCP_ESTATS_DATA_RW_v0" />
    <seealso cref="TCP_ESTATS_FINE_RTT_RW_v0" />
    <seealso cref="TCP_ESTATS_OBS_REC_RW_v0" />
    <seealso cref="TCP_ESTATS_PATH_RW_v0" />
    <seealso cref="TCP_ESTATS_REC_RW_v0" />
    <seealso cref="TCP_ESTATS_SEND_BUFF_RW_v0" />
    <seealso cref="TCP_ESTATS_SND_CONG_RW_v0" />
    <seealso cref="TCP_ESTATS_TYPE" />
  </member>
  <member name="Windows.SetTcpEntry">
    <summary>
      <para>The
<b>SetTcpEntry</b> function sets the state of a TCP connection.</para>
    </summary>
    <param name="pTcpRow">
      <para>A pointer to a
<see cref="MIB_TCPROW" /> structure. This structure specifies information to identify the TCP connection to modify. It also specifies the new state for the TCP connection. The caller must specify values for all the members in this structure.</para>
    </param>
    <returns>
      <para>The function returns <b>NO_ERROR</b> (zero) if the function is successful.</para>
      <para>If the function fails, the return value is one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ACCESS_DENIED</b>
            </para>
          </description>
          <description>
            <para>Access is denied. This error is returned on Windows Vista and Windows Server 2008 under several conditions that include the following: the  user lacks the required administrative privileges on the local computer or the application is not running in an enhanced shell as the built-in Administrator (RunAs administrator).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>An input parameter is invalid, no action was taken.  This error is returned if the <i>pTcpRow</i> parameter is <b>NULL</b> or the <b>Row</b> member in the <see cref="MIB_TCPROW" /> structure pointed to by the <i>pTcpRow</i> parameter is not set to MIB_TCP_STATE_DELETE_TCB.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_SUPPORTED</b>
            </para>
          </description>
          <description>
            <para>The IPv4 transport is not configured on the local computer.</para>
          </description>
        </item>
        <item>
          <description>
            <para>317</para>
          </description>
          <description>
            <para>The function is unable to set the TCP entry since the application is running non-elevated.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Currently, the only state to which a TCP connection can be set is MIB_TCP_STATE_DELETE_TCB.</para>
      <para>On Windows Vista and later, the <b>SetTcpEntry</b> function can only be called by a user logged on as a member of the Administrators group. If <b>SetTcpEntry</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>ERROR_ACCESS_DENIED</b> is returned.</para>
      <para>The <b>SetTcpEntry</b> function can also fail because of user account control (UAC) on Windows Vista and later. If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to requireAdministrator. If the application lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="MIB_TCPROW" />
  </member>
  <member name="Windows.UnenableRouter">
    <summary>
      <para>The
<b>UnenableRouter</b> function decrements the reference count that tracks the number of requests to enable IPv4 forwarding. When this reference count reaches zero,
<b>UnenableRouter</b> turns off IPv4 forwarding on the local computer.</para>
    </summary>
    <param name="pOverlapped">
      <para>A pointer to an <see cref="OVERLAPPED" /> structure. This structure should be the same as the one used in the call to
the <see cref="EnableRouter" /> function.</para>
    </param>
    <param name="lpdwEnableCount">
      <para>An optional pointer to a <b>DWORD</b> variable. This variable receives the number of references remaining.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
    </returns>
    <remarks>
      <para>The <b>UnenableRouter</b> function is specific to IPv4 forwarding. Each call that a process makes to
<b>UnenableRouter</b> must correspond to a previous call to
<see cref="EnableRouter" /> by the same process. The system returns an error on extraneous calls to
<b>UnenableRouter</b>. As a result, a given process is not able to decrement the reference count that tracks the number of requests for enabling IPv4 forwarding for another process. Also, if IPv4 forwarding was enabled by a given process, it cannot be disabled by a different process.</para>
      <para>It is not possible to accurately determine the reference count that tracks the number of requests for enabling IPv4 forwarding since there might be other outstanding <see cref="EnableRouter" /> requests.
So the value returned for the <i>lpdwEnableCount</i> parameter is always a large count equal to ULONG_MAX/2.</para>
      <para>If the process that calls
<see cref="EnableRouter" /> terminates without calling
<b>UnenableRouter</b>, the system  decrements the reference count that tracks requests to enable  IPv4 forwarding as though the process had called
<b>UnenableRouter</b>.</para>
      <para>After calling the
<b>UnenableRouter</b>, use the
<see cref="CloseHandle" /> call to close the handle to the event object in the
<see cref="OVERLAPPED" /> structure.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="EnableRouter" />
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-function-reference">IP Helper Function Reference</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/IpHlp/ip-helper-start-page">IP Helper Start Page</seealso>
    <seealso cref="OVERLAPPED" />
  </member>
  <member name="Windows.UnregisterInterfaceTimestampConfigChange">
    <summary>
      <para>Cancels notifications about timestamp capability changes by unregistering the callback function you registered in a call to <see cref="RegisterInterfaceTimestampConfigChange" />.</para>
      <para>To avoid deadlock, you shouldn't call <b>UnregisterInterfaceTimestampConfigChange</b> in the context of the thread that's executing a callback that was specified to <b>RegisterInterfaceTimestampConfigChange</b>. This is because <b>UnregisterInterfaceTimestampConfigChange</b> waits for outstanding notification callbacks to complete before it returns. Consequently, <b>UnregisterInterfaceTimestampConfigChange</b> mustn't be called in a way that prevents an outstanding notification callback from completing. No further callbacks will take place after <b>UnregisterInterfaceTimestampConfigChange</b> returns.</para>
      <para>For more info, and code examples, see <a href="https://docs.microsoft.com//windows/win32/iphlp/packet-timestamping">Packet timestamping</a>.</para>
    </summary>
    <param name="NotificationHandle">
      <para>Type: _In_ <b>HIFTIMESTAMPCHANGE</b></para>
      <para>The handle that was returned by <see cref="RegisterInterfaceTimestampConfigChange" />. This identifies the registration to be canceled.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">DWORD</a></b></para>
      <para>A <b>DWORD</b> return code indicating success or failure.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/win32/iphlp/packet-timestamping">Packet timestamping</seealso>
    <seealso cref="RegisterInterfaceTimestampConfigChange" />
  </member>
</doc>