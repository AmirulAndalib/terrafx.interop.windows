<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AssocCreateForClasses">
    <summary>
      <para>Retrieves an object that implements an <see cref="IQueryAssociations" /> interface.</para>
    </summary>
    <param name="rgClasses">
      <para>Type: <b>const <see cref="ASSOCIATIONELEMENT" />*</b></para>
      <para>A pointer to an array of <see cref="ASSOCIATIONELEMENT" /> structures.</para>
    </param>
    <param name="cClasses">
      <para>Type: <b>ULONG</b></para>
      <para>The number of elements in the array pointed to by <i>rgClasses</i>.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>Reference to the desired IID, normally IID_IQueryAssociations.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>void**</b></para>
      <para>When this method returns, contains the interface pointer requested in <i>riid</i>. This is normally <see cref="IQueryAssociations" />.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>For systems earlier than Windows Vista, use the <see cref="AssocCreate" /> function.</para>
    </remarks>
  </member>
  <member name="Windows.DragAcceptFiles">
    <summary>
      <para>Registers whether a window accepts dropped files.</para>
    </summary>
    <param name="hWnd">
      <para>Type: <b>HWND</b></para>
      <para>The identifier of the window that is registering whether it will accept dropped files.</para>
    </param>
    <param name="fAccept">
      <para>Type: <b>BOOL</b></para>
      <para>A value that indicates if the window identified by the <i>hWnd</i> parameter accepts dropped files. This value is <b>TRUE</b> to accept dropped files or <b>FALSE</b> to discontinue accepting dropped files.</para>
    </param>
    <remarks>
      <para>An application that calls <b>DragAcceptFiles</b> with the <i>fAccept</i> parameter set to <b>TRUE</b> has identified itself as able to process the <a href="https://docs.microsoft.com//windows/desktop/shell/wm-dropfiles">WM_DROPFILES</a> message from File Manager.</para>
    </remarks>
  </member>
  <member name="Windows.DragFinish">
    <summary>
      <para>Releases memory that the system allocated for use in transferring file names to the application.</para>
    </summary>
    <param name="hDrop">
      <para>Type: <b>HDROP</b></para>
      <para>Identifier of the structure that describes dropped files. This handle is retrieved from the <i>wParam</i> parameter of the <a href="https://docs.microsoft.com//windows/desktop/shell/wm-dropfiles">WM_DROPFILES</a> message.</para>
    </param>
  </member>
  <member name="Windows.DragQueryFile">
    <summary>
      <para>Retrieves the names of dropped files that result from a successful drag-and-drop operation.</para>
    </summary>
    <param name="hDrop">
      <para>Type: <b>HDROP</b></para>
      <para>Identifier of the structure that contains the file names of the dropped files.</para>
    </param>
    <param name="iFile">
      <para>Type: <b>UINT</b></para>
      <para>Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b> returns a count of the files dropped. If the value of this parameter is between zero and the total number of files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by the <i>lpszFile</i> parameter.</para>
    </param>
    <param name="lpszFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of a dropped file when the function returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b> returns the required size, in characters, of this buffer.</para>
    </param>
    <param name="cch">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, of the <i>lpszFile</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>A nonzero value indicates a successful call.</para>
      <para>When the function copies a file name to the buffer, the return value is a count of the characters copied, not including the terminating null character.</para>
      <para>If the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable itself returns unchanged, and therefore remains 0xFFFFFFFF.</para>
      <para>If the index value is between zero and the total number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required size, in characters, of the buffer, <i>not including</i> the terminating null character.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines DragQueryFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DragQueryPoint" />
  </member>
  <member name="Windows.DragQueryFileA">
    <summary>
      <para>Retrieves the names of dropped files that result from a successful drag-and-drop operation.</para>
    </summary>
    <param name="hDrop">
      <para>Type: <b>HDROP</b></para>
      <para>Identifier of the structure that contains the file names of the dropped files.</para>
    </param>
    <param name="iFile">
      <para>Type: <b>UINT</b></para>
      <para>Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b> returns a count of the files dropped. If the value of this parameter is between zero and the total number of files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by the <i>lpszFile</i> parameter.</para>
    </param>
    <param name="lpszFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of a dropped file when the function returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b> returns the required size, in characters, of this buffer.</para>
    </param>
    <param name="cch">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, of the <i>lpszFile</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>A nonzero value indicates a successful call.</para>
      <para>When the function copies a file name to the buffer, the return value is a count of the characters copied, not including the terminating null character.</para>
      <para>If the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable itself returns unchanged, and therefore remains 0xFFFFFFFF.</para>
      <para>If the index value is between zero and the total number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required size, in characters, of the buffer, <i>not including</i> the terminating null character.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines DragQueryFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DragQueryPoint" />
  </member>
  <member name="Windows.DragQueryFileW">
    <summary>
      <para>Retrieves the names of dropped files that result from a successful drag-and-drop operation.</para>
    </summary>
    <param name="hDrop">
      <para>Type: <b>HDROP</b></para>
      <para>Identifier of the structure that contains the file names of the dropped files.</para>
    </param>
    <param name="iFile">
      <para>Type: <b>UINT</b></para>
      <para>Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b> returns a count of the files dropped. If the value of this parameter is between zero and the total number of files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by the <i>lpszFile</i> parameter.</para>
    </param>
    <param name="lpszFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of a dropped file when the function returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b> returns the required size, in characters, of this buffer.</para>
    </param>
    <param name="cch">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, of the <i>lpszFile</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>A nonzero value indicates a successful call.</para>
      <para>When the function copies a file name to the buffer, the return value is a count of the characters copied, not including the terminating null character.</para>
      <para>If the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable itself returns unchanged, and therefore remains 0xFFFFFFFF.</para>
      <para>If the index value is between zero and the total number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required size, in characters, of the buffer, <i>not including</i> the terminating null character.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines DragQueryFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DragQueryPoint" />
  </member>
  <member name="Windows.DragQueryFile">
    <summary>
      <para>Retrieves the names of dropped files that result from a successful drag-and-drop operation.</para>
    </summary>
    <param name="hDrop">
      <para>Type: <b>HDROP</b></para>
      <para>Identifier of the structure that contains the file names of the dropped files.</para>
    </param>
    <param name="iFile">
      <para>Type: <b>UINT</b></para>
      <para>Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b> returns a count of the files dropped. If the value of this parameter is between zero and the total number of files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by the <i>lpszFile</i> parameter.</para>
    </param>
    <param name="lpszFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of a dropped file when the function returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b> returns the required size, in characters, of this buffer.</para>
    </param>
    <param name="cch">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, of the <i>lpszFile</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>A nonzero value indicates a successful call.</para>
      <para>When the function copies a file name to the buffer, the return value is a count of the characters copied, not including the terminating null character.</para>
      <para>If the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable itself returns unchanged, and therefore remains 0xFFFFFFFF.</para>
      <para>If the index value is between zero and the total number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required size, in characters, of the buffer, <i>not including</i> the terminating null character.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines DragQueryFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DragQueryPoint" />
  </member>
  <member name="Windows.DragQueryFileA">
    <summary>
      <para>Retrieves the names of dropped files that result from a successful drag-and-drop operation.</para>
    </summary>
    <param name="hDrop">
      <para>Type: <b>HDROP</b></para>
      <para>Identifier of the structure that contains the file names of the dropped files.</para>
    </param>
    <param name="iFile">
      <para>Type: <b>UINT</b></para>
      <para>Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b> returns a count of the files dropped. If the value of this parameter is between zero and the total number of files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by the <i>lpszFile</i> parameter.</para>
    </param>
    <param name="lpszFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of a dropped file when the function returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b> returns the required size, in characters, of this buffer.</para>
    </param>
    <param name="cch">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, of the <i>lpszFile</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>A nonzero value indicates a successful call.</para>
      <para>When the function copies a file name to the buffer, the return value is a count of the characters copied, not including the terminating null character.</para>
      <para>If the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable itself returns unchanged, and therefore remains 0xFFFFFFFF.</para>
      <para>If the index value is between zero and the total number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required size, in characters, of the buffer, <i>not including</i> the terminating null character.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines DragQueryFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DragQueryPoint" />
  </member>
  <member name="Windows.DragQueryFileW">
    <summary>
      <para>Retrieves the names of dropped files that result from a successful drag-and-drop operation.</para>
    </summary>
    <param name="hDrop">
      <para>Type: <b>HDROP</b></para>
      <para>Identifier of the structure that contains the file names of the dropped files.</para>
    </param>
    <param name="iFile">
      <para>Type: <b>UINT</b></para>
      <para>Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b> returns a count of the files dropped. If the value of this parameter is between zero and the total number of files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by the <i>lpszFile</i> parameter.</para>
    </param>
    <param name="lpszFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of a dropped file when the function returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b> returns the required size, in characters, of this buffer.</para>
    </param>
    <param name="cch">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, of the <i>lpszFile</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>A nonzero value indicates a successful call.</para>
      <para>When the function copies a file name to the buffer, the return value is a count of the characters copied, not including the terminating null character.</para>
      <para>If the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable itself returns unchanged, and therefore remains 0xFFFFFFFF.</para>
      <para>If the index value is between zero and the total number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required size, in characters, of the buffer, <i>not including</i> the terminating null character.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines DragQueryFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DragQueryPoint" />
  </member>
  <member name="Windows.DragQueryPoint">
    <summary>
      <para>Retrieves the position of the mouse pointer at the time a file was dropped during a drag-and-drop operation.</para>
    </summary>
    <param name="hDrop">
      <para>Type: <b>HDROP</b></para>
      <para>Handle of the drop structure that describes the dropped file.</para>
    </param>
    <param name="ppt">
      <para>Type: <b><a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a>*</b></para>
      <para>Pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure that, when this function returns successfully, receives the coordinates of the mouse pointer at the time the file was dropped.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the drop occurred in the client area of the window; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The window for which coordinates are returned is the window that received the <a href="https://docs.microsoft.com//windows/desktop/shell/wm-dropfiles">WM_DROPFILES</a> message.</para>
    </remarks>
    <seealso cref="DragQueryFile" />
  </member>
  <member name="Windows.DuplicateIcon">
    <summary>
      <para>Creates a duplicate of a specified icon.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
    </param>
    <param name="hIcon">
      <para>Type: <b>HICON</b></para>
      <para>Handle to the icon to be duplicated.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>If successful, the function returns the handle to the new icon that was created; otherwise, <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, the caller is responsible for freeing the icon handle returned by <b>DuplicateIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
    </remarks>
  </member>
  <member name="Windows.ExtractAssociatedIcon">
    <summary>
      <para>Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>A handle to the instance of the calling application.</para>
    </param>
    <param name="pszIconPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file.</para>
      <para>When this function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.</para>
    </param>
    <param name="piIcon">
      <para>Type: <b>LPWORD</b></para>
      <para>Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained.</para>
      <para>When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>If the function succeeds, the return value is an icon handle. If the icon is extracted from an associated executable file, the function stores the full path and file name of the executable file in the string pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by <i>lpiIcon</i>.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, the caller is responsible for freeing the icon handle returned by <b>ExtractAssociatedIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>The <b>ExtractAssociatedIcon</b> function first looks for the indexed icon in the file specified by <i>lpIconPath</i>. If the function cannot obtain the icon handle from that file, and the file has an associated executable file, it looks in that executable file for an icon. Associations with executable files are based on file name extensions and are stored in the per-user part of the registry.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractAssociatedIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.ExtractAssociatedIconA">
    <summary>
      <para>Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>A handle to the instance of the calling application.</para>
    </param>
    <param name="pszIconPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file.</para>
      <para>When this function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.</para>
    </param>
    <param name="piIcon">
      <para>Type: <b>LPWORD</b></para>
      <para>Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained.</para>
      <para>When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>If the function succeeds, the return value is an icon handle. If the icon is extracted from an associated executable file, the function stores the full path and file name of the executable file in the string pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by <i>lpiIcon</i>.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, the caller is responsible for freeing the icon handle returned by <b>ExtractAssociatedIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>The <b>ExtractAssociatedIcon</b> function first looks for the indexed icon in the file specified by <i>lpIconPath</i>. If the function cannot obtain the icon handle from that file, and the file has an associated executable file, it looks in that executable file for an icon. Associations with executable files are based on file name extensions and are stored in the per-user part of the registry.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractAssociatedIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.ExtractAssociatedIconW">
    <summary>
      <para>Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>A handle to the instance of the calling application.</para>
    </param>
    <param name="pszIconPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file.</para>
      <para>When this function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.</para>
    </param>
    <param name="piIcon">
      <para>Type: <b>LPWORD</b></para>
      <para>Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained.</para>
      <para>When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>If the function succeeds, the return value is an icon handle. If the icon is extracted from an associated executable file, the function stores the full path and file name of the executable file in the string pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by <i>lpiIcon</i>.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, the caller is responsible for freeing the icon handle returned by <b>ExtractAssociatedIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>The <b>ExtractAssociatedIcon</b> function first looks for the indexed icon in the file specified by <i>lpIconPath</i>. If the function cannot obtain the icon handle from that file, and the file has an associated executable file, it looks in that executable file for an icon. Associations with executable files are based on file name extensions and are stored in the per-user part of the registry.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractAssociatedIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.ExtractAssociatedIcon">
    <summary>
      <para>Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>A handle to the instance of the calling application.</para>
    </param>
    <param name="pszIconPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file.</para>
      <para>When this function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.</para>
    </param>
    <param name="piIcon">
      <para>Type: <b>LPWORD</b></para>
      <para>Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained.</para>
      <para>When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>If the function succeeds, the return value is an icon handle. If the icon is extracted from an associated executable file, the function stores the full path and file name of the executable file in the string pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by <i>lpiIcon</i>.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, the caller is responsible for freeing the icon handle returned by <b>ExtractAssociatedIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>The <b>ExtractAssociatedIcon</b> function first looks for the indexed icon in the file specified by <i>lpIconPath</i>. If the function cannot obtain the icon handle from that file, and the file has an associated executable file, it looks in that executable file for an icon. Associations with executable files are based on file name extensions and are stored in the per-user part of the registry.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractAssociatedIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.ExtractAssociatedIconA">
    <summary>
      <para>Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>A handle to the instance of the calling application.</para>
    </param>
    <param name="pszIconPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file.</para>
      <para>When this function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.</para>
    </param>
    <param name="piIcon">
      <para>Type: <b>LPWORD</b></para>
      <para>Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained.</para>
      <para>When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>If the function succeeds, the return value is an icon handle. If the icon is extracted from an associated executable file, the function stores the full path and file name of the executable file in the string pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by <i>lpiIcon</i>.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, the caller is responsible for freeing the icon handle returned by <b>ExtractAssociatedIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>The <b>ExtractAssociatedIcon</b> function first looks for the indexed icon in the file specified by <i>lpIconPath</i>. If the function cannot obtain the icon handle from that file, and the file has an associated executable file, it looks in that executable file for an icon. Associations with executable files are based on file name extensions and are stored in the per-user part of the registry.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractAssociatedIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.ExtractAssociatedIconW">
    <summary>
      <para>Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>A handle to the instance of the calling application.</para>
    </param>
    <param name="pszIconPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file.</para>
      <para>When this function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.</para>
    </param>
    <param name="piIcon">
      <para>Type: <b>LPWORD</b></para>
      <para>Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained.</para>
      <para>When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>If the function succeeds, the return value is an icon handle. If the icon is extracted from an associated executable file, the function stores the full path and file name of the executable file in the string pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by <i>lpiIcon</i>.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, the caller is responsible for freeing the icon handle returned by <b>ExtractAssociatedIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>The <b>ExtractAssociatedIcon</b> function first looks for the indexed icon in the file specified by <i>lpIconPath</i>. If the function cannot obtain the icon handle from that file, and the file has an associated executable file, it looks in that executable file for an icon. Associations with executable files are based on file name extensions and are stored in the per-user part of the registry.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractAssociatedIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.ExtractIcon">
    <summary>
      <para>Gets a handle to an icon from the specified executable file, DLL, or icon file.</para>
      <para>To retrieve an array of handles to large or small icons, use the <see cref="ExtractIconEx" /> function.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>Handle to the instance of the application that calls the function.</para>
    </param>
    <param name="pszExeFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>UINT</b></para>
      <para>Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the function returns a handle to the first icon in the specified file.</para>
      <para>If this value is -1, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1.</para>
      <para>If this value is a negative number not equal to –1, the function returns a handle to the icon in the specified file whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use –3 to extract the icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the <see cref="ExtractIconEx" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>The return value is a handle to an icon. If the file specified was not an executable file, DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, you must destroy the icon handle returned by <b>ExtractIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.ExtractIconA">
    <summary>
      <para>Gets a handle to an icon from the specified executable file, DLL, or icon file.</para>
      <para>To retrieve an array of handles to large or small icons, use the <see cref="ExtractIconEx" /> function.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>Handle to the instance of the application that calls the function.</para>
    </param>
    <param name="pszExeFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>UINT</b></para>
      <para>Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the function returns a handle to the first icon in the specified file.</para>
      <para>If this value is -1, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1.</para>
      <para>If this value is a negative number not equal to –1, the function returns a handle to the icon in the specified file whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use –3 to extract the icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the <see cref="ExtractIconEx" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>The return value is a handle to an icon. If the file specified was not an executable file, DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, you must destroy the icon handle returned by <b>ExtractIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.ExtractIconW">
    <summary>
      <para>Gets a handle to an icon from the specified executable file, DLL, or icon file.</para>
      <para>To retrieve an array of handles to large or small icons, use the <see cref="ExtractIconEx" /> function.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>Handle to the instance of the application that calls the function.</para>
    </param>
    <param name="pszExeFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>UINT</b></para>
      <para>Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the function returns a handle to the first icon in the specified file.</para>
      <para>If this value is -1, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1.</para>
      <para>If this value is a negative number not equal to –1, the function returns a handle to the icon in the specified file whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use –3 to extract the icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the <see cref="ExtractIconEx" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>The return value is a handle to an icon. If the file specified was not an executable file, DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, you must destroy the icon handle returned by <b>ExtractIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.ExtractIconEx">
    <summary>
      <para>The <b>ExtractIconEx</b> function creates an array of handles to large or small icons extracted from the specified executable file, DLL, or icon file.</para>
    </summary>
    <param name="lpszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file from which icons will be extracted.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>int</b></para>
      <para>Specifies the zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file.</para>
      <para>If this value is –1 and <i>phiconLarge</i> and <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ico file, the return value is 1.</para>
      <para>If this value is a negative number and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource identifier is 3.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the large icons extracted from the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the small icons extracted from the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.</para>
    </param>
    <param name="nIcons">
      <para>Type: <b>UINT</b></para>
      <para>The number of icons to extract from the file.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the <i>nIconIndex</i> parameter is -1 and both the <i>phiconLarge</i> and <i>phiconSmall</i> parameters are <b>NULL</b>, then the return value is the number of icons contained in the specified file.</para>
      <para>If the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the return value is the number of icons successfully extracted from the file.</para>
      <blockquote>
        <para>[!NOTE]
If the function encounters an error, it returns <b>UINT_MAX</b>. In this case, you can call <see cref="GetLastError" /> to retrieve the error code. For example, this function returns <b>UINT_MAX</b> if the file specified by <i>lpszFile</i> cannot be found while the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>. In this case, <b>GetLastError</b> returns <b>ERROR_FILE_NOT_FOUND</b> (2).</para>
      </blockquote>
    </returns>
    <remarks>
      <para>When they are no longer needed, you must destroy all icons extracted by <b>ExtractIconEx</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>To retrieve the dimensions of the large and small icons, use this function with the SM_CXICON, SM_CYICON, SM_CXSMICON, and SM_CYSMICON flags.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIconEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
  </member>
  <member name="Windows.ExtractIconExA">
    <summary>
      <para>The <b>ExtractIconEx</b> function creates an array of handles to large or small icons extracted from the specified executable file, DLL, or icon file.</para>
    </summary>
    <param name="lpszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file from which icons will be extracted.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>int</b></para>
      <para>Specifies the zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file.</para>
      <para>If this value is –1 and <i>phiconLarge</i> and <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ico file, the return value is 1.</para>
      <para>If this value is a negative number and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource identifier is 3.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the large icons extracted from the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the small icons extracted from the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.</para>
    </param>
    <param name="nIcons">
      <para>Type: <b>UINT</b></para>
      <para>The number of icons to extract from the file.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the <i>nIconIndex</i> parameter is -1 and both the <i>phiconLarge</i> and <i>phiconSmall</i> parameters are <b>NULL</b>, then the return value is the number of icons contained in the specified file.</para>
      <para>If the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the return value is the number of icons successfully extracted from the file.</para>
      <blockquote>
        <para>[!NOTE]
If the function encounters an error, it returns <b>UINT_MAX</b>. In this case, you can call <see cref="GetLastError" /> to retrieve the error code. For example, this function returns <b>UINT_MAX</b> if the file specified by <i>lpszFile</i> cannot be found while the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>. In this case, <b>GetLastError</b> returns <b>ERROR_FILE_NOT_FOUND</b> (2).</para>
      </blockquote>
    </returns>
    <remarks>
      <para>When they are no longer needed, you must destroy all icons extracted by <b>ExtractIconEx</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>To retrieve the dimensions of the large and small icons, use this function with the SM_CXICON, SM_CYICON, SM_CXSMICON, and SM_CYSMICON flags.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIconEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
  </member>
  <member name="Windows.ExtractIconExW">
    <summary>
      <para>The <b>ExtractIconEx</b> function creates an array of handles to large or small icons extracted from the specified executable file, DLL, or icon file.</para>
    </summary>
    <param name="lpszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file from which icons will be extracted.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>int</b></para>
      <para>Specifies the zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file.</para>
      <para>If this value is –1 and <i>phiconLarge</i> and <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ico file, the return value is 1.</para>
      <para>If this value is a negative number and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource identifier is 3.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the large icons extracted from the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the small icons extracted from the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.</para>
    </param>
    <param name="nIcons">
      <para>Type: <b>UINT</b></para>
      <para>The number of icons to extract from the file.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the <i>nIconIndex</i> parameter is -1 and both the <i>phiconLarge</i> and <i>phiconSmall</i> parameters are <b>NULL</b>, then the return value is the number of icons contained in the specified file.</para>
      <para>If the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the return value is the number of icons successfully extracted from the file.</para>
      <blockquote>
        <para>[!NOTE]
If the function encounters an error, it returns <b>UINT_MAX</b>. In this case, you can call <see cref="GetLastError" /> to retrieve the error code. For example, this function returns <b>UINT_MAX</b> if the file specified by <i>lpszFile</i> cannot be found while the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>. In this case, <b>GetLastError</b> returns <b>ERROR_FILE_NOT_FOUND</b> (2).</para>
      </blockquote>
    </returns>
    <remarks>
      <para>When they are no longer needed, you must destroy all icons extracted by <b>ExtractIconEx</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>To retrieve the dimensions of the large and small icons, use this function with the SM_CXICON, SM_CYICON, SM_CXSMICON, and SM_CYSMICON flags.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIconEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
  </member>
  <member name="Windows.ExtractIconEx">
    <summary>
      <para>The <b>ExtractIconEx</b> function creates an array of handles to large or small icons extracted from the specified executable file, DLL, or icon file.</para>
    </summary>
    <param name="lpszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file from which icons will be extracted.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>int</b></para>
      <para>Specifies the zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file.</para>
      <para>If this value is –1 and <i>phiconLarge</i> and <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ico file, the return value is 1.</para>
      <para>If this value is a negative number and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource identifier is 3.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the large icons extracted from the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the small icons extracted from the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.</para>
    </param>
    <param name="nIcons">
      <para>Type: <b>UINT</b></para>
      <para>The number of icons to extract from the file.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the <i>nIconIndex</i> parameter is -1 and both the <i>phiconLarge</i> and <i>phiconSmall</i> parameters are <b>NULL</b>, then the return value is the number of icons contained in the specified file.</para>
      <para>If the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the return value is the number of icons successfully extracted from the file.</para>
      <blockquote>
        <para>[!NOTE]
If the function encounters an error, it returns <b>UINT_MAX</b>. In this case, you can call <see cref="GetLastError" /> to retrieve the error code. For example, this function returns <b>UINT_MAX</b> if the file specified by <i>lpszFile</i> cannot be found while the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>. In this case, <b>GetLastError</b> returns <b>ERROR_FILE_NOT_FOUND</b> (2).</para>
      </blockquote>
    </returns>
    <remarks>
      <para>When they are no longer needed, you must destroy all icons extracted by <b>ExtractIconEx</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>To retrieve the dimensions of the large and small icons, use this function with the SM_CXICON, SM_CYICON, SM_CXSMICON, and SM_CYSMICON flags.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIconEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
  </member>
  <member name="Windows.ExtractIconExA">
    <summary>
      <para>The <b>ExtractIconEx</b> function creates an array of handles to large or small icons extracted from the specified executable file, DLL, or icon file.</para>
    </summary>
    <param name="lpszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file from which icons will be extracted.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>int</b></para>
      <para>Specifies the zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file.</para>
      <para>If this value is –1 and <i>phiconLarge</i> and <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ico file, the return value is 1.</para>
      <para>If this value is a negative number and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource identifier is 3.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the large icons extracted from the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the small icons extracted from the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.</para>
    </param>
    <param name="nIcons">
      <para>Type: <b>UINT</b></para>
      <para>The number of icons to extract from the file.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the <i>nIconIndex</i> parameter is -1 and both the <i>phiconLarge</i> and <i>phiconSmall</i> parameters are <b>NULL</b>, then the return value is the number of icons contained in the specified file.</para>
      <para>If the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the return value is the number of icons successfully extracted from the file.</para>
      <blockquote>
        <para>[!NOTE]
If the function encounters an error, it returns <b>UINT_MAX</b>. In this case, you can call <see cref="GetLastError" /> to retrieve the error code. For example, this function returns <b>UINT_MAX</b> if the file specified by <i>lpszFile</i> cannot be found while the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>. In this case, <b>GetLastError</b> returns <b>ERROR_FILE_NOT_FOUND</b> (2).</para>
      </blockquote>
    </returns>
    <remarks>
      <para>When they are no longer needed, you must destroy all icons extracted by <b>ExtractIconEx</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>To retrieve the dimensions of the large and small icons, use this function with the SM_CXICON, SM_CYICON, SM_CXSMICON, and SM_CYSMICON flags.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIconEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
  </member>
  <member name="Windows.ExtractIconExW">
    <summary>
      <para>The <b>ExtractIconEx</b> function creates an array of handles to large or small icons extracted from the specified executable file, DLL, or icon file.</para>
    </summary>
    <param name="lpszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file from which icons will be extracted.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>int</b></para>
      <para>Specifies the zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file.</para>
      <para>If this value is –1 and <i>phiconLarge</i> and <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ico file, the return value is 1.</para>
      <para>If this value is a negative number and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource identifier is 3.</para>
    </param>
    <param name="phiconLarge">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the large icons extracted from the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.</para>
    </param>
    <param name="phiconSmall">
      <para>Type: <b>HICON*</b></para>
      <para>Pointer to an array of icon handles that receives handles to the small icons extracted from the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.</para>
    </param>
    <param name="nIcons">
      <para>Type: <b>UINT</b></para>
      <para>The number of icons to extract from the file.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the <i>nIconIndex</i> parameter is -1 and both the <i>phiconLarge</i> and <i>phiconSmall</i> parameters are <b>NULL</b>, then the return value is the number of icons contained in the specified file.</para>
      <para>If the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the return value is the number of icons successfully extracted from the file.</para>
      <blockquote>
        <para>[!NOTE]
If the function encounters an error, it returns <b>UINT_MAX</b>. In this case, you can call <see cref="GetLastError" /> to retrieve the error code. For example, this function returns <b>UINT_MAX</b> if the file specified by <i>lpszFile</i> cannot be found while the <i>nIconIndex</i> parameter is any value other than -1 and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>. In this case, <b>GetLastError</b> returns <b>ERROR_FILE_NOT_FOUND</b> (2).</para>
      </blockquote>
    </returns>
    <remarks>
      <para>When they are no longer needed, you must destroy all icons extracted by <b>ExtractIconEx</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <para>To retrieve the dimensions of the large and small icons, use this function with the SM_CXICON, SM_CYICON, SM_CXSMICON, and SM_CYSMICON flags.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIconEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIcon" />
  </member>
  <member name="Windows.ExtractIcon">
    <summary>
      <para>Gets a handle to an icon from the specified executable file, DLL, or icon file.</para>
      <para>To retrieve an array of handles to large or small icons, use the <see cref="ExtractIconEx" /> function.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>Handle to the instance of the application that calls the function.</para>
    </param>
    <param name="pszExeFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>UINT</b></para>
      <para>Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the function returns a handle to the first icon in the specified file.</para>
      <para>If this value is -1, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1.</para>
      <para>If this value is a negative number not equal to –1, the function returns a handle to the icon in the specified file whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use –3 to extract the icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the <see cref="ExtractIconEx" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>The return value is a handle to an icon. If the file specified was not an executable file, DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, you must destroy the icon handle returned by <b>ExtractIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.ExtractIconA">
    <summary>
      <para>Gets a handle to an icon from the specified executable file, DLL, or icon file.</para>
      <para>To retrieve an array of handles to large or small icons, use the <see cref="ExtractIconEx" /> function.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>Handle to the instance of the application that calls the function.</para>
    </param>
    <param name="pszExeFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>UINT</b></para>
      <para>Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the function returns a handle to the first icon in the specified file.</para>
      <para>If this value is -1, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1.</para>
      <para>If this value is a negative number not equal to –1, the function returns a handle to the icon in the specified file whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use –3 to extract the icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the <see cref="ExtractIconEx" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>The return value is a handle to an icon. If the file specified was not an executable file, DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, you must destroy the icon handle returned by <b>ExtractIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.ExtractIconW">
    <summary>
      <para>Gets a handle to an icon from the specified executable file, DLL, or icon file.</para>
      <para>To retrieve an array of handles to large or small icons, use the <see cref="ExtractIconEx" /> function.</para>
    </summary>
    <param name="hInst">
      <para>Type: <b>HINSTANCE</b></para>
      <para>Handle to the instance of the application that calls the function.</para>
    </param>
    <param name="pszExeFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file.</para>
    </param>
    <param name="nIconIndex">
      <para>Type: <b>UINT</b></para>
      <para>Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the function returns a handle to the first icon in the specified file.</para>
      <para>If this value is -1, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1.</para>
      <para>If this value is a negative number not equal to –1, the function returns a handle to the icon in the specified file whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use –3 to extract the icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the <see cref="ExtractIconEx" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HICON</b></para>
      <para>The return value is a handle to an icon. If the file specified was not an executable file, DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When it is no longer needed, you must destroy the icon handle returned by <b>ExtractIcon</b> by calling the <see cref="DestroyIcon" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtractAssociatedIcon" />
    <seealso cref="ExtractAssociatedIconEx" />
    <seealso cref="ExtractIconEx" />
  </member>
  <member name="Windows.FindExecutable">
    <summary>
      <para>Retrieves the name of and handle to the executable (.exe) file associated with a specific document file.</para>
    </summary>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies a file name. This file should be a document.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies the default directory. This value can be <b>NULL</b>.</para>
    </param>
    <param name="lpResult">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of the associated executable file. This file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH. Responsibility for validating the value is left to the programmer.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>Returns a value greater than 32 if successful, or a value less than or equal to 32 representing an error.</para>
      <para>The following table lists possible error values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_FNF</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_PNF</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified path is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_ACCESSDENIED</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file cannot be accessed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_OOM</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_NOASSOC</b>
                </description>
              </item>
              <item>
                <description>31</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no association for the specified file type with an executable file.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Use <b>FindExecutable</b> for documents. If you want to retrieve the path of an executable file, use the following:</para>
      <code>AssocQueryString(ASSOCF_OPEN_BYEXENAME,
                 ASSOCSTR_EXECUTABLE,
                 pszExecutableName,
                 NULL,
                 pszPath,
                 pcchOut);
</code>
      <para>Here, <i>pszExecutableName</i> is a pointer to a <b>null</b>-terminated string that specifies the name of the executable file, <i>pszPath</i> is a pointer to the <b>null</b>-terminated string buffer that receives the path to the executable file, and <i>pcchOut</i> is a pointer to a <b>DWORD</b> that specifies the number of characters in the <i>pszPath</i> buffer. When the function returns, <i>pcchOut</i> is set to the number of characters actually placed in the buffer. See <see cref="AssocQueryString" /> for more information.</para>
      <para>When <b>FindExecutable</b> returns, the <i>lpResult</i> parameter may contain the path to the Dynamic Data Exchange (DDE) server started if a server does not respond to a request to initiate a DDE conversation with the DDE client application.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines FindExecutable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.FindExecutableA">
    <summary>
      <para>Retrieves the name of and handle to the executable (.exe) file associated with a specific document file.</para>
    </summary>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies a file name. This file should be a document.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies the default directory. This value can be <b>NULL</b>.</para>
    </param>
    <param name="lpResult">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of the associated executable file. This file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH. Responsibility for validating the value is left to the programmer.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>Returns a value greater than 32 if successful, or a value less than or equal to 32 representing an error.</para>
      <para>The following table lists possible error values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_FNF</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_PNF</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified path is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_ACCESSDENIED</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file cannot be accessed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_OOM</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_NOASSOC</b>
                </description>
              </item>
              <item>
                <description>31</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no association for the specified file type with an executable file.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Use <b>FindExecutable</b> for documents. If you want to retrieve the path of an executable file, use the following:</para>
      <code>AssocQueryString(ASSOCF_OPEN_BYEXENAME,
                 ASSOCSTR_EXECUTABLE,
                 pszExecutableName,
                 NULL,
                 pszPath,
                 pcchOut);
</code>
      <para>Here, <i>pszExecutableName</i> is a pointer to a <b>null</b>-terminated string that specifies the name of the executable file, <i>pszPath</i> is a pointer to the <b>null</b>-terminated string buffer that receives the path to the executable file, and <i>pcchOut</i> is a pointer to a <b>DWORD</b> that specifies the number of characters in the <i>pszPath</i> buffer. When the function returns, <i>pcchOut</i> is set to the number of characters actually placed in the buffer. See <see cref="AssocQueryString" /> for more information.</para>
      <para>When <b>FindExecutable</b> returns, the <i>lpResult</i> parameter may contain the path to the Dynamic Data Exchange (DDE) server started if a server does not respond to a request to initiate a DDE conversation with the DDE client application.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines FindExecutable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.FindExecutableW">
    <summary>
      <para>Retrieves the name of and handle to the executable (.exe) file associated with a specific document file.</para>
    </summary>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies a file name. This file should be a document.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies the default directory. This value can be <b>NULL</b>.</para>
    </param>
    <param name="lpResult">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of the associated executable file. This file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH. Responsibility for validating the value is left to the programmer.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>Returns a value greater than 32 if successful, or a value less than or equal to 32 representing an error.</para>
      <para>The following table lists possible error values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_FNF</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_PNF</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified path is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_ACCESSDENIED</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file cannot be accessed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_OOM</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_NOASSOC</b>
                </description>
              </item>
              <item>
                <description>31</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no association for the specified file type with an executable file.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Use <b>FindExecutable</b> for documents. If you want to retrieve the path of an executable file, use the following:</para>
      <code>AssocQueryString(ASSOCF_OPEN_BYEXENAME,
                 ASSOCSTR_EXECUTABLE,
                 pszExecutableName,
                 NULL,
                 pszPath,
                 pcchOut);
</code>
      <para>Here, <i>pszExecutableName</i> is a pointer to a <b>null</b>-terminated string that specifies the name of the executable file, <i>pszPath</i> is a pointer to the <b>null</b>-terminated string buffer that receives the path to the executable file, and <i>pcchOut</i> is a pointer to a <b>DWORD</b> that specifies the number of characters in the <i>pszPath</i> buffer. When the function returns, <i>pcchOut</i> is set to the number of characters actually placed in the buffer. See <see cref="AssocQueryString" /> for more information.</para>
      <para>When <b>FindExecutable</b> returns, the <i>lpResult</i> parameter may contain the path to the Dynamic Data Exchange (DDE) server started if a server does not respond to a request to initiate a DDE conversation with the DDE client application.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines FindExecutable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.FindExecutable">
    <summary>
      <para>Retrieves the name of and handle to the executable (.exe) file associated with a specific document file.</para>
    </summary>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies a file name. This file should be a document.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies the default directory. This value can be <b>NULL</b>.</para>
    </param>
    <param name="lpResult">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of the associated executable file. This file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH. Responsibility for validating the value is left to the programmer.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>Returns a value greater than 32 if successful, or a value less than or equal to 32 representing an error.</para>
      <para>The following table lists possible error values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_FNF</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_PNF</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified path is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_ACCESSDENIED</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file cannot be accessed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_OOM</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_NOASSOC</b>
                </description>
              </item>
              <item>
                <description>31</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no association for the specified file type with an executable file.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Use <b>FindExecutable</b> for documents. If you want to retrieve the path of an executable file, use the following:</para>
      <code>AssocQueryString(ASSOCF_OPEN_BYEXENAME,
                 ASSOCSTR_EXECUTABLE,
                 pszExecutableName,
                 NULL,
                 pszPath,
                 pcchOut);
</code>
      <para>Here, <i>pszExecutableName</i> is a pointer to a <b>null</b>-terminated string that specifies the name of the executable file, <i>pszPath</i> is a pointer to the <b>null</b>-terminated string buffer that receives the path to the executable file, and <i>pcchOut</i> is a pointer to a <b>DWORD</b> that specifies the number of characters in the <i>pszPath</i> buffer. When the function returns, <i>pcchOut</i> is set to the number of characters actually placed in the buffer. See <see cref="AssocQueryString" /> for more information.</para>
      <para>When <b>FindExecutable</b> returns, the <i>lpResult</i> parameter may contain the path to the Dynamic Data Exchange (DDE) server started if a server does not respond to a request to initiate a DDE conversation with the DDE client application.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines FindExecutable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.FindExecutableA">
    <summary>
      <para>Retrieves the name of and handle to the executable (.exe) file associated with a specific document file.</para>
    </summary>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies a file name. This file should be a document.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies the default directory. This value can be <b>NULL</b>.</para>
    </param>
    <param name="lpResult">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of the associated executable file. This file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH. Responsibility for validating the value is left to the programmer.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>Returns a value greater than 32 if successful, or a value less than or equal to 32 representing an error.</para>
      <para>The following table lists possible error values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_FNF</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_PNF</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified path is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_ACCESSDENIED</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file cannot be accessed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_OOM</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_NOASSOC</b>
                </description>
              </item>
              <item>
                <description>31</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no association for the specified file type with an executable file.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Use <b>FindExecutable</b> for documents. If you want to retrieve the path of an executable file, use the following:</para>
      <code>AssocQueryString(ASSOCF_OPEN_BYEXENAME,
                 ASSOCSTR_EXECUTABLE,
                 pszExecutableName,
                 NULL,
                 pszPath,
                 pcchOut);
</code>
      <para>Here, <i>pszExecutableName</i> is a pointer to a <b>null</b>-terminated string that specifies the name of the executable file, <i>pszPath</i> is a pointer to the <b>null</b>-terminated string buffer that receives the path to the executable file, and <i>pcchOut</i> is a pointer to a <b>DWORD</b> that specifies the number of characters in the <i>pszPath</i> buffer. When the function returns, <i>pcchOut</i> is set to the number of characters actually placed in the buffer. See <see cref="AssocQueryString" /> for more information.</para>
      <para>When <b>FindExecutable</b> returns, the <i>lpResult</i> parameter may contain the path to the Dynamic Data Exchange (DDE) server started if a server does not respond to a request to initiate a DDE conversation with the DDE client application.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines FindExecutable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.FindExecutableW">
    <summary>
      <para>Retrieves the name of and handle to the executable (.exe) file associated with a specific document file.</para>
    </summary>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies a file name. This file should be a document.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string that specifies the default directory. This value can be <b>NULL</b>.</para>
    </param>
    <param name="lpResult">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a buffer that receives the file name of the associated executable file. This file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH. Responsibility for validating the value is left to the programmer.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>Returns a value greater than 32 if successful, or a value less than or equal to 32 representing an error.</para>
      <para>The following table lists possible error values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_FNF</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_PNF</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified path is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_ACCESSDENIED</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file cannot be accessed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_OOM</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SE_ERR_NOASSOC</b>
                </description>
              </item>
              <item>
                <description>31</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no association for the specified file type with an executable file.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Use <b>FindExecutable</b> for documents. If you want to retrieve the path of an executable file, use the following:</para>
      <code>AssocQueryString(ASSOCF_OPEN_BYEXENAME,
                 ASSOCSTR_EXECUTABLE,
                 pszExecutableName,
                 NULL,
                 pszPath,
                 pcchOut);
</code>
      <para>Here, <i>pszExecutableName</i> is a pointer to a <b>null</b>-terminated string that specifies the name of the executable file, <i>pszPath</i> is a pointer to the <b>null</b>-terminated string buffer that receives the path to the executable file, and <i>pcchOut</i> is a pointer to a <b>DWORD</b> that specifies the number of characters in the <i>pszPath</i> buffer. When the function returns, <i>pcchOut</i> is set to the number of characters actually placed in the buffer. See <see cref="AssocQueryString" /> for more information.</para>
      <para>When <b>FindExecutable</b> returns, the <i>lpResult</i> parameter may contain the path to the Dynamic Data Exchange (DDE) server started if a server does not respond to a request to initiate a DDE conversation with the DDE client application.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines FindExecutable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.InitNetworkAddressControl">
    <summary>
      <para>Initializes the network address control window class.</para>
    </summary>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the initialization succeeded; or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The network address control looks like an edit control and offers the additional functionality of network address verification. The control uses a balloon tip to display error messages.</para>
      <para>This function initializes class WC_NETADDRESS. If this function returns <b>TRUE</b>, the control can be created.</para>
    </remarks>
  </member>
  <member name="Windows.NetAddr_DisplayErrorTip">
    <summary>
      <para>Displays an error message in the balloon tip associated with the network address control.</para>
    </summary>
    <param name="hwnd">
      <para>A handle to the network address control.</para>
    </param>
    <remarks>
      <para>Call this macro to display an error message when an address typed into the control does not validate against the allowed network address types set with macro <see cref="NetAddr_SetAllowType" />. Use the macro <see cref="NetAddr_GetAddress" /> to validate the address.</para>
    </remarks>
    <seealso cref="NetAddr_GetAllowType" />
  </member>
  <member name="Windows.NetAddr_GetAddress">
    <summary>
      <para>Indicates whether a network address conforms to a specified type and format.</para>
    </summary>
    <param name="hwnd">
      <para>A handle to the network address control that contains the address to validate.</para>
    </param>
    <param name="pv">
      <para>A pointer to an <see cref="NC_ADDRESS" /> structure to receive network address information in parsed form, if the address format and type in the control specified by <i>hwnd</i> are validated. The calling application is responsible for allocating the memory for this structure.</para>
    </param>
    <remarks>
      <para>Use the <b>NetAddr_GetAddress</b> macro to validate a network address in a network address control against a preset network address type mask. To instantiate, use the class <b>msctls_netaddress</b> defined in Shellapi.h. Call <see cref="InitNetworkAddressControl" /> at run time before calling this macro. This initializes the common controls library that contains the network address control.</para>
      <para>This macro gets the network address string from a network address control, parses the string, and checks whether the string matches a network address type mask. If the string matches the mask, the function returns S_OK and returns the string in parsed form to the calling application (including the port number, prefix length, and other address information), using the <see cref="NC_ADDRESS" /> structure pointed to by <i>pv</i>. This macro returns E_INVALIDARG if the calling application fails to allocate the structure pointed to by <i>pv</i>.</para>
      <para>Representations of Internet Protocol (IP) address versions 4 and 6 (v4/v6) for services and networks, as well as named Internet addresses and services using Domain Name System (DNS) format are parsed. If the network address string represents a named host name (DNS) or service, the value returned in the <b>PrefixLength</b> member of <see cref="NC_ADDRESS" /> is zero.</para>
      <para>Set the network address type mask using the <see cref="NetAddr_SetAllowType" /> macro before you call the <b>NetAddr_GetAddress</b> macro.</para>
    </remarks>
    <seealso cref="NetAddr_GetAllowType" />
  </member>
  <member name="Windows.NetAddr_GetAllowType">
    <summary>
      <para>Retrieves the network address types that a specified network address control accepts.</para>
    </summary>
    <param name="hwnd">
      <para>A handle to the network address control.</para>
    </param>
    <remarks>
      <para>The returned mask is the criterion used to validate a network address in the macro <see cref="NetAddr_GetAddress" />.</para>
      <para>Use this macro for a network address control only. To instantiate, use the class <b>msctls_netaddress</b> defined in Shellapi.h. Call <see cref="InitNetworkAddressControl" /> at run time before calling this macro. This initializes the common controls library that contains the network address control.</para>
    </remarks>
    <seealso cref="NetAddr_SetAllowType" />
  </member>
  <member name="Windows.NetAddr_SetAllowType">
    <summary>
      <para>Sets the network address types that a specified network address control accepts.</para>
    </summary>
    <param name="hwnd">
      <para>A handle to the network address control.</para>
    </param>
    <param name="addrMask">
      <para>Specifies the network address types as one or more of the <a href="https://docs.microsoft.com//windows/desktop/shell/net-string">NET_STRING</a> constants.</para>
    </param>
    <remarks>
      <para>The mask set is the criterion used to validate a network address in the macro <see cref="NetAddr_GetAddress" />.</para>
      <para>Use this macro for a network address control only. To instantiate, use the class <b>msctls_netaddress</b> defined in Shellapi.h. Call <see cref="InitNetworkAddressControl" /> at run time before calling this macro. This initializes the common controls library that contains the network address control.</para>
    </remarks>
    <seealso cref="NetAddr_GetAllowType" />
  </member>
  <member name="Windows.SHAppBarMessage">
    <summary>
      <para>Sends an appbar message to the system.</para>
    </summary>
    <param name="dwMessage">
      <para>Type: <b>DWORD</b></para>
      <para>Appbar message value to send. This parameter can be one of the following values.</para>
      <h4>ABM_NEW (0x00000000)</h4>
      <para>Registers a new appbar and specifies the message identifier that the system should use to send notification messages to the appbar.</para>
      <h4>ABM_REMOVE (0x00000001)</h4>
      <para>Unregisters an appbar, removing the bar from the system's internal list.</para>
      <h4>ABM_QUERYPOS (0x00000002)</h4>
      <para>Requests a size and screen position for an appbar.</para>
      <h4>ABM_SETPOS (0x00000003)</h4>
      <para>Sets the size and screen position of an appbar.</para>
      <h4>ABM_GETSTATE (0x00000004)</h4>
      <para>Retrieves the autohide and always-on-top states of the Windows taskbar.</para>
      <h4>ABM_GETTASKBARPOS (0x00000005)</h4>
      <para>Retrieves the bounding rectangle of the Windows taskbar. Note that this applies only to the system taskbar. Other objects, particularly toolbars supplied with third-party software, also can be present. As a result, some of the screen area not covered by the Windows taskbar might not be visible to the user. To retrieve the area of the screen not covered by both the taskbar and other app bars—the working area available to your application—, use the <see cref="GetMonitorInfo" /> function.</para>
      <h4>ABM_ACTIVATE (0x00000006)</h4>
      <para>Notifies the system to activate or deactivate an appbar. The <b>lParam</b> member of the <see cref="APPBARDATA" /> pointed to by <i>pData</i> is set to <b>TRUE</b> to activate or <b>FALSE</b> to deactivate.</para>
      <h4>ABM_GETAUTOHIDEBAR (0x00000007)</h4>
      <para>Retrieves the handle to the autohide appbar associated with a particular edge of the screen.</para>
      <h4>ABM_SETAUTOHIDEBAR (0x00000008)</h4>
      <para>Registers or unregisters an autohide appbar for an edge of the screen.</para>
      <h4>ABM_WINDOWPOSCHANGED (0x00000009)</h4>
      <para>Notifies the system when an appbar's position has changed.</para>
      <h4>ABM_SETSTATE (0x0000000A)</h4>
      <para>
        <b>Windows XP and later:</b> Sets the state of the appbar's autohide and always-on-top attributes.</para>
      <h4>ABM_GETAUTOHIDEBAREX (0x0000000B)</h4>
      <para>
        <b>Windows XP and later:</b> Retrieves the handle to the autohide appbar associated with a particular edge of a particular monitor.</para>
      <h4>ABM_SETAUTOHIDEBAREX (0x0000000C)</h4>
      <para>
        <b>Windows XP and later:</b> Registers or unregisters an autohide appbar for an edge of a particular monitor.</para>
    </param>
    <param name="pData">
      <para>Type: <b>PAPPBARDATA</b></para>
      <para>A pointer to an <see cref="APPBARDATA" /> structure. The content of the structure on entry and on exit depends on the value set in the <i>dwMessage</i> parameter. See the individual message pages for specifics.</para>
    </param>
    <returns>
      <para>Type: <b>UINT_PTR</b></para>
      <para>This function returns a message-dependent value. For more information, see the Windows SDK documentation for the specific appbar message sent. Links to those documents are given in the See Also section.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-activate">ABM_ACTIVATE</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-getautohidebar">ABM_GETAUTOHIDEBAR</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-getautohidebarex">ABM_GETAUTOHIDEBAREX</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-getstate">ABM_GETSTATE</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-gettaskbarpos">ABM_GETTASKBARPOS</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-new">ABM_NEW</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-querypos">ABM_QUERYPOS</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-remove">ABM_REMOVE</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-setautohidebar">ABM_SETAUTOHIDEBAR</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-setautohidebarex">ABM_SETAUTOHIDEBAREX</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-setpos">ABM_SETPOS</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-setstate">ABM_SETSTATE</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/abm-windowposchanged">ABM_WINDOWPOSCHANGED</seealso>
  </member>
  <member name="Windows.ShellAbout">
    <summary>
      <para>Displays a <b>ShellAbout</b> dialog box.</para>
    </summary>
    <param name="hWnd">
      <para>Type: <b>HWND</b></para>
      <para>A window handle to a parent window. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="szApp">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the title bar of the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text contains a separator (#) that divides it into two parts, the function displays the first part in the title bar and the second part on the first line after the text "Microsoft".</para>
      <para>
        <b>Windows 2000, Windows XP, Windows Server 2003</b>: If the string pointed to by this parameter contains a separator (#), then the string must be writable.</para>
      <para>
        <b>Windows Vista, Windows Server 2008</b>: This string cannot exceed 200 characters in length.</para>
    </param>
    <param name="szOtherStuff">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the dialog box after the version and copyright information. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="hIcon">
      <para>Type: <b>HICON</b></para>
      <para>The handle of an icon that the function displays in the dialog box. This parameter can be <b>NULL</b>, in which case the function displays the Windows icon.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Note that the <b>ShellAbout</b> function dialog box uses text and a default icon that are specific to Windows.</para>
      <para>To see an example of a <b>ShellAbout</b> dialog box, choose <b>About Windows</b> from the <b>Help</b> menu drop-down list in Windows Explorer.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellAbout as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ShellAboutA">
    <summary>
      <para>Displays a <b>ShellAbout</b> dialog box.</para>
    </summary>
    <param name="hWnd">
      <para>Type: <b>HWND</b></para>
      <para>A window handle to a parent window. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="szApp">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the title bar of the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text contains a separator (#) that divides it into two parts, the function displays the first part in the title bar and the second part on the first line after the text "Microsoft".</para>
      <para>
        <b>Windows 2000, Windows XP, Windows Server 2003</b>: If the string pointed to by this parameter contains a separator (#), then the string must be writable.</para>
      <para>
        <b>Windows Vista, Windows Server 2008</b>: This string cannot exceed 200 characters in length.</para>
    </param>
    <param name="szOtherStuff">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the dialog box after the version and copyright information. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="hIcon">
      <para>Type: <b>HICON</b></para>
      <para>The handle of an icon that the function displays in the dialog box. This parameter can be <b>NULL</b>, in which case the function displays the Windows icon.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Note that the <b>ShellAbout</b> function dialog box uses text and a default icon that are specific to Windows.</para>
      <para>To see an example of a <b>ShellAbout</b> dialog box, choose <b>About Windows</b> from the <b>Help</b> menu drop-down list in Windows Explorer.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellAbout as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ShellAboutW">
    <summary>
      <para>Displays a <b>ShellAbout</b> dialog box.</para>
    </summary>
    <param name="hWnd">
      <para>Type: <b>HWND</b></para>
      <para>A window handle to a parent window. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="szApp">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the title bar of the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text contains a separator (#) that divides it into two parts, the function displays the first part in the title bar and the second part on the first line after the text "Microsoft".</para>
      <para>
        <b>Windows 2000, Windows XP, Windows Server 2003</b>: If the string pointed to by this parameter contains a separator (#), then the string must be writable.</para>
      <para>
        <b>Windows Vista, Windows Server 2008</b>: This string cannot exceed 200 characters in length.</para>
    </param>
    <param name="szOtherStuff">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the dialog box after the version and copyright information. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="hIcon">
      <para>Type: <b>HICON</b></para>
      <para>The handle of an icon that the function displays in the dialog box. This parameter can be <b>NULL</b>, in which case the function displays the Windows icon.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Note that the <b>ShellAbout</b> function dialog box uses text and a default icon that are specific to Windows.</para>
      <para>To see an example of a <b>ShellAbout</b> dialog box, choose <b>About Windows</b> from the <b>Help</b> menu drop-down list in Windows Explorer.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellAbout as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ShellAbout">
    <summary>
      <para>Displays a <b>ShellAbout</b> dialog box.</para>
    </summary>
    <param name="hWnd">
      <para>Type: <b>HWND</b></para>
      <para>A window handle to a parent window. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="szApp">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the title bar of the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text contains a separator (#) that divides it into two parts, the function displays the first part in the title bar and the second part on the first line after the text "Microsoft".</para>
      <para>
        <b>Windows 2000, Windows XP, Windows Server 2003</b>: If the string pointed to by this parameter contains a separator (#), then the string must be writable.</para>
      <para>
        <b>Windows Vista, Windows Server 2008</b>: This string cannot exceed 200 characters in length.</para>
    </param>
    <param name="szOtherStuff">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the dialog box after the version and copyright information. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="hIcon">
      <para>Type: <b>HICON</b></para>
      <para>The handle of an icon that the function displays in the dialog box. This parameter can be <b>NULL</b>, in which case the function displays the Windows icon.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Note that the <b>ShellAbout</b> function dialog box uses text and a default icon that are specific to Windows.</para>
      <para>To see an example of a <b>ShellAbout</b> dialog box, choose <b>About Windows</b> from the <b>Help</b> menu drop-down list in Windows Explorer.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellAbout as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ShellAboutA">
    <summary>
      <para>Displays a <b>ShellAbout</b> dialog box.</para>
    </summary>
    <param name="hWnd">
      <para>Type: <b>HWND</b></para>
      <para>A window handle to a parent window. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="szApp">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the title bar of the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text contains a separator (#) that divides it into two parts, the function displays the first part in the title bar and the second part on the first line after the text "Microsoft".</para>
      <para>
        <b>Windows 2000, Windows XP, Windows Server 2003</b>: If the string pointed to by this parameter contains a separator (#), then the string must be writable.</para>
      <para>
        <b>Windows Vista, Windows Server 2008</b>: This string cannot exceed 200 characters in length.</para>
    </param>
    <param name="szOtherStuff">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the dialog box after the version and copyright information. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="hIcon">
      <para>Type: <b>HICON</b></para>
      <para>The handle of an icon that the function displays in the dialog box. This parameter can be <b>NULL</b>, in which case the function displays the Windows icon.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Note that the <b>ShellAbout</b> function dialog box uses text and a default icon that are specific to Windows.</para>
      <para>To see an example of a <b>ShellAbout</b> dialog box, choose <b>About Windows</b> from the <b>Help</b> menu drop-down list in Windows Explorer.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellAbout as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ShellAboutW">
    <summary>
      <para>Displays a <b>ShellAbout</b> dialog box.</para>
    </summary>
    <param name="hWnd">
      <para>Type: <b>HWND</b></para>
      <para>A window handle to a parent window. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="szApp">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the title bar of the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text contains a separator (#) that divides it into two parts, the function displays the first part in the title bar and the second part on the first line after the text "Microsoft".</para>
      <para>
        <b>Windows 2000, Windows XP, Windows Server 2003</b>: If the string pointed to by this parameter contains a separator (#), then the string must be writable.</para>
      <para>
        <b>Windows Vista, Windows Server 2008</b>: This string cannot exceed 200 characters in length.</para>
    </param>
    <param name="szOtherStuff">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains text to be displayed in the dialog box after the version and copyright information. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="hIcon">
      <para>Type: <b>HICON</b></para>
      <para>The handle of an icon that the function displays in the dialog box. This parameter can be <b>NULL</b>, in which case the function displays the Windows icon.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>
        <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Note that the <b>ShellAbout</b> function dialog box uses text and a default icon that are specific to Windows.</para>
      <para>To see an example of a <b>ShellAbout</b> dialog box, choose <b>About Windows</b> from the <b>Help</b> menu drop-down list in Windows Explorer.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellAbout as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ShellExecute">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window used for displaying a UI or error messages. This value can be <b>NULL</b> if the operation is not associated with a window.</para>
    </param>
    <param name="lpOperation">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>, that specifies the action to be performed. The set of available verbs depends on the particular file or folder. Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are commonly used:</para>
      <h4>edit</h4>
      <para>Launches an editor and opens the document for editing. If <i>lpFile</i> is not a document file, the function will fail.</para>
      <h4>explore</h4>
      <para>Explores a folder specified by <i>lpFile</i>.</para>
      <h4>find</h4>
      <para>Initiates a search beginning in the directory specified by <i>lpDirectory</i>.</para>
      <h4>open</h4>
      <para>Opens the item specified by the <i>lpFile</i> parameter. The item can be a file or folder.</para>
      <h4>print</h4>
      <para>Prints the file specified by <i>lpFile</i>. If <i>lpFile</i> is not a document file, the function fails.</para>
      <h4>runas</h4>
      <para>Launches an application as Administrator. User Account Control (UAC) will prompt the user for consent to run the application elevated or enter the credentials of an administrator account used to run the application.</para>
      <h4>NULL</h4>
      <para>The default verb is used, if available. If not, the "open" verb is used. If neither verb is available, the system uses the first verb listed in the registry.</para>
    </param>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the file or object on which to execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.</para>
    </param>
    <param name="lpParameters">
      <para>Type: <b>LPCTSTR</b></para>
      <para>If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file, <i>lpParameters</i> should be <b>NULL</b>.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the default (working) directory for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.</para>
    </param>
    <param name="nShowCmd">
      <para>Type: <b>INT</b></para>
      <para>The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i> specifies a document file, the flag is simply passed to the associated application. It is up to the application to decide how to handle it. It can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <see cref="ShowWindow" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>If the function succeeds, it returns a value greater than 32. If the function fails, it returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an <b>INT_PTR</b> and compared to either 32 or the following error codes below.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>The operating system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_FILE_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_BAD_FORMAT</b>
            </para>
          </description>
          <description>
            <para>The .exe file is invalid (non-Win32 .exe or error in .exe image).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>The operating system denied access to the specified file.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ASSOCINCOMPLETE</b>
            </para>
          </description>
          <description>
            <para>The file name association is incomplete or invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEBUSY</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because other DDE transactions were being processed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEFAIL</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction failed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDETIMEOUT</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because the request timed out.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DLLNOTFOUND</b>
            </para>
          </description>
          <description>
            <para>The specified DLL was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_FNF</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_NOASSOC</b>
            </para>
          </description>
          <description>
            <para>There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_OOM</b>
            </para>
          </description>
          <description>
            <para>There was not enough memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_PNF</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_SHARE</b>
            </para>
          </description>
          <description>
            <para>A sharing violation occurred.</para>
          </description>
        </item>
      </list>
      <para>Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecute</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecute</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are certainly instances where <b>ShellExecute</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to <i>always</i> initialize COM before using this function.</para>
      <para>This method allows you to execute any commands in a folder's shortcut menu or stored in the registry.</para>
      <para>To open a folder, use either of the following calls:</para>
      <code>ShellExecute(handle, NULL, &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>or</para>
      <code>ShellExecute(handle, "open", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To explore a folder, use the following call:</para>
      <code>ShellExecute(handle, "explore", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To launch the Shell's Find utility for a directory, use the following call.</para>
      <code>ShellExecute(handle, "find", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, 0);
</code>
      <para>If <i>lpOperation</i> is <b>NULL</b>, the function opens the file specified by <i>lpFile</i>. If <i>lpOperation</i> is "open" or "explore", the function  attempts to open or explore the folder.</para>
      <para>To obtain information about the application that is launched as a result of calling <b>ShellExecute</b>, use <see cref="ShellExecuteEx" />.</para>
      <para>
        <b>Note</b>  The <b>Launch folder windows in a separate process</b> setting in Folder Options affects <b>ShellExecute</b>. If that option is disabled (the default setting), <b>ShellExecute</b> uses an open Explorer window rather than launch a new one. If no Explorer window is open, <b>ShellExecute</b> launches a new one.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecute as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecuteEx" />
  </member>
  <member name="Windows.ShellExecuteA">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window used for displaying a UI or error messages. This value can be <b>NULL</b> if the operation is not associated with a window.</para>
    </param>
    <param name="lpOperation">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>, that specifies the action to be performed. The set of available verbs depends on the particular file or folder. Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are commonly used:</para>
      <h4>edit</h4>
      <para>Launches an editor and opens the document for editing. If <i>lpFile</i> is not a document file, the function will fail.</para>
      <h4>explore</h4>
      <para>Explores a folder specified by <i>lpFile</i>.</para>
      <h4>find</h4>
      <para>Initiates a search beginning in the directory specified by <i>lpDirectory</i>.</para>
      <h4>open</h4>
      <para>Opens the item specified by the <i>lpFile</i> parameter. The item can be a file or folder.</para>
      <h4>print</h4>
      <para>Prints the file specified by <i>lpFile</i>. If <i>lpFile</i> is not a document file, the function fails.</para>
      <h4>runas</h4>
      <para>Launches an application as Administrator. User Account Control (UAC) will prompt the user for consent to run the application elevated or enter the credentials of an administrator account used to run the application.</para>
      <h4>NULL</h4>
      <para>The default verb is used, if available. If not, the "open" verb is used. If neither verb is available, the system uses the first verb listed in the registry.</para>
    </param>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the file or object on which to execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.</para>
    </param>
    <param name="lpParameters">
      <para>Type: <b>LPCTSTR</b></para>
      <para>If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file, <i>lpParameters</i> should be <b>NULL</b>.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the default (working) directory for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.</para>
    </param>
    <param name="nShowCmd">
      <para>Type: <b>INT</b></para>
      <para>The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i> specifies a document file, the flag is simply passed to the associated application. It is up to the application to decide how to handle it. It can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <see cref="ShowWindow" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>If the function succeeds, it returns a value greater than 32. If the function fails, it returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an <b>INT_PTR</b> and compared to either 32 or the following error codes below.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>The operating system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_FILE_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_BAD_FORMAT</b>
            </para>
          </description>
          <description>
            <para>The .exe file is invalid (non-Win32 .exe or error in .exe image).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>The operating system denied access to the specified file.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ASSOCINCOMPLETE</b>
            </para>
          </description>
          <description>
            <para>The file name association is incomplete or invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEBUSY</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because other DDE transactions were being processed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEFAIL</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction failed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDETIMEOUT</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because the request timed out.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DLLNOTFOUND</b>
            </para>
          </description>
          <description>
            <para>The specified DLL was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_FNF</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_NOASSOC</b>
            </para>
          </description>
          <description>
            <para>There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_OOM</b>
            </para>
          </description>
          <description>
            <para>There was not enough memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_PNF</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_SHARE</b>
            </para>
          </description>
          <description>
            <para>A sharing violation occurred.</para>
          </description>
        </item>
      </list>
      <para>Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecute</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecute</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are certainly instances where <b>ShellExecute</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to <i>always</i> initialize COM before using this function.</para>
      <para>This method allows you to execute any commands in a folder's shortcut menu or stored in the registry.</para>
      <para>To open a folder, use either of the following calls:</para>
      <code>ShellExecute(handle, NULL, &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>or</para>
      <code>ShellExecute(handle, "open", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To explore a folder, use the following call:</para>
      <code>ShellExecute(handle, "explore", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To launch the Shell's Find utility for a directory, use the following call.</para>
      <code>ShellExecute(handle, "find", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, 0);
</code>
      <para>If <i>lpOperation</i> is <b>NULL</b>, the function opens the file specified by <i>lpFile</i>. If <i>lpOperation</i> is "open" or "explore", the function  attempts to open or explore the folder.</para>
      <para>To obtain information about the application that is launched as a result of calling <b>ShellExecute</b>, use <see cref="ShellExecuteEx" />.</para>
      <para>
        <b>Note</b>  The <b>Launch folder windows in a separate process</b> setting in Folder Options affects <b>ShellExecute</b>. If that option is disabled (the default setting), <b>ShellExecute</b> uses an open Explorer window rather than launch a new one. If no Explorer window is open, <b>ShellExecute</b> launches a new one.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecute as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecuteEx" />
  </member>
  <member name="Windows.ShellExecuteW">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window used for displaying a UI or error messages. This value can be <b>NULL</b> if the operation is not associated with a window.</para>
    </param>
    <param name="lpOperation">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>, that specifies the action to be performed. The set of available verbs depends on the particular file or folder. Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are commonly used:</para>
      <h4>edit</h4>
      <para>Launches an editor and opens the document for editing. If <i>lpFile</i> is not a document file, the function will fail.</para>
      <h4>explore</h4>
      <para>Explores a folder specified by <i>lpFile</i>.</para>
      <h4>find</h4>
      <para>Initiates a search beginning in the directory specified by <i>lpDirectory</i>.</para>
      <h4>open</h4>
      <para>Opens the item specified by the <i>lpFile</i> parameter. The item can be a file or folder.</para>
      <h4>print</h4>
      <para>Prints the file specified by <i>lpFile</i>. If <i>lpFile</i> is not a document file, the function fails.</para>
      <h4>runas</h4>
      <para>Launches an application as Administrator. User Account Control (UAC) will prompt the user for consent to run the application elevated or enter the credentials of an administrator account used to run the application.</para>
      <h4>NULL</h4>
      <para>The default verb is used, if available. If not, the "open" verb is used. If neither verb is available, the system uses the first verb listed in the registry.</para>
    </param>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the file or object on which to execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.</para>
    </param>
    <param name="lpParameters">
      <para>Type: <b>LPCTSTR</b></para>
      <para>If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file, <i>lpParameters</i> should be <b>NULL</b>.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the default (working) directory for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.</para>
    </param>
    <param name="nShowCmd">
      <para>Type: <b>INT</b></para>
      <para>The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i> specifies a document file, the flag is simply passed to the associated application. It is up to the application to decide how to handle it. It can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <see cref="ShowWindow" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>If the function succeeds, it returns a value greater than 32. If the function fails, it returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an <b>INT_PTR</b> and compared to either 32 or the following error codes below.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>The operating system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_FILE_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_BAD_FORMAT</b>
            </para>
          </description>
          <description>
            <para>The .exe file is invalid (non-Win32 .exe or error in .exe image).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>The operating system denied access to the specified file.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ASSOCINCOMPLETE</b>
            </para>
          </description>
          <description>
            <para>The file name association is incomplete or invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEBUSY</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because other DDE transactions were being processed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEFAIL</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction failed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDETIMEOUT</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because the request timed out.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DLLNOTFOUND</b>
            </para>
          </description>
          <description>
            <para>The specified DLL was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_FNF</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_NOASSOC</b>
            </para>
          </description>
          <description>
            <para>There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_OOM</b>
            </para>
          </description>
          <description>
            <para>There was not enough memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_PNF</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_SHARE</b>
            </para>
          </description>
          <description>
            <para>A sharing violation occurred.</para>
          </description>
        </item>
      </list>
      <para>Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecute</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecute</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are certainly instances where <b>ShellExecute</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to <i>always</i> initialize COM before using this function.</para>
      <para>This method allows you to execute any commands in a folder's shortcut menu or stored in the registry.</para>
      <para>To open a folder, use either of the following calls:</para>
      <code>ShellExecute(handle, NULL, &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>or</para>
      <code>ShellExecute(handle, "open", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To explore a folder, use the following call:</para>
      <code>ShellExecute(handle, "explore", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To launch the Shell's Find utility for a directory, use the following call.</para>
      <code>ShellExecute(handle, "find", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, 0);
</code>
      <para>If <i>lpOperation</i> is <b>NULL</b>, the function opens the file specified by <i>lpFile</i>. If <i>lpOperation</i> is "open" or "explore", the function  attempts to open or explore the folder.</para>
      <para>To obtain information about the application that is launched as a result of calling <b>ShellExecute</b>, use <see cref="ShellExecuteEx" />.</para>
      <para>
        <b>Note</b>  The <b>Launch folder windows in a separate process</b> setting in Folder Options affects <b>ShellExecute</b>. If that option is disabled (the default setting), <b>ShellExecute</b> uses an open Explorer window rather than launch a new one. If no Explorer window is open, <b>ShellExecute</b> launches a new one.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecute as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecuteEx" />
  </member>
  <member name="Windows.ShellExecuteEx">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="pExecInfo">
      <para>Type: <b>SHELLEXECUTEINFO*</b></para>
      <para>A pointer to a <see cref="SHELLEXECUTEINFO" /> structure that contains and receives information about the application being executed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecuteEx</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecuteEx</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are instances where <b>ShellExecuteEx</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to always initialize COM before using this function.</para>
      <para>When DLLs are loaded into your process, you acquire a lock known as a <a href="https://docs.microsoft.com//windows/win32/win7appqual/preventing-hangs-in-windows-applications">loader lock</a>. The <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function always executes under the loader lock. It is important that you do not call <b>ShellExecuteEx</b> while you hold a loader lock. Because <b>ShellExecuteEx</b> is extensible, you could load code that does not function properly in the presence of a loader lock, risking a deadlock and therefore an unresponsive thread.</para>
      <para>With multiple monitors, if you specify an <b>HWND</b> and set the <b>lpVerb</b> member of the <see cref="SHELLEXECUTEINFO" /> structure pointed to by <i>lpExecInfo</i> to "Properties", any windows created by <b>ShellExecuteEx</b> might not appear in the correct position.</para>
      <para>If the function succeeds, it sets the <b>hInstApp</b> member of the <see cref="SHELLEXECUTEINFO" /> structure to a value greater than 32. If the function fails, <b>hInstApp</b> is set to the <see cref="SE_ERR_XXX" /> error value that best indicates the cause of the failure. Although <b>hInstApp</b> is declared as an HINSTANCE for compatibility with 16-bit Windows applications, it is not a true HINSTANCE. It can be cast only to an <b>int</b> and can be compared only to either the value 32 or the SE_ERR_XXX error codes.</para>
      <para>The SE_ERR_XXX error values are provided for compatibility with <see cref="ShellExecute" />. To retrieve more accurate error information, use <see cref="GetLastError" />. It may return one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>ERROR_FILE_NOT_FOUND </description>
          <description>The specified file was not found.</description>
        </item>
        <item>
          <description>ERROR_PATH_NOT_FOUND </description>
          <description>The specified path was not found.</description>
        </item>
        <item>
          <description>ERROR_DDE_FAIL </description>
          <description>The Dynamic Data Exchange (DDE) transaction failed.</description>
        </item>
        <item>
          <description>ERROR_NO_ASSOCIATION </description>
          <description>There is no application associated with the specified file name extension.</description>
        </item>
        <item>
          <description>ERROR_ACCESS_DENIED </description>
          <description>Access to the specified file is denied.</description>
        </item>
        <item>
          <description>ERROR_DLL_NOT_FOUND </description>
          <description>One of the library files necessary to run the application can't be found.</description>
        </item>
        <item>
          <description>ERROR_CANCELLED </description>
          <description>The function prompted the user for additional information, but the user canceled the request.</description>
        </item>
        <item>
          <description>ERROR_NOT_ENOUGH_MEMORY </description>
          <description>There is not enough memory to perform the specified action.</description>
        </item>
        <item>
          <description>ERROR_SHARING_VIOLATION </description>
          <description>A sharing violation occurred.</description>
        </item>
      </list>
      <para>
        <b>Opening items from a URL</b> You can register your application to activate when passed URLs. You can also specify which protocols your application supports. See <a href="https://docs.microsoft.com//windows/desktop/shell/app-registration">Application Registration</a> for more info.</para>
      <para>
        <b>Site chain support</b> As of Windows 8, you can provide a site chain pointer to the <b>ShellExecuteEx</b> function to support item activation with services from that site. See <a href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</a> for more information.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecuteEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.ShellExecuteExA">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="pExecInfo">
      <para>Type: <b>SHELLEXECUTEINFO*</b></para>
      <para>A pointer to a <see cref="SHELLEXECUTEINFO" /> structure that contains and receives information about the application being executed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecuteEx</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecuteEx</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are instances where <b>ShellExecuteEx</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to always initialize COM before using this function.</para>
      <para>When DLLs are loaded into your process, you acquire a lock known as a <a href="https://docs.microsoft.com//windows/win32/win7appqual/preventing-hangs-in-windows-applications">loader lock</a>. The <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function always executes under the loader lock. It is important that you do not call <b>ShellExecuteEx</b> while you hold a loader lock. Because <b>ShellExecuteEx</b> is extensible, you could load code that does not function properly in the presence of a loader lock, risking a deadlock and therefore an unresponsive thread.</para>
      <para>With multiple monitors, if you specify an <b>HWND</b> and set the <b>lpVerb</b> member of the <see cref="SHELLEXECUTEINFO" /> structure pointed to by <i>lpExecInfo</i> to "Properties", any windows created by <b>ShellExecuteEx</b> might not appear in the correct position.</para>
      <para>If the function succeeds, it sets the <b>hInstApp</b> member of the <see cref="SHELLEXECUTEINFO" /> structure to a value greater than 32. If the function fails, <b>hInstApp</b> is set to the <see cref="SE_ERR_XXX" /> error value that best indicates the cause of the failure. Although <b>hInstApp</b> is declared as an HINSTANCE for compatibility with 16-bit Windows applications, it is not a true HINSTANCE. It can be cast only to an <b>int</b> and can be compared only to either the value 32 or the SE_ERR_XXX error codes.</para>
      <para>The SE_ERR_XXX error values are provided for compatibility with <see cref="ShellExecute" />. To retrieve more accurate error information, use <see cref="GetLastError" />. It may return one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>ERROR_FILE_NOT_FOUND </description>
          <description>The specified file was not found.</description>
        </item>
        <item>
          <description>ERROR_PATH_NOT_FOUND </description>
          <description>The specified path was not found.</description>
        </item>
        <item>
          <description>ERROR_DDE_FAIL </description>
          <description>The Dynamic Data Exchange (DDE) transaction failed.</description>
        </item>
        <item>
          <description>ERROR_NO_ASSOCIATION </description>
          <description>There is no application associated with the specified file name extension.</description>
        </item>
        <item>
          <description>ERROR_ACCESS_DENIED </description>
          <description>Access to the specified file is denied.</description>
        </item>
        <item>
          <description>ERROR_DLL_NOT_FOUND </description>
          <description>One of the library files necessary to run the application can't be found.</description>
        </item>
        <item>
          <description>ERROR_CANCELLED </description>
          <description>The function prompted the user for additional information, but the user canceled the request.</description>
        </item>
        <item>
          <description>ERROR_NOT_ENOUGH_MEMORY </description>
          <description>There is not enough memory to perform the specified action.</description>
        </item>
        <item>
          <description>ERROR_SHARING_VIOLATION </description>
          <description>A sharing violation occurred.</description>
        </item>
      </list>
      <para>
        <b>Opening items from a URL</b> You can register your application to activate when passed URLs. You can also specify which protocols your application supports. See <a href="https://docs.microsoft.com//windows/desktop/shell/app-registration">Application Registration</a> for more info.</para>
      <para>
        <b>Site chain support</b> As of Windows 8, you can provide a site chain pointer to the <b>ShellExecuteEx</b> function to support item activation with services from that site. See <a href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</a> for more information.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecuteEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.ShellExecuteExW">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="pExecInfo">
      <para>Type: <b>SHELLEXECUTEINFO*</b></para>
      <para>A pointer to a <see cref="SHELLEXECUTEINFO" /> structure that contains and receives information about the application being executed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecuteEx</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecuteEx</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are instances where <b>ShellExecuteEx</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to always initialize COM before using this function.</para>
      <para>When DLLs are loaded into your process, you acquire a lock known as a <a href="https://docs.microsoft.com//windows/win32/win7appqual/preventing-hangs-in-windows-applications">loader lock</a>. The <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function always executes under the loader lock. It is important that you do not call <b>ShellExecuteEx</b> while you hold a loader lock. Because <b>ShellExecuteEx</b> is extensible, you could load code that does not function properly in the presence of a loader lock, risking a deadlock and therefore an unresponsive thread.</para>
      <para>With multiple monitors, if you specify an <b>HWND</b> and set the <b>lpVerb</b> member of the <see cref="SHELLEXECUTEINFO" /> structure pointed to by <i>lpExecInfo</i> to "Properties", any windows created by <b>ShellExecuteEx</b> might not appear in the correct position.</para>
      <para>If the function succeeds, it sets the <b>hInstApp</b> member of the <see cref="SHELLEXECUTEINFO" /> structure to a value greater than 32. If the function fails, <b>hInstApp</b> is set to the <see cref="SE_ERR_XXX" /> error value that best indicates the cause of the failure. Although <b>hInstApp</b> is declared as an HINSTANCE for compatibility with 16-bit Windows applications, it is not a true HINSTANCE. It can be cast only to an <b>int</b> and can be compared only to either the value 32 or the SE_ERR_XXX error codes.</para>
      <para>The SE_ERR_XXX error values are provided for compatibility with <see cref="ShellExecute" />. To retrieve more accurate error information, use <see cref="GetLastError" />. It may return one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>ERROR_FILE_NOT_FOUND </description>
          <description>The specified file was not found.</description>
        </item>
        <item>
          <description>ERROR_PATH_NOT_FOUND </description>
          <description>The specified path was not found.</description>
        </item>
        <item>
          <description>ERROR_DDE_FAIL </description>
          <description>The Dynamic Data Exchange (DDE) transaction failed.</description>
        </item>
        <item>
          <description>ERROR_NO_ASSOCIATION </description>
          <description>There is no application associated with the specified file name extension.</description>
        </item>
        <item>
          <description>ERROR_ACCESS_DENIED </description>
          <description>Access to the specified file is denied.</description>
        </item>
        <item>
          <description>ERROR_DLL_NOT_FOUND </description>
          <description>One of the library files necessary to run the application can't be found.</description>
        </item>
        <item>
          <description>ERROR_CANCELLED </description>
          <description>The function prompted the user for additional information, but the user canceled the request.</description>
        </item>
        <item>
          <description>ERROR_NOT_ENOUGH_MEMORY </description>
          <description>There is not enough memory to perform the specified action.</description>
        </item>
        <item>
          <description>ERROR_SHARING_VIOLATION </description>
          <description>A sharing violation occurred.</description>
        </item>
      </list>
      <para>
        <b>Opening items from a URL</b> You can register your application to activate when passed URLs. You can also specify which protocols your application supports. See <a href="https://docs.microsoft.com//windows/desktop/shell/app-registration">Application Registration</a> for more info.</para>
      <para>
        <b>Site chain support</b> As of Windows 8, you can provide a site chain pointer to the <b>ShellExecuteEx</b> function to support item activation with services from that site. See <a href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</a> for more information.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecuteEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.ShellExecuteEx">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="pExecInfo">
      <para>Type: <b>SHELLEXECUTEINFO*</b></para>
      <para>A pointer to a <see cref="SHELLEXECUTEINFO" /> structure that contains and receives information about the application being executed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecuteEx</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecuteEx</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are instances where <b>ShellExecuteEx</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to always initialize COM before using this function.</para>
      <para>When DLLs are loaded into your process, you acquire a lock known as a <a href="https://docs.microsoft.com//windows/win32/win7appqual/preventing-hangs-in-windows-applications">loader lock</a>. The <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function always executes under the loader lock. It is important that you do not call <b>ShellExecuteEx</b> while you hold a loader lock. Because <b>ShellExecuteEx</b> is extensible, you could load code that does not function properly in the presence of a loader lock, risking a deadlock and therefore an unresponsive thread.</para>
      <para>With multiple monitors, if you specify an <b>HWND</b> and set the <b>lpVerb</b> member of the <see cref="SHELLEXECUTEINFO" /> structure pointed to by <i>lpExecInfo</i> to "Properties", any windows created by <b>ShellExecuteEx</b> might not appear in the correct position.</para>
      <para>If the function succeeds, it sets the <b>hInstApp</b> member of the <see cref="SHELLEXECUTEINFO" /> structure to a value greater than 32. If the function fails, <b>hInstApp</b> is set to the <see cref="SE_ERR_XXX" /> error value that best indicates the cause of the failure. Although <b>hInstApp</b> is declared as an HINSTANCE for compatibility with 16-bit Windows applications, it is not a true HINSTANCE. It can be cast only to an <b>int</b> and can be compared only to either the value 32 or the SE_ERR_XXX error codes.</para>
      <para>The SE_ERR_XXX error values are provided for compatibility with <see cref="ShellExecute" />. To retrieve more accurate error information, use <see cref="GetLastError" />. It may return one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>ERROR_FILE_NOT_FOUND </description>
          <description>The specified file was not found.</description>
        </item>
        <item>
          <description>ERROR_PATH_NOT_FOUND </description>
          <description>The specified path was not found.</description>
        </item>
        <item>
          <description>ERROR_DDE_FAIL </description>
          <description>The Dynamic Data Exchange (DDE) transaction failed.</description>
        </item>
        <item>
          <description>ERROR_NO_ASSOCIATION </description>
          <description>There is no application associated with the specified file name extension.</description>
        </item>
        <item>
          <description>ERROR_ACCESS_DENIED </description>
          <description>Access to the specified file is denied.</description>
        </item>
        <item>
          <description>ERROR_DLL_NOT_FOUND </description>
          <description>One of the library files necessary to run the application can't be found.</description>
        </item>
        <item>
          <description>ERROR_CANCELLED </description>
          <description>The function prompted the user for additional information, but the user canceled the request.</description>
        </item>
        <item>
          <description>ERROR_NOT_ENOUGH_MEMORY </description>
          <description>There is not enough memory to perform the specified action.</description>
        </item>
        <item>
          <description>ERROR_SHARING_VIOLATION </description>
          <description>A sharing violation occurred.</description>
        </item>
      </list>
      <para>
        <b>Opening items from a URL</b> You can register your application to activate when passed URLs. You can also specify which protocols your application supports. See <a href="https://docs.microsoft.com//windows/desktop/shell/app-registration">Application Registration</a> for more info.</para>
      <para>
        <b>Site chain support</b> As of Windows 8, you can provide a site chain pointer to the <b>ShellExecuteEx</b> function to support item activation with services from that site. See <a href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</a> for more information.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecuteEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.ShellExecuteExA">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="pExecInfo">
      <para>Type: <b>SHELLEXECUTEINFO*</b></para>
      <para>A pointer to a <see cref="SHELLEXECUTEINFO" /> structure that contains and receives information about the application being executed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecuteEx</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecuteEx</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are instances where <b>ShellExecuteEx</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to always initialize COM before using this function.</para>
      <para>When DLLs are loaded into your process, you acquire a lock known as a <a href="https://docs.microsoft.com//windows/win32/win7appqual/preventing-hangs-in-windows-applications">loader lock</a>. The <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function always executes under the loader lock. It is important that you do not call <b>ShellExecuteEx</b> while you hold a loader lock. Because <b>ShellExecuteEx</b> is extensible, you could load code that does not function properly in the presence of a loader lock, risking a deadlock and therefore an unresponsive thread.</para>
      <para>With multiple monitors, if you specify an <b>HWND</b> and set the <b>lpVerb</b> member of the <see cref="SHELLEXECUTEINFO" /> structure pointed to by <i>lpExecInfo</i> to "Properties", any windows created by <b>ShellExecuteEx</b> might not appear in the correct position.</para>
      <para>If the function succeeds, it sets the <b>hInstApp</b> member of the <see cref="SHELLEXECUTEINFO" /> structure to a value greater than 32. If the function fails, <b>hInstApp</b> is set to the <see cref="SE_ERR_XXX" /> error value that best indicates the cause of the failure. Although <b>hInstApp</b> is declared as an HINSTANCE for compatibility with 16-bit Windows applications, it is not a true HINSTANCE. It can be cast only to an <b>int</b> and can be compared only to either the value 32 or the SE_ERR_XXX error codes.</para>
      <para>The SE_ERR_XXX error values are provided for compatibility with <see cref="ShellExecute" />. To retrieve more accurate error information, use <see cref="GetLastError" />. It may return one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>ERROR_FILE_NOT_FOUND </description>
          <description>The specified file was not found.</description>
        </item>
        <item>
          <description>ERROR_PATH_NOT_FOUND </description>
          <description>The specified path was not found.</description>
        </item>
        <item>
          <description>ERROR_DDE_FAIL </description>
          <description>The Dynamic Data Exchange (DDE) transaction failed.</description>
        </item>
        <item>
          <description>ERROR_NO_ASSOCIATION </description>
          <description>There is no application associated with the specified file name extension.</description>
        </item>
        <item>
          <description>ERROR_ACCESS_DENIED </description>
          <description>Access to the specified file is denied.</description>
        </item>
        <item>
          <description>ERROR_DLL_NOT_FOUND </description>
          <description>One of the library files necessary to run the application can't be found.</description>
        </item>
        <item>
          <description>ERROR_CANCELLED </description>
          <description>The function prompted the user for additional information, but the user canceled the request.</description>
        </item>
        <item>
          <description>ERROR_NOT_ENOUGH_MEMORY </description>
          <description>There is not enough memory to perform the specified action.</description>
        </item>
        <item>
          <description>ERROR_SHARING_VIOLATION </description>
          <description>A sharing violation occurred.</description>
        </item>
      </list>
      <para>
        <b>Opening items from a URL</b> You can register your application to activate when passed URLs. You can also specify which protocols your application supports. See <a href="https://docs.microsoft.com//windows/desktop/shell/app-registration">Application Registration</a> for more info.</para>
      <para>
        <b>Site chain support</b> As of Windows 8, you can provide a site chain pointer to the <b>ShellExecuteEx</b> function to support item activation with services from that site. See <a href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</a> for more information.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecuteEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.ShellExecuteExW">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="pExecInfo">
      <para>Type: <b>SHELLEXECUTEINFO*</b></para>
      <para>A pointer to a <see cref="SHELLEXECUTEINFO" /> structure that contains and receives information about the application being executed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecuteEx</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecuteEx</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are instances where <b>ShellExecuteEx</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to always initialize COM before using this function.</para>
      <para>When DLLs are loaded into your process, you acquire a lock known as a <a href="https://docs.microsoft.com//windows/win32/win7appqual/preventing-hangs-in-windows-applications">loader lock</a>. The <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function always executes under the loader lock. It is important that you do not call <b>ShellExecuteEx</b> while you hold a loader lock. Because <b>ShellExecuteEx</b> is extensible, you could load code that does not function properly in the presence of a loader lock, risking a deadlock and therefore an unresponsive thread.</para>
      <para>With multiple monitors, if you specify an <b>HWND</b> and set the <b>lpVerb</b> member of the <see cref="SHELLEXECUTEINFO" /> structure pointed to by <i>lpExecInfo</i> to "Properties", any windows created by <b>ShellExecuteEx</b> might not appear in the correct position.</para>
      <para>If the function succeeds, it sets the <b>hInstApp</b> member of the <see cref="SHELLEXECUTEINFO" /> structure to a value greater than 32. If the function fails, <b>hInstApp</b> is set to the <see cref="SE_ERR_XXX" /> error value that best indicates the cause of the failure. Although <b>hInstApp</b> is declared as an HINSTANCE for compatibility with 16-bit Windows applications, it is not a true HINSTANCE. It can be cast only to an <b>int</b> and can be compared only to either the value 32 or the SE_ERR_XXX error codes.</para>
      <para>The SE_ERR_XXX error values are provided for compatibility with <see cref="ShellExecute" />. To retrieve more accurate error information, use <see cref="GetLastError" />. It may return one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>ERROR_FILE_NOT_FOUND </description>
          <description>The specified file was not found.</description>
        </item>
        <item>
          <description>ERROR_PATH_NOT_FOUND </description>
          <description>The specified path was not found.</description>
        </item>
        <item>
          <description>ERROR_DDE_FAIL </description>
          <description>The Dynamic Data Exchange (DDE) transaction failed.</description>
        </item>
        <item>
          <description>ERROR_NO_ASSOCIATION </description>
          <description>There is no application associated with the specified file name extension.</description>
        </item>
        <item>
          <description>ERROR_ACCESS_DENIED </description>
          <description>Access to the specified file is denied.</description>
        </item>
        <item>
          <description>ERROR_DLL_NOT_FOUND </description>
          <description>One of the library files necessary to run the application can't be found.</description>
        </item>
        <item>
          <description>ERROR_CANCELLED </description>
          <description>The function prompted the user for additional information, but the user canceled the request.</description>
        </item>
        <item>
          <description>ERROR_NOT_ENOUGH_MEMORY </description>
          <description>There is not enough memory to perform the specified action.</description>
        </item>
        <item>
          <description>ERROR_SHARING_VIOLATION </description>
          <description>A sharing violation occurred.</description>
        </item>
      </list>
      <para>
        <b>Opening items from a URL</b> You can register your application to activate when passed URLs. You can also specify which protocols your application supports. See <a href="https://docs.microsoft.com//windows/desktop/shell/app-registration">Application Registration</a> for more info.</para>
      <para>
        <b>Site chain support</b> As of Windows 8, you can provide a site chain pointer to the <b>ShellExecuteEx</b> function to support item activation with services from that site. See <a href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</a> for more information.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecuteEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecute" />
  </member>
  <member name="Windows.ShellExecute">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window used for displaying a UI or error messages. This value can be <b>NULL</b> if the operation is not associated with a window.</para>
    </param>
    <param name="lpOperation">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>, that specifies the action to be performed. The set of available verbs depends on the particular file or folder. Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are commonly used:</para>
      <h4>edit</h4>
      <para>Launches an editor and opens the document for editing. If <i>lpFile</i> is not a document file, the function will fail.</para>
      <h4>explore</h4>
      <para>Explores a folder specified by <i>lpFile</i>.</para>
      <h4>find</h4>
      <para>Initiates a search beginning in the directory specified by <i>lpDirectory</i>.</para>
      <h4>open</h4>
      <para>Opens the item specified by the <i>lpFile</i> parameter. The item can be a file or folder.</para>
      <h4>print</h4>
      <para>Prints the file specified by <i>lpFile</i>. If <i>lpFile</i> is not a document file, the function fails.</para>
      <h4>runas</h4>
      <para>Launches an application as Administrator. User Account Control (UAC) will prompt the user for consent to run the application elevated or enter the credentials of an administrator account used to run the application.</para>
      <h4>NULL</h4>
      <para>The default verb is used, if available. If not, the "open" verb is used. If neither verb is available, the system uses the first verb listed in the registry.</para>
    </param>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the file or object on which to execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.</para>
    </param>
    <param name="lpParameters">
      <para>Type: <b>LPCTSTR</b></para>
      <para>If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file, <i>lpParameters</i> should be <b>NULL</b>.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the default (working) directory for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.</para>
    </param>
    <param name="nShowCmd">
      <para>Type: <b>INT</b></para>
      <para>The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i> specifies a document file, the flag is simply passed to the associated application. It is up to the application to decide how to handle it. It can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <see cref="ShowWindow" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>If the function succeeds, it returns a value greater than 32. If the function fails, it returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an <b>INT_PTR</b> and compared to either 32 or the following error codes below.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>The operating system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_FILE_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_BAD_FORMAT</b>
            </para>
          </description>
          <description>
            <para>The .exe file is invalid (non-Win32 .exe or error in .exe image).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>The operating system denied access to the specified file.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ASSOCINCOMPLETE</b>
            </para>
          </description>
          <description>
            <para>The file name association is incomplete or invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEBUSY</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because other DDE transactions were being processed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEFAIL</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction failed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDETIMEOUT</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because the request timed out.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DLLNOTFOUND</b>
            </para>
          </description>
          <description>
            <para>The specified DLL was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_FNF</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_NOASSOC</b>
            </para>
          </description>
          <description>
            <para>There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_OOM</b>
            </para>
          </description>
          <description>
            <para>There was not enough memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_PNF</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_SHARE</b>
            </para>
          </description>
          <description>
            <para>A sharing violation occurred.</para>
          </description>
        </item>
      </list>
      <para>Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecute</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecute</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are certainly instances where <b>ShellExecute</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to <i>always</i> initialize COM before using this function.</para>
      <para>This method allows you to execute any commands in a folder's shortcut menu or stored in the registry.</para>
      <para>To open a folder, use either of the following calls:</para>
      <code>ShellExecute(handle, NULL, &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>or</para>
      <code>ShellExecute(handle, "open", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To explore a folder, use the following call:</para>
      <code>ShellExecute(handle, "explore", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To launch the Shell's Find utility for a directory, use the following call.</para>
      <code>ShellExecute(handle, "find", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, 0);
</code>
      <para>If <i>lpOperation</i> is <b>NULL</b>, the function opens the file specified by <i>lpFile</i>. If <i>lpOperation</i> is "open" or "explore", the function  attempts to open or explore the folder.</para>
      <para>To obtain information about the application that is launched as a result of calling <b>ShellExecute</b>, use <see cref="ShellExecuteEx" />.</para>
      <para>
        <b>Note</b>  The <b>Launch folder windows in a separate process</b> setting in Folder Options affects <b>ShellExecute</b>. If that option is disabled (the default setting), <b>ShellExecute</b> uses an open Explorer window rather than launch a new one. If no Explorer window is open, <b>ShellExecute</b> launches a new one.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecute as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecuteEx" />
  </member>
  <member name="Windows.ShellExecuteA">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window used for displaying a UI or error messages. This value can be <b>NULL</b> if the operation is not associated with a window.</para>
    </param>
    <param name="lpOperation">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>, that specifies the action to be performed. The set of available verbs depends on the particular file or folder. Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are commonly used:</para>
      <h4>edit</h4>
      <para>Launches an editor and opens the document for editing. If <i>lpFile</i> is not a document file, the function will fail.</para>
      <h4>explore</h4>
      <para>Explores a folder specified by <i>lpFile</i>.</para>
      <h4>find</h4>
      <para>Initiates a search beginning in the directory specified by <i>lpDirectory</i>.</para>
      <h4>open</h4>
      <para>Opens the item specified by the <i>lpFile</i> parameter. The item can be a file or folder.</para>
      <h4>print</h4>
      <para>Prints the file specified by <i>lpFile</i>. If <i>lpFile</i> is not a document file, the function fails.</para>
      <h4>runas</h4>
      <para>Launches an application as Administrator. User Account Control (UAC) will prompt the user for consent to run the application elevated or enter the credentials of an administrator account used to run the application.</para>
      <h4>NULL</h4>
      <para>The default verb is used, if available. If not, the "open" verb is used. If neither verb is available, the system uses the first verb listed in the registry.</para>
    </param>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the file or object on which to execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.</para>
    </param>
    <param name="lpParameters">
      <para>Type: <b>LPCTSTR</b></para>
      <para>If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file, <i>lpParameters</i> should be <b>NULL</b>.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the default (working) directory for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.</para>
    </param>
    <param name="nShowCmd">
      <para>Type: <b>INT</b></para>
      <para>The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i> specifies a document file, the flag is simply passed to the associated application. It is up to the application to decide how to handle it. It can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <see cref="ShowWindow" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>If the function succeeds, it returns a value greater than 32. If the function fails, it returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an <b>INT_PTR</b> and compared to either 32 or the following error codes below.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>The operating system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_FILE_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_BAD_FORMAT</b>
            </para>
          </description>
          <description>
            <para>The .exe file is invalid (non-Win32 .exe or error in .exe image).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>The operating system denied access to the specified file.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ASSOCINCOMPLETE</b>
            </para>
          </description>
          <description>
            <para>The file name association is incomplete or invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEBUSY</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because other DDE transactions were being processed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEFAIL</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction failed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDETIMEOUT</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because the request timed out.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DLLNOTFOUND</b>
            </para>
          </description>
          <description>
            <para>The specified DLL was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_FNF</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_NOASSOC</b>
            </para>
          </description>
          <description>
            <para>There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_OOM</b>
            </para>
          </description>
          <description>
            <para>There was not enough memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_PNF</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_SHARE</b>
            </para>
          </description>
          <description>
            <para>A sharing violation occurred.</para>
          </description>
        </item>
      </list>
      <para>Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecute</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecute</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are certainly instances where <b>ShellExecute</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to <i>always</i> initialize COM before using this function.</para>
      <para>This method allows you to execute any commands in a folder's shortcut menu or stored in the registry.</para>
      <para>To open a folder, use either of the following calls:</para>
      <code>ShellExecute(handle, NULL, &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>or</para>
      <code>ShellExecute(handle, "open", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To explore a folder, use the following call:</para>
      <code>ShellExecute(handle, "explore", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To launch the Shell's Find utility for a directory, use the following call.</para>
      <code>ShellExecute(handle, "find", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, 0);
</code>
      <para>If <i>lpOperation</i> is <b>NULL</b>, the function opens the file specified by <i>lpFile</i>. If <i>lpOperation</i> is "open" or "explore", the function  attempts to open or explore the folder.</para>
      <para>To obtain information about the application that is launched as a result of calling <b>ShellExecute</b>, use <see cref="ShellExecuteEx" />.</para>
      <para>
        <b>Note</b>  The <b>Launch folder windows in a separate process</b> setting in Folder Options affects <b>ShellExecute</b>. If that option is disabled (the default setting), <b>ShellExecute</b> uses an open Explorer window rather than launch a new one. If no Explorer window is open, <b>ShellExecute</b> launches a new one.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecute as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecuteEx" />
  </member>
  <member name="Windows.ShellExecuteW">
    <summary>
      <para>Performs an operation on a specified file.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window used for displaying a UI or error messages. This value can be <b>NULL</b> if the operation is not associated with a window.</para>
    </param>
    <param name="lpOperation">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>, that specifies the action to be performed. The set of available verbs depends on the particular file or folder. Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are commonly used:</para>
      <h4>edit</h4>
      <para>Launches an editor and opens the document for editing. If <i>lpFile</i> is not a document file, the function will fail.</para>
      <h4>explore</h4>
      <para>Explores a folder specified by <i>lpFile</i>.</para>
      <h4>find</h4>
      <para>Initiates a search beginning in the directory specified by <i>lpDirectory</i>.</para>
      <h4>open</h4>
      <para>Opens the item specified by the <i>lpFile</i> parameter. The item can be a file or folder.</para>
      <h4>print</h4>
      <para>Prints the file specified by <i>lpFile</i>. If <i>lpFile</i> is not a document file, the function fails.</para>
      <h4>runas</h4>
      <para>Launches an application as Administrator. User Account Control (UAC) will prompt the user for consent to run the application elevated or enter the credentials of an administrator account used to run the application.</para>
      <h4>NULL</h4>
      <para>The default verb is used, if available. If not, the "open" verb is used. If neither verb is available, the system uses the first verb listed in the registry.</para>
    </param>
    <param name="lpFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the file or object on which to execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.</para>
    </param>
    <param name="lpParameters">
      <para>Type: <b>LPCTSTR</b></para>
      <para>If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file, <i>lpParameters</i> should be <b>NULL</b>.</para>
    </param>
    <param name="lpDirectory">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that specifies the default (working) directory for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.</para>
    </param>
    <param name="nShowCmd">
      <para>Type: <b>INT</b></para>
      <para>The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i> specifies a document file, the flag is simply passed to the associated application. It is up to the application to decide how to handle it. It can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <see cref="ShowWindow" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HINSTANCE</b></para>
      <para>If the function succeeds, it returns a value greater than 32. If the function fails, it returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an <b>INT_PTR</b> and compared to either 32 or the following error codes below.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>The operating system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_FILE_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_BAD_FORMAT</b>
            </para>
          </description>
          <description>
            <para>The .exe file is invalid (non-Win32 .exe or error in .exe image).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ACCESSDENIED</b>
            </para>
          </description>
          <description>
            <para>The operating system denied access to the specified file.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_ASSOCINCOMPLETE</b>
            </para>
          </description>
          <description>
            <para>The file name association is incomplete or invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEBUSY</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because other DDE transactions were being processed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDEFAIL</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction failed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DDETIMEOUT</b>
            </para>
          </description>
          <description>
            <para>The DDE transaction could not be completed because the request timed out.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_DLLNOTFOUND</b>
            </para>
          </description>
          <description>
            <para>The specified DLL was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_FNF</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_NOASSOC</b>
            </para>
          </description>
          <description>
            <para>There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_OOM</b>
            </para>
          </description>
          <description>
            <para>There was not enough memory to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_PNF</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SE_ERR_SHARE</b>
            </para>
          </description>
          <description>
            <para>A sharing violation occurred.</para>
          </description>
        </item>
      </list>
      <para>Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>Because <b>ShellExecute</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecute</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:</para>
      <code>CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
</code>
      <para>There are certainly instances where <b>ShellExecute</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to <i>always</i> initialize COM before using this function.</para>
      <para>This method allows you to execute any commands in a folder's shortcut menu or stored in the registry.</para>
      <para>To open a folder, use either of the following calls:</para>
      <code>ShellExecute(handle, NULL, &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>or</para>
      <code>ShellExecute(handle, "open", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To explore a folder, use the following call:</para>
      <code>ShellExecute(handle, "explore", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, SW_SHOWNORMAL);
</code>
      <para>To launch the Shell's Find utility for a directory, use the following call.</para>
      <code>ShellExecute(handle, "find", &lt;fully_qualified_path_to_folder&gt;, NULL, NULL, 0);
</code>
      <para>If <i>lpOperation</i> is <b>NULL</b>, the function opens the file specified by <i>lpFile</i>. If <i>lpOperation</i> is "open" or "explore", the function  attempts to open or explore the folder.</para>
      <para>To obtain information about the application that is launched as a result of calling <b>ShellExecute</b>, use <see cref="ShellExecuteEx" />.</para>
      <para>
        <b>Note</b>  The <b>Launch folder windows in a separate process</b> setting in Folder Options affects <b>ShellExecute</b>. If that option is disabled (the default setting), <b>ShellExecute</b> uses an open Explorer window rather than launch a new one. If no Explorer window is open, <b>ShellExecute</b> launches a new one.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines ShellExecute as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CoInitializeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/how-to-register-and-implement-a-property-sheet-handler-for-a-control-panel-application">IShellExecuteHook</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</seealso>
    <seealso cref="ShellExecuteEx" />
  </member>
  <member name="Windows.Shell_NotifyIcon">
    <summary>
      <para>Sends a message to the taskbar's status area.</para>
    </summary>
    <param name="dwMessage">
      <para>Type: <b>DWORD</b></para>
      <para>A value that specifies the action to be taken by this function. It can have one of the following values:</para>
      <h4>NIM_ADD (0x00000000)</h4>
      <para>0x00000000. Adds an icon to the status area. The icon is given an identifier in the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>—either through its <b>uID</b> or <b>guidItem</b> member. This identifier is used in subsequent calls to <b>Shell_NotifyIcon</b> to perform later actions on the icon.</para>
      <h4>NIM_MODIFY (0x00000001)</h4>
      <para>0x00000001. Modifies an icon in the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be modified.</para>
      <h4>NIM_DELETE (0x00000002)</h4>
      <para>0x00000002. Deletes an icon from the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be deleted.</para>
      <h4>NIM_SETFOCUS (0x00000003)</h4>
      <para>0x00000003. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Returns focus to the taskbar notification area. Notification area icons should use this message when they have completed their UI operation. For example, if the icon displays a shortcut menu, but the user presses ESC to cancel it, use <b>NIM_SETFOCUS</b> to return focus to the notification area.</para>
      <h4>NIM_SETVERSION (0x00000004)</h4>
      <para>0x00000004. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Instructs the notification area to behave according to the version number specified in the <b>uVersion</b> member of the structure pointed to by <i>lpdata</i>. The version number specifies which members are recognized.</para>
      <para>NIM_SETVERSION must be called every time a notification area icon is added (NIM_ADD). It does not need to be called with NIM_MODIFY. The version setting is not persisted once a user logs off.</para>
      <para>For details, see the Remarks section.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>PNOTIFYICONDATA</b></para>
      <para>A pointer to a <see cref="NOTIFYICONDATA" /> structure. The content of the structure depends on the value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a notification, or identify an icon to modify or delete.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the requested version is not supported.</para>
    </returns>
    <remarks>
      <para>As of Windows 2000 (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0</a>), if you set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to NOTIFYICON_VERSION_4 or higher, <b>Shell_NotifyIcon</b> mouse and keyboard events are handled differently than in earlier versions of Windows. The differences include the following:</para>
      <list type="bullet">
        <item>
          <description>If a user selects a notify icon's shortcut menu with the keyboard, the Shell now sends the associated application a <a href="https://docs.microsoft.com//windows/desktop/menurc/wm-contextmenu">WM_CONTEXTMENU</a> message. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the keyboard and activates it with the SPACEBAR or ENTER key, the version 5.0 Shell sends the associated application an NIN_KEYSELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the mouse and activates it with the ENTER key, the Shell now sends the associated application an NIN_SELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
      </list>
      <para>As of Windows XP (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 6.0</a>), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Shell sends the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_BALLOONSHOW. Sent when the balloon is shown (balloons are queued).</description>
        </item>
        <item>
          <description>
            <para>NIN_BALLOONHIDE. Sent when the balloon disappears. For example, when the icon is deleted. This message is not sent if the balloon is dismissed because of a timeout or if the user clicks the mouse.</para>
            <para>As of Windows 7, NIN_BALLOONHIDE is also sent when a notification with the <see cref="NIIF_RESPECT_QUIET_TIME" /> flag set attempts to display during quiet time (a user's first hour on a new computer). In that case, the balloon is never displayed at all.</para>
          </description>
        </item>
        <item>
          <description>NIN_BALLOONTIMEOUT. Sent when the balloon is dismissed because of a timeout.</description>
        </item>
        <item>
          <description>NIN_BALLOONUSERCLICK. Sent when the balloon is dismissed because the user clicked the mouse.</description>
        </item>
      </list>
      <para>In addition to those messages, as of Windows Vista (Shell32.dll version 6.0.6), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Windows Vista Shell also adds the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_POPUPOPEN. Sent when the user hovers the cursor over an icon to indicate that the richer pop-up UI should be used in place of a standard textual tooltip.</description>
        </item>
        <item>
          <description>NIN_POPUPCLOSE. Sent when a cursor no longer hovers over an icon to indicate that the rich pop-up UI should be closed.</description>
        </item>
      </list>
      <para>Regardless of the operating system version, you can select which way the Shell should behave by calling <b>Shell_NotifyIcon</b> with <i>dwMessage</i> set to <b>NIM_SETVERSION</b>. Set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to indicate whether you want Windows 2000, Windows Vista, or pre-version 5.0 (Windows 95) behavior.</para>
      <para>
        <b>Note</b>  The messages discussed above are not conventional Windows messages. They are sent as the <i>lParam</i> value of the application-defined message that is specified in the <b>uCallbackMessage</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>, when <b>Shell_NotifyIcon</b> is called with the <b>NIM_ADD</b> flag set in <i>dwMessage</i>.</para>
      <para>As of Windows XP Service Pack 2 (SP2), a custom icon can be displayed in the notification balloon. This allows the calling process to customize the notification beyond the previously available options of info, warning, and error, and distinguish it from other types of notification for the user.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines Shell_NotifyIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/notification-area">Notifications and the Notification Area</seealso>
  </member>
  <member name="Windows.Shell_NotifyIconA">
    <summary>
      <para>Sends a message to the taskbar's status area.</para>
    </summary>
    <param name="dwMessage">
      <para>Type: <b>DWORD</b></para>
      <para>A value that specifies the action to be taken by this function. It can have one of the following values:</para>
      <h4>NIM_ADD (0x00000000)</h4>
      <para>0x00000000. Adds an icon to the status area. The icon is given an identifier in the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>—either through its <b>uID</b> or <b>guidItem</b> member. This identifier is used in subsequent calls to <b>Shell_NotifyIcon</b> to perform later actions on the icon.</para>
      <h4>NIM_MODIFY (0x00000001)</h4>
      <para>0x00000001. Modifies an icon in the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be modified.</para>
      <h4>NIM_DELETE (0x00000002)</h4>
      <para>0x00000002. Deletes an icon from the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be deleted.</para>
      <h4>NIM_SETFOCUS (0x00000003)</h4>
      <para>0x00000003. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Returns focus to the taskbar notification area. Notification area icons should use this message when they have completed their UI operation. For example, if the icon displays a shortcut menu, but the user presses ESC to cancel it, use <b>NIM_SETFOCUS</b> to return focus to the notification area.</para>
      <h4>NIM_SETVERSION (0x00000004)</h4>
      <para>0x00000004. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Instructs the notification area to behave according to the version number specified in the <b>uVersion</b> member of the structure pointed to by <i>lpdata</i>. The version number specifies which members are recognized.</para>
      <para>NIM_SETVERSION must be called every time a notification area icon is added (NIM_ADD). It does not need to be called with NIM_MODIFY. The version setting is not persisted once a user logs off.</para>
      <para>For details, see the Remarks section.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>PNOTIFYICONDATA</b></para>
      <para>A pointer to a <see cref="NOTIFYICONDATA" /> structure. The content of the structure depends on the value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a notification, or identify an icon to modify or delete.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the requested version is not supported.</para>
    </returns>
    <remarks>
      <para>As of Windows 2000 (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0</a>), if you set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to NOTIFYICON_VERSION_4 or higher, <b>Shell_NotifyIcon</b> mouse and keyboard events are handled differently than in earlier versions of Windows. The differences include the following:</para>
      <list type="bullet">
        <item>
          <description>If a user selects a notify icon's shortcut menu with the keyboard, the Shell now sends the associated application a <a href="https://docs.microsoft.com//windows/desktop/menurc/wm-contextmenu">WM_CONTEXTMENU</a> message. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the keyboard and activates it with the SPACEBAR or ENTER key, the version 5.0 Shell sends the associated application an NIN_KEYSELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the mouse and activates it with the ENTER key, the Shell now sends the associated application an NIN_SELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
      </list>
      <para>As of Windows XP (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 6.0</a>), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Shell sends the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_BALLOONSHOW. Sent when the balloon is shown (balloons are queued).</description>
        </item>
        <item>
          <description>
            <para>NIN_BALLOONHIDE. Sent when the balloon disappears. For example, when the icon is deleted. This message is not sent if the balloon is dismissed because of a timeout or if the user clicks the mouse.</para>
            <para>As of Windows 7, NIN_BALLOONHIDE is also sent when a notification with the <see cref="NIIF_RESPECT_QUIET_TIME" /> flag set attempts to display during quiet time (a user's first hour on a new computer). In that case, the balloon is never displayed at all.</para>
          </description>
        </item>
        <item>
          <description>NIN_BALLOONTIMEOUT. Sent when the balloon is dismissed because of a timeout.</description>
        </item>
        <item>
          <description>NIN_BALLOONUSERCLICK. Sent when the balloon is dismissed because the user clicked the mouse.</description>
        </item>
      </list>
      <para>In addition to those messages, as of Windows Vista (Shell32.dll version 6.0.6), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Windows Vista Shell also adds the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_POPUPOPEN. Sent when the user hovers the cursor over an icon to indicate that the richer pop-up UI should be used in place of a standard textual tooltip.</description>
        </item>
        <item>
          <description>NIN_POPUPCLOSE. Sent when a cursor no longer hovers over an icon to indicate that the rich pop-up UI should be closed.</description>
        </item>
      </list>
      <para>Regardless of the operating system version, you can select which way the Shell should behave by calling <b>Shell_NotifyIcon</b> with <i>dwMessage</i> set to <b>NIM_SETVERSION</b>. Set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to indicate whether you want Windows 2000, Windows Vista, or pre-version 5.0 (Windows 95) behavior.</para>
      <para>
        <b>Note</b>  The messages discussed above are not conventional Windows messages. They are sent as the <i>lParam</i> value of the application-defined message that is specified in the <b>uCallbackMessage</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>, when <b>Shell_NotifyIcon</b> is called with the <b>NIM_ADD</b> flag set in <i>dwMessage</i>.</para>
      <para>As of Windows XP Service Pack 2 (SP2), a custom icon can be displayed in the notification balloon. This allows the calling process to customize the notification beyond the previously available options of info, warning, and error, and distinguish it from other types of notification for the user.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines Shell_NotifyIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/notification-area">Notifications and the Notification Area</seealso>
  </member>
  <member name="Windows.Shell_NotifyIconW">
    <summary>
      <para>Sends a message to the taskbar's status area.</para>
    </summary>
    <param name="dwMessage">
      <para>Type: <b>DWORD</b></para>
      <para>A value that specifies the action to be taken by this function. It can have one of the following values:</para>
      <h4>NIM_ADD (0x00000000)</h4>
      <para>0x00000000. Adds an icon to the status area. The icon is given an identifier in the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>—either through its <b>uID</b> or <b>guidItem</b> member. This identifier is used in subsequent calls to <b>Shell_NotifyIcon</b> to perform later actions on the icon.</para>
      <h4>NIM_MODIFY (0x00000001)</h4>
      <para>0x00000001. Modifies an icon in the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be modified.</para>
      <h4>NIM_DELETE (0x00000002)</h4>
      <para>0x00000002. Deletes an icon from the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be deleted.</para>
      <h4>NIM_SETFOCUS (0x00000003)</h4>
      <para>0x00000003. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Returns focus to the taskbar notification area. Notification area icons should use this message when they have completed their UI operation. For example, if the icon displays a shortcut menu, but the user presses ESC to cancel it, use <b>NIM_SETFOCUS</b> to return focus to the notification area.</para>
      <h4>NIM_SETVERSION (0x00000004)</h4>
      <para>0x00000004. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Instructs the notification area to behave according to the version number specified in the <b>uVersion</b> member of the structure pointed to by <i>lpdata</i>. The version number specifies which members are recognized.</para>
      <para>NIM_SETVERSION must be called every time a notification area icon is added (NIM_ADD). It does not need to be called with NIM_MODIFY. The version setting is not persisted once a user logs off.</para>
      <para>For details, see the Remarks section.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>PNOTIFYICONDATA</b></para>
      <para>A pointer to a <see cref="NOTIFYICONDATA" /> structure. The content of the structure depends on the value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a notification, or identify an icon to modify or delete.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the requested version is not supported.</para>
    </returns>
    <remarks>
      <para>As of Windows 2000 (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0</a>), if you set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to NOTIFYICON_VERSION_4 or higher, <b>Shell_NotifyIcon</b> mouse and keyboard events are handled differently than in earlier versions of Windows. The differences include the following:</para>
      <list type="bullet">
        <item>
          <description>If a user selects a notify icon's shortcut menu with the keyboard, the Shell now sends the associated application a <a href="https://docs.microsoft.com//windows/desktop/menurc/wm-contextmenu">WM_CONTEXTMENU</a> message. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the keyboard and activates it with the SPACEBAR or ENTER key, the version 5.0 Shell sends the associated application an NIN_KEYSELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the mouse and activates it with the ENTER key, the Shell now sends the associated application an NIN_SELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
      </list>
      <para>As of Windows XP (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 6.0</a>), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Shell sends the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_BALLOONSHOW. Sent when the balloon is shown (balloons are queued).</description>
        </item>
        <item>
          <description>
            <para>NIN_BALLOONHIDE. Sent when the balloon disappears. For example, when the icon is deleted. This message is not sent if the balloon is dismissed because of a timeout or if the user clicks the mouse.</para>
            <para>As of Windows 7, NIN_BALLOONHIDE is also sent when a notification with the <see cref="NIIF_RESPECT_QUIET_TIME" /> flag set attempts to display during quiet time (a user's first hour on a new computer). In that case, the balloon is never displayed at all.</para>
          </description>
        </item>
        <item>
          <description>NIN_BALLOONTIMEOUT. Sent when the balloon is dismissed because of a timeout.</description>
        </item>
        <item>
          <description>NIN_BALLOONUSERCLICK. Sent when the balloon is dismissed because the user clicked the mouse.</description>
        </item>
      </list>
      <para>In addition to those messages, as of Windows Vista (Shell32.dll version 6.0.6), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Windows Vista Shell also adds the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_POPUPOPEN. Sent when the user hovers the cursor over an icon to indicate that the richer pop-up UI should be used in place of a standard textual tooltip.</description>
        </item>
        <item>
          <description>NIN_POPUPCLOSE. Sent when a cursor no longer hovers over an icon to indicate that the rich pop-up UI should be closed.</description>
        </item>
      </list>
      <para>Regardless of the operating system version, you can select which way the Shell should behave by calling <b>Shell_NotifyIcon</b> with <i>dwMessage</i> set to <b>NIM_SETVERSION</b>. Set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to indicate whether you want Windows 2000, Windows Vista, or pre-version 5.0 (Windows 95) behavior.</para>
      <para>
        <b>Note</b>  The messages discussed above are not conventional Windows messages. They are sent as the <i>lParam</i> value of the application-defined message that is specified in the <b>uCallbackMessage</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>, when <b>Shell_NotifyIcon</b> is called with the <b>NIM_ADD</b> flag set in <i>dwMessage</i>.</para>
      <para>As of Windows XP Service Pack 2 (SP2), a custom icon can be displayed in the notification balloon. This allows the calling process to customize the notification beyond the previously available options of info, warning, and error, and distinguish it from other types of notification for the user.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines Shell_NotifyIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/notification-area">Notifications and the Notification Area</seealso>
  </member>
  <member name="Windows.Shell_NotifyIconGetRect">
    <summary>
      <para>Gets the screen coordinates of the bounding rectangle of a notification icon.</para>
    </summary>
    <param name="identifier">
      <para>Type: <b>const <see cref="NOTIFYICONIDENTIFIER" />*</b></para>
      <para>Pointer to a <see cref="NOTIFYICONIDENTIFIER" /> structure that identifies the icon.</para>
    </param>
    <param name="iconLocation">
      <para>Type: <b><see cref="RECT" />*</b></para>
      <para>Pointer to a <see cref="RECT" /> structure that, when this function returns successfully, receives the coordinates of the icon.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/notification-area">Notifications and the Notification Area</seealso>
  </member>
  <member name="Windows.Shell_NotifyIcon">
    <summary>
      <para>Sends a message to the taskbar's status area.</para>
    </summary>
    <param name="dwMessage">
      <para>Type: <b>DWORD</b></para>
      <para>A value that specifies the action to be taken by this function. It can have one of the following values:</para>
      <h4>NIM_ADD (0x00000000)</h4>
      <para>0x00000000. Adds an icon to the status area. The icon is given an identifier in the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>—either through its <b>uID</b> or <b>guidItem</b> member. This identifier is used in subsequent calls to <b>Shell_NotifyIcon</b> to perform later actions on the icon.</para>
      <h4>NIM_MODIFY (0x00000001)</h4>
      <para>0x00000001. Modifies an icon in the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be modified.</para>
      <h4>NIM_DELETE (0x00000002)</h4>
      <para>0x00000002. Deletes an icon from the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be deleted.</para>
      <h4>NIM_SETFOCUS (0x00000003)</h4>
      <para>0x00000003. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Returns focus to the taskbar notification area. Notification area icons should use this message when they have completed their UI operation. For example, if the icon displays a shortcut menu, but the user presses ESC to cancel it, use <b>NIM_SETFOCUS</b> to return focus to the notification area.</para>
      <h4>NIM_SETVERSION (0x00000004)</h4>
      <para>0x00000004. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Instructs the notification area to behave according to the version number specified in the <b>uVersion</b> member of the structure pointed to by <i>lpdata</i>. The version number specifies which members are recognized.</para>
      <para>NIM_SETVERSION must be called every time a notification area icon is added (NIM_ADD)&gt;. It does not need to be called with NIM_MOFIDY. The version setting is not persisted once a user logs off.</para>
      <para>For details, see the Remarks section.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>PNOTIFYICONDATA</b></para>
      <para>A pointer to a <see cref="NOTIFYICONDATA" /> structure. The content of the structure depends on the value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a notification, or identify an icon to modify or delete.</para>
      <h5>- dwMessage.NIM_ADD (0x00000000)</h5>
      <para>0x00000000. Adds an icon to the status area. The icon is given an identifier in the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>—either through its <b>uID</b> or <b>guidItem</b> member. This identifier is used in subsequent calls to <b>Shell_NotifyIcon</b> to perform later actions on the icon.</para>
      <h5>- dwMessage.NIM_DELETE (0x00000002)</h5>
      <para>0x00000002. Deletes an icon from the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be deleted.</para>
      <h5>- dwMessage.NIM_MODIFY (0x00000001)</h5>
      <para>0x00000001. Modifies an icon in the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be modified.</para>
      <h5>- dwMessage.NIM_SETFOCUS (0x00000003)</h5>
      <para>0x00000003. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Returns focus to the taskbar notification area. Notification area icons should use this message when they have completed their UI operation. For example, if the icon displays a shortcut menu, but the user presses ESC to cancel it, use <b>NIM_SETFOCUS</b> to return focus to the notification area.</para>
      <h5>- dwMessage.NIM_SETVERSION (0x00000004)</h5>
      <para>0x00000004. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Instructs the notification area to behave according to the version number specified in the <b>uVersion</b> member of the structure pointed to by <i>lpdata</i>. The version number specifies which members are recognized.</para>
      <para>NIM_SETVERSION must be called every time a notification area icon is added (NIM_ADD)&gt;. It does not need to be called with NIM_MOFIDY. The version setting is not persisted once a user logs off.</para>
      <para>For details, see the Remarks section.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the requested version is not supported.</para>
    </returns>
    <remarks>
      <para>As of Windows 2000 (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0</a>), if you set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to NOTIFYICON_VERSION_4 or higher, <b>Shell_NotifyIcon</b> mouse and keyboard events are handled differently than in earlier versions of Windows. The differences include the following:</para>
      <list type="bullet">
        <item>
          <description>If a user selects a notify icon's shortcut menu with the keyboard, the Shell now sends the associated application a <a href="https://docs.microsoft.com//windows/desktop/menurc/wm-contextmenu">WM_CONTEXTMENU</a> message. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the keyboard and activates it with the SPACEBAR or ENTER key, the version 5.0 Shell sends the associated application an NIN_KEYSELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the mouse and activates it with the ENTER key, the Shell now sends the associated application an NIN_SELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
      </list>
      <para>As of Windows XP (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 6.0</a>), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Shell sends the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_BALLOONSHOW. Sent when the balloon is shown (balloons are queued).</description>
        </item>
        <item>
          <description>
            <para>NIN_BALLOONHIDE. Sent when the balloon disappears. For example, when the icon is deleted. This message is not sent if the balloon is dismissed because of a timeout or if the user clicks the mouse.</para>
            <para>As of Windows 7, NIN_BALLOONHIDE is also sent when a notification with the <see cref="NIIF_RESPECT_QUIET_TIME" /> flag set attempts to display during quiet time (a user's first hour on a new computer). In that case, the balloon is never displayed at all.</para>
          </description>
        </item>
        <item>
          <description>NIN_BALLOONTIMEOUT. Sent when the balloon is dismissed because of a timeout.</description>
        </item>
        <item>
          <description>NIN_BALLOONUSERCLICK. Sent when the balloon is dismissed because the user clicked the mouse.</description>
        </item>
      </list>
      <para>In addition to those messages, as of Windows Vista (Shell32.dll version 6.0.6), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Windows Vista Shell also adds the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_POPUPOPEN. Sent when the user hovers the cursor over an icon to indicate that the richer pop-up UI should be used in place of a standard textual tooltip.</description>
        </item>
        <item>
          <description>NIN_POPUPCLOSE. Sent when a cursor no longer hovers over an icon to indicate that the rich pop-up UI should be closed.</description>
        </item>
      </list>
      <para>Regardless of the operating system version, you can select which way the Shell should behave by calling <b>Shell_NotifyIcon</b> with <i>dwMessage</i> set to <b>NIM_SETVERSION</b>. Set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to indicate whether you want Windows 2000, Windows Vista, or pre-version 5.0 (Windows 95) behavior.</para>
      <para>
        <b>Note</b>  The messages discussed above are not conventional Windows messages. They are sent as the <i>lParam</i> value of the application-defined message that is specified in the <b>uCallbackMessage</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>, when <b>Shell_NotifyIcon</b> is called with the <b>NIM_ADD</b> flag set in <i>dwMessage</i>.</para>
      <para>As of Windows XP Service Pack 2 (SP2), a custom icon can be displayed in the notification balloon. This allows the calling process to customize the notification beyond the previously available options of info, warning, and error, and distinguish it from other types of notification for the user.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines Shell_NotifyIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/notification-area">Notifications and the Notification Area</seealso>
  </member>
  <member name="Windows.Shell_NotifyIconA">
    <summary>
      <para>Sends a message to the taskbar's status area.</para>
    </summary>
    <param name="dwMessage">
      <para>Type: <b>DWORD</b></para>
      <para>A value that specifies the action to be taken by this function. It can have one of the following values:</para>
      <h4>NIM_ADD (0x00000000)</h4>
      <para>0x00000000. Adds an icon to the status area. The icon is given an identifier in the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>—either through its <b>uID</b> or <b>guidItem</b> member. This identifier is used in subsequent calls to <b>Shell_NotifyIcon</b> to perform later actions on the icon.</para>
      <h4>NIM_MODIFY (0x00000001)</h4>
      <para>0x00000001. Modifies an icon in the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be modified.</para>
      <h4>NIM_DELETE (0x00000002)</h4>
      <para>0x00000002. Deletes an icon from the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be deleted.</para>
      <h4>NIM_SETFOCUS (0x00000003)</h4>
      <para>0x00000003. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Returns focus to the taskbar notification area. Notification area icons should use this message when they have completed their UI operation. For example, if the icon displays a shortcut menu, but the user presses ESC to cancel it, use <b>NIM_SETFOCUS</b> to return focus to the notification area.</para>
      <h4>NIM_SETVERSION (0x00000004)</h4>
      <para>0x00000004. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Instructs the notification area to behave according to the version number specified in the <b>uVersion</b> member of the structure pointed to by <i>lpdata</i>. The version number specifies which members are recognized.</para>
      <para>NIM_SETVERSION must be called every time a notification area icon is added (NIM_ADD)&gt;. It does not need to be called with NIM_MOFIDY. The version setting is not persisted once a user logs off.</para>
      <para>For details, see the Remarks section.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>PNOTIFYICONDATA</b></para>
      <para>A pointer to a <see cref="NOTIFYICONDATA" /> structure. The content of the structure depends on the value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a notification, or identify an icon to modify or delete.</para>
      <h5>- dwMessage.NIM_ADD (0x00000000)</h5>
      <para>0x00000000. Adds an icon to the status area. The icon is given an identifier in the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>—either through its <b>uID</b> or <b>guidItem</b> member. This identifier is used in subsequent calls to <b>Shell_NotifyIcon</b> to perform later actions on the icon.</para>
      <h5>- dwMessage.NIM_DELETE (0x00000002)</h5>
      <para>0x00000002. Deletes an icon from the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be deleted.</para>
      <h5>- dwMessage.NIM_MODIFY (0x00000001)</h5>
      <para>0x00000001. Modifies an icon in the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be modified.</para>
      <h5>- dwMessage.NIM_SETFOCUS (0x00000003)</h5>
      <para>0x00000003. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Returns focus to the taskbar notification area. Notification area icons should use this message when they have completed their UI operation. For example, if the icon displays a shortcut menu, but the user presses ESC to cancel it, use <b>NIM_SETFOCUS</b> to return focus to the notification area.</para>
      <h5>- dwMessage.NIM_SETVERSION (0x00000004)</h5>
      <para>0x00000004. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Instructs the notification area to behave according to the version number specified in the <b>uVersion</b> member of the structure pointed to by <i>lpdata</i>. The version number specifies which members are recognized.</para>
      <para>NIM_SETVERSION must be called every time a notification area icon is added (NIM_ADD)&gt;. It does not need to be called with NIM_MOFIDY. The version setting is not persisted once a user logs off.</para>
      <para>For details, see the Remarks section.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the requested version is not supported.</para>
    </returns>
    <remarks>
      <para>As of Windows 2000 (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0</a>), if you set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to NOTIFYICON_VERSION_4 or higher, <b>Shell_NotifyIcon</b> mouse and keyboard events are handled differently than in earlier versions of Windows. The differences include the following:</para>
      <list type="bullet">
        <item>
          <description>If a user selects a notify icon's shortcut menu with the keyboard, the Shell now sends the associated application a <a href="https://docs.microsoft.com//windows/desktop/menurc/wm-contextmenu">WM_CONTEXTMENU</a> message. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the keyboard and activates it with the SPACEBAR or ENTER key, the version 5.0 Shell sends the associated application an NIN_KEYSELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the mouse and activates it with the ENTER key, the Shell now sends the associated application an NIN_SELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
      </list>
      <para>As of Windows XP (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 6.0</a>), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Shell sends the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_BALLOONSHOW. Sent when the balloon is shown (balloons are queued).</description>
        </item>
        <item>
          <description>
            <para>NIN_BALLOONHIDE. Sent when the balloon disappears. For example, when the icon is deleted. This message is not sent if the balloon is dismissed because of a timeout or if the user clicks the mouse.</para>
            <para>As of Windows 7, NIN_BALLOONHIDE is also sent when a notification with the <see cref="NIIF_RESPECT_QUIET_TIME" /> flag set attempts to display during quiet time (a user's first hour on a new computer). In that case, the balloon is never displayed at all.</para>
          </description>
        </item>
        <item>
          <description>NIN_BALLOONTIMEOUT. Sent when the balloon is dismissed because of a timeout.</description>
        </item>
        <item>
          <description>NIN_BALLOONUSERCLICK. Sent when the balloon is dismissed because the user clicked the mouse.</description>
        </item>
      </list>
      <para>In addition to those messages, as of Windows Vista (Shell32.dll version 6.0.6), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Windows Vista Shell also adds the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_POPUPOPEN. Sent when the user hovers the cursor over an icon to indicate that the richer pop-up UI should be used in place of a standard textual tooltip.</description>
        </item>
        <item>
          <description>NIN_POPUPCLOSE. Sent when a cursor no longer hovers over an icon to indicate that the rich pop-up UI should be closed.</description>
        </item>
      </list>
      <para>Regardless of the operating system version, you can select which way the Shell should behave by calling <b>Shell_NotifyIcon</b> with <i>dwMessage</i> set to <b>NIM_SETVERSION</b>. Set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to indicate whether you want Windows 2000, Windows Vista, or pre-version 5.0 (Windows 95) behavior.</para>
      <para>
        <b>Note</b>  The messages discussed above are not conventional Windows messages. They are sent as the <i>lParam</i> value of the application-defined message that is specified in the <b>uCallbackMessage</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>, when <b>Shell_NotifyIcon</b> is called with the <b>NIM_ADD</b> flag set in <i>dwMessage</i>.</para>
      <para>As of Windows XP Service Pack 2 (SP2), a custom icon can be displayed in the notification balloon. This allows the calling process to customize the notification beyond the previously available options of info, warning, and error, and distinguish it from other types of notification for the user.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines Shell_NotifyIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/notification-area">Notifications and the Notification Area</seealso>
  </member>
  <member name="Windows.Shell_NotifyIconW">
    <summary>
      <para>Sends a message to the taskbar's status area.</para>
    </summary>
    <param name="dwMessage">
      <para>Type: <b>DWORD</b></para>
      <para>A value that specifies the action to be taken by this function. It can have one of the following values:</para>
      <h4>NIM_ADD (0x00000000)</h4>
      <para>0x00000000. Adds an icon to the status area. The icon is given an identifier in the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>—either through its <b>uID</b> or <b>guidItem</b> member. This identifier is used in subsequent calls to <b>Shell_NotifyIcon</b> to perform later actions on the icon.</para>
      <h4>NIM_MODIFY (0x00000001)</h4>
      <para>0x00000001. Modifies an icon in the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be modified.</para>
      <h4>NIM_DELETE (0x00000002)</h4>
      <para>0x00000002. Deletes an icon from the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be deleted.</para>
      <h4>NIM_SETFOCUS (0x00000003)</h4>
      <para>0x00000003. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Returns focus to the taskbar notification area. Notification area icons should use this message when they have completed their UI operation. For example, if the icon displays a shortcut menu, but the user presses ESC to cancel it, use <b>NIM_SETFOCUS</b> to return focus to the notification area.</para>
      <h4>NIM_SETVERSION (0x00000004)</h4>
      <para>0x00000004. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Instructs the notification area to behave according to the version number specified in the <b>uVersion</b> member of the structure pointed to by <i>lpdata</i>. The version number specifies which members are recognized.</para>
      <para>NIM_SETVERSION must be called every time a notification area icon is added (NIM_ADD)&gt;. It does not need to be called with NIM_MOFIDY. The version setting is not persisted once a user logs off.</para>
      <para>For details, see the Remarks section.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>PNOTIFYICONDATA</b></para>
      <para>A pointer to a <see cref="NOTIFYICONDATA" /> structure. The content of the structure depends on the value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a notification, or identify an icon to modify or delete.</para>
      <h5>- dwMessage.NIM_ADD (0x00000000)</h5>
      <para>0x00000000. Adds an icon to the status area. The icon is given an identifier in the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>—either through its <b>uID</b> or <b>guidItem</b> member. This identifier is used in subsequent calls to <b>Shell_NotifyIcon</b> to perform later actions on the icon.</para>
      <h5>- dwMessage.NIM_DELETE (0x00000002)</h5>
      <para>0x00000002. Deletes an icon from the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be deleted.</para>
      <h5>- dwMessage.NIM_MODIFY (0x00000001)</h5>
      <para>0x00000001. Modifies an icon in the status area. <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> uses the ID originally assigned to the icon when it was added to the notification area (NIM_ADD) to identify the icon to be modified.</para>
      <h5>- dwMessage.NIM_SETFOCUS (0x00000003)</h5>
      <para>0x00000003. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Returns focus to the taskbar notification area. Notification area icons should use this message when they have completed their UI operation. For example, if the icon displays a shortcut menu, but the user presses ESC to cancel it, use <b>NIM_SETFOCUS</b> to return focus to the notification area.</para>
      <h5>- dwMessage.NIM_SETVERSION (0x00000004)</h5>
      <para>0x00000004. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0 and later only</a>. Instructs the notification area to behave according to the version number specified in the <b>uVersion</b> member of the structure pointed to by <i>lpdata</i>. The version number specifies which members are recognized.</para>
      <para>NIM_SETVERSION must be called every time a notification area icon is added (NIM_ADD)&gt;. It does not need to be called with NIM_MOFIDY. The version setting is not persisted once a user logs off.</para>
      <para>For details, see the Remarks section.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the requested version is not supported.</para>
    </returns>
    <remarks>
      <para>As of Windows 2000 (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0</a>), if you set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to NOTIFYICON_VERSION_4 or higher, <b>Shell_NotifyIcon</b> mouse and keyboard events are handled differently than in earlier versions of Windows. The differences include the following:</para>
      <list type="bullet">
        <item>
          <description>If a user selects a notify icon's shortcut menu with the keyboard, the Shell now sends the associated application a <a href="https://docs.microsoft.com//windows/desktop/menurc/wm-contextmenu">WM_CONTEXTMENU</a> message. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the keyboard and activates it with the SPACEBAR or ENTER key, the version 5.0 Shell sends the associated application an NIN_KEYSELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
        <item>
          <description>If a user selects a notify icon with the mouse and activates it with the ENTER key, the Shell now sends the associated application an NIN_SELECT notification. Earlier versions send <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com//windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</description>
        </item>
      </list>
      <para>As of Windows XP (<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 6.0</a>), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Shell sends the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_BALLOONSHOW. Sent when the balloon is shown (balloons are queued).</description>
        </item>
        <item>
          <description>
            <para>NIN_BALLOONHIDE. Sent when the balloon disappears. For example, when the icon is deleted. This message is not sent if the balloon is dismissed because of a timeout or if the user clicks the mouse.</para>
            <para>As of Windows 7, NIN_BALLOONHIDE is also sent when a notification with the <see cref="NIIF_RESPECT_QUIET_TIME" /> flag set attempts to display during quiet time (a user's first hour on a new computer). In that case, the balloon is never displayed at all.</para>
          </description>
        </item>
        <item>
          <description>NIN_BALLOONTIMEOUT. Sent when the balloon is dismissed because of a timeout.</description>
        </item>
        <item>
          <description>NIN_BALLOONUSERCLICK. Sent when the balloon is dismissed because the user clicked the mouse.</description>
        </item>
      </list>
      <para>In addition to those messages, as of Windows Vista (Shell32.dll version 6.0.6), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Windows Vista Shell also adds the following messages:</para>
      <list type="bullet">
        <item>
          <description>NIN_POPUPOPEN. Sent when the user hovers the cursor over an icon to indicate that the richer pop-up UI should be used in place of a standard textual tooltip.</description>
        </item>
        <item>
          <description>NIN_POPUPCLOSE. Sent when a cursor no longer hovers over an icon to indicate that the rich pop-up UI should be closed.</description>
        </item>
      </list>
      <para>Regardless of the operating system version, you can select which way the Shell should behave by calling <b>Shell_NotifyIcon</b> with <i>dwMessage</i> set to <b>NIM_SETVERSION</b>. Set the <b>uVersion</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i> to indicate whether you want Windows 2000, Windows Vista, or pre-version 5.0 (Windows 95) behavior.</para>
      <para>
        <b>Note</b>  The messages discussed above are not conventional Windows messages. They are sent as the <i>lParam</i> value of the application-defined message that is specified in the <b>uCallbackMessage</b> member of the <see cref="NOTIFYICONDATA" /> structure pointed to by <i>lpdata</i>, when <b>Shell_NotifyIcon</b> is called with the <b>NIM_ADD</b> flag set in <i>dwMessage</i>.</para>
      <para>As of Windows XP Service Pack 2 (SP2), a custom icon can be displayed in the notification balloon. This allows the calling process to customize the notification beyond the previously available options of info, warning, and error, and distinguish it from other types of notification for the user.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines Shell_NotifyIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/notification-area">Notifications and the Notification Area</seealso>
  </member>
  <member name="Windows.SHEmptyRecycleBin">
    <summary>
      <para>Empties the Recycle Bin on the specified drive.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window of any dialog boxes that might be displayed during the operation. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string of maximum length MAX_PATH that contains the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names, for example c:\windows\system. It can also contain an empty string or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>One or more of the following values.</para>
      <h4>SHERB_NOCONFIRMATION</h4>
      <para>No dialog box confirming the deletion of the objects will be displayed.</para>
      <h4>SHERB_NOPROGRESSUI</h4>
      <para>No dialog box indicating the progress will be displayed.</para>
      <h4>SHERB_NOSOUND</h4>
      <para>No sound will be played when the operation is complete.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEmptyRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHQueryRecycleBin" />
  </member>
  <member name="Windows.SHEmptyRecycleBinA">
    <summary>
      <para>Empties the Recycle Bin on the specified drive.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window of any dialog boxes that might be displayed during the operation. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string of maximum length MAX_PATH that contains the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names, for example c:\windows\system. It can also contain an empty string or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>One or more of the following values.</para>
      <h4>SHERB_NOCONFIRMATION</h4>
      <para>No dialog box confirming the deletion of the objects will be displayed.</para>
      <h4>SHERB_NOPROGRESSUI</h4>
      <para>No dialog box indicating the progress will be displayed.</para>
      <h4>SHERB_NOSOUND</h4>
      <para>No sound will be played when the operation is complete.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEmptyRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHQueryRecycleBin" />
  </member>
  <member name="Windows.SHEmptyRecycleBinW">
    <summary>
      <para>Empties the Recycle Bin on the specified drive.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window of any dialog boxes that might be displayed during the operation. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string of maximum length MAX_PATH that contains the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names, for example c:\windows\system. It can also contain an empty string or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>One or more of the following values.</para>
      <h4>SHERB_NOCONFIRMATION</h4>
      <para>No dialog box confirming the deletion of the objects will be displayed.</para>
      <h4>SHERB_NOPROGRESSUI</h4>
      <para>No dialog box indicating the progress will be displayed.</para>
      <h4>SHERB_NOSOUND</h4>
      <para>No sound will be played when the operation is complete.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEmptyRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHQueryRecycleBin" />
  </member>
  <member name="Windows.SHEmptyRecycleBin">
    <summary>
      <para>Empties the Recycle Bin on the specified drive.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window of any dialog boxes that might be displayed during the operation. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string of maximum length MAX_PATH that contains the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names, for example c:\windows\system. It can also contain an empty string or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>One or more of the following values.</para>
      <h4>SHERB_NOCONFIRMATION</h4>
      <para>No dialog box confirming the deletion of the objects will be displayed.</para>
      <h4>SHERB_NOPROGRESSUI</h4>
      <para>No dialog box indicating the progress will be displayed.</para>
      <h4>SHERB_NOSOUND</h4>
      <para>No sound will be played when the operation is complete.</para>
      <h5>- dwFlags.SHERB_NOCONFIRMATION</h5>
      <para>No dialog box confirming the deletion of the objects will be displayed.</para>
      <h5>- dwFlags.SHERB_NOPROGRESSUI</h5>
      <para>No dialog box indicating the progress will be displayed.</para>
      <h5>- dwFlags.SHERB_NOSOUND</h5>
      <para>No sound will be played when the operation is complete.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEmptyRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHQueryRecycleBin" />
  </member>
  <member name="Windows.SHEmptyRecycleBinA">
    <summary>
      <para>Empties the Recycle Bin on the specified drive.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window of any dialog boxes that might be displayed during the operation. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string of maximum length MAX_PATH that contains the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names, for example c:\windows\system. It can also contain an empty string or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>One or more of the following values.</para>
      <h4>SHERB_NOCONFIRMATION</h4>
      <para>No dialog box confirming the deletion of the objects will be displayed.</para>
      <h4>SHERB_NOPROGRESSUI</h4>
      <para>No dialog box indicating the progress will be displayed.</para>
      <h4>SHERB_NOSOUND</h4>
      <para>No sound will be played when the operation is complete.</para>
      <h5>- dwFlags.SHERB_NOCONFIRMATION</h5>
      <para>No dialog box confirming the deletion of the objects will be displayed.</para>
      <h5>- dwFlags.SHERB_NOPROGRESSUI</h5>
      <para>No dialog box indicating the progress will be displayed.</para>
      <h5>- dwFlags.SHERB_NOSOUND</h5>
      <para>No sound will be played when the operation is complete.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEmptyRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHQueryRecycleBin" />
  </member>
  <member name="Windows.SHEmptyRecycleBinW">
    <summary>
      <para>Empties the Recycle Bin on the specified drive.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the parent window of any dialog boxes that might be displayed during the operation. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string of maximum length MAX_PATH that contains the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names, for example c:\windows\system. It can also contain an empty string or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>One or more of the following values.</para>
      <h4>SHERB_NOCONFIRMATION</h4>
      <para>No dialog box confirming the deletion of the objects will be displayed.</para>
      <h4>SHERB_NOPROGRESSUI</h4>
      <para>No dialog box indicating the progress will be displayed.</para>
      <h4>SHERB_NOSOUND</h4>
      <para>No sound will be played when the operation is complete.</para>
      <h5>- dwFlags.SHERB_NOCONFIRMATION</h5>
      <para>No dialog box confirming the deletion of the objects will be displayed.</para>
      <h5>- dwFlags.SHERB_NOPROGRESSUI</h5>
      <para>No dialog box indicating the progress will be displayed.</para>
      <h5>- dwFlags.SHERB_NOSOUND</h5>
      <para>No sound will be played when the operation is complete.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEmptyRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHQueryRecycleBin" />
  </member>
  <member name="Windows.SHEnumerateUnreadMailAccounts">
    <summary>
      <para>Enumerates the user accounts that have unread email.</para>
    </summary>
    <param name="hKeyUser">
      <para>Type: <b>HKEY</b></para>
      <para>A valid HKEY for a given user.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the user account.</para>
    </param>
    <param name="pszMailAddress">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a Unicode string that specifies the email address of an account belonging to the specified user.</para>
    </param>
    <param name="cchMailAddress">
      <para>Type: <b>int</b></para>
      <para>The number of characters in the email address.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>The <i>hKeyUser</i> parameter is the HKEY for the root of the user's information, for example <b>HKEY_CURRENT_USER</b>, or any key enumerated under <b>HKEY_USERS</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEnumerateUnreadMailAccounts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumerateUnreadMailAccountsA">
    <summary>
      <para>Enumerates the user accounts that have unread email.</para>
    </summary>
    <param name="hKeyUser">
      <para>Type: <b>HKEY</b></para>
      <para>A valid HKEY for a given user.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the user account.</para>
    </param>
    <param name="pszMailAddress">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a Unicode string that specifies the email address of an account belonging to the specified user.</para>
    </param>
    <param name="cchMailAddress">
      <para>Type: <b>int</b></para>
      <para>The number of characters in the email address.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>The <i>hKeyUser</i> parameter is the HKEY for the root of the user's information, for example <b>HKEY_CURRENT_USER</b>, or any key enumerated under <b>HKEY_USERS</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEnumerateUnreadMailAccounts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumerateUnreadMailAccountsW">
    <summary>
      <para>Enumerates the user accounts that have unread email.</para>
    </summary>
    <param name="hKeyUser">
      <para>Type: <b>HKEY</b></para>
      <para>A valid HKEY for a given user.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the user account.</para>
    </param>
    <param name="pszMailAddress">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a Unicode string that specifies the email address of an account belonging to the specified user.</para>
    </param>
    <param name="cchMailAddress">
      <para>Type: <b>int</b></para>
      <para>The number of characters in the email address.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>The <i>hKeyUser</i> parameter is the HKEY for the root of the user's information, for example <b>HKEY_CURRENT_USER</b>, or any key enumerated under <b>HKEY_USERS</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEnumerateUnreadMailAccounts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumerateUnreadMailAccounts">
    <summary>
      <para>Enumerates the user accounts that have unread email.</para>
    </summary>
    <param name="hKeyUser">
      <para>Type: <b>HKEY</b></para>
      <para>A valid HKEY for a given user.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the user account.</para>
    </param>
    <param name="pszMailAddress">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a Unicode string that specifies the email address of an account belonging to the specified user.</para>
    </param>
    <param name="cchMailAddress">
      <para>Type: <b>int</b></para>
      <para>The number of characters in the email address.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>The <i>hKeyUser</i> parameter is the HKEY for the root of the user's information, for example <b>HKEY_CURRENT_USER</b>, or any key enumerated under <b>HKEY_USERS</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEnumerateUnreadMailAccounts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumerateUnreadMailAccountsA">
    <summary>
      <para>Enumerates the user accounts that have unread email.</para>
    </summary>
    <param name="hKeyUser">
      <para>Type: <b>HKEY</b></para>
      <para>A valid HKEY for a given user.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the user account.</para>
    </param>
    <param name="pszMailAddress">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a Unicode string that specifies the email address of an account belonging to the specified user.</para>
    </param>
    <param name="cchMailAddress">
      <para>Type: <b>int</b></para>
      <para>The number of characters in the email address.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>The <i>hKeyUser</i> parameter is the HKEY for the root of the user's information, for example <b>HKEY_CURRENT_USER</b>, or any key enumerated under <b>HKEY_USERS</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEnumerateUnreadMailAccounts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumerateUnreadMailAccountsW">
    <summary>
      <para>Enumerates the user accounts that have unread email.</para>
    </summary>
    <param name="hKeyUser">
      <para>Type: <b>HKEY</b></para>
      <para>A valid HKEY for a given user.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the user account.</para>
    </param>
    <param name="pszMailAddress">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a Unicode string that specifies the email address of an account belonging to the specified user.</para>
    </param>
    <param name="cchMailAddress">
      <para>Type: <b>int</b></para>
      <para>The number of characters in the email address.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>The <i>hKeyUser</i> parameter is the HKEY for the root of the user's information, for example <b>HKEY_CURRENT_USER</b>, or any key enumerated under <b>HKEY_USERS</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHEnumerateUnreadMailAccounts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEvaluateSystemCommandTemplate">
    <summary>
      <para>Enforces strict validation of parameters used in a call to <see cref="CreateProcess" /> or <see cref="ShellExecute" />.</para>
    </summary>
    <param name="pszCmdTemplate">
      <para>Type: <b>PCWSTR</b></para>
      <para>A command line, which may or may not include parameters. If the parameters are substitution parameters, then <b>SHEvaluateSystemCommandTemplate</b> should be called before parameters have been replaced.</para>
    </param>
    <param name="ppszApplication">
      <para>Type: <b>PWSTR*</b></para>
      <para>A pointer to the verified path to the application. This value should be passed as the <i>lpApplication</i> parameter in a call to <see cref="CreateProcess" /> or as the <i>lpFile</i> parameter in a call to <see cref="ShellExecute" />. This resource is allocated using <see cref="CoTaskMemAlloc" />, and it is the responsibility of the caller to free the resource when it is no longer needed by calling <see cref="CoTaskMemFree" />.</para>
    </param>
    <param name="ppszCommandLine">
      <para>Type: <b>PWSTR*</b></para>
      <para>A pointer to a command-line string template to be used in a call to <see cref="CreateProcess" />. Command-line parameters should be specified based on this template, and then passed as the <i>lpCommandLine</i> parameter to <b>CreateProcess</b>. It is guaranteed to be of a form that <see cref="PathGetArgs" /> can always read correctly. This resource is allocated using <see cref="CoTaskMemAlloc" />, and it is the responsibility of the caller to free the resource when it is no longer needed by calling <see cref="CoTaskMemFree" />.</para>
      <para>This parameter can be <b>NULL</b> if this function is not being used in association with a call to <see cref="CreateProcess" />.</para>
    </param>
    <param name="ppszParameters">
      <para>Type: <b>PWSTR*</b></para>
      <para>A pointer to a command-line string template to be used in a call to <see cref="ShellExecute" />. Command-line parameters should be specified based on this template, and then passed as the <i>lpParameters</i> parameter to <b>ShellExecute</b>. This parameter is identical to calling <see cref="PathGetArgs" />. This resource is allocated using <see cref="CoTaskMemAlloc" />, and it is the responsibility of the caller to free the resource when it is no longer needed by calling <see cref="CoTaskMemFree" />.</para>
      <para>This parameter can be <b>NULL</b> if this function is not being used in association with a call to <see cref="CreateProcess" />.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function is used when a calling process needs the deterministic behavior from a command template, regardless of execution context. It ignores the current process state, such as the <code>%PATH%</code>, <see cref="GetCurrentDirectory" />, and parent process directory.</para>
      <para>This function is used when the command is hard-coded.</para>
      <para>This function is used by <see cref="ShellExecute" /> when handling file associations from HKEY_CLASSES_ROOT. The purpose of this function is to reduce <see cref="CreateProcess" /> command-line exploits. It is not designed for processing user input and if used for that purpose can generate unexpected failures.</para>
    </remarks>
  </member>
  <member name="Windows.SHFileOperation">
    <summary>
      <para>Copies, moves, renames, or deletes a file system object. This function has been replaced in Windows Vista by <see cref="IFileOperation" />.</para>
    </summary>
    <param name="lpFileOp">
      <para>Type: <b>LPSHFILEOPSTRUCT</b></para>
      <para>A pointer to an <see cref="SHFILEOPSTRUCT" /> structure that contains information this function needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>. You are responsible for validating the value. If you do not validate it, you will experience unexpected results.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero.</para>
      <para>It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the <see cref="SHFILEOPSTRUCT" />. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished the full task you asked of it and you might proceed under incorrect assumptions.</para>
      <para>Do not use <see cref="GetLastError" /> with the return values of this function.</para>
      <para>To examine the nonzero values for troubleshooting purposes, they largely map to those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes, which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the Winerror.h codes. However, these values are provided with these warnings:</para>
      <list type="bullet">
        <item>
          <description>These are pre-Win32 error codes and are no longer supported or defined in any public header file. To use them, you must either define them yourself or compare against the numerical value.</description>
        </item>
        <item>
          <description>These error codes are subject to change and have historically done so.</description>
        </item>
        <item>
          <description>These values are provided only as an aid in debugging. They should not be regarded as definitive.</description>
        </item>
      </list>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>DE_SAMEFILE</description>
          <description>0x71</description>
          <description>The source and destination files are the same file.</description>
        </item>
        <item>
          <description>DE_MANYSRC1DEST</description>
          <description>0x72</description>
          <description>Multiple file paths were specified in the source buffer, but only one destination file path.</description>
        </item>
        <item>
          <description>DE_DIFFDIR</description>
          <description>0x73</description>
          <description>Rename operation was specified but the destination path is a different directory. Use the move operation instead.</description>
        </item>
        <item>
          <description>DE_ROOTDIR</description>
          <description>0x74</description>
          <description>The source is a root directory, which cannot be moved or renamed.</description>
        </item>
        <item>
          <description>DE_OPCANCELLED</description>
          <description>0x75</description>
          <description>The operation was canceled by the user, or silently canceled if the appropriate flags were supplied to <b>SHFileOperation</b>.</description>
        </item>
        <item>
          <description>DE_DESTSUBTREE</description>
          <description>0x76</description>
          <description>The destination is a subtree of the source.</description>
        </item>
        <item>
          <description>DE_ACCESSDENIEDSRC</description>
          <description>0x78</description>
          <description>Security settings denied access to the source.</description>
        </item>
        <item>
          <description>DE_PATHTOODEEP</description>
          <description>0x79</description>
          <description>The source or destination path exceeded or would exceed MAX_PATH.</description>
        </item>
        <item>
          <description>DE_MANYDEST</description>
          <description>0x7A</description>
          <description>The operation involved multiple destination paths, which can fail in the case of a move operation.</description>
        </item>
        <item>
          <description>DE_INVALIDFILES</description>
          <description>0x7C</description>
          <description>The path in the source or destination or both was invalid.</description>
        </item>
        <item>
          <description>DE_DESTSAMETREE</description>
          <description>0x7D</description>
          <description>The source and destination have the same parent folder.</description>
        </item>
        <item>
          <description>DE_FLDDESTISFILE</description>
          <description>0x7E</description>
          <description>The destination path is an existing file.</description>
        </item>
        <item>
          <description>DE_FILEDESTISFLD</description>
          <description>0x80</description>
          <description>The destination path is an existing folder.</description>
        </item>
        <item>
          <description>DE_FILENAMETOOLONG</description>
          <description>0x81</description>
          <description>The name of the file exceeds MAX_PATH.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDROM</description>
          <description>0x82</description>
          <description>The destination is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_DVD</description>
          <description>0x83</description>
          <description>The destination is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDRECORD</description>
          <description>0x84</description>
          <description>The destination is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_FILE_TOO_LARGE</description>
          <description>0x85</description>
          <description>The file involved in the operation is too large for the destination media or file system.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDROM</description>
          <description>0x86</description>
          <description>The source is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_DVD</description>
          <description>0x87</description>
          <description>The source is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDRECORD</description>
          <description>0x88</description>
          <description>The source is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_ERROR_MAX</description>
          <description>0xB7</description>
          <description>MAX_PATH was exceeded during the operation.</description>
        </item>
        <item>
          <description></description>
          <description>0x402</description>
          <description>An unknown error occurred. This is typically due to an invalid path in the source or destination. This error does not occur on Windows Vista and later.</description>
        </item>
        <item>
          <description>ERRORONDEST</description>
          <description>0x10000</description>
          <description>An unspecified error occurred on the destination.</description>
        </item>
        <item>
          <description>DE_ROOTDIR | ERRORONDEST</description>
          <description>0x10074</description>
          <description>Destination is a root directory and cannot be renamed.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should use fully qualified path names with this function. Using it with relative path names is not thread safe.</para>
      <para>With two exceptions, you cannot use <b>SHFileOperation</b> to move special folders from a local drive to a remote computer by specifying a network path. The exceptions are the <b>My Documents</b> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>, <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_DOCUMENTS</a>) and <b>My Pictures</b> folders (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>).</para>
      <para>When used to delete a file, <b>SHFileOperation</b> permanently deletes the file unless you set the <b>FOF_ALLOWUNDO</b> flag in the <b>fFlags</b> member of the <see cref="SHFILEOPSTRUCT" /> structure pointed to by <i>lpFileOp</i>. Setting that flag sends the file to the Recycle Bin. If you want to simply delete a file and guarantee that it is not placed in the Recycle Bin, use <see cref="DeleteFile" />.</para>
      <para>If a copy callback handler is exposed and registered, <b>SHFileOperation</b> calls it unless you set a flag such as <b>FOF_NOCONFIRMATION</b> in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>. See <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776048(v=vs.85)">ICopyHook.CopyCallback</a> for details on implementing copy callback handlers.</para>
      <para>File deletion is recursive unless you set the <b>FOF_NORECURSION</b> flag in <i>lpFileOp</i>.</para>
      <h3>Connecting Files</h3>
      <para>With Windows 2000 or later, it is possible to <i>connect</i> an HTML file with a folder that contains related files such as Graphics Interchange Format (GIF) images or style sheets. If file connection is enabled, when you move or copy the HTML file, the connected folder and all of its files are also moved or copied. Conversely, if you move the folder with the related files, the HTML file is also moved.</para>
      <para>The HTML file must have a .htm or .html extension. You create the connection to the related files by placing the folder that contains them into the same folder as the HTML file. The name of the folder that contains the connected files must be the same as the name of the HTML file followed by "_files" or ".files" (this is case sensitive; for example, ".Files" does not work). An example is given here.</para>
      <list type="number">
        <item>
          <description>Create a file named Test.htm in the C:\Files directory (C:\Files\Test.htm).</description>
        </item>
        <item>
          <description>Create a new folder named Test.files in the C:\Files directory (C:\Files\Test.files).</description>
        </item>
        <item>
          <description>Populate the folder with a few files. Any file placed in this folder is connected to Test.htm.</description>
        </item>
        <item>
          <description>Move or copy the Test.htm file to the C:\Files2 directory.</description>
        </item>
        <item>
          <description>Note that the Test.files directory is now found in the C:\Files2 directory as well.</description>
        </item>
      </list>
      <para>File connection is enabled by default. It can be disabled by adding a <b>REG_DWORD</b> entry, NoFileFolderConnection, as shown here:</para>
      <code>
        <b>HKEY_CURRENT_USER</b>
        <b>Software</b>
        <b>Microsoft</b>
        <b>Windows</b>
        <b>CurrentVersion</b>
        <b>Explorer</b>
        <b>NoFileFolderConnection</b>
      </code>
      <para>Setting NoFileFolderConnection to 1 disables file connection. If the value is set to zero or is missing, file connection is enabled.</para>
      <para>To move only the specified files and none of the connected files, set the <b>FOF_NO_CONNECTED_ELEMENTS</b> flag in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>.</para>
      <para>Note that the use of a folder with a name like "MyFile_files" to define a connection may not be valid for localized versions of Windows. The term "files" may need to be replaced by the equivalent word in the local language.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHFileOperation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHFileOperationA">
    <summary>
      <para>Copies, moves, renames, or deletes a file system object. This function has been replaced in Windows Vista by <see cref="IFileOperation" />.</para>
    </summary>
    <param name="lpFileOp">
      <para>Type: <b>LPSHFILEOPSTRUCT</b></para>
      <para>A pointer to an <see cref="SHFILEOPSTRUCT" /> structure that contains information this function needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>. You are responsible for validating the value. If you do not validate it, you will experience unexpected results.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero.</para>
      <para>It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the <see cref="SHFILEOPSTRUCT" />. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished the full task you asked of it and you might proceed under incorrect assumptions.</para>
      <para>Do not use <see cref="GetLastError" /> with the return values of this function.</para>
      <para>To examine the nonzero values for troubleshooting purposes, they largely map to those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes, which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the Winerror.h codes. However, these values are provided with these warnings:</para>
      <list type="bullet">
        <item>
          <description>These are pre-Win32 error codes and are no longer supported or defined in any public header file. To use them, you must either define them yourself or compare against the numerical value.</description>
        </item>
        <item>
          <description>These error codes are subject to change and have historically done so.</description>
        </item>
        <item>
          <description>These values are provided only as an aid in debugging. They should not be regarded as definitive.</description>
        </item>
      </list>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>DE_SAMEFILE</description>
          <description>0x71</description>
          <description>The source and destination files are the same file.</description>
        </item>
        <item>
          <description>DE_MANYSRC1DEST</description>
          <description>0x72</description>
          <description>Multiple file paths were specified in the source buffer, but only one destination file path.</description>
        </item>
        <item>
          <description>DE_DIFFDIR</description>
          <description>0x73</description>
          <description>Rename operation was specified but the destination path is a different directory. Use the move operation instead.</description>
        </item>
        <item>
          <description>DE_ROOTDIR</description>
          <description>0x74</description>
          <description>The source is a root directory, which cannot be moved or renamed.</description>
        </item>
        <item>
          <description>DE_OPCANCELLED</description>
          <description>0x75</description>
          <description>The operation was canceled by the user, or silently canceled if the appropriate flags were supplied to <b>SHFileOperation</b>.</description>
        </item>
        <item>
          <description>DE_DESTSUBTREE</description>
          <description>0x76</description>
          <description>The destination is a subtree of the source.</description>
        </item>
        <item>
          <description>DE_ACCESSDENIEDSRC</description>
          <description>0x78</description>
          <description>Security settings denied access to the source.</description>
        </item>
        <item>
          <description>DE_PATHTOODEEP</description>
          <description>0x79</description>
          <description>The source or destination path exceeded or would exceed MAX_PATH.</description>
        </item>
        <item>
          <description>DE_MANYDEST</description>
          <description>0x7A</description>
          <description>The operation involved multiple destination paths, which can fail in the case of a move operation.</description>
        </item>
        <item>
          <description>DE_INVALIDFILES</description>
          <description>0x7C</description>
          <description>The path in the source or destination or both was invalid.</description>
        </item>
        <item>
          <description>DE_DESTSAMETREE</description>
          <description>0x7D</description>
          <description>The source and destination have the same parent folder.</description>
        </item>
        <item>
          <description>DE_FLDDESTISFILE</description>
          <description>0x7E</description>
          <description>The destination path is an existing file.</description>
        </item>
        <item>
          <description>DE_FILEDESTISFLD</description>
          <description>0x80</description>
          <description>The destination path is an existing folder.</description>
        </item>
        <item>
          <description>DE_FILENAMETOOLONG</description>
          <description>0x81</description>
          <description>The name of the file exceeds MAX_PATH.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDROM</description>
          <description>0x82</description>
          <description>The destination is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_DVD</description>
          <description>0x83</description>
          <description>The destination is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDRECORD</description>
          <description>0x84</description>
          <description>The destination is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_FILE_TOO_LARGE</description>
          <description>0x85</description>
          <description>The file involved in the operation is too large for the destination media or file system.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDROM</description>
          <description>0x86</description>
          <description>The source is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_DVD</description>
          <description>0x87</description>
          <description>The source is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDRECORD</description>
          <description>0x88</description>
          <description>The source is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_ERROR_MAX</description>
          <description>0xB7</description>
          <description>MAX_PATH was exceeded during the operation.</description>
        </item>
        <item>
          <description></description>
          <description>0x402</description>
          <description>An unknown error occurred. This is typically due to an invalid path in the source or destination. This error does not occur on Windows Vista and later.</description>
        </item>
        <item>
          <description>ERRORONDEST</description>
          <description>0x10000</description>
          <description>An unspecified error occurred on the destination.</description>
        </item>
        <item>
          <description>DE_ROOTDIR | ERRORONDEST</description>
          <description>0x10074</description>
          <description>Destination is a root directory and cannot be renamed.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should use fully qualified path names with this function. Using it with relative path names is not thread safe.</para>
      <para>With two exceptions, you cannot use <b>SHFileOperation</b> to move special folders from a local drive to a remote computer by specifying a network path. The exceptions are the <b>My Documents</b> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>, <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_DOCUMENTS</a>) and <b>My Pictures</b> folders (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>).</para>
      <para>When used to delete a file, <b>SHFileOperation</b> permanently deletes the file unless you set the <b>FOF_ALLOWUNDO</b> flag in the <b>fFlags</b> member of the <see cref="SHFILEOPSTRUCT" /> structure pointed to by <i>lpFileOp</i>. Setting that flag sends the file to the Recycle Bin. If you want to simply delete a file and guarantee that it is not placed in the Recycle Bin, use <see cref="DeleteFile" />.</para>
      <para>If a copy callback handler is exposed and registered, <b>SHFileOperation</b> calls it unless you set a flag such as <b>FOF_NOCONFIRMATION</b> in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>. See <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776048(v=vs.85)">ICopyHook.CopyCallback</a> for details on implementing copy callback handlers.</para>
      <para>File deletion is recursive unless you set the <b>FOF_NORECURSION</b> flag in <i>lpFileOp</i>.</para>
      <h3>Connecting Files</h3>
      <para>With Windows 2000 or later, it is possible to <i>connect</i> an HTML file with a folder that contains related files such as Graphics Interchange Format (GIF) images or style sheets. If file connection is enabled, when you move or copy the HTML file, the connected folder and all of its files are also moved or copied. Conversely, if you move the folder with the related files, the HTML file is also moved.</para>
      <para>The HTML file must have a .htm or .html extension. You create the connection to the related files by placing the folder that contains them into the same folder as the HTML file. The name of the folder that contains the connected files must be the same as the name of the HTML file followed by "_files" or ".files" (this is case sensitive; for example, ".Files" does not work). An example is given here.</para>
      <list type="number">
        <item>
          <description>Create a file named Test.htm in the C:\Files directory (C:\Files\Test.htm).</description>
        </item>
        <item>
          <description>Create a new folder named Test.files in the C:\Files directory (C:\Files\Test.files).</description>
        </item>
        <item>
          <description>Populate the folder with a few files. Any file placed in this folder is connected to Test.htm.</description>
        </item>
        <item>
          <description>Move or copy the Test.htm file to the C:\Files2 directory.</description>
        </item>
        <item>
          <description>Note that the Test.files directory is now found in the C:\Files2 directory as well.</description>
        </item>
      </list>
      <para>File connection is enabled by default. It can be disabled by adding a <b>REG_DWORD</b> entry, NoFileFolderConnection, as shown here:</para>
      <code>
        <b>HKEY_CURRENT_USER</b>
        <b>Software</b>
        <b>Microsoft</b>
        <b>Windows</b>
        <b>CurrentVersion</b>
        <b>Explorer</b>
        <b>NoFileFolderConnection</b>
      </code>
      <para>Setting NoFileFolderConnection to 1 disables file connection. If the value is set to zero or is missing, file connection is enabled.</para>
      <para>To move only the specified files and none of the connected files, set the <b>FOF_NO_CONNECTED_ELEMENTS</b> flag in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>.</para>
      <para>Note that the use of a folder with a name like "MyFile_files" to define a connection may not be valid for localized versions of Windows. The term "files" may need to be replaced by the equivalent word in the local language.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHFileOperation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHFileOperationW">
    <summary>
      <para>Copies, moves, renames, or deletes a file system object. This function has been replaced in Windows Vista by <see cref="IFileOperation" />.</para>
    </summary>
    <param name="lpFileOp">
      <para>Type: <b>LPSHFILEOPSTRUCT</b></para>
      <para>A pointer to an <see cref="SHFILEOPSTRUCT" /> structure that contains information this function needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>. You are responsible for validating the value. If you do not validate it, you will experience unexpected results.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero.</para>
      <para>It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the <see cref="SHFILEOPSTRUCT" />. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished the full task you asked of it and you might proceed under incorrect assumptions.</para>
      <para>Do not use <see cref="GetLastError" /> with the return values of this function.</para>
      <para>To examine the nonzero values for troubleshooting purposes, they largely map to those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes, which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the Winerror.h codes. However, these values are provided with these warnings:</para>
      <list type="bullet">
        <item>
          <description>These are pre-Win32 error codes and are no longer supported or defined in any public header file. To use them, you must either define them yourself or compare against the numerical value.</description>
        </item>
        <item>
          <description>These error codes are subject to change and have historically done so.</description>
        </item>
        <item>
          <description>These values are provided only as an aid in debugging. They should not be regarded as definitive.</description>
        </item>
      </list>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>DE_SAMEFILE</description>
          <description>0x71</description>
          <description>The source and destination files are the same file.</description>
        </item>
        <item>
          <description>DE_MANYSRC1DEST</description>
          <description>0x72</description>
          <description>Multiple file paths were specified in the source buffer, but only one destination file path.</description>
        </item>
        <item>
          <description>DE_DIFFDIR</description>
          <description>0x73</description>
          <description>Rename operation was specified but the destination path is a different directory. Use the move operation instead.</description>
        </item>
        <item>
          <description>DE_ROOTDIR</description>
          <description>0x74</description>
          <description>The source is a root directory, which cannot be moved or renamed.</description>
        </item>
        <item>
          <description>DE_OPCANCELLED</description>
          <description>0x75</description>
          <description>The operation was canceled by the user, or silently canceled if the appropriate flags were supplied to <b>SHFileOperation</b>.</description>
        </item>
        <item>
          <description>DE_DESTSUBTREE</description>
          <description>0x76</description>
          <description>The destination is a subtree of the source.</description>
        </item>
        <item>
          <description>DE_ACCESSDENIEDSRC</description>
          <description>0x78</description>
          <description>Security settings denied access to the source.</description>
        </item>
        <item>
          <description>DE_PATHTOODEEP</description>
          <description>0x79</description>
          <description>The source or destination path exceeded or would exceed MAX_PATH.</description>
        </item>
        <item>
          <description>DE_MANYDEST</description>
          <description>0x7A</description>
          <description>The operation involved multiple destination paths, which can fail in the case of a move operation.</description>
        </item>
        <item>
          <description>DE_INVALIDFILES</description>
          <description>0x7C</description>
          <description>The path in the source or destination or both was invalid.</description>
        </item>
        <item>
          <description>DE_DESTSAMETREE</description>
          <description>0x7D</description>
          <description>The source and destination have the same parent folder.</description>
        </item>
        <item>
          <description>DE_FLDDESTISFILE</description>
          <description>0x7E</description>
          <description>The destination path is an existing file.</description>
        </item>
        <item>
          <description>DE_FILEDESTISFLD</description>
          <description>0x80</description>
          <description>The destination path is an existing folder.</description>
        </item>
        <item>
          <description>DE_FILENAMETOOLONG</description>
          <description>0x81</description>
          <description>The name of the file exceeds MAX_PATH.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDROM</description>
          <description>0x82</description>
          <description>The destination is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_DVD</description>
          <description>0x83</description>
          <description>The destination is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDRECORD</description>
          <description>0x84</description>
          <description>The destination is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_FILE_TOO_LARGE</description>
          <description>0x85</description>
          <description>The file involved in the operation is too large for the destination media or file system.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDROM</description>
          <description>0x86</description>
          <description>The source is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_DVD</description>
          <description>0x87</description>
          <description>The source is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDRECORD</description>
          <description>0x88</description>
          <description>The source is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_ERROR_MAX</description>
          <description>0xB7</description>
          <description>MAX_PATH was exceeded during the operation.</description>
        </item>
        <item>
          <description></description>
          <description>0x402</description>
          <description>An unknown error occurred. This is typically due to an invalid path in the source or destination. This error does not occur on Windows Vista and later.</description>
        </item>
        <item>
          <description>ERRORONDEST</description>
          <description>0x10000</description>
          <description>An unspecified error occurred on the destination.</description>
        </item>
        <item>
          <description>DE_ROOTDIR | ERRORONDEST</description>
          <description>0x10074</description>
          <description>Destination is a root directory and cannot be renamed.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should use fully qualified path names with this function. Using it with relative path names is not thread safe.</para>
      <para>With two exceptions, you cannot use <b>SHFileOperation</b> to move special folders from a local drive to a remote computer by specifying a network path. The exceptions are the <b>My Documents</b> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>, <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_DOCUMENTS</a>) and <b>My Pictures</b> folders (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>).</para>
      <para>When used to delete a file, <b>SHFileOperation</b> permanently deletes the file unless you set the <b>FOF_ALLOWUNDO</b> flag in the <b>fFlags</b> member of the <see cref="SHFILEOPSTRUCT" /> structure pointed to by <i>lpFileOp</i>. Setting that flag sends the file to the Recycle Bin. If you want to simply delete a file and guarantee that it is not placed in the Recycle Bin, use <see cref="DeleteFile" />.</para>
      <para>If a copy callback handler is exposed and registered, <b>SHFileOperation</b> calls it unless you set a flag such as <b>FOF_NOCONFIRMATION</b> in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>. See <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776048(v=vs.85)">ICopyHook.CopyCallback</a> for details on implementing copy callback handlers.</para>
      <para>File deletion is recursive unless you set the <b>FOF_NORECURSION</b> flag in <i>lpFileOp</i>.</para>
      <h3>Connecting Files</h3>
      <para>With Windows 2000 or later, it is possible to <i>connect</i> an HTML file with a folder that contains related files such as Graphics Interchange Format (GIF) images or style sheets. If file connection is enabled, when you move or copy the HTML file, the connected folder and all of its files are also moved or copied. Conversely, if you move the folder with the related files, the HTML file is also moved.</para>
      <para>The HTML file must have a .htm or .html extension. You create the connection to the related files by placing the folder that contains them into the same folder as the HTML file. The name of the folder that contains the connected files must be the same as the name of the HTML file followed by "_files" or ".files" (this is case sensitive; for example, ".Files" does not work). An example is given here.</para>
      <list type="number">
        <item>
          <description>Create a file named Test.htm in the C:\Files directory (C:\Files\Test.htm).</description>
        </item>
        <item>
          <description>Create a new folder named Test.files in the C:\Files directory (C:\Files\Test.files).</description>
        </item>
        <item>
          <description>Populate the folder with a few files. Any file placed in this folder is connected to Test.htm.</description>
        </item>
        <item>
          <description>Move or copy the Test.htm file to the C:\Files2 directory.</description>
        </item>
        <item>
          <description>Note that the Test.files directory is now found in the C:\Files2 directory as well.</description>
        </item>
      </list>
      <para>File connection is enabled by default. It can be disabled by adding a <b>REG_DWORD</b> entry, NoFileFolderConnection, as shown here:</para>
      <code>
        <b>HKEY_CURRENT_USER</b>
        <b>Software</b>
        <b>Microsoft</b>
        <b>Windows</b>
        <b>CurrentVersion</b>
        <b>Explorer</b>
        <b>NoFileFolderConnection</b>
      </code>
      <para>Setting NoFileFolderConnection to 1 disables file connection. If the value is set to zero or is missing, file connection is enabled.</para>
      <para>To move only the specified files and none of the connected files, set the <b>FOF_NO_CONNECTED_ELEMENTS</b> flag in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>.</para>
      <para>Note that the use of a folder with a name like "MyFile_files" to define a connection may not be valid for localized versions of Windows. The term "files" may need to be replaced by the equivalent word in the local language.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHFileOperation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHFileOperation">
    <summary>
      <para>Copies, moves, renames, or deletes a file system object. This function has been replaced in Windows Vista by <see cref="IFileOperation" />.</para>
    </summary>
    <param name="lpFileOp">
      <para>Type: <b>LPSHFILEOPSTRUCT</b></para>
      <para>A pointer to an <see cref="SHFILEOPSTRUCT" /> structure that contains information this function needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>. You are responsible for validating the value. If you do not validate it, you will experience unexpected results.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero.</para>
      <para>It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the <see cref="SHFILEOPSTRUCT" />. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished the full task you asked of it and you might proceed under incorrect assumptions.</para>
      <para>Do not use <see cref="GetLastError" /> with the return values of this function.</para>
      <para>To examine the nonzero values for troubleshooting purposes, they largely map to those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes, which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the Winerror.h codes. However, these values are provided with these warnings:</para>
      <list type="bullet">
        <item>
          <description>These are pre-Win32 error codes and are no longer supported or defined in any public header file. To use them, you must either define them yourself or compare against the numerical value.</description>
        </item>
        <item>
          <description>These error codes are subject to change and have historically done so.</description>
        </item>
        <item>
          <description>These values are provided only as an aid in debugging. They should not be regarded as definitive.</description>
        </item>
      </list>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>DE_SAMEFILE</description>
          <description>0x71</description>
          <description>The source and destination files are the same file.</description>
        </item>
        <item>
          <description>DE_MANYSRC1DEST</description>
          <description>0x72</description>
          <description>Multiple file paths were specified in the source buffer, but only one destination file path.</description>
        </item>
        <item>
          <description>DE_DIFFDIR</description>
          <description>0x73</description>
          <description>Rename operation was specified but the destination path is a different directory. Use the move operation instead.</description>
        </item>
        <item>
          <description>DE_ROOTDIR</description>
          <description>0x74</description>
          <description>The source is a root directory, which cannot be moved or renamed.</description>
        </item>
        <item>
          <description>DE_OPCANCELLED</description>
          <description>0x75</description>
          <description>The operation was canceled by the user, or silently canceled if the appropriate flags were supplied to <b>SHFileOperation</b>.</description>
        </item>
        <item>
          <description>DE_DESTSUBTREE</description>
          <description>0x76</description>
          <description>The destination is a subtree of the source.</description>
        </item>
        <item>
          <description>DE_ACCESSDENIEDSRC</description>
          <description>0x78</description>
          <description>Security settings denied access to the source.</description>
        </item>
        <item>
          <description>DE_PATHTOODEEP</description>
          <description>0x79</description>
          <description>The source or destination path exceeded or would exceed MAX_PATH.</description>
        </item>
        <item>
          <description>DE_MANYDEST</description>
          <description>0x7A</description>
          <description>The operation involved multiple destination paths, which can fail in the case of a move operation.</description>
        </item>
        <item>
          <description>DE_INVALIDFILES</description>
          <description>0x7C</description>
          <description>The path in the source or destination or both was invalid.</description>
        </item>
        <item>
          <description>DE_DESTSAMETREE</description>
          <description>0x7D</description>
          <description>The source and destination have the same parent folder.</description>
        </item>
        <item>
          <description>DE_FLDDESTISFILE</description>
          <description>0x7E</description>
          <description>The destination path is an existing file.</description>
        </item>
        <item>
          <description>DE_FILEDESTISFLD</description>
          <description>0x80</description>
          <description>The destination path is an existing folder.</description>
        </item>
        <item>
          <description>DE_FILENAMETOOLONG</description>
          <description>0x81</description>
          <description>The name of the file exceeds MAX_PATH.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDROM</description>
          <description>0x82</description>
          <description>The destination is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_DVD</description>
          <description>0x83</description>
          <description>The destination is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDRECORD</description>
          <description>0x84</description>
          <description>The destination is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_FILE_TOO_LARGE</description>
          <description>0x85</description>
          <description>The file involved in the operation is too large for the destination media or file system.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDROM</description>
          <description>0x86</description>
          <description>The source is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_DVD</description>
          <description>0x87</description>
          <description>The source is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDRECORD</description>
          <description>0x88</description>
          <description>The source is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_ERROR_MAX</description>
          <description>0xB7</description>
          <description>MAX_PATH was exceeded during the operation.</description>
        </item>
        <item>
          <description></description>
          <description>0x402</description>
          <description>An unknown error occurred. This is typically due to an invalid path in the source or destination. This error does not occur on Windows Vista and later.</description>
        </item>
        <item>
          <description>ERRORONDEST</description>
          <description>0x10000</description>
          <description>An unspecified error occurred on the destination.</description>
        </item>
        <item>
          <description>DE_ROOTDIR | ERRORONDEST</description>
          <description>0x10074</description>
          <description>Destination is a root directory and cannot be renamed.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should use fully qualified path names with this function. Using it with relative path names is not thread safe.</para>
      <para>With two exceptions, you cannot use <b>SHFileOperation</b> to move special folders from a local drive to a remote computer by specifying a network path. The exceptions are the <b>My Documents</b> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>, <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_DOCUMENTS</a>) and <b>My Pictures</b> folders (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>).</para>
      <para>When used to delete a file, <b>SHFileOperation</b> permanently deletes the file unless you set the <b>FOF_ALLOWUNDO</b> flag in the <b>fFlags</b> member of the <see cref="SHFILEOPSTRUCT" /> structure pointed to by <i>lpFileOp</i>. Setting that flag sends the file to the Recycle Bin. If you want to simply delete a file and guarantee that it is not placed in the Recycle Bin, use <see cref="DeleteFile" />.</para>
      <para>If a copy callback handler is exposed and registered, <b>SHFileOperation</b> calls it unless you set a flag such as <b>FOF_NOCONFIRMATION</b> in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>. See <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776048(v=vs.85)">ICopyHook.CopyCallback</a> for details on implementing copy callback handlers.</para>
      <para>File deletion is recursive unless you set the <b>FOF_NORECURSION</b> flag in <i>lpFileOp</i>.</para>
      <h3>Connecting Files</h3>
      <para>With Windows 2000 or later, it is possible to <i>connect</i> an HTML file with a folder that contains related files such as Graphics Interchange Format (GIF) images or style sheets. If file connection is enabled, when you move or copy the HTML file, the connected folder and all of its files are also moved or copied. Conversely, if you move the folder with the related files, the HTML file is also moved.</para>
      <para>The HTML file must have a .htm or .html extension. You create the connection to the related files by placing the folder that contains them into the same folder as the HTML file. The name of the folder that contains the connected files must be the same as the name of the HTML file followed by "_files" or ".files" (this is case sensitive; for example, ".Files" does not work). An example is given here.</para>
      <list type="number">
        <item>
          <description>Create a file named Test.htm in the C:\Files directory (C:\Files\Test.htm).</description>
        </item>
        <item>
          <description>Create a new folder named Test.files in the C:\Files directory (C:\Files\Test.files).</description>
        </item>
        <item>
          <description>Populate the folder with a few files. Any file placed in this folder is connected to Test.htm.</description>
        </item>
        <item>
          <description>Move or copy the Test.htm file to the C:\Files2 directory.</description>
        </item>
        <item>
          <description>Note that the Test.files directory is now found in the C:\Files2 directory as well.</description>
        </item>
      </list>
      <para>File connection is enabled by default. It can be disabled by adding a <b>REG_DWORD</b> entry, NoFileFolderConnection, as shown here:</para>
      <code>
        <b>HKEY_CURRENT_USER</b>
        <b>Software</b>
        <b>Microsoft</b>
        <b>Windows</b>
        <b>CurrentVersion</b>
        <b>Explorer</b>
        <b>NoFileFolderConnection</b>
      </code>
      <para>Setting NoFileFolderConnection to 1 disables file connection. If the value is set to zero or is missing, file connection is enabled.</para>
      <para>To move only the specified files and none of the connected files, set the <b>FOF_NO_CONNECTED_ELEMENTS</b> flag in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>.</para>
      <para>Note that the use of a folder with a name like "MyFile_files" to define a connection may not be valid for localized versions of Windows. The term "files" may need to be replaced by the equivalent word in the local language.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHFileOperation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHFileOperationA">
    <summary>
      <para>Copies, moves, renames, or deletes a file system object. This function has been replaced in Windows Vista by <see cref="IFileOperation" />.</para>
    </summary>
    <param name="lpFileOp">
      <para>Type: <b>LPSHFILEOPSTRUCT</b></para>
      <para>A pointer to an <see cref="SHFILEOPSTRUCT" /> structure that contains information this function needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>. You are responsible for validating the value. If you do not validate it, you will experience unexpected results.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero.</para>
      <para>It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the <see cref="SHFILEOPSTRUCT" />. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished the full task you asked of it and you might proceed under incorrect assumptions.</para>
      <para>Do not use <see cref="GetLastError" /> with the return values of this function.</para>
      <para>To examine the nonzero values for troubleshooting purposes, they largely map to those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes, which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the Winerror.h codes. However, these values are provided with these warnings:</para>
      <list type="bullet">
        <item>
          <description>These are pre-Win32 error codes and are no longer supported or defined in any public header file. To use them, you must either define them yourself or compare against the numerical value.</description>
        </item>
        <item>
          <description>These error codes are subject to change and have historically done so.</description>
        </item>
        <item>
          <description>These values are provided only as an aid in debugging. They should not be regarded as definitive.</description>
        </item>
      </list>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>DE_SAMEFILE</description>
          <description>0x71</description>
          <description>The source and destination files are the same file.</description>
        </item>
        <item>
          <description>DE_MANYSRC1DEST</description>
          <description>0x72</description>
          <description>Multiple file paths were specified in the source buffer, but only one destination file path.</description>
        </item>
        <item>
          <description>DE_DIFFDIR</description>
          <description>0x73</description>
          <description>Rename operation was specified but the destination path is a different directory. Use the move operation instead.</description>
        </item>
        <item>
          <description>DE_ROOTDIR</description>
          <description>0x74</description>
          <description>The source is a root directory, which cannot be moved or renamed.</description>
        </item>
        <item>
          <description>DE_OPCANCELLED</description>
          <description>0x75</description>
          <description>The operation was canceled by the user, or silently canceled if the appropriate flags were supplied to <b>SHFileOperation</b>.</description>
        </item>
        <item>
          <description>DE_DESTSUBTREE</description>
          <description>0x76</description>
          <description>The destination is a subtree of the source.</description>
        </item>
        <item>
          <description>DE_ACCESSDENIEDSRC</description>
          <description>0x78</description>
          <description>Security settings denied access to the source.</description>
        </item>
        <item>
          <description>DE_PATHTOODEEP</description>
          <description>0x79</description>
          <description>The source or destination path exceeded or would exceed MAX_PATH.</description>
        </item>
        <item>
          <description>DE_MANYDEST</description>
          <description>0x7A</description>
          <description>The operation involved multiple destination paths, which can fail in the case of a move operation.</description>
        </item>
        <item>
          <description>DE_INVALIDFILES</description>
          <description>0x7C</description>
          <description>The path in the source or destination or both was invalid.</description>
        </item>
        <item>
          <description>DE_DESTSAMETREE</description>
          <description>0x7D</description>
          <description>The source and destination have the same parent folder.</description>
        </item>
        <item>
          <description>DE_FLDDESTISFILE</description>
          <description>0x7E</description>
          <description>The destination path is an existing file.</description>
        </item>
        <item>
          <description>DE_FILEDESTISFLD</description>
          <description>0x80</description>
          <description>The destination path is an existing folder.</description>
        </item>
        <item>
          <description>DE_FILENAMETOOLONG</description>
          <description>0x81</description>
          <description>The name of the file exceeds MAX_PATH.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDROM</description>
          <description>0x82</description>
          <description>The destination is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_DVD</description>
          <description>0x83</description>
          <description>The destination is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDRECORD</description>
          <description>0x84</description>
          <description>The destination is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_FILE_TOO_LARGE</description>
          <description>0x85</description>
          <description>The file involved in the operation is too large for the destination media or file system.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDROM</description>
          <description>0x86</description>
          <description>The source is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_DVD</description>
          <description>0x87</description>
          <description>The source is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDRECORD</description>
          <description>0x88</description>
          <description>The source is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_ERROR_MAX</description>
          <description>0xB7</description>
          <description>MAX_PATH was exceeded during the operation.</description>
        </item>
        <item>
          <description></description>
          <description>0x402</description>
          <description>An unknown error occurred. This is typically due to an invalid path in the source or destination. This error does not occur on Windows Vista and later.</description>
        </item>
        <item>
          <description>ERRORONDEST</description>
          <description>0x10000</description>
          <description>An unspecified error occurred on the destination.</description>
        </item>
        <item>
          <description>DE_ROOTDIR | ERRORONDEST</description>
          <description>0x10074</description>
          <description>Destination is a root directory and cannot be renamed.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should use fully qualified path names with this function. Using it with relative path names is not thread safe.</para>
      <para>With two exceptions, you cannot use <b>SHFileOperation</b> to move special folders from a local drive to a remote computer by specifying a network path. The exceptions are the <b>My Documents</b> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>, <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_DOCUMENTS</a>) and <b>My Pictures</b> folders (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>).</para>
      <para>When used to delete a file, <b>SHFileOperation</b> permanently deletes the file unless you set the <b>FOF_ALLOWUNDO</b> flag in the <b>fFlags</b> member of the <see cref="SHFILEOPSTRUCT" /> structure pointed to by <i>lpFileOp</i>. Setting that flag sends the file to the Recycle Bin. If you want to simply delete a file and guarantee that it is not placed in the Recycle Bin, use <see cref="DeleteFile" />.</para>
      <para>If a copy callback handler is exposed and registered, <b>SHFileOperation</b> calls it unless you set a flag such as <b>FOF_NOCONFIRMATION</b> in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>. See <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776048(v=vs.85)">ICopyHook.CopyCallback</a> for details on implementing copy callback handlers.</para>
      <para>File deletion is recursive unless you set the <b>FOF_NORECURSION</b> flag in <i>lpFileOp</i>.</para>
      <h3>Connecting Files</h3>
      <para>With Windows 2000 or later, it is possible to <i>connect</i> an HTML file with a folder that contains related files such as Graphics Interchange Format (GIF) images or style sheets. If file connection is enabled, when you move or copy the HTML file, the connected folder and all of its files are also moved or copied. Conversely, if you move the folder with the related files, the HTML file is also moved.</para>
      <para>The HTML file must have a .htm or .html extension. You create the connection to the related files by placing the folder that contains them into the same folder as the HTML file. The name of the folder that contains the connected files must be the same as the name of the HTML file followed by "_files" or ".files" (this is case sensitive; for example, ".Files" does not work). An example is given here.</para>
      <list type="number">
        <item>
          <description>Create a file named Test.htm in the C:\Files directory (C:\Files\Test.htm).</description>
        </item>
        <item>
          <description>Create a new folder named Test.files in the C:\Files directory (C:\Files\Test.files).</description>
        </item>
        <item>
          <description>Populate the folder with a few files. Any file placed in this folder is connected to Test.htm.</description>
        </item>
        <item>
          <description>Move or copy the Test.htm file to the C:\Files2 directory.</description>
        </item>
        <item>
          <description>Note that the Test.files directory is now found in the C:\Files2 directory as well.</description>
        </item>
      </list>
      <para>File connection is enabled by default. It can be disabled by adding a <b>REG_DWORD</b> entry, NoFileFolderConnection, as shown here:</para>
      <code>
        <b>HKEY_CURRENT_USER</b>
        <b>Software</b>
        <b>Microsoft</b>
        <b>Windows</b>
        <b>CurrentVersion</b>
        <b>Explorer</b>
        <b>NoFileFolderConnection</b>
      </code>
      <para>Setting NoFileFolderConnection to 1 disables file connection. If the value is set to zero or is missing, file connection is enabled.</para>
      <para>To move only the specified files and none of the connected files, set the <b>FOF_NO_CONNECTED_ELEMENTS</b> flag in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>.</para>
      <para>Note that the use of a folder with a name like "MyFile_files" to define a connection may not be valid for localized versions of Windows. The term "files" may need to be replaced by the equivalent word in the local language.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHFileOperation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHFileOperationW">
    <summary>
      <para>Copies, moves, renames, or deletes a file system object. This function has been replaced in Windows Vista by <see cref="IFileOperation" />.</para>
    </summary>
    <param name="lpFileOp">
      <para>Type: <b>LPSHFILEOPSTRUCT</b></para>
      <para>A pointer to an <see cref="SHFILEOPSTRUCT" /> structure that contains information this function needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>. You are responsible for validating the value. If you do not validate it, you will experience unexpected results.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero.</para>
      <para>It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the <see cref="SHFILEOPSTRUCT" />. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished the full task you asked of it and you might proceed under incorrect assumptions.</para>
      <para>Do not use <see cref="GetLastError" /> with the return values of this function.</para>
      <para>To examine the nonzero values for troubleshooting purposes, they largely map to those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes, which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the Winerror.h codes. However, these values are provided with these warnings:</para>
      <list type="bullet">
        <item>
          <description>These are pre-Win32 error codes and are no longer supported or defined in any public header file. To use them, you must either define them yourself or compare against the numerical value.</description>
        </item>
        <item>
          <description>These error codes are subject to change and have historically done so.</description>
        </item>
        <item>
          <description>These values are provided only as an aid in debugging. They should not be regarded as definitive.</description>
        </item>
      </list>
      <list type="table">
        <listheader>
          <description>Error Code</description>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>DE_SAMEFILE</description>
          <description>0x71</description>
          <description>The source and destination files are the same file.</description>
        </item>
        <item>
          <description>DE_MANYSRC1DEST</description>
          <description>0x72</description>
          <description>Multiple file paths were specified in the source buffer, but only one destination file path.</description>
        </item>
        <item>
          <description>DE_DIFFDIR</description>
          <description>0x73</description>
          <description>Rename operation was specified but the destination path is a different directory. Use the move operation instead.</description>
        </item>
        <item>
          <description>DE_ROOTDIR</description>
          <description>0x74</description>
          <description>The source is a root directory, which cannot be moved or renamed.</description>
        </item>
        <item>
          <description>DE_OPCANCELLED</description>
          <description>0x75</description>
          <description>The operation was canceled by the user, or silently canceled if the appropriate flags were supplied to <b>SHFileOperation</b>.</description>
        </item>
        <item>
          <description>DE_DESTSUBTREE</description>
          <description>0x76</description>
          <description>The destination is a subtree of the source.</description>
        </item>
        <item>
          <description>DE_ACCESSDENIEDSRC</description>
          <description>0x78</description>
          <description>Security settings denied access to the source.</description>
        </item>
        <item>
          <description>DE_PATHTOODEEP</description>
          <description>0x79</description>
          <description>The source or destination path exceeded or would exceed MAX_PATH.</description>
        </item>
        <item>
          <description>DE_MANYDEST</description>
          <description>0x7A</description>
          <description>The operation involved multiple destination paths, which can fail in the case of a move operation.</description>
        </item>
        <item>
          <description>DE_INVALIDFILES</description>
          <description>0x7C</description>
          <description>The path in the source or destination or both was invalid.</description>
        </item>
        <item>
          <description>DE_DESTSAMETREE</description>
          <description>0x7D</description>
          <description>The source and destination have the same parent folder.</description>
        </item>
        <item>
          <description>DE_FLDDESTISFILE</description>
          <description>0x7E</description>
          <description>The destination path is an existing file.</description>
        </item>
        <item>
          <description>DE_FILEDESTISFLD</description>
          <description>0x80</description>
          <description>The destination path is an existing folder.</description>
        </item>
        <item>
          <description>DE_FILENAMETOOLONG</description>
          <description>0x81</description>
          <description>The name of the file exceeds MAX_PATH.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDROM</description>
          <description>0x82</description>
          <description>The destination is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_DVD</description>
          <description>0x83</description>
          <description>The destination is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_DEST_IS_CDRECORD</description>
          <description>0x84</description>
          <description>The destination is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_FILE_TOO_LARGE</description>
          <description>0x85</description>
          <description>The file involved in the operation is too large for the destination media or file system.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDROM</description>
          <description>0x86</description>
          <description>The source is a read-only CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_DVD</description>
          <description>0x87</description>
          <description>The source is a read-only DVD, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_SRC_IS_CDRECORD</description>
          <description>0x88</description>
          <description>The source is a writable CD-ROM, possibly unformatted.</description>
        </item>
        <item>
          <description>DE_ERROR_MAX</description>
          <description>0xB7</description>
          <description>MAX_PATH was exceeded during the operation.</description>
        </item>
        <item>
          <description></description>
          <description>0x402</description>
          <description>An unknown error occurred. This is typically due to an invalid path in the source or destination. This error does not occur on Windows Vista and later.</description>
        </item>
        <item>
          <description>ERRORONDEST</description>
          <description>0x10000</description>
          <description>An unspecified error occurred on the destination.</description>
        </item>
        <item>
          <description>DE_ROOTDIR | ERRORONDEST</description>
          <description>0x10074</description>
          <description>Destination is a root directory and cannot be renamed.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should use fully qualified path names with this function. Using it with relative path names is not thread safe.</para>
      <para>With two exceptions, you cannot use <b>SHFileOperation</b> to move special folders from a local drive to a remote computer by specifying a network path. The exceptions are the <b>My Documents</b> (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_PERSONAL</a>, <a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_DOCUMENTS</a>) and <b>My Pictures</b> folders (<a href="https://docs.microsoft.com//windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>).</para>
      <para>When used to delete a file, <b>SHFileOperation</b> permanently deletes the file unless you set the <b>FOF_ALLOWUNDO</b> flag in the <b>fFlags</b> member of the <see cref="SHFILEOPSTRUCT" /> structure pointed to by <i>lpFileOp</i>. Setting that flag sends the file to the Recycle Bin. If you want to simply delete a file and guarantee that it is not placed in the Recycle Bin, use <see cref="DeleteFile" />.</para>
      <para>If a copy callback handler is exposed and registered, <b>SHFileOperation</b> calls it unless you set a flag such as <b>FOF_NOCONFIRMATION</b> in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>. See <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776048(v=vs.85)">ICopyHook.CopyCallback</a> for details on implementing copy callback handlers.</para>
      <para>File deletion is recursive unless you set the <b>FOF_NORECURSION</b> flag in <i>lpFileOp</i>.</para>
      <h3>Connecting Files</h3>
      <para>With Windows 2000 or later, it is possible to <i>connect</i> an HTML file with a folder that contains related files such as Graphics Interchange Format (GIF) images or style sheets. If file connection is enabled, when you move or copy the HTML file, the connected folder and all of its files are also moved or copied. Conversely, if you move the folder with the related files, the HTML file is also moved.</para>
      <para>The HTML file must have a .htm or .html extension. You create the connection to the related files by placing the folder that contains them into the same folder as the HTML file. The name of the folder that contains the connected files must be the same as the name of the HTML file followed by "_files" or ".files" (this is case sensitive; for example, ".Files" does not work). An example is given here.</para>
      <list type="number">
        <item>
          <description>Create a file named Test.htm in the C:\Files directory (C:\Files\Test.htm).</description>
        </item>
        <item>
          <description>Create a new folder named Test.files in the C:\Files directory (C:\Files\Test.files).</description>
        </item>
        <item>
          <description>Populate the folder with a few files. Any file placed in this folder is connected to Test.htm.</description>
        </item>
        <item>
          <description>Move or copy the Test.htm file to the C:\Files2 directory.</description>
        </item>
        <item>
          <description>Note that the Test.files directory is now found in the C:\Files2 directory as well.</description>
        </item>
      </list>
      <para>File connection is enabled by default. It can be disabled by adding a <b>REG_DWORD</b> entry, NoFileFolderConnection, as shown here:</para>
      <code>
        <b>HKEY_CURRENT_USER</b>
        <b>Software</b>
        <b>Microsoft</b>
        <b>Windows</b>
        <b>CurrentVersion</b>
        <b>Explorer</b>
        <b>NoFileFolderConnection</b>
      </code>
      <para>Setting NoFileFolderConnection to 1 disables file connection. If the value is set to zero or is missing, file connection is enabled.</para>
      <para>To move only the specified files and none of the connected files, set the <b>FOF_NO_CONNECTED_ELEMENTS</b> flag in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>.</para>
      <para>Note that the use of a folder with a name like "MyFile_files" to define a connection may not be valid for localized versions of Windows. The term "files" may need to be replaced by the equivalent word in the local language.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHFileOperation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHFreeNameMappings">
    <summary>
      <para>Frees a file name mapping object that was retrieved by the <see cref="SHFileOperation" /> function.</para>
    </summary>
    <param name="hNameMappings">
      <para>Type: <b>HANDLE</b></para>
      <para>A handle to the file name mapping object to be freed.</para>
    </param>
  </member>
  <member name="Windows.SHGetDiskFreeSpaceEx">
    <summary>
      <para>Retrieves disk space information for a disk volume.</para>
    </summary>
    <param name="pszDirectoryName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A null-terminated string that specifies the volume for which size information is retrieved. This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the current drive.</para>
    </param>
    <param name="pulFreeBytesAvailableToCaller">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes on the volume available to the calling application. If the operating system implements per-user quotas, this value may be less than the total number of free bytes on the volume.</para>
    </param>
    <param name="pulTotalNumberOfBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the total size of the volume, in bytes.</para>
    </param>
    <param name="pulTotalNumberOfFreeBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes of free space on the volume.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The similarly named function <a href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</a> is merely an alias for <b>SHGetDiskFreeSpaceEx</b>. When you call <b>SHGetDiskFreeSpace</b> you actually call this function.</para>
      <para>This function calls the <see cref="GetDiskFreeSpaceEx" /> function if it is available on the operating system. If <b>GetDiskFreeSpaceEx</b> is not available, it is emulated by calling the <see cref="GetDiskFreeSpace" /> function and manipulating the return values. For additional information, see the documentation for <b>GetDiskFreeSpaceEx</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</seealso>
  </member>
  <member name="Windows.SHGetDiskFreeSpaceExA">
    <summary>
      <para>Retrieves disk space information for a disk volume.</para>
    </summary>
    <param name="pszDirectoryName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A null-terminated string that specifies the volume for which size information is retrieved. This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the current drive.</para>
    </param>
    <param name="pulFreeBytesAvailableToCaller">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes on the volume available to the calling application. If the operating system implements per-user quotas, this value may be less than the total number of free bytes on the volume.</para>
    </param>
    <param name="pulTotalNumberOfBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the total size of the volume, in bytes.</para>
    </param>
    <param name="pulTotalNumberOfFreeBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes of free space on the volume.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The similarly named function <a href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</a> is merely an alias for <b>SHGetDiskFreeSpaceEx</b>. When you call <b>SHGetDiskFreeSpace</b> you actually call this function.</para>
      <para>This function calls the <see cref="GetDiskFreeSpaceEx" /> function if it is available on the operating system. If <b>GetDiskFreeSpaceEx</b> is not available, it is emulated by calling the <see cref="GetDiskFreeSpace" /> function and manipulating the return values. For additional information, see the documentation for <b>GetDiskFreeSpaceEx</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</seealso>
  </member>
  <member name="Windows.SHGetDiskFreeSpaceExW">
    <summary>
      <para>Retrieves disk space information for a disk volume.</para>
    </summary>
    <param name="pszDirectoryName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A null-terminated string that specifies the volume for which size information is retrieved. This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the current drive.</para>
    </param>
    <param name="pulFreeBytesAvailableToCaller">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes on the volume available to the calling application. If the operating system implements per-user quotas, this value may be less than the total number of free bytes on the volume.</para>
    </param>
    <param name="pulTotalNumberOfBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the total size of the volume, in bytes.</para>
    </param>
    <param name="pulTotalNumberOfFreeBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes of free space on the volume.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The similarly named function <a href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</a> is merely an alias for <b>SHGetDiskFreeSpaceEx</b>. When you call <b>SHGetDiskFreeSpace</b> you actually call this function.</para>
      <para>This function calls the <see cref="GetDiskFreeSpaceEx" /> function if it is available on the operating system. If <b>GetDiskFreeSpaceEx</b> is not available, it is emulated by calling the <see cref="GetDiskFreeSpace" /> function and manipulating the return values. For additional information, see the documentation for <b>GetDiskFreeSpaceEx</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</seealso>
  </member>
  <member name="Windows.SHGetDiskFreeSpaceEx">
    <summary>
      <para>Retrieves disk space information for a disk volume.</para>
    </summary>
    <param name="pszDirectoryName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A null-terminated string that specifies the volume for which size information is retrieved. This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the current drive.</para>
    </param>
    <param name="pulFreeBytesAvailableToCaller">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes on the volume available to the calling application. If the operating system implements per-user quotas, this value may be less than the total number of free bytes on the volume.</para>
    </param>
    <param name="pulTotalNumberOfBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the total size of the volume, in bytes.</para>
    </param>
    <param name="pulTotalNumberOfFreeBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes of free space on the volume.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The similarly named function <a href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</a> is merely an alias for <b>SHGetDiskFreeSpaceEx</b>. When you call <b>SHGetDiskFreeSpace</b> you actually call this function.</para>
      <para>This function calls the <see cref="GetDiskFreeSpaceEx" /> function if it is available on the operating system. If <b>GetDiskFreeSpaceEx</b> is not available, it is emulated by calling the <see cref="GetDiskFreeSpace" /> function and manipulating the return values. For additional information, see the documentation for <b>GetDiskFreeSpaceEx</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</seealso>
  </member>
  <member name="Windows.SHGetDiskFreeSpaceExA">
    <summary>
      <para>Retrieves disk space information for a disk volume.</para>
    </summary>
    <param name="pszDirectoryName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A null-terminated string that specifies the volume for which size information is retrieved. This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the current drive.</para>
    </param>
    <param name="pulFreeBytesAvailableToCaller">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes on the volume available to the calling application. If the operating system implements per-user quotas, this value may be less than the total number of free bytes on the volume.</para>
    </param>
    <param name="pulTotalNumberOfBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the total size of the volume, in bytes.</para>
    </param>
    <param name="pulTotalNumberOfFreeBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes of free space on the volume.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The similarly named function <a href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</a> is merely an alias for <b>SHGetDiskFreeSpaceEx</b>. When you call <b>SHGetDiskFreeSpace</b> you actually call this function.</para>
      <para>This function calls the <see cref="GetDiskFreeSpaceEx" /> function if it is available on the operating system. If <b>GetDiskFreeSpaceEx</b> is not available, it is emulated by calling the <see cref="GetDiskFreeSpace" /> function and manipulating the return values. For additional information, see the documentation for <b>GetDiskFreeSpaceEx</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</seealso>
  </member>
  <member name="Windows.SHGetDiskFreeSpaceExW">
    <summary>
      <para>Retrieves disk space information for a disk volume.</para>
    </summary>
    <param name="pszDirectoryName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A null-terminated string that specifies the volume for which size information is retrieved. This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the current drive.</para>
    </param>
    <param name="pulFreeBytesAvailableToCaller">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes on the volume available to the calling application. If the operating system implements per-user quotas, this value may be less than the total number of free bytes on the volume.</para>
    </param>
    <param name="pulTotalNumberOfBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the total size of the volume, in bytes.</para>
    </param>
    <param name="pulTotalNumberOfFreeBytes">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>Pointer to a value that receives the number of bytes of free space on the volume.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The similarly named function <a href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</a> is merely an alias for <b>SHGetDiskFreeSpaceEx</b>. When you call <b>SHGetDiskFreeSpace</b> you actually call this function.</para>
      <para>This function calls the <see cref="GetDiskFreeSpaceEx" /> function if it is available on the operating system. If <b>GetDiskFreeSpaceEx</b> is not available, it is emulated by calling the <see cref="GetDiskFreeSpace" /> function and manipulating the return values. For additional information, see the documentation for <b>GetDiskFreeSpaceEx</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetDiskFreeSpaceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</seealso>
  </member>
  <member name="Windows.SHGetDriveMedia">
    <summary>
      <para>Returns the type of media that is in the given drive.</para>
    </summary>
    <param name="pszDrive">
      <para>Type: <b>PCWSTR</b></para>
      <para>The drive in which to check the media type.</para>
    </param>
    <param name="pdwMediaContent">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to the type of media in the given drive. A combination of <see cref="ARCONTENT" /> flags.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.SHGetFileInfo">
    <summary>
      <para>Retrieves information about an object in the file system, such as a file, folder, directory, or drive root.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the path and file name. Both absolute and relative paths are valid.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_PIDL</b> flag, this parameter must be the address of an <see cref="ITEMIDLIST" /> (PIDL) structure that contains the list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully qualified PIDL. Relative PIDLs are not allowed.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will proceed as if the file exists with the specified name and with the file attributes passed in the <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>.</para>
      <para>This string can use either short (the 8.3 form) or long file names.</para>
    </param>
    <param name="dwFileAttributes">
      <para>Type: <b>DWORD</b></para>
      <para>A combination of one or more <a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">file attribute flags</a> (FILE_ATTRIBUTE_ values as defined in Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.</para>
    </param>
    <param name="psfi">
      <para>Type: <b><see cref="SHFILEINFO" />*</b></para>
      <para>Pointer to a <see cref="SHFILEINFO" /> structure to receive the file information.</para>
    </param>
    <param name="cbFileInfo">
      <para>Type: <b>UINT</b></para>
      <para>The size, in bytes, of the <see cref="SHFILEINFO" /> structure pointed to by the <i>psfi</i> parameter.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The flags that specify the file information to retrieve. This parameter can be a combination of the following values.</para>
      <h4>SHGFI_ADDOVERLAYS (0x000000020)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Apply the appropriate overlays to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_ATTR_SPECIFIED (0x000020000)</h4>
      <para>Modify <b>SHGFI_ATTRIBUTES</b> to indicate that the <b>dwAttributes</b> member of the <see cref="SHFILEINFO" /> structure at <i>psfi</i> contains the specific attributes that are desired. These attributes are passed to <see cref="IShellFolder.GetAttributesOf" />. If this flag is not specified, 0xFFFFFFFF is passed to <b>IShellFolder.GetAttributesOf</b>, requesting all attributes. This flag cannot be specified with the <b>SHGFI_ICON</b> flag.</para>
      <h4>SHGFI_ATTRIBUTES (0x000000800)</h4>
      <para>Retrieve the item attributes. The attributes are copied to the <b>dwAttributes</b> member of the structure specified in the <i>psfi</i> parameter. These are the same attributes that are obtained from <see cref="IShellFolder.GetAttributesOf" />.</para>
      <h4>SHGFI_DISPLAYNAME (0x000000200)</h4>
      <para>Retrieve the display name for the file, which is the name as it appears in Windows Explorer. The name is copied to the <b>szDisplayName</b> member of the structure specified in <i>psfi</i>. The returned display name uses the long file name, if there is one, rather than the 8.3 form of the file name. Note that the display name can be affected by settings such as whether extensions are shown.</para>
      <h4>SHGFI_EXETYPE (0x000002000)</h4>
      <para>Retrieve the type of the executable file if <i>pszPath</i> identifies an executable file. The information is packed into the return value. This flag cannot be specified with any other flags.</para>
      <h4>SHGFI_ICON (0x000000100)</h4>
      <para>Retrieve the handle to the icon that represents the file and the index of the icon within the system image list. The handle is copied to the <b>hIcon</b> member of the structure specified by <i>psfi</i>, and the index is copied to the <b>iIcon</b> member.</para>
      <h4>SHGFI_ICONLOCATION (0x000001000)</h4>
      <para>Retrieve the name of the file that contains the icon representing the file specified by <i>pszPath</i>, as returned by the <see cref="IExtractIcon.GetIconLocation" /> method of the file's icon handler. Also retrieve the icon index within that file. The name of the file containing the icon is copied to the <b>szDisplayName</b> member of the structure specified by <i>psfi</i>. The icon's index is copied to that structure's <b>iIcon</b> member.</para>
      <h4>SHGFI_LARGEICON (0x000000000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's large icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_LINKOVERLAY (0x000008000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to add the link overlay to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_OPENICON (0x000000002)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's open icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains the file's small open icon. A container object displays an open icon to indicate that the container is open. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_OVERLAYINDEX (0x000000040)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Return the index of the overlay icon. The value of the overlay index is returned in the upper eight bits of the <b>iIcon</b> member of the structure specified by <i>psfi</i>. This flag requires that the <b>SHGFI_ICON</b> be set as well.</para>
      <h4>SHGFI_PIDL (0x000000008)</h4>
      <para>Indicate that <i>pszPath</i> is the address of an <see cref="ITEMIDLIST" /> structure rather than a path name.</para>
      <h4>SHGFI_SELECTED (0x000010000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to blend the file's icon with the system highlight color. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SHELLICONSIZE (0x000000004)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve a Shell-sized icon. If this flag is not specified the function sizes the icon according to the system metric values. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SMALLICON (0x000000001)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's small icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains small icon images. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_SYSICONINDEX (0x000004000)</h4>
      <para>Retrieve the index of a system image list icon. If successful, the index is copied to the <b>iIcon</b> member of <i>psfi</i>. The return value is a handle to the system image list. Only those images whose indices are successfully copied to <b>iIcon</b> are valid. Attempting to access other images in the system image list will result in undefined behavior.</para>
      <h4>SHGFI_TYPENAME (0x000000400)</h4>
      <para>Retrieve the string that describes the file's type. The string is copied to the <b>szTypeName</b> member of the structure specified in <i>psfi</i>.</para>
      <h4>SHGFI_USEFILEATTRIBUTES (0x000000010)</h4>
      <para>Indicates that the function should not attempt to access the file specified by <i>pszPath</i>. Rather, it should act as if the file specified by <i>pszPath</i> exists with the file attributes passed in <i>dwFileAttributes</i>. This flag cannot be combined with the <b>SHGFI_ATTRIBUTES</b>, <b>SHGFI_EXETYPE</b>, or <b>SHGFI_PIDL</b> flags.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD_PTR</b></para>
      <para>Returns a value whose meaning depends on the <i>uFlags</i> parameter.</para>
      <para>If <i>uFlags</i> does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or zero otherwise.</para>
      <para>If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of the executable file. It will be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>Nonexecutable file or an error condition.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = NE or PE and HIWORD = Windows version</b>
            </para>
          </description>
          <description>
            <para>Windows application.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = MZ and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>MS-DOS .exe or .com file</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = PE and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>Console application or .bat file</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should call this function from a background thread. Failure to do so could cause the UI to stop responding.</para>
      <para>If <b>SHGetFileInfo</b> returns an icon handle in the <b>hIcon</b> member of the <see cref="SHFILEINFO" /> structure pointed to by <i>psfi</i>, you are responsible for freeing it with <see cref="DestroyIcon" /> when you no longer need it.</para>
      <para>
        <b>Note</b>  Once you have a handle to a system image list, you can use the <a href="https://docs.microsoft.com//windows/desktop/Controls/image-lists">Image List API</a> to manipulate it like any other image list. Because system image lists are created on a per-process basis, you should treat them as read-only objects. Writing to a system image list may overwrite or delete one of the system images, making it unavailable or incorrect for the remainder of the process.</para>
      <para>You must initialize Component Object Model (COM) with <see cref="CoInitialize" /> or <see cref="OleInitialize" /> prior to calling <b>SHGetFileInfo</b>.</para>
      <para>When you use the <b>SHGFI_EXETYPE</b> flag with a Windows application, the Windows version of the executable is given in the HIWORD of the return value. This version is returned as a hexadecimal value. For details on equating this value with a specific Windows version, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFileInfo</b> to retrieve the display name of the Recycle Bin, identified by its PIDL.</para>
      <code>LPITEMIDLIST pidl = NULL;
hr = SHGetFolderLocation(NULL, CSIDL_BITBUCKET, NULL, 0, &amp;amp;amp;amp;amp;amp;pidl);

if (SUCCEEDED(hr))
{
    SHFILEINFOW sfi = {0};
    hr = SHGetFileInfo((LPCTSTR)pidl,
                        -1,
                        &amp;amp;amp;amp;amp;amp;sfi,
                        sizeof(sfi),
                        SHGFI_PIDL | SHGFI_DISPLAYNAME)

    if (SUCCEEDED(hr))
    {
        // The display name is now held in sfi.szDisplayName.
    }
}

ILFree(pidl);
</code>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetFileInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/fileiconinit">FileIconInit</seealso>
  </member>
  <member name="Windows.SHGetFileInfoA">
    <summary>
      <para>Retrieves information about an object in the file system, such as a file, folder, directory, or drive root.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the path and file name. Both absolute and relative paths are valid.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_PIDL</b> flag, this parameter must be the address of an <see cref="ITEMIDLIST" /> (PIDL) structure that contains the list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully qualified PIDL. Relative PIDLs are not allowed.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will proceed as if the file exists with the specified name and with the file attributes passed in the <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>.</para>
      <para>This string can use either short (the 8.3 form) or long file names.</para>
    </param>
    <param name="dwFileAttributes">
      <para>Type: <b>DWORD</b></para>
      <para>A combination of one or more <a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">file attribute flags</a> (FILE_ATTRIBUTE_ values as defined in Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.</para>
    </param>
    <param name="psfi">
      <para>Type: <b><see cref="SHFILEINFO" />*</b></para>
      <para>Pointer to a <see cref="SHFILEINFO" /> structure to receive the file information.</para>
    </param>
    <param name="cbFileInfo">
      <para>Type: <b>UINT</b></para>
      <para>The size, in bytes, of the <see cref="SHFILEINFO" /> structure pointed to by the <i>psfi</i> parameter.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The flags that specify the file information to retrieve. This parameter can be a combination of the following values.</para>
      <h4>SHGFI_ADDOVERLAYS (0x000000020)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Apply the appropriate overlays to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_ATTR_SPECIFIED (0x000020000)</h4>
      <para>Modify <b>SHGFI_ATTRIBUTES</b> to indicate that the <b>dwAttributes</b> member of the <see cref="SHFILEINFO" /> structure at <i>psfi</i> contains the specific attributes that are desired. These attributes are passed to <see cref="IShellFolder.GetAttributesOf" />. If this flag is not specified, 0xFFFFFFFF is passed to <b>IShellFolder.GetAttributesOf</b>, requesting all attributes. This flag cannot be specified with the <b>SHGFI_ICON</b> flag.</para>
      <h4>SHGFI_ATTRIBUTES (0x000000800)</h4>
      <para>Retrieve the item attributes. The attributes are copied to the <b>dwAttributes</b> member of the structure specified in the <i>psfi</i> parameter. These are the same attributes that are obtained from <see cref="IShellFolder.GetAttributesOf" />.</para>
      <h4>SHGFI_DISPLAYNAME (0x000000200)</h4>
      <para>Retrieve the display name for the file, which is the name as it appears in Windows Explorer. The name is copied to the <b>szDisplayName</b> member of the structure specified in <i>psfi</i>. The returned display name uses the long file name, if there is one, rather than the 8.3 form of the file name. Note that the display name can be affected by settings such as whether extensions are shown.</para>
      <h4>SHGFI_EXETYPE (0x000002000)</h4>
      <para>Retrieve the type of the executable file if <i>pszPath</i> identifies an executable file. The information is packed into the return value. This flag cannot be specified with any other flags.</para>
      <h4>SHGFI_ICON (0x000000100)</h4>
      <para>Retrieve the handle to the icon that represents the file and the index of the icon within the system image list. The handle is copied to the <b>hIcon</b> member of the structure specified by <i>psfi</i>, and the index is copied to the <b>iIcon</b> member.</para>
      <h4>SHGFI_ICONLOCATION (0x000001000)</h4>
      <para>Retrieve the name of the file that contains the icon representing the file specified by <i>pszPath</i>, as returned by the <see cref="IExtractIcon.GetIconLocation" /> method of the file's icon handler. Also retrieve the icon index within that file. The name of the file containing the icon is copied to the <b>szDisplayName</b> member of the structure specified by <i>psfi</i>. The icon's index is copied to that structure's <b>iIcon</b> member.</para>
      <h4>SHGFI_LARGEICON (0x000000000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's large icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_LINKOVERLAY (0x000008000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to add the link overlay to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_OPENICON (0x000000002)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's open icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains the file's small open icon. A container object displays an open icon to indicate that the container is open. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_OVERLAYINDEX (0x000000040)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Return the index of the overlay icon. The value of the overlay index is returned in the upper eight bits of the <b>iIcon</b> member of the structure specified by <i>psfi</i>. This flag requires that the <b>SHGFI_ICON</b> be set as well.</para>
      <h4>SHGFI_PIDL (0x000000008)</h4>
      <para>Indicate that <i>pszPath</i> is the address of an <see cref="ITEMIDLIST" /> structure rather than a path name.</para>
      <h4>SHGFI_SELECTED (0x000010000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to blend the file's icon with the system highlight color. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SHELLICONSIZE (0x000000004)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve a Shell-sized icon. If this flag is not specified the function sizes the icon according to the system metric values. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SMALLICON (0x000000001)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's small icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains small icon images. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_SYSICONINDEX (0x000004000)</h4>
      <para>Retrieve the index of a system image list icon. If successful, the index is copied to the <b>iIcon</b> member of <i>psfi</i>. The return value is a handle to the system image list. Only those images whose indices are successfully copied to <b>iIcon</b> are valid. Attempting to access other images in the system image list will result in undefined behavior.</para>
      <h4>SHGFI_TYPENAME (0x000000400)</h4>
      <para>Retrieve the string that describes the file's type. The string is copied to the <b>szTypeName</b> member of the structure specified in <i>psfi</i>.</para>
      <h4>SHGFI_USEFILEATTRIBUTES (0x000000010)</h4>
      <para>Indicates that the function should not attempt to access the file specified by <i>pszPath</i>. Rather, it should act as if the file specified by <i>pszPath</i> exists with the file attributes passed in <i>dwFileAttributes</i>. This flag cannot be combined with the <b>SHGFI_ATTRIBUTES</b>, <b>SHGFI_EXETYPE</b>, or <b>SHGFI_PIDL</b> flags.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD_PTR</b></para>
      <para>Returns a value whose meaning depends on the <i>uFlags</i> parameter.</para>
      <para>If <i>uFlags</i> does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or zero otherwise.</para>
      <para>If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of the executable file. It will be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>Nonexecutable file or an error condition.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = NE or PE and HIWORD = Windows version</b>
            </para>
          </description>
          <description>
            <para>Windows application.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = MZ and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>MS-DOS .exe or .com file</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = PE and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>Console application or .bat file</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should call this function from a background thread. Failure to do so could cause the UI to stop responding.</para>
      <para>If <b>SHGetFileInfo</b> returns an icon handle in the <b>hIcon</b> member of the <see cref="SHFILEINFO" /> structure pointed to by <i>psfi</i>, you are responsible for freeing it with <see cref="DestroyIcon" /> when you no longer need it.</para>
      <para>
        <b>Note</b>  Once you have a handle to a system image list, you can use the <a href="https://docs.microsoft.com//windows/desktop/Controls/image-lists">Image List API</a> to manipulate it like any other image list. Because system image lists are created on a per-process basis, you should treat them as read-only objects. Writing to a system image list may overwrite or delete one of the system images, making it unavailable or incorrect for the remainder of the process.</para>
      <para>You must initialize Component Object Model (COM) with <see cref="CoInitialize" /> or <see cref="OleInitialize" /> prior to calling <b>SHGetFileInfo</b>.</para>
      <para>When you use the <b>SHGFI_EXETYPE</b> flag with a Windows application, the Windows version of the executable is given in the HIWORD of the return value. This version is returned as a hexadecimal value. For details on equating this value with a specific Windows version, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFileInfo</b> to retrieve the display name of the Recycle Bin, identified by its PIDL.</para>
      <code>LPITEMIDLIST pidl = NULL;
hr = SHGetFolderLocation(NULL, CSIDL_BITBUCKET, NULL, 0, &amp;amp;amp;amp;amp;amp;pidl);

if (SUCCEEDED(hr))
{
    SHFILEINFOW sfi = {0};
    hr = SHGetFileInfo((LPCTSTR)pidl,
                        -1,
                        &amp;amp;amp;amp;amp;amp;sfi,
                        sizeof(sfi),
                        SHGFI_PIDL | SHGFI_DISPLAYNAME)

    if (SUCCEEDED(hr))
    {
        // The display name is now held in sfi.szDisplayName.
    }
}

ILFree(pidl);
</code>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetFileInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/fileiconinit">FileIconInit</seealso>
  </member>
  <member name="Windows.SHGetFileInfoW">
    <summary>
      <para>Retrieves information about an object in the file system, such as a file, folder, directory, or drive root.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the path and file name. Both absolute and relative paths are valid.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_PIDL</b> flag, this parameter must be the address of an <see cref="ITEMIDLIST" /> (PIDL) structure that contains the list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully qualified PIDL. Relative PIDLs are not allowed.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will proceed as if the file exists with the specified name and with the file attributes passed in the <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>.</para>
      <para>This string can use either short (the 8.3 form) or long file names.</para>
    </param>
    <param name="dwFileAttributes">
      <para>Type: <b>DWORD</b></para>
      <para>A combination of one or more <a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">file attribute flags</a> (FILE_ATTRIBUTE_ values as defined in Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.</para>
    </param>
    <param name="psfi">
      <para>Type: <b><see cref="SHFILEINFO" />*</b></para>
      <para>Pointer to a <see cref="SHFILEINFO" /> structure to receive the file information.</para>
    </param>
    <param name="cbFileInfo">
      <para>Type: <b>UINT</b></para>
      <para>The size, in bytes, of the <see cref="SHFILEINFO" /> structure pointed to by the <i>psfi</i> parameter.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The flags that specify the file information to retrieve. This parameter can be a combination of the following values.</para>
      <h4>SHGFI_ADDOVERLAYS (0x000000020)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Apply the appropriate overlays to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_ATTR_SPECIFIED (0x000020000)</h4>
      <para>Modify <b>SHGFI_ATTRIBUTES</b> to indicate that the <b>dwAttributes</b> member of the <see cref="SHFILEINFO" /> structure at <i>psfi</i> contains the specific attributes that are desired. These attributes are passed to <see cref="IShellFolder.GetAttributesOf" />. If this flag is not specified, 0xFFFFFFFF is passed to <b>IShellFolder.GetAttributesOf</b>, requesting all attributes. This flag cannot be specified with the <b>SHGFI_ICON</b> flag.</para>
      <h4>SHGFI_ATTRIBUTES (0x000000800)</h4>
      <para>Retrieve the item attributes. The attributes are copied to the <b>dwAttributes</b> member of the structure specified in the <i>psfi</i> parameter. These are the same attributes that are obtained from <see cref="IShellFolder.GetAttributesOf" />.</para>
      <h4>SHGFI_DISPLAYNAME (0x000000200)</h4>
      <para>Retrieve the display name for the file, which is the name as it appears in Windows Explorer. The name is copied to the <b>szDisplayName</b> member of the structure specified in <i>psfi</i>. The returned display name uses the long file name, if there is one, rather than the 8.3 form of the file name. Note that the display name can be affected by settings such as whether extensions are shown.</para>
      <h4>SHGFI_EXETYPE (0x000002000)</h4>
      <para>Retrieve the type of the executable file if <i>pszPath</i> identifies an executable file. The information is packed into the return value. This flag cannot be specified with any other flags.</para>
      <h4>SHGFI_ICON (0x000000100)</h4>
      <para>Retrieve the handle to the icon that represents the file and the index of the icon within the system image list. The handle is copied to the <b>hIcon</b> member of the structure specified by <i>psfi</i>, and the index is copied to the <b>iIcon</b> member.</para>
      <h4>SHGFI_ICONLOCATION (0x000001000)</h4>
      <para>Retrieve the name of the file that contains the icon representing the file specified by <i>pszPath</i>, as returned by the <see cref="IExtractIcon.GetIconLocation" /> method of the file's icon handler. Also retrieve the icon index within that file. The name of the file containing the icon is copied to the <b>szDisplayName</b> member of the structure specified by <i>psfi</i>. The icon's index is copied to that structure's <b>iIcon</b> member.</para>
      <h4>SHGFI_LARGEICON (0x000000000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's large icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_LINKOVERLAY (0x000008000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to add the link overlay to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_OPENICON (0x000000002)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's open icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains the file's small open icon. A container object displays an open icon to indicate that the container is open. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_OVERLAYINDEX (0x000000040)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Return the index of the overlay icon. The value of the overlay index is returned in the upper eight bits of the <b>iIcon</b> member of the structure specified by <i>psfi</i>. This flag requires that the <b>SHGFI_ICON</b> be set as well.</para>
      <h4>SHGFI_PIDL (0x000000008)</h4>
      <para>Indicate that <i>pszPath</i> is the address of an <see cref="ITEMIDLIST" /> structure rather than a path name.</para>
      <h4>SHGFI_SELECTED (0x000010000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to blend the file's icon with the system highlight color. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SHELLICONSIZE (0x000000004)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve a Shell-sized icon. If this flag is not specified the function sizes the icon according to the system metric values. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SMALLICON (0x000000001)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's small icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains small icon images. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_SYSICONINDEX (0x000004000)</h4>
      <para>Retrieve the index of a system image list icon. If successful, the index is copied to the <b>iIcon</b> member of <i>psfi</i>. The return value is a handle to the system image list. Only those images whose indices are successfully copied to <b>iIcon</b> are valid. Attempting to access other images in the system image list will result in undefined behavior.</para>
      <h4>SHGFI_TYPENAME (0x000000400)</h4>
      <para>Retrieve the string that describes the file's type. The string is copied to the <b>szTypeName</b> member of the structure specified in <i>psfi</i>.</para>
      <h4>SHGFI_USEFILEATTRIBUTES (0x000000010)</h4>
      <para>Indicates that the function should not attempt to access the file specified by <i>pszPath</i>. Rather, it should act as if the file specified by <i>pszPath</i> exists with the file attributes passed in <i>dwFileAttributes</i>. This flag cannot be combined with the <b>SHGFI_ATTRIBUTES</b>, <b>SHGFI_EXETYPE</b>, or <b>SHGFI_PIDL</b> flags.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD_PTR</b></para>
      <para>Returns a value whose meaning depends on the <i>uFlags</i> parameter.</para>
      <para>If <i>uFlags</i> does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or zero otherwise.</para>
      <para>If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of the executable file. It will be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>Nonexecutable file or an error condition.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = NE or PE and HIWORD = Windows version</b>
            </para>
          </description>
          <description>
            <para>Windows application.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = MZ and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>MS-DOS .exe or .com file</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = PE and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>Console application or .bat file</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should call this function from a background thread. Failure to do so could cause the UI to stop responding.</para>
      <para>If <b>SHGetFileInfo</b> returns an icon handle in the <b>hIcon</b> member of the <see cref="SHFILEINFO" /> structure pointed to by <i>psfi</i>, you are responsible for freeing it with <see cref="DestroyIcon" /> when you no longer need it.</para>
      <para>
        <b>Note</b>  Once you have a handle to a system image list, you can use the <a href="https://docs.microsoft.com//windows/desktop/Controls/image-lists">Image List API</a> to manipulate it like any other image list. Because system image lists are created on a per-process basis, you should treat them as read-only objects. Writing to a system image list may overwrite or delete one of the system images, making it unavailable or incorrect for the remainder of the process.</para>
      <para>You must initialize Component Object Model (COM) with <see cref="CoInitialize" /> or <see cref="OleInitialize" /> prior to calling <b>SHGetFileInfo</b>.</para>
      <para>When you use the <b>SHGFI_EXETYPE</b> flag with a Windows application, the Windows version of the executable is given in the HIWORD of the return value. This version is returned as a hexadecimal value. For details on equating this value with a specific Windows version, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFileInfo</b> to retrieve the display name of the Recycle Bin, identified by its PIDL.</para>
      <code>LPITEMIDLIST pidl = NULL;
hr = SHGetFolderLocation(NULL, CSIDL_BITBUCKET, NULL, 0, &amp;amp;amp;amp;amp;amp;pidl);

if (SUCCEEDED(hr))
{
    SHFILEINFOW sfi = {0};
    hr = SHGetFileInfo((LPCTSTR)pidl,
                        -1,
                        &amp;amp;amp;amp;amp;amp;sfi,
                        sizeof(sfi),
                        SHGFI_PIDL | SHGFI_DISPLAYNAME)

    if (SUCCEEDED(hr))
    {
        // The display name is now held in sfi.szDisplayName.
    }
}

ILFree(pidl);
</code>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetFileInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/fileiconinit">FileIconInit</seealso>
  </member>
  <member name="Windows.SHGetFileInfo">
    <summary>
      <para>Retrieves information about an object in the file system, such as a file, folder, directory, or drive root.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the path and file name. Both absolute and relative paths are valid.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_PIDL</b> flag, this parameter must be the address of an <see cref="ITEMIDLIST" /> (PIDL) structure that contains the list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully qualified PIDL. Relative PIDLs are not allowed.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will proceed as if the file exists with the specified name and with the file attributes passed in the <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>.</para>
      <para>This string can use either short (the 8.3 form) or long file names.</para>
    </param>
    <param name="dwFileAttributes">
      <para>Type: <b>DWORD</b></para>
      <para>A combination of one or more <a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">file attribute flags</a> (FILE_ATTRIBUTE_ values as defined in Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.</para>
    </param>
    <param name="psfi">
      <para>Type: <b><see cref="SHFILEINFO" />*</b></para>
      <para>Pointer to a <see cref="SHFILEINFO" /> structure to receive the file information.</para>
    </param>
    <param name="cbFileInfo">
      <para>Type: <b>UINT</b></para>
      <para>The size, in bytes, of the <see cref="SHFILEINFO" /> structure pointed to by the <i>psfi</i> parameter.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The flags that specify the file information to retrieve. This parameter can be a combination of the following values.</para>
      <h4>SHGFI_ADDOVERLAYS (0x000000020)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Apply the appropriate overlays to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_ATTR_SPECIFIED (0x000020000)</h4>
      <para>Modify <b>SHGFI_ATTRIBUTES</b> to indicate that the <b>dwAttributes</b> member of the <see cref="SHFILEINFO" /> structure at <i>psfi</i> contains the specific attributes that are desired. These attributes are passed to <see cref="IShellFolder.GetAttributesOf" />. If this flag is not specified, 0xFFFFFFFF is passed to <b>IShellFolder.GetAttributesOf</b>, requesting all attributes. This flag cannot be specified with the <b>SHGFI_ICON</b> flag.</para>
      <h4>SHGFI_ATTRIBUTES (0x000000800)</h4>
      <para>Retrieve the item attributes. The attributes are copied to the <b>dwAttributes</b> member of the structure specified in the <i>psfi</i> parameter. These are the same attributes that are obtained from <see cref="IShellFolder.GetAttributesOf" />.</para>
      <h4>SHGFI_DISPLAYNAME (0x000000200)</h4>
      <para>Retrieve the display name for the file, which is the name as it appears in Windows Explorer. The name is copied to the <b>szDisplayName</b> member of the structure specified in <i>psfi</i>. The returned display name uses the long file name, if there is one, rather than the 8.3 form of the file name. Note that the display name can be affected by settings such as whether extensions are shown.</para>
      <h4>SHGFI_EXETYPE (0x000002000)</h4>
      <para>Retrieve the type of the executable file if <i>pszPath</i> identifies an executable file. The information is packed into the return value. This flag cannot be specified with any other flags.</para>
      <h4>SHGFI_ICON (0x000000100)</h4>
      <para>Retrieve the handle to the icon that represents the file and the index of the icon within the system image list. The handle is copied to the <b>hIcon</b> member of the structure specified by <i>psfi</i>, and the index is copied to the <b>iIcon</b> member.</para>
      <h4>SHGFI_ICONLOCATION (0x000001000)</h4>
      <para>Retrieve the name of the file that contains the icon representing the file specified by <i>pszPath</i>, as returned by the <see cref="IExtractIcon.GetIconLocation" /> method of the file's icon handler. Also retrieve the icon index within that file. The name of the file containing the icon is copied to the <b>szDisplayName</b> member of the structure specified by <i>psfi</i>. The icon's index is copied to that structure's <b>iIcon</b> member.</para>
      <h4>SHGFI_LARGEICON (0x000000000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's large icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_LINKOVERLAY (0x000008000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to add the link overlay to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_OPENICON (0x000000002)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's open icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains the file's small open icon. A container object displays an open icon to indicate that the container is open. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_OVERLAYINDEX (0x000000040)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Return the index of the overlay icon. The value of the overlay index is returned in the upper eight bits of the <b>iIcon</b> member of the structure specified by <i>psfi</i>. This flag requires that the <b>SHGFI_ICON</b> be set as well.</para>
      <h4>SHGFI_PIDL (0x000000008)</h4>
      <para>Indicate that <i>pszPath</i> is the address of an <see cref="ITEMIDLIST" /> structure rather than a path name.</para>
      <h4>SHGFI_SELECTED (0x000010000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to blend the file's icon with the system highlight color. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SHELLICONSIZE (0x000000004)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve a Shell-sized icon. If this flag is not specified the function sizes the icon according to the system metric values. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SMALLICON (0x000000001)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's small icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains small icon images. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_SYSICONINDEX (0x000004000)</h4>
      <para>Retrieve the index of a system image list icon. If successful, the index is copied to the <b>iIcon</b> member of <i>psfi</i>. The return value is a handle to the system image list. Only those images whose indices are successfully copied to <b>iIcon</b> are valid. Attempting to access other images in the system image list will result in undefined behavior.</para>
      <h4>SHGFI_TYPENAME (0x000000400)</h4>
      <para>Retrieve the string that describes the file's type. The string is copied to the <b>szTypeName</b> member of the structure specified in <i>psfi</i>.</para>
      <h4>SHGFI_USEFILEATTRIBUTES (0x000000010)</h4>
      <para>Indicates that the function should not attempt to access the file specified by <i>pszPath</i>. Rather, it should act as if the file specified by <i>pszPath</i> exists with the file attributes passed in <i>dwFileAttributes</i>. This flag cannot be combined with the <b>SHGFI_ATTRIBUTES</b>, <b>SHGFI_EXETYPE</b>, or <b>SHGFI_PIDL</b> flags.</para>
      <h5>- uFlags.SHGFI_ADDOVERLAYS (0x000000020)</h5>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Apply the appropriate overlays to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_ATTRIBUTES (0x000000800)</h5>
      <para>Retrieve the item attributes. The attributes are copied to the <b>dwAttributes</b> member of the structure specified in the <i>psfi</i> parameter. These are the same attributes that are obtained from <see cref="IShellFolder.GetAttributesOf" />.</para>
      <h5>- uFlags.SHGFI_ATTR_SPECIFIED (0x000020000)</h5>
      <para>Modify <b>SHGFI_ATTRIBUTES</b> to indicate that the <b>dwAttributes</b> member of the <see cref="SHFILEINFO" /> structure at <i>psfi</i> contains the specific attributes that are desired. These attributes are passed to <see cref="IShellFolder.GetAttributesOf" />. If this flag is not specified, 0xFFFFFFFF is passed to <b>IShellFolder.GetAttributesOf</b>, requesting all attributes. This flag cannot be specified with the <b>SHGFI_ICON</b> flag.</para>
      <h5>- uFlags.SHGFI_DISPLAYNAME (0x000000200)</h5>
      <para>Retrieve the display name for the file, which is the name as it appears in Windows Explorer. The name is copied to the <b>szDisplayName</b> member of the structure specified in <i>psfi</i>. The returned display name uses the long file name, if there is one, rather than the 8.3 form of the file name. Note that the display name can be affected by settings such as whether extensions are shown.</para>
      <h5>- uFlags.SHGFI_EXETYPE (0x000002000)</h5>
      <para>Retrieve the type of the executable file if <i>pszPath</i> identifies an executable file. The information is packed into the return value. This flag cannot be specified with any other flags.</para>
      <h5>- uFlags.SHGFI_ICON (0x000000100)</h5>
      <para>Retrieve the handle to the icon that represents the file and the index of the icon within the system image list. The handle is copied to the <b>hIcon</b> member of the structure specified by <i>psfi</i>, and the index is copied to the <b>iIcon</b> member.</para>
      <h5>- uFlags.SHGFI_ICONLOCATION (0x000001000)</h5>
      <para>Retrieve the name of the file that contains the icon representing the file specified by <i>pszPath</i>, as returned by the <see cref="IExtractIcon.GetIconLocation" /> method of the file's icon handler. Also retrieve the icon index within that file. The name of the file containing the icon is copied to the <b>szDisplayName</b> member of the structure specified by <i>psfi</i>. The icon's index is copied to that structure's <b>iIcon</b> member.</para>
      <h5>- uFlags.SHGFI_LARGEICON (0x000000000)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's large icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_LINKOVERLAY (0x000008000)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to add the link overlay to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_OPENICON (0x000000002)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's open icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains the file's small open icon. A container object displays an open icon to indicate that the container is open. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_OVERLAYINDEX (0x000000040)</h5>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Return the index of the overlay icon. The value of the overlay index is returned in the upper eight bits of the <b>iIcon</b> member of the structure specified by <i>psfi</i>. This flag requires that the <b>SHGFI_ICON</b> be set as well.</para>
      <h5>- uFlags.SHGFI_PIDL (0x000000008)</h5>
      <para>Indicate that <i>pszPath</i> is the address of an <see cref="ITEMIDLIST" /> structure rather than a path name.</para>
      <h5>- uFlags.SHGFI_SELECTED (0x000010000)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to blend the file's icon with the system highlight color. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_SHELLICONSIZE (0x000000004)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve a Shell-sized icon. If this flag is not specified the function sizes the icon according to the system metric values. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_SMALLICON (0x000000001)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's small icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains small icon images. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_SYSICONINDEX (0x000004000)</h5>
      <para>Retrieve the index of a system image list icon. If successful, the index is copied to the <b>iIcon</b> member of <i>psfi</i>. The return value is a handle to the system image list. Only those images whose indices are successfully copied to <b>iIcon</b> are valid. Attempting to access other images in the system image list will result in undefined behavior.</para>
      <h5>- uFlags.SHGFI_TYPENAME (0x000000400)</h5>
      <para>Retrieve the string that describes the file's type. The string is copied to the <b>szTypeName</b> member of the structure specified in <i>psfi</i>.</para>
      <h5>- uFlags.SHGFI_USEFILEATTRIBUTES (0x000000010)</h5>
      <para>Indicates that the function should not attempt to access the file specified by <i>pszPath</i>. Rather, it should act as if the file specified by <i>pszPath</i> exists with the file attributes passed in <i>dwFileAttributes</i>. This flag cannot be combined with the <b>SHGFI_ATTRIBUTES</b>, <b>SHGFI_EXETYPE</b>, or <b>SHGFI_PIDL</b> flags.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD_PTR</b></para>
      <para>Returns a value whose meaning depends on the <i>uFlags</i> parameter.</para>
      <para>If <i>uFlags</i> does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or zero otherwise.</para>
      <para>If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of the executable file. It will be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>Nonexecutable file or an error condition.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = NE or PE and HIWORD = Windows version</b>
            </para>
          </description>
          <description>
            <para>Windows application.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = MZ and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>MS-DOS .exe or .com file</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = PE and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>Console application or .bat file</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should call this function from a background thread. Failure to do so could cause the UI to stop responding.</para>
      <para>If <b>SHGetFileInfo</b> returns an icon handle in the <b>hIcon</b> member of the <see cref="SHFILEINFO" /> structure pointed to by <i>psfi</i>, you are responsible for freeing it with <see cref="DestroyIcon" /> when you no longer need it.</para>
      <para>
        <b>Note</b>  Once you have a handle to a system image list, you can use the <a href="https://docs.microsoft.com//windows/desktop/Controls/image-lists">Image List API</a> to manipulate it like any other image list. Because system image lists are created on a per-process basis, you should treat them as read-only objects. Writing to a system image list may overwrite or delete one of the system images, making it unavailable or incorrect for the remainder of the process.</para>
      <para>You must initialize Component Object Model (COM) with <see cref="CoInitialize" /> or <see cref="OleInitialize" /> prior to calling <b>SHGetFileInfo</b>.</para>
      <para>When you use the <b>SHGFI_EXETYPE</b> flag with a Windows application, the Windows version of the executable is given in the HIWORD of the return value. This version is returned as a hexadecimal value. For details on equating this value with a specific Windows version, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFileInfo</b> to retrieve the display name of the Recycle Bin, identified by its PIDL.</para>
      <code>LPITEMIDLIST pidl = NULL;
hr = SHGetFolderLocation(NULL, CSIDL_BITBUCKET, NULL, 0, &amp;amp;amp;amp;amp;amp;pidl);

if (SUCCEEDED(hr))
{
    SHFILEINFOW sfi = {0};
    hr = SHGetFileInfo((LPCTSTR)pidl,
                        -1,
                        &amp;amp;amp;amp;amp;amp;sfi,
                        sizeof(sfi),
                        SHGFI_PIDL | SHGFI_DISPLAYNAME)

    if (SUCCEEDED(hr))
    {
        // The display name is now held in sfi.szDisplayName.
    }
}

ILFree(pidl);
</code>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetFileInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/fileiconinit">FileIconInit</seealso>
  </member>
  <member name="Windows.SHGetFileInfoA">
    <summary>
      <para>Retrieves information about an object in the file system, such as a file, folder, directory, or drive root.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the path and file name. Both absolute and relative paths are valid.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_PIDL</b> flag, this parameter must be the address of an <see cref="ITEMIDLIST" /> (PIDL) structure that contains the list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully qualified PIDL. Relative PIDLs are not allowed.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will proceed as if the file exists with the specified name and with the file attributes passed in the <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>.</para>
      <para>This string can use either short (the 8.3 form) or long file names.</para>
    </param>
    <param name="dwFileAttributes">
      <para>Type: <b>DWORD</b></para>
      <para>A combination of one or more <a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">file attribute flags</a> (FILE_ATTRIBUTE_ values as defined in Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.</para>
    </param>
    <param name="psfi">
      <para>Type: <b><see cref="SHFILEINFO" />*</b></para>
      <para>Pointer to a <see cref="SHFILEINFO" /> structure to receive the file information.</para>
    </param>
    <param name="cbFileInfo">
      <para>Type: <b>UINT</b></para>
      <para>The size, in bytes, of the <see cref="SHFILEINFO" /> structure pointed to by the <i>psfi</i> parameter.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The flags that specify the file information to retrieve. This parameter can be a combination of the following values.</para>
      <h4>SHGFI_ADDOVERLAYS (0x000000020)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Apply the appropriate overlays to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_ATTR_SPECIFIED (0x000020000)</h4>
      <para>Modify <b>SHGFI_ATTRIBUTES</b> to indicate that the <b>dwAttributes</b> member of the <see cref="SHFILEINFO" /> structure at <i>psfi</i> contains the specific attributes that are desired. These attributes are passed to <see cref="IShellFolder.GetAttributesOf" />. If this flag is not specified, 0xFFFFFFFF is passed to <b>IShellFolder.GetAttributesOf</b>, requesting all attributes. This flag cannot be specified with the <b>SHGFI_ICON</b> flag.</para>
      <h4>SHGFI_ATTRIBUTES (0x000000800)</h4>
      <para>Retrieve the item attributes. The attributes are copied to the <b>dwAttributes</b> member of the structure specified in the <i>psfi</i> parameter. These are the same attributes that are obtained from <see cref="IShellFolder.GetAttributesOf" />.</para>
      <h4>SHGFI_DISPLAYNAME (0x000000200)</h4>
      <para>Retrieve the display name for the file, which is the name as it appears in Windows Explorer. The name is copied to the <b>szDisplayName</b> member of the structure specified in <i>psfi</i>. The returned display name uses the long file name, if there is one, rather than the 8.3 form of the file name. Note that the display name can be affected by settings such as whether extensions are shown.</para>
      <h4>SHGFI_EXETYPE (0x000002000)</h4>
      <para>Retrieve the type of the executable file if <i>pszPath</i> identifies an executable file. The information is packed into the return value. This flag cannot be specified with any other flags.</para>
      <h4>SHGFI_ICON (0x000000100)</h4>
      <para>Retrieve the handle to the icon that represents the file and the index of the icon within the system image list. The handle is copied to the <b>hIcon</b> member of the structure specified by <i>psfi</i>, and the index is copied to the <b>iIcon</b> member.</para>
      <h4>SHGFI_ICONLOCATION (0x000001000)</h4>
      <para>Retrieve the name of the file that contains the icon representing the file specified by <i>pszPath</i>, as returned by the <see cref="IExtractIcon.GetIconLocation" /> method of the file's icon handler. Also retrieve the icon index within that file. The name of the file containing the icon is copied to the <b>szDisplayName</b> member of the structure specified by <i>psfi</i>. The icon's index is copied to that structure's <b>iIcon</b> member.</para>
      <h4>SHGFI_LARGEICON (0x000000000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's large icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_LINKOVERLAY (0x000008000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to add the link overlay to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_OPENICON (0x000000002)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's open icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains the file's small open icon. A container object displays an open icon to indicate that the container is open. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_OVERLAYINDEX (0x000000040)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Return the index of the overlay icon. The value of the overlay index is returned in the upper eight bits of the <b>iIcon</b> member of the structure specified by <i>psfi</i>. This flag requires that the <b>SHGFI_ICON</b> be set as well.</para>
      <h4>SHGFI_PIDL (0x000000008)</h4>
      <para>Indicate that <i>pszPath</i> is the address of an <see cref="ITEMIDLIST" /> structure rather than a path name.</para>
      <h4>SHGFI_SELECTED (0x000010000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to blend the file's icon with the system highlight color. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SHELLICONSIZE (0x000000004)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve a Shell-sized icon. If this flag is not specified the function sizes the icon according to the system metric values. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SMALLICON (0x000000001)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's small icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains small icon images. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_SYSICONINDEX (0x000004000)</h4>
      <para>Retrieve the index of a system image list icon. If successful, the index is copied to the <b>iIcon</b> member of <i>psfi</i>. The return value is a handle to the system image list. Only those images whose indices are successfully copied to <b>iIcon</b> are valid. Attempting to access other images in the system image list will result in undefined behavior.</para>
      <h4>SHGFI_TYPENAME (0x000000400)</h4>
      <para>Retrieve the string that describes the file's type. The string is copied to the <b>szTypeName</b> member of the structure specified in <i>psfi</i>.</para>
      <h4>SHGFI_USEFILEATTRIBUTES (0x000000010)</h4>
      <para>Indicates that the function should not attempt to access the file specified by <i>pszPath</i>. Rather, it should act as if the file specified by <i>pszPath</i> exists with the file attributes passed in <i>dwFileAttributes</i>. This flag cannot be combined with the <b>SHGFI_ATTRIBUTES</b>, <b>SHGFI_EXETYPE</b>, or <b>SHGFI_PIDL</b> flags.</para>
      <h5>- uFlags.SHGFI_ADDOVERLAYS (0x000000020)</h5>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Apply the appropriate overlays to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_ATTRIBUTES (0x000000800)</h5>
      <para>Retrieve the item attributes. The attributes are copied to the <b>dwAttributes</b> member of the structure specified in the <i>psfi</i> parameter. These are the same attributes that are obtained from <see cref="IShellFolder.GetAttributesOf" />.</para>
      <h5>- uFlags.SHGFI_ATTR_SPECIFIED (0x000020000)</h5>
      <para>Modify <b>SHGFI_ATTRIBUTES</b> to indicate that the <b>dwAttributes</b> member of the <see cref="SHFILEINFO" /> structure at <i>psfi</i> contains the specific attributes that are desired. These attributes are passed to <see cref="IShellFolder.GetAttributesOf" />. If this flag is not specified, 0xFFFFFFFF is passed to <b>IShellFolder.GetAttributesOf</b>, requesting all attributes. This flag cannot be specified with the <b>SHGFI_ICON</b> flag.</para>
      <h5>- uFlags.SHGFI_DISPLAYNAME (0x000000200)</h5>
      <para>Retrieve the display name for the file, which is the name as it appears in Windows Explorer. The name is copied to the <b>szDisplayName</b> member of the structure specified in <i>psfi</i>. The returned display name uses the long file name, if there is one, rather than the 8.3 form of the file name. Note that the display name can be affected by settings such as whether extensions are shown.</para>
      <h5>- uFlags.SHGFI_EXETYPE (0x000002000)</h5>
      <para>Retrieve the type of the executable file if <i>pszPath</i> identifies an executable file. The information is packed into the return value. This flag cannot be specified with any other flags.</para>
      <h5>- uFlags.SHGFI_ICON (0x000000100)</h5>
      <para>Retrieve the handle to the icon that represents the file and the index of the icon within the system image list. The handle is copied to the <b>hIcon</b> member of the structure specified by <i>psfi</i>, and the index is copied to the <b>iIcon</b> member.</para>
      <h5>- uFlags.SHGFI_ICONLOCATION (0x000001000)</h5>
      <para>Retrieve the name of the file that contains the icon representing the file specified by <i>pszPath</i>, as returned by the <see cref="IExtractIcon.GetIconLocation" /> method of the file's icon handler. Also retrieve the icon index within that file. The name of the file containing the icon is copied to the <b>szDisplayName</b> member of the structure specified by <i>psfi</i>. The icon's index is copied to that structure's <b>iIcon</b> member.</para>
      <h5>- uFlags.SHGFI_LARGEICON (0x000000000)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's large icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_LINKOVERLAY (0x000008000)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to add the link overlay to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_OPENICON (0x000000002)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's open icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains the file's small open icon. A container object displays an open icon to indicate that the container is open. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_OVERLAYINDEX (0x000000040)</h5>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Return the index of the overlay icon. The value of the overlay index is returned in the upper eight bits of the <b>iIcon</b> member of the structure specified by <i>psfi</i>. This flag requires that the <b>SHGFI_ICON</b> be set as well.</para>
      <h5>- uFlags.SHGFI_PIDL (0x000000008)</h5>
      <para>Indicate that <i>pszPath</i> is the address of an <see cref="ITEMIDLIST" /> structure rather than a path name.</para>
      <h5>- uFlags.SHGFI_SELECTED (0x000010000)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to blend the file's icon with the system highlight color. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_SHELLICONSIZE (0x000000004)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve a Shell-sized icon. If this flag is not specified the function sizes the icon according to the system metric values. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_SMALLICON (0x000000001)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's small icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains small icon images. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_SYSICONINDEX (0x000004000)</h5>
      <para>Retrieve the index of a system image list icon. If successful, the index is copied to the <b>iIcon</b> member of <i>psfi</i>. The return value is a handle to the system image list. Only those images whose indices are successfully copied to <b>iIcon</b> are valid. Attempting to access other images in the system image list will result in undefined behavior.</para>
      <h5>- uFlags.SHGFI_TYPENAME (0x000000400)</h5>
      <para>Retrieve the string that describes the file's type. The string is copied to the <b>szTypeName</b> member of the structure specified in <i>psfi</i>.</para>
      <h5>- uFlags.SHGFI_USEFILEATTRIBUTES (0x000000010)</h5>
      <para>Indicates that the function should not attempt to access the file specified by <i>pszPath</i>. Rather, it should act as if the file specified by <i>pszPath</i> exists with the file attributes passed in <i>dwFileAttributes</i>. This flag cannot be combined with the <b>SHGFI_ATTRIBUTES</b>, <b>SHGFI_EXETYPE</b>, or <b>SHGFI_PIDL</b> flags.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD_PTR</b></para>
      <para>Returns a value whose meaning depends on the <i>uFlags</i> parameter.</para>
      <para>If <i>uFlags</i> does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or zero otherwise.</para>
      <para>If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of the executable file. It will be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>Nonexecutable file or an error condition.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = NE or PE and HIWORD = Windows version</b>
            </para>
          </description>
          <description>
            <para>Windows application.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = MZ and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>MS-DOS .exe or .com file</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = PE and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>Console application or .bat file</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should call this function from a background thread. Failure to do so could cause the UI to stop responding.</para>
      <para>If <b>SHGetFileInfo</b> returns an icon handle in the <b>hIcon</b> member of the <see cref="SHFILEINFO" /> structure pointed to by <i>psfi</i>, you are responsible for freeing it with <see cref="DestroyIcon" /> when you no longer need it.</para>
      <para>
        <b>Note</b>  Once you have a handle to a system image list, you can use the <a href="https://docs.microsoft.com//windows/desktop/Controls/image-lists">Image List API</a> to manipulate it like any other image list. Because system image lists are created on a per-process basis, you should treat them as read-only objects. Writing to a system image list may overwrite or delete one of the system images, making it unavailable or incorrect for the remainder of the process.</para>
      <para>You must initialize Component Object Model (COM) with <see cref="CoInitialize" /> or <see cref="OleInitialize" /> prior to calling <b>SHGetFileInfo</b>.</para>
      <para>When you use the <b>SHGFI_EXETYPE</b> flag with a Windows application, the Windows version of the executable is given in the HIWORD of the return value. This version is returned as a hexadecimal value. For details on equating this value with a specific Windows version, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFileInfo</b> to retrieve the display name of the Recycle Bin, identified by its PIDL.</para>
      <code>LPITEMIDLIST pidl = NULL;
hr = SHGetFolderLocation(NULL, CSIDL_BITBUCKET, NULL, 0, &amp;amp;amp;amp;amp;amp;pidl);

if (SUCCEEDED(hr))
{
    SHFILEINFOW sfi = {0};
    hr = SHGetFileInfo((LPCTSTR)pidl,
                        -1,
                        &amp;amp;amp;amp;amp;amp;sfi,
                        sizeof(sfi),
                        SHGFI_PIDL | SHGFI_DISPLAYNAME)

    if (SUCCEEDED(hr))
    {
        // The display name is now held in sfi.szDisplayName.
    }
}

ILFree(pidl);
</code>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetFileInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/fileiconinit">FileIconInit</seealso>
  </member>
  <member name="Windows.SHGetFileInfoW">
    <summary>
      <para>Retrieves information about an object in the file system, such as a file, folder, directory, or drive root.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the path and file name. Both absolute and relative paths are valid.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_PIDL</b> flag, this parameter must be the address of an <see cref="ITEMIDLIST" /> (PIDL) structure that contains the list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully qualified PIDL. Relative PIDLs are not allowed.</para>
      <para>If the <i>uFlags</i> parameter includes the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will proceed as if the file exists with the specified name and with the file attributes passed in the <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>.</para>
      <para>This string can use either short (the 8.3 form) or long file names.</para>
    </param>
    <param name="dwFileAttributes">
      <para>Type: <b>DWORD</b></para>
      <para>A combination of one or more <a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">file attribute flags</a> (FILE_ATTRIBUTE_ values as defined in Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.</para>
    </param>
    <param name="psfi">
      <para>Type: <b><see cref="SHFILEINFO" />*</b></para>
      <para>Pointer to a <see cref="SHFILEINFO" /> structure to receive the file information.</para>
    </param>
    <param name="cbFileInfo">
      <para>Type: <b>UINT</b></para>
      <para>The size, in bytes, of the <see cref="SHFILEINFO" /> structure pointed to by the <i>psfi</i> parameter.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The flags that specify the file information to retrieve. This parameter can be a combination of the following values.</para>
      <h4>SHGFI_ADDOVERLAYS (0x000000020)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Apply the appropriate overlays to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_ATTR_SPECIFIED (0x000020000)</h4>
      <para>Modify <b>SHGFI_ATTRIBUTES</b> to indicate that the <b>dwAttributes</b> member of the <see cref="SHFILEINFO" /> structure at <i>psfi</i> contains the specific attributes that are desired. These attributes are passed to <see cref="IShellFolder.GetAttributesOf" />. If this flag is not specified, 0xFFFFFFFF is passed to <b>IShellFolder.GetAttributesOf</b>, requesting all attributes. This flag cannot be specified with the <b>SHGFI_ICON</b> flag.</para>
      <h4>SHGFI_ATTRIBUTES (0x000000800)</h4>
      <para>Retrieve the item attributes. The attributes are copied to the <b>dwAttributes</b> member of the structure specified in the <i>psfi</i> parameter. These are the same attributes that are obtained from <see cref="IShellFolder.GetAttributesOf" />.</para>
      <h4>SHGFI_DISPLAYNAME (0x000000200)</h4>
      <para>Retrieve the display name for the file, which is the name as it appears in Windows Explorer. The name is copied to the <b>szDisplayName</b> member of the structure specified in <i>psfi</i>. The returned display name uses the long file name, if there is one, rather than the 8.3 form of the file name. Note that the display name can be affected by settings such as whether extensions are shown.</para>
      <h4>SHGFI_EXETYPE (0x000002000)</h4>
      <para>Retrieve the type of the executable file if <i>pszPath</i> identifies an executable file. The information is packed into the return value. This flag cannot be specified with any other flags.</para>
      <h4>SHGFI_ICON (0x000000100)</h4>
      <para>Retrieve the handle to the icon that represents the file and the index of the icon within the system image list. The handle is copied to the <b>hIcon</b> member of the structure specified by <i>psfi</i>, and the index is copied to the <b>iIcon</b> member.</para>
      <h4>SHGFI_ICONLOCATION (0x000001000)</h4>
      <para>Retrieve the name of the file that contains the icon representing the file specified by <i>pszPath</i>, as returned by the <see cref="IExtractIcon.GetIconLocation" /> method of the file's icon handler. Also retrieve the icon index within that file. The name of the file containing the icon is copied to the <b>szDisplayName</b> member of the structure specified by <i>psfi</i>. The icon's index is copied to that structure's <b>iIcon</b> member.</para>
      <h4>SHGFI_LARGEICON (0x000000000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's large icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_LINKOVERLAY (0x000008000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to add the link overlay to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_OPENICON (0x000000002)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's open icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains the file's small open icon. A container object displays an open icon to indicate that the container is open. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_OVERLAYINDEX (0x000000040)</h4>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Return the index of the overlay icon. The value of the overlay index is returned in the upper eight bits of the <b>iIcon</b> member of the structure specified by <i>psfi</i>. This flag requires that the <b>SHGFI_ICON</b> be set as well.</para>
      <h4>SHGFI_PIDL (0x000000008)</h4>
      <para>Indicate that <i>pszPath</i> is the address of an <see cref="ITEMIDLIST" /> structure rather than a path name.</para>
      <h4>SHGFI_SELECTED (0x000010000)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to blend the file's icon with the system highlight color. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SHELLICONSIZE (0x000000004)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve a Shell-sized icon. If this flag is not specified the function sizes the icon according to the system metric values. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h4>SHGFI_SMALLICON (0x000000001)</h4>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's small icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains small icon images. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h4>SHGFI_SYSICONINDEX (0x000004000)</h4>
      <para>Retrieve the index of a system image list icon. If successful, the index is copied to the <b>iIcon</b> member of <i>psfi</i>. The return value is a handle to the system image list. Only those images whose indices are successfully copied to <b>iIcon</b> are valid. Attempting to access other images in the system image list will result in undefined behavior.</para>
      <h4>SHGFI_TYPENAME (0x000000400)</h4>
      <para>Retrieve the string that describes the file's type. The string is copied to the <b>szTypeName</b> member of the structure specified in <i>psfi</i>.</para>
      <h4>SHGFI_USEFILEATTRIBUTES (0x000000010)</h4>
      <para>Indicates that the function should not attempt to access the file specified by <i>pszPath</i>. Rather, it should act as if the file specified by <i>pszPath</i> exists with the file attributes passed in <i>dwFileAttributes</i>. This flag cannot be combined with the <b>SHGFI_ATTRIBUTES</b>, <b>SHGFI_EXETYPE</b>, or <b>SHGFI_PIDL</b> flags.</para>
      <h5>- uFlags.SHGFI_ADDOVERLAYS (0x000000020)</h5>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Apply the appropriate overlays to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_ATTRIBUTES (0x000000800)</h5>
      <para>Retrieve the item attributes. The attributes are copied to the <b>dwAttributes</b> member of the structure specified in the <i>psfi</i> parameter. These are the same attributes that are obtained from <see cref="IShellFolder.GetAttributesOf" />.</para>
      <h5>- uFlags.SHGFI_ATTR_SPECIFIED (0x000020000)</h5>
      <para>Modify <b>SHGFI_ATTRIBUTES</b> to indicate that the <b>dwAttributes</b> member of the <see cref="SHFILEINFO" /> structure at <i>psfi</i> contains the specific attributes that are desired. These attributes are passed to <see cref="IShellFolder.GetAttributesOf" />. If this flag is not specified, 0xFFFFFFFF is passed to <b>IShellFolder.GetAttributesOf</b>, requesting all attributes. This flag cannot be specified with the <b>SHGFI_ICON</b> flag.</para>
      <h5>- uFlags.SHGFI_DISPLAYNAME (0x000000200)</h5>
      <para>Retrieve the display name for the file, which is the name as it appears in Windows Explorer. The name is copied to the <b>szDisplayName</b> member of the structure specified in <i>psfi</i>. The returned display name uses the long file name, if there is one, rather than the 8.3 form of the file name. Note that the display name can be affected by settings such as whether extensions are shown.</para>
      <h5>- uFlags.SHGFI_EXETYPE (0x000002000)</h5>
      <para>Retrieve the type of the executable file if <i>pszPath</i> identifies an executable file. The information is packed into the return value. This flag cannot be specified with any other flags.</para>
      <h5>- uFlags.SHGFI_ICON (0x000000100)</h5>
      <para>Retrieve the handle to the icon that represents the file and the index of the icon within the system image list. The handle is copied to the <b>hIcon</b> member of the structure specified by <i>psfi</i>, and the index is copied to the <b>iIcon</b> member.</para>
      <h5>- uFlags.SHGFI_ICONLOCATION (0x000001000)</h5>
      <para>Retrieve the name of the file that contains the icon representing the file specified by <i>pszPath</i>, as returned by the <see cref="IExtractIcon.GetIconLocation" /> method of the file's icon handler. Also retrieve the icon index within that file. The name of the file containing the icon is copied to the <b>szDisplayName</b> member of the structure specified by <i>psfi</i>. The icon's index is copied to that structure's <b>iIcon</b> member.</para>
      <h5>- uFlags.SHGFI_LARGEICON (0x000000000)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's large icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_LINKOVERLAY (0x000008000)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to add the link overlay to the file's icon. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_OPENICON (0x000000002)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's open icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains the file's small open icon. A container object displays an open icon to indicate that the container is open. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_OVERLAYINDEX (0x000000040)</h5>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a>. Return the index of the overlay icon. The value of the overlay index is returned in the upper eight bits of the <b>iIcon</b> member of the structure specified by <i>psfi</i>. This flag requires that the <b>SHGFI_ICON</b> be set as well.</para>
      <h5>- uFlags.SHGFI_PIDL (0x000000008)</h5>
      <para>Indicate that <i>pszPath</i> is the address of an <see cref="ITEMIDLIST" /> structure rather than a path name.</para>
      <h5>- uFlags.SHGFI_SELECTED (0x000010000)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to blend the file's icon with the system highlight color. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_SHELLICONSIZE (0x000000004)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve a Shell-sized icon. If this flag is not specified the function sizes the icon according to the system metric values. The <b>SHGFI_ICON</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_SMALLICON (0x000000001)</h5>
      <para>Modify <b>SHGFI_ICON</b>, causing the function to retrieve the file's small icon. Also used to modify <b>SHGFI_SYSICONINDEX</b>, causing the function to return the handle to the system image list that contains small icon images. The <b>SHGFI_ICON</b> and/or <b>SHGFI_SYSICONINDEX</b> flag must also be set.</para>
      <h5>- uFlags.SHGFI_SYSICONINDEX (0x000004000)</h5>
      <para>Retrieve the index of a system image list icon. If successful, the index is copied to the <b>iIcon</b> member of <i>psfi</i>. The return value is a handle to the system image list. Only those images whose indices are successfully copied to <b>iIcon</b> are valid. Attempting to access other images in the system image list will result in undefined behavior.</para>
      <h5>- uFlags.SHGFI_TYPENAME (0x000000400)</h5>
      <para>Retrieve the string that describes the file's type. The string is copied to the <b>szTypeName</b> member of the structure specified in <i>psfi</i>.</para>
      <h5>- uFlags.SHGFI_USEFILEATTRIBUTES (0x000000010)</h5>
      <para>Indicates that the function should not attempt to access the file specified by <i>pszPath</i>. Rather, it should act as if the file specified by <i>pszPath</i> exists with the file attributes passed in <i>dwFileAttributes</i>. This flag cannot be combined with the <b>SHGFI_ATTRIBUTES</b>, <b>SHGFI_EXETYPE</b>, or <b>SHGFI_PIDL</b> flags.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD_PTR</b></para>
      <para>Returns a value whose meaning depends on the <i>uFlags</i> parameter.</para>
      <para>If <i>uFlags</i> does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or zero otherwise.</para>
      <para>If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of the executable file. It will be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>0</b>
            </para>
          </description>
          <description>
            <para>Nonexecutable file or an error condition.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = NE or PE and HIWORD = Windows version</b>
            </para>
          </description>
          <description>
            <para>Windows application.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = MZ and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>MS-DOS .exe or .com file</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>LOWORD = PE and HIWORD = 0</b>
            </para>
          </description>
          <description>
            <para>Console application or .bat file</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You should call this function from a background thread. Failure to do so could cause the UI to stop responding.</para>
      <para>If <b>SHGetFileInfo</b> returns an icon handle in the <b>hIcon</b> member of the <see cref="SHFILEINFO" /> structure pointed to by <i>psfi</i>, you are responsible for freeing it with <see cref="DestroyIcon" /> when you no longer need it.</para>
      <para>
        <b>Note</b>  Once you have a handle to a system image list, you can use the <a href="https://docs.microsoft.com//windows/desktop/Controls/image-lists">Image List API</a> to manipulate it like any other image list. Because system image lists are created on a per-process basis, you should treat them as read-only objects. Writing to a system image list may overwrite or delete one of the system images, making it unavailable or incorrect for the remainder of the process.</para>
      <para>You must initialize Component Object Model (COM) with <see cref="CoInitialize" /> or <see cref="OleInitialize" /> prior to calling <b>SHGetFileInfo</b>.</para>
      <para>When you use the <b>SHGFI_EXETYPE</b> flag with a Windows application, the Windows version of the executable is given in the HIWORD of the return value. This version is returned as a hexadecimal value. For details on equating this value with a specific Windows version, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>The following code example uses <b>SHGetFileInfo</b> to retrieve the display name of the Recycle Bin, identified by its PIDL.</para>
      <code>LPITEMIDLIST pidl = NULL;
hr = SHGetFolderLocation(NULL, CSIDL_BITBUCKET, NULL, 0, &amp;amp;amp;amp;amp;amp;pidl);

if (SUCCEEDED(hr))
{
    SHFILEINFOW sfi = {0};
    hr = SHGetFileInfo((LPCTSTR)pidl,
                        -1,
                        &amp;amp;amp;amp;amp;amp;sfi,
                        sizeof(sfi),
                        SHGFI_PIDL | SHGFI_DISPLAYNAME)

    if (SUCCEEDED(hr))
    {
        // The display name is now held in sfi.szDisplayName.
    }
}

ILFree(pidl);
</code>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetFileInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/fileiconinit">FileIconInit</seealso>
  </member>
  <member name="Windows.SHGetImageList">
    <summary>
      <para>Retrieves an image list.</para>
    </summary>
    <param name="iImageList">
      <para>Type: <b>int</b></para>
      <para>The image type contained in the list. One of the following values:</para>
      <h4>SHIL_LARGE (0x0)</h4>
      <para>0x0. The image size is normally 32x32 pixels. However, if the <b>Use large icons</b> option is selected from the <b>Effects</b> section of the <b>Appearance</b> tab in <b>Display Properties</b>, the image is 48x48 pixels.</para>
      <h4>SHIL_SMALL (0x1)</h4>
      <para>0x1. These images are the Shell standard small icon size of 16x16, but the size can be customized by the user.</para>
      <h4>SHIL_EXTRALARGE (0x2)</h4>
      <para>0x2. These images are the Shell standard extra-large icon size. This is typically 48x48, but the size can be customized by the user.</para>
      <h4>SHIL_SYSSMALL (0x3)</h4>
      <para>0x3. These images are the size specified by <see cref="GetSystemMetrics" /> called with <b>SM_CXSMICON</b> and <b>GetSystemMetrics</b> called with <b>SM_CYSMICON</b>.</para>
      <h4>SHIL_JUMBO (0x4)</h4>
      <para>0x4. <b>Windows Vista and later.</b> The image is normally 256x256 pixels.</para>
      <h4>SHIL_LAST</h4>
      <para>The largest valid flag value, for validation purposes.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>Reference to the image list interface identifier, normally IID_IImageList.</para>
    </param>
    <param name="ppvObj">
      <para>Type: <b>void**</b></para>
      <para>When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <see cref="IImageList" />.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>The <see cref="IImageList" /> pointer type, such as that returned in the <i>ppv</i> parameter, can be cast as an <b>HIMAGELIST</b> as needed; for example, for use in a list view. Conversely, an <b>HIMAGELIST</b> can be cast as a pointer to an <b>IImageList</b>.</para>
      <para>As of Windows Vista, <b>SHIL_SMALL</b>, <b>SHIL_LARGE</b>, and <b>SHIL_EXTRALARGE</b> scale with dots per inch (dpi) if the process is marked as dpi-aware. To set these types to be dpi-aware, call <see cref="SetProcessDPIAware" />. <b>SHIL_JUMBO</b> is fixed at 256 pixels regardless of the dpi-aware setting.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/fileiconinit">FileIconInit</seealso>
  </member>
  <member name="Windows.SHGetLocalizedName">
    <summary>
      <para>Retrieves the localized name of a file in a Shell folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to a string that specifies the fully qualified path of the file.</para>
    </param>
    <param name="pszResModule">
      <para>Type: <b>PWSTR</b></para>
      <para>When this function returns, contains a pointer to a string resource that specifies the localized version of the file name.</para>
    </param>
    <param name="cch">
      <para>Type: <b>UINT</b></para>
      <para>When this function returns, contains the size of the string, in <b>WCHARs</b>, at <i>pszResModule</i>.</para>
    </param>
    <param name="pidsRes">
      <para>Type: <b>int*</b></para>
      <para>When this function returns, contains a pointer to the ID of the localized file name in the resource file.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.SHGetNewLinkInfo">
    <summary>
      <para>Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the shortcut, just the name.</para>
    </summary>
    <param name="pszLinkTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the target.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path of the folder in which the shortcut would be created.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the null-terminated path and file name for the shortcut. This buffer is assumed to be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pfMustCopy">
      <para>Type: <b>BOOL*</b></para>
      <para>The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives zero if the target does not specify a shortcut that would be copied.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The options for the function. This can be zero or a combination of the following values.</para>
      <h4>SHGNLI_PIDL (0x000000001)</h4>
      <para>0x000000001. The target pointed to by <i>pszLinkTo</i> is a PIDL that represents the target. If this flag is not included, <i>pszLinkTo</i> is regarded as the address of a string that contains the path and file name of the target.</para>
      <h4>SHGNLI_NOUNIQUE (0x000000002)</h4>
      <para>0x000000002. Skip the normal checks that ensure that the shortcut name is unique within the destination folder. If this flag is not included, the function creates the shortcut name and then determines whether the name is unique in the destination folder. If a file with the same name already exists in the destination folder, the shortcut name will be modified. This process is repeated until a unique name is found.</para>
      <h4>SHGNLI_PREFIXNAME (0x000000004)</h4>
      <para>0x000000004. The created name will be preceded by the string "Shortcut to ".</para>
      <h4>SHGNLI_NOLNK (0x000000008)</h4>
      <para>0x000000008. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a> Do not add the .lnk file name extension. You must set the <b>_WIN32_IE</b> macro to 5.01 or greater to use this flag. For more information about versioning, see Shell and Common Controls Versions.</para>
      <h4>SHGNLI_NOLOCNAME (0x000000010)</h4>
      <para>0x000000010. <b>Windows Vista and later</b>. Use the non-localized parsing name of the target pointed to by <i>pszLinkTo</i> as the name of the shortcut file. If this flag is not set, the localized name is used.</para>
      <h4>SHGNLI_USEURLEXT (0x000000020)</h4>
      <para>0x000000020. <b>Windows 7 and later</b>. Append a .url file name extension (rather than .lnk) to the name pointed to by <i>pszName</i>. If this flag is not set, the shortcut name uses a .lnk extension unless SHGNLI_NOLNK is set.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SHGetNewLinkInfo</b> determines whether the destination file system supports long file names. If it does, a long file name is used for the shortcut name. If the destination file system does not support long file names, the shortcut name is returned in an 8.3 format.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetNewLinkInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetNewLinkInfoA">
    <summary>
      <para>Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the shortcut, just the name.</para>
    </summary>
    <param name="pszLinkTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the target.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path of the folder in which the shortcut would be created.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the null-terminated path and file name for the shortcut. This buffer is assumed to be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pfMustCopy">
      <para>Type: <b>BOOL*</b></para>
      <para>The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives zero if the target does not specify a shortcut that would be copied.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The options for the function. This can be zero or a combination of the following values.</para>
      <h4>SHGNLI_PIDL (0x000000001)</h4>
      <para>0x000000001. The target pointed to by <i>pszLinkTo</i> is a PIDL that represents the target. If this flag is not included, <i>pszLinkTo</i> is regarded as the address of a string that contains the path and file name of the target.</para>
      <h4>SHGNLI_NOUNIQUE (0x000000002)</h4>
      <para>0x000000002. Skip the normal checks that ensure that the shortcut name is unique within the destination folder. If this flag is not included, the function creates the shortcut name and then determines whether the name is unique in the destination folder. If a file with the same name already exists in the destination folder, the shortcut name will be modified. This process is repeated until a unique name is found.</para>
      <h4>SHGNLI_PREFIXNAME (0x000000004)</h4>
      <para>0x000000004. The created name will be preceded by the string "Shortcut to ".</para>
      <h4>SHGNLI_NOLNK (0x000000008)</h4>
      <para>0x000000008. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a> Do not add the .lnk file name extension. You must set the <b>_WIN32_IE</b> macro to 5.01 or greater to use this flag. For more information about versioning, see Shell and Common Controls Versions.</para>
      <h4>SHGNLI_NOLOCNAME (0x000000010)</h4>
      <para>0x000000010. <b>Windows Vista and later</b>. Use the non-localized parsing name of the target pointed to by <i>pszLinkTo</i> as the name of the shortcut file. If this flag is not set, the localized name is used.</para>
      <h4>SHGNLI_USEURLEXT (0x000000020)</h4>
      <para>0x000000020. <b>Windows 7 and later</b>. Append a .url file name extension (rather than .lnk) to the name pointed to by <i>pszName</i>. If this flag is not set, the shortcut name uses a .lnk extension unless SHGNLI_NOLNK is set.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SHGetNewLinkInfo</b> determines whether the destination file system supports long file names. If it does, a long file name is used for the shortcut name. If the destination file system does not support long file names, the shortcut name is returned in an 8.3 format.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetNewLinkInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetNewLinkInfoW">
    <summary>
      <para>Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the shortcut, just the name.</para>
    </summary>
    <param name="pszLinkTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the target.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path of the folder in which the shortcut would be created.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the null-terminated path and file name for the shortcut. This buffer is assumed to be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pfMustCopy">
      <para>Type: <b>BOOL*</b></para>
      <para>The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives zero if the target does not specify a shortcut that would be copied.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The options for the function. This can be zero or a combination of the following values.</para>
      <h4>SHGNLI_PIDL (0x000000001)</h4>
      <para>0x000000001. The target pointed to by <i>pszLinkTo</i> is a PIDL that represents the target. If this flag is not included, <i>pszLinkTo</i> is regarded as the address of a string that contains the path and file name of the target.</para>
      <h4>SHGNLI_NOUNIQUE (0x000000002)</h4>
      <para>0x000000002. Skip the normal checks that ensure that the shortcut name is unique within the destination folder. If this flag is not included, the function creates the shortcut name and then determines whether the name is unique in the destination folder. If a file with the same name already exists in the destination folder, the shortcut name will be modified. This process is repeated until a unique name is found.</para>
      <h4>SHGNLI_PREFIXNAME (0x000000004)</h4>
      <para>0x000000004. The created name will be preceded by the string "Shortcut to ".</para>
      <h4>SHGNLI_NOLNK (0x000000008)</h4>
      <para>0x000000008. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a> Do not add the .lnk file name extension. You must set the <b>_WIN32_IE</b> macro to 5.01 or greater to use this flag. For more information about versioning, see Shell and Common Controls Versions.</para>
      <h4>SHGNLI_NOLOCNAME (0x000000010)</h4>
      <para>0x000000010. <b>Windows Vista and later</b>. Use the non-localized parsing name of the target pointed to by <i>pszLinkTo</i> as the name of the shortcut file. If this flag is not set, the localized name is used.</para>
      <h4>SHGNLI_USEURLEXT (0x000000020)</h4>
      <para>0x000000020. <b>Windows 7 and later</b>. Append a .url file name extension (rather than .lnk) to the name pointed to by <i>pszName</i>. If this flag is not set, the shortcut name uses a .lnk extension unless SHGNLI_NOLNK is set.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SHGetNewLinkInfo</b> determines whether the destination file system supports long file names. If it does, a long file name is used for the shortcut name. If the destination file system does not support long file names, the shortcut name is returned in an 8.3 format.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetNewLinkInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetNewLinkInfo">
    <summary>
      <para>Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the shortcut, just the name.</para>
    </summary>
    <param name="pszLinkTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the target.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path of the folder in which the shortcut would be created.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the null-terminated path and file name for the shortcut. This buffer is assumed to be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pfMustCopy">
      <para>Type: <b>BOOL*</b></para>
      <para>The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives zero if the target does not specify a shortcut that would be copied.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The options for the function. This can be zero or a combination of the following values.</para>
      <h4>SHGNLI_PIDL (0x000000001)</h4>
      <para>0x000000001. The target pointed to by <i>pszLinkTo</i> is a PIDL that represents the target. If this flag is not included, <i>pszLinkTo</i> is regarded as the address of a string that contains the path and file name of the target.</para>
      <h4>SHGNLI_NOUNIQUE (0x000000002)</h4>
      <para>0x000000002. Skip the normal checks that ensure that the shortcut name is unique within the destination folder. If this flag is not included, the function creates the shortcut name and then determines whether the name is unique in the destination folder. If a file with the same name already exists in the destination folder, the shortcut name will be modified. This process is repeated until a unique name is found.</para>
      <h4>SHGNLI_PREFIXNAME (0x000000004)</h4>
      <para>0x000000004. The created name will be preceded by the string "Shortcut to ".</para>
      <h4>SHGNLI_NOLNK (0x000000008)</h4>
      <para>0x000000008. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a> Do not add the .lnk file name extension. You must set the <b>_WIN32_IE</b> macro to 5.01 or greater to use this flag. For more information about versioning, see Shell and Common Controls Versions.</para>
      <h4>SHGNLI_NOLOCNAME (0x000000010)</h4>
      <para>0x000000010. <b>Windows Vista and later</b>. Use the non-localized parsing name of the target pointed to by <i>pszLinkTo</i> as the name of the shortcut file. If this flag is not set, the localized name is used.</para>
      <h4>SHGNLI_USEURLEXT (0x000000020)</h4>
      <para>0x000000020. <b>Windows 7 and later</b>. Append a .url file name extension (rather than .lnk) to the name pointed to by <i>pszName</i>. If this flag is not set, the shortcut name uses a .lnk extension unless SHGNLI_NOLNK is set.</para>
      <h5>- uFlags.SHGNLI_NOLNK (0x000000008)</h5>
      <para>0x000000008. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a> Do not add the .lnk file name extension. You must set the <b>_WIN32_IE</b> macro to 5.01 or greater to use this flag. For more information about versioning, see Shell and Common Controls Versions.</para>
      <h5>- uFlags.SHGNLI_NOLOCNAME (0x000000010)</h5>
      <para>0x000000010. <b>Windows Vista and later</b>. Use the non-localized parsing name of the target pointed to by <i>pszLinkTo</i> as the name of the shortcut file. If this flag is not set, the localized name is used.</para>
      <h5>- uFlags.SHGNLI_NOUNIQUE (0x000000002)</h5>
      <para>0x000000002. Skip the normal checks that ensure that the shortcut name is unique within the destination folder. If this flag is not included, the function creates the shortcut name and then determines whether the name is unique in the destination folder. If a file with the same name already exists in the destination folder, the shortcut name will be modified. This process is repeated until a unique name is found.</para>
      <h5>- uFlags.SHGNLI_PIDL (0x000000001)</h5>
      <para>0x000000001. The target pointed to by <i>pszLinkTo</i> is a PIDL that represents the target. If this flag is not included, <i>pszLinkTo</i> is regarded as the address of a string that contains the path and file name of the target.</para>
      <h5>- uFlags.SHGNLI_PREFIXNAME (0x000000004)</h5>
      <para>0x000000004. The created name will be preceded by the string "Shortcut to ".</para>
      <h5>- uFlags.SHGNLI_USEURLEXT (0x000000020)</h5>
      <para>0x000000020. <b>Windows 7 and later</b>. Append a .url file name extension (rather than .lnk) to the name pointed to by <i>pszName</i>. If this flag is not set, the shortcut name uses a .lnk extension unless SHGNLI_NOLNK is set.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SHGetNewLinkInfo</b> determines whether the destination file system supports long file names. If it does, a long file name is used for the shortcut name. If the destination file system does not support long file names, the shortcut name is returned in an 8.3 format.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetNewLinkInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetNewLinkInfoA">
    <summary>
      <para>Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the shortcut, just the name.</para>
    </summary>
    <param name="pszLinkTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the target.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path of the folder in which the shortcut would be created.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the null-terminated path and file name for the shortcut. This buffer is assumed to be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pfMustCopy">
      <para>Type: <b>BOOL*</b></para>
      <para>The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives zero if the target does not specify a shortcut that would be copied.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The options for the function. This can be zero or a combination of the following values.</para>
      <h4>SHGNLI_PIDL (0x000000001)</h4>
      <para>0x000000001. The target pointed to by <i>pszLinkTo</i> is a PIDL that represents the target. If this flag is not included, <i>pszLinkTo</i> is regarded as the address of a string that contains the path and file name of the target.</para>
      <h4>SHGNLI_NOUNIQUE (0x000000002)</h4>
      <para>0x000000002. Skip the normal checks that ensure that the shortcut name is unique within the destination folder. If this flag is not included, the function creates the shortcut name and then determines whether the name is unique in the destination folder. If a file with the same name already exists in the destination folder, the shortcut name will be modified. This process is repeated until a unique name is found.</para>
      <h4>SHGNLI_PREFIXNAME (0x000000004)</h4>
      <para>0x000000004. The created name will be preceded by the string "Shortcut to ".</para>
      <h4>SHGNLI_NOLNK (0x000000008)</h4>
      <para>0x000000008. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a> Do not add the .lnk file name extension. You must set the <b>_WIN32_IE</b> macro to 5.01 or greater to use this flag. For more information about versioning, see Shell and Common Controls Versions.</para>
      <h4>SHGNLI_NOLOCNAME (0x000000010)</h4>
      <para>0x000000010. <b>Windows Vista and later</b>. Use the non-localized parsing name of the target pointed to by <i>pszLinkTo</i> as the name of the shortcut file. If this flag is not set, the localized name is used.</para>
      <h4>SHGNLI_USEURLEXT (0x000000020)</h4>
      <para>0x000000020. <b>Windows 7 and later</b>. Append a .url file name extension (rather than .lnk) to the name pointed to by <i>pszName</i>. If this flag is not set, the shortcut name uses a .lnk extension unless SHGNLI_NOLNK is set.</para>
      <h5>- uFlags.SHGNLI_NOLNK (0x000000008)</h5>
      <para>0x000000008. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a> Do not add the .lnk file name extension. You must set the <b>_WIN32_IE</b> macro to 5.01 or greater to use this flag. For more information about versioning, see Shell and Common Controls Versions.</para>
      <h5>- uFlags.SHGNLI_NOLOCNAME (0x000000010)</h5>
      <para>0x000000010. <b>Windows Vista and later</b>. Use the non-localized parsing name of the target pointed to by <i>pszLinkTo</i> as the name of the shortcut file. If this flag is not set, the localized name is used.</para>
      <h5>- uFlags.SHGNLI_NOUNIQUE (0x000000002)</h5>
      <para>0x000000002. Skip the normal checks that ensure that the shortcut name is unique within the destination folder. If this flag is not included, the function creates the shortcut name and then determines whether the name is unique in the destination folder. If a file with the same name already exists in the destination folder, the shortcut name will be modified. This process is repeated until a unique name is found.</para>
      <h5>- uFlags.SHGNLI_PIDL (0x000000001)</h5>
      <para>0x000000001. The target pointed to by <i>pszLinkTo</i> is a PIDL that represents the target. If this flag is not included, <i>pszLinkTo</i> is regarded as the address of a string that contains the path and file name of the target.</para>
      <h5>- uFlags.SHGNLI_PREFIXNAME (0x000000004)</h5>
      <para>0x000000004. The created name will be preceded by the string "Shortcut to ".</para>
      <h5>- uFlags.SHGNLI_USEURLEXT (0x000000020)</h5>
      <para>0x000000020. <b>Windows 7 and later</b>. Append a .url file name extension (rather than .lnk) to the name pointed to by <i>pszName</i>. If this flag is not set, the shortcut name uses a .lnk extension unless SHGNLI_NOLNK is set.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SHGetNewLinkInfo</b> determines whether the destination file system supports long file names. If it does, a long file name is used for the shortcut name. If the destination file system does not support long file names, the shortcut name is returned in an 8.3 format.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetNewLinkInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetNewLinkInfoW">
    <summary>
      <para>Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the shortcut, just the name.</para>
    </summary>
    <param name="pszLinkTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the target.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path of the folder in which the shortcut would be created.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the null-terminated path and file name for the shortcut. This buffer is assumed to be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pfMustCopy">
      <para>Type: <b>BOOL*</b></para>
      <para>The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives zero if the target does not specify a shortcut that would be copied.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>The options for the function. This can be zero or a combination of the following values.</para>
      <h4>SHGNLI_PIDL (0x000000001)</h4>
      <para>0x000000001. The target pointed to by <i>pszLinkTo</i> is a PIDL that represents the target. If this flag is not included, <i>pszLinkTo</i> is regarded as the address of a string that contains the path and file name of the target.</para>
      <h4>SHGNLI_NOUNIQUE (0x000000002)</h4>
      <para>0x000000002. Skip the normal checks that ensure that the shortcut name is unique within the destination folder. If this flag is not included, the function creates the shortcut name and then determines whether the name is unique in the destination folder. If a file with the same name already exists in the destination folder, the shortcut name will be modified. This process is repeated until a unique name is found.</para>
      <h4>SHGNLI_PREFIXNAME (0x000000004)</h4>
      <para>0x000000004. The created name will be preceded by the string "Shortcut to ".</para>
      <h4>SHGNLI_NOLNK (0x000000008)</h4>
      <para>0x000000008. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a> Do not add the .lnk file name extension. You must set the <b>_WIN32_IE</b> macro to 5.01 or greater to use this flag. For more information about versioning, see Shell and Common Controls Versions.</para>
      <h4>SHGNLI_NOLOCNAME (0x000000010)</h4>
      <para>0x000000010. <b>Windows Vista and later</b>. Use the non-localized parsing name of the target pointed to by <i>pszLinkTo</i> as the name of the shortcut file. If this flag is not set, the localized name is used.</para>
      <h4>SHGNLI_USEURLEXT (0x000000020)</h4>
      <para>0x000000020. <b>Windows 7 and later</b>. Append a .url file name extension (rather than .lnk) to the name pointed to by <i>pszName</i>. If this flag is not set, the shortcut name uses a .lnk extension unless SHGNLI_NOLNK is set.</para>
      <h5>- uFlags.SHGNLI_NOLNK (0x000000008)</h5>
      <para>0x000000008. <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Version 5.0</a> Do not add the .lnk file name extension. You must set the <b>_WIN32_IE</b> macro to 5.01 or greater to use this flag. For more information about versioning, see Shell and Common Controls Versions.</para>
      <h5>- uFlags.SHGNLI_NOLOCNAME (0x000000010)</h5>
      <para>0x000000010. <b>Windows Vista and later</b>. Use the non-localized parsing name of the target pointed to by <i>pszLinkTo</i> as the name of the shortcut file. If this flag is not set, the localized name is used.</para>
      <h5>- uFlags.SHGNLI_NOUNIQUE (0x000000002)</h5>
      <para>0x000000002. Skip the normal checks that ensure that the shortcut name is unique within the destination folder. If this flag is not included, the function creates the shortcut name and then determines whether the name is unique in the destination folder. If a file with the same name already exists in the destination folder, the shortcut name will be modified. This process is repeated until a unique name is found.</para>
      <h5>- uFlags.SHGNLI_PIDL (0x000000001)</h5>
      <para>0x000000001. The target pointed to by <i>pszLinkTo</i> is a PIDL that represents the target. If this flag is not included, <i>pszLinkTo</i> is regarded as the address of a string that contains the path and file name of the target.</para>
      <h5>- uFlags.SHGNLI_PREFIXNAME (0x000000004)</h5>
      <para>0x000000004. The created name will be preceded by the string "Shortcut to ".</para>
      <h5>- uFlags.SHGNLI_USEURLEXT (0x000000020)</h5>
      <para>0x000000020. <b>Windows 7 and later</b>. Append a .url file name extension (rather than .lnk) to the name pointed to by <i>pszName</i>. If this flag is not set, the shortcut name uses a .lnk extension unless SHGNLI_NOLNK is set.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SHGetNewLinkInfo</b> determines whether the destination file system supports long file names. If it does, a long file name is used for the shortcut name. If the destination file system does not support long file names, the shortcut name is returned in an 8.3 format.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHGetNewLinkInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetPropertyStoreForWindow">
    <summary>
      <para>Retrieves an object that represents a specific window's collection of properties, which allows those properties to be queried or set.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the window whose properties are being retrieved.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>A reference to the IID of the property store object to retrieve through <i>ppv</i>. This is typically IID_IPropertyStore.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>void**</b></para>
      <para>When this function returns, contains the interface pointer requested in <i>riid</i>. This is typically <see cref="IPropertyStore" />.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>An application can use this function to obtain access to a window's property store so that it can set an explicit Application User Model ID (AppUserModelID) in the <a href="https://docs.microsoft.com//windows/desktop/properties/props-system-appusermodel-id">System.AppUserModel.ID</a> property.</para>
      <para>A window's properties must be removed before the window is closed. If this is not done, the resources used by those properties are not returned to the system. A property is removed by setting it to the <see cref="PROPVARIANT" /> type VT_EMPTY.</para>
      <para>When a call is made to <see cref="IPropertyStore.SetValue" /> on the object retrieved through <i>ppv</i>, the properties and values are immediately stored on the window. Therefore, no call to <see cref="IPropertyStore.Commit" /> is needed. No error occurs if it is called, but it has no effect.</para>
      <para>An application sets AppUserModelIDs on individual windows to control the application's taskbar grouping and Jump List contents. For instance, a suite application might want to provide a different taskbar button for each of its subfeatures, with the windows relating to that subfeature grouped under that button. Without window-level AppUserModelIDs, those windows would all be grouped together under the main process.</para>
      <para>Applications should also use this property store to set these relaunch properties so that the system can return the application to that state.</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/properties/props-system-appusermodel-relaunchcommand">System.AppUserModel.RelaunchCommand</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/properties/props-system-appusermodel-relaunchdisplaynameresource">System.AppUserModel.RelaunchDisplayNameResource</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/properties/props-system-appusermodel-relaunchiconresource">System.AppUserModel.RelaunchIconResource</a>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/appids">Application User Model IDs (AppUserModelIDs)</seealso>
  </member>
  <member name="Windows.SHGetStockIconInfo">
    <summary>
      <para>Retrieves information about system-defined Shell icons.</para>
    </summary>
    <param name="siid">
      <para>Type: <b><see cref="SHSTOCKICONID" /></b></para>
      <para>One of the values from the <see cref="SHSTOCKICONID" /> enumeration that specifies which icon should be retrieved.</para>
    </param>
    <param name="uFlags">
      <para>Type: <b>UINT</b></para>
      <para>A combination of zero or more of the following flags that specify which information is requested.</para>
      <h4>SHGSI_ICONLOCATION</h4>
      <para>The <b>szPath</b> and <b>iIcon</b> members of the <see cref="SHSTOCKICONINFO" /> structure receive the path and icon index of the requested icon, in a format suitable for passing to the <see cref="ExtractIcon" /> function. The numerical value of this flag is zero, so you always get the icon location regardless of other flags.</para>
      <h4>SHGSI_ICON</h4>
      <para>The <b>hIcon</b> member of the <see cref="SHSTOCKICONINFO" /> structure receives a handle to the specified icon.</para>
      <h4>SHGSI_SYSICONINDEX</h4>
      <para>The <b>iSysImageImage</b> member of the <see cref="SHSTOCKICONINFO" /> structure receives the index of the specified icon in the system imagelist.</para>
      <h4>SHGSI_LINKOVERLAY</h4>
      <para>Modifies the SHGSI_ICON value by causing the function to add the link overlay to the file's icon.</para>
      <h4>SHGSI_SELECTED</h4>
      <para>Modifies the SHGSI_ICON value by causing the function to blend the icon with the system highlight color.</para>
      <h4>SHGSI_LARGEICON</h4>
      <para>Modifies the SHGSI_ICON value by causing the function to retrieve the large version of the icon, as specified by the SM_CXICON and SM_CYICON system metrics.</para>
      <h4>SHGSI_SMALLICON</h4>
      <para>Modifies the SHGSI_ICON value by causing the function to retrieve the small version of the icon, as specified by the SM_CXSMICON and SM_CYSMICON system metrics.</para>
      <h4>SHGSI_SHELLICONSIZE</h4>
      <para>Modifies the SHGSI_LARGEICON or SHGSI_SMALLICON values by causing the function to retrieve the Shell-sized icons rather than the sizes specified by the system metrics.</para>
    </param>
    <param name="psii">
      <para>Type: <b><see cref="SHSTOCKICONINFO" />*</b></para>
      <para>A pointer to a <see cref="SHSTOCKICONINFO" /> structure. When this function is called, the <b>cbSize</b> member of this structure needs to be set to the size of the <b>SHSTOCKICONINFO</b> structure. When this function returns, contains a pointer to a <b>SHSTOCKICONINFO</b> structure that contains the requested information.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>If this function returns an icon handle in the <b>hIcon</b> member of the <see cref="SHSTOCKICONINFO" />  structure pointed to by <i>psii</i>, you are responsible for freeing the icon with <see cref="DestroyIcon" /> when you no longer need it.</para>
    </remarks>
  </member>
  <member name="Windows.SHGetUnreadMailCount">
    <summary>
      <para>Retrieves a specified user's unread message count for any or all email accounts.</para>
    </summary>
    <param name="hKeyUser">
      <para>Type: <b>HKEY</b></para>
      <para>A valid HKEY for a given user. This parameter should be <b>NULL</b> if the function is called in a user's environment, in which case <b>HKEY_CURRENT_USER</b> is used. This parameter should be <b>NULL</b> if the function is called from the SYSTEM context, in which case <b>HKEY_USERS</b>\<i>{SID}</i> is used.</para>
    </param>
    <param name="pszMailAddress">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that specifies the email address of an account belonging to the specified user. When this parameter is <b>NULL</b>, <i>pdwCount</i> returns the total count of unread messages for all accounts owned by the designated user.</para>
    </param>
    <param name="pdwCount">
      <para>Type: <b>DWORD*</b></para>
      <para>Pointer to a DWORD value which receives the unread message count.</para>
    </param>
    <param name="pFileTime">
      <para>Type: <b>FILETIME*</b></para>
      <para>A pointer to a <see cref="FILETIME" /> structure.  The use of this parameter is determined by whether <i>pszMailAddress</i> is <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, then this parameter is treated as an [in] parameter, which specifies a filter, so that only unread mail newer than the specified time appears. If <i>pszMailAddress</i> is not <b>NULL</b>, then this parameter is treated as an [out] parameter, which points to a <b>FILETIME</b> structure into which the function places the <b>timestamp</b> of the last <see cref="SHSetUnreadMailCount" /> call for the specified user and email account.</para>
    </param>
    <param name="pszShellExecuteCommand">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string that returns the ShellExecute command statement passed into the last <see cref="SHSetUnreadMailCount" /> call for the specified user and email account. This command string starts the email application that owns the account referenced by <i>pszMailAddress</i>. If the ShellExecute command is not required, this parameter can be <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, this parameter is ignored and must be <b>NULL</b>.</para>
    </param>
    <param name="cchShellExecuteCommand">
      <para>Type: <b>int</b></para>
      <para>The maximum size, in characters, of the ShellExecute command buffer pointed to by <i>pszShellExecuteCommand</i>. This parameter must be zero for total counts when <i>pszMailAddress</i> is <b>NULL</b>. It can also be <b>NULL</b> whenever the ShellExecute command string is not required.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.SHGetUnreadMailCountA">
    <summary>
      <para>Retrieves a specified user's unread message count for any or all email accounts.</para>
    </summary>
    <param name="hKeyUser">
      <para>Type: <b>HKEY</b></para>
      <para>A valid HKEY for a given user. This parameter should be <b>NULL</b> if the function is called in a user's environment, in which case <b>HKEY_CURRENT_USER</b> is used. This parameter should be <b>NULL</b> if the function is called from the SYSTEM context, in which case <b>HKEY_USERS</b>\<i>{SID}</i> is used.</para>
    </param>
    <param name="pszMailAddress">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that specifies the email address of an account belonging to the specified user. When this parameter is <b>NULL</b>, <i>pdwCount</i> returns the total count of unread messages for all accounts owned by the designated user.</para>
    </param>
    <param name="pdwCount">
      <para>Type: <b>DWORD*</b></para>
      <para>Pointer to a DWORD value which receives the unread message count.</para>
    </param>
    <param name="pFileTime">
      <para>Type: <b>FILETIME*</b></para>
      <para>A pointer to a <see cref="FILETIME" /> structure.  The use of this parameter is determined by whether <i>pszMailAddress</i> is <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, then this parameter is treated as an [in] parameter, which specifies a filter, so that only unread mail newer than the specified time appears. If <i>pszMailAddress</i> is not <b>NULL</b>, then this parameter is treated as an [out] parameter, which points to a <b>FILETIME</b> structure into which the function places the <b>timestamp</b> of the last <see cref="SHSetUnreadMailCount" /> call for the specified user and email account.</para>
    </param>
    <param name="pszShellExecuteCommand">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string that returns the ShellExecute command statement passed into the last <see cref="SHSetUnreadMailCount" /> call for the specified user and email account. This command string starts the email application that owns the account referenced by <i>pszMailAddress</i>. If the ShellExecute command is not required, this parameter can be <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, this parameter is ignored and must be <b>NULL</b>.</para>
    </param>
    <param name="cchShellExecuteCommand">
      <para>Type: <b>int</b></para>
      <para>The maximum size, in characters, of the ShellExecute command buffer pointed to by <i>pszShellExecuteCommand</i>. This parameter must be zero for total counts when <i>pszMailAddress</i> is <b>NULL</b>. It can also be <b>NULL</b> whenever the ShellExecute command string is not required.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.SHGetUnreadMailCount">
    <summary>
      <para>Retrieves a specified user's unread message count for any or all email accounts.</para>
    </summary>
    <param name="hKeyUser">
      <para>Type: <b>HKEY</b></para>
      <para>A valid HKEY for a given user. This parameter should be <b>NULL</b> if the function is called in a user's environment, in which case <b>HKEY_CURRENT_USER</b> is used. This parameter should be <b>NULL</b> if the function is called from the SYSTEM context, in which case <b>HKEY_USERS</b>\<i>{SID}</i> is used.</para>
    </param>
    <param name="pszMailAddress">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that specifies the email address of an account belonging to the specified user. When this parameter is <b>NULL</b>, <i>pdwCount</i> returns the total count of unread messages for all accounts owned by the designated user.</para>
    </param>
    <param name="pdwCount">
      <para>Type: <b>DWORD*</b></para>
      <para>Pointer to a DWORD value which receives the unread message count.</para>
    </param>
    <param name="pFileTime">
      <para>Type: <b>FILETIME*</b></para>
      <para>A pointer to a <see cref="FILETIME" /> structure.  The use of this parameter is determined by whether <i>pszMailAddress</i> is <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, then this parameter is treated as an [in] parameter, which specifies a filter, so that only unread mail newer than the specified time appears. If <i>pszMailAddress</i> is not <b>NULL</b>, then this parameter is treated as an [out] parameter, which points to a <b>FILETIME</b> structure into which the function places the <b>timestamp</b> of the last <see cref="SHSetUnreadMailCount" /> call for the specified user and email account.</para>
    </param>
    <param name="pszShellExecuteCommand">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string that returns the ShellExecute command statement passed into the last <see cref="SHSetUnreadMailCount" /> call for the specified user and email account. This command string starts the email application that owns the account referenced by <i>pszMailAddress</i>. If the ShellExecute command is not required, this parameter can be <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, this parameter is ignored and must be <b>NULL</b>.</para>
    </param>
    <param name="cchShellExecuteCommand">
      <para>Type: <b>int</b></para>
      <para>The maximum size, in characters, of the ShellExecute command buffer pointed to by <i>pszShellExecuteCommand</i>. This parameter must be zero for total counts when <i>pszMailAddress</i> is <b>NULL</b>. It can also be <b>NULL</b> whenever the ShellExecute command string is not required.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.SHGetUnreadMailCountW">
    <summary>
      <para>Retrieves a specified user's unread message count for any or all email accounts.</para>
    </summary>
    <param name="hKeyUser">
      <para>Type: <b>HKEY</b></para>
      <para>A valid HKEY for a given user. This parameter should be <b>NULL</b> if the function is called in a user's environment, in which case <b>HKEY_CURRENT_USER</b> is used. This parameter should be <b>NULL</b> if the function is called from the SYSTEM context, in which case <b>HKEY_USERS</b>\<i>{SID}</i> is used.</para>
    </param>
    <param name="pszMailAddress">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that specifies the email address of an account belonging to the specified user. When this parameter is <b>NULL</b>, <i>pdwCount</i> returns the total count of unread messages for all accounts owned by the designated user.</para>
    </param>
    <param name="pdwCount">
      <para>Type: <b>DWORD*</b></para>
      <para>Pointer to a DWORD value which receives the unread message count.</para>
    </param>
    <param name="pFileTime">
      <para>Type: <b>FILETIME*</b></para>
      <para>A pointer to a <see cref="FILETIME" /> structure.  The use of this parameter is determined by whether <i>pszMailAddress</i> is <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, then this parameter is treated as an [in] parameter, which specifies a filter, so that only unread mail newer than the specified time appears. If <i>pszMailAddress</i> is not <b>NULL</b>, then this parameter is treated as an [out] parameter, which points to a <b>FILETIME</b> structure into which the function places the <b>timestamp</b> of the last <see cref="SHSetUnreadMailCount" /> call for the specified user and email account.</para>
    </param>
    <param name="pszShellExecuteCommand">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string that returns the ShellExecute command statement passed into the last <see cref="SHSetUnreadMailCount" /> call for the specified user and email account. This command string starts the email application that owns the account referenced by <i>pszMailAddress</i>. If the ShellExecute command is not required, this parameter can be <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, this parameter is ignored and must be <b>NULL</b>.</para>
    </param>
    <param name="cchShellExecuteCommand">
      <para>Type: <b>int</b></para>
      <para>The maximum size, in characters, of the ShellExecute command buffer pointed to by <i>pszShellExecuteCommand</i>. This parameter must be zero for total counts when <i>pszMailAddress</i> is <b>NULL</b>. It can also be <b>NULL</b> whenever the ShellExecute command string is not required.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.SHInvokePrinterCommand">
    <summary>
      <para>Executes a command on a printer object.</para>
      <para>
        <b>Note</b>  This function has been deprecated as of Windows Vista. It is recommended that, in its place, you invoke verbs on printers through <see cref="IContextMenu" /> or <see cref="ShellExecute" />.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>The handle of the parent window of any windows or dialog boxes that are created during the operation.</para>
    </param>
    <param name="uAction">
      <para>Type: <b>UINT</b></para>
      <para>The type of printer operation to perform. One of the following values:</para>
      <h4>PRINTACTION_OPEN (0)</h4>
      <para>0x0. Open the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_PROPERTIES (1)</h4>
      <para>0x1. Display the property pages for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter can be <b>NULL</b> or can name a specific property sheet to display, either by name or number. If the high <b>WORD</b> of <i>lpBuf2</i> is nonzero, it is assumed that this parameter is a pointer to a buffer that contains the name of the sheet to open. Otherwise, <i>lpBuf2</i> is seen as the zero-based index of the property sheet to open.</para>
      <h4>PRINTACTION_NETINSTALL (2)</h4>
      <para>0x2. Install the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_NETINSTALLLINK (3)</h4>
      <para>0x3. Create a shortcut to the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter specifies the drive and path of the folder in which to create the shortcut. The network printer must already have been installed on the local computer.</para>
      <h4>PRINTACTION_TESTPAGE (4)</h4>
      <para>0x4. Print a test page on the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_OPENNETPRN (5)</h4>
      <para>0x5. Open the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_DOCUMENTDEFAULTS (6)</h4>
      <para>0x6. Display the default document properties for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_SERVERPROPERTIES (7)</h4>
      <para>0x7. Display the properties for the printer server specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
    </param>
    <param name="lpBuf1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="lpBuf2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="fModal">
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>When a printer name is specified by <i>lpBuf1</i>, the name can either be the name of a local printer or the server and share name of a network printer. When specifying a network printer name, the name must be specified in this format:</para>
      <code>"\\&lt;server&gt;&lt;shared printer name&gt;"
</code>
      <para>This function is implemented in <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell versions 4.71</a> and later. In order to maintain backward compatibility with previous Shell versions, this function should not be used explicitly. Instead, the <see cref="LoadLibrary" /> and <see cref="GetProcAddress" /> functions should be used to obtain the function address.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHInvokePrinterCommand as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHInvokePrinterCommandA">
    <summary>
      <para>Executes a command on a printer object.</para>
      <para>
        <b>Note</b>  This function has been deprecated as of Windows Vista. It is recommended that, in its place, you invoke verbs on printers through <see cref="IContextMenu" /> or <see cref="ShellExecute" />.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>The handle of the parent window of any windows or dialog boxes that are created during the operation.</para>
    </param>
    <param name="uAction">
      <para>Type: <b>UINT</b></para>
      <para>The type of printer operation to perform. One of the following values:</para>
      <h4>PRINTACTION_OPEN (0)</h4>
      <para>0x0. Open the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_PROPERTIES (1)</h4>
      <para>0x1. Display the property pages for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter can be <b>NULL</b> or can name a specific property sheet to display, either by name or number. If the high <b>WORD</b> of <i>lpBuf2</i> is nonzero, it is assumed that this parameter is a pointer to a buffer that contains the name of the sheet to open. Otherwise, <i>lpBuf2</i> is seen as the zero-based index of the property sheet to open.</para>
      <h4>PRINTACTION_NETINSTALL (2)</h4>
      <para>0x2. Install the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_NETINSTALLLINK (3)</h4>
      <para>0x3. Create a shortcut to the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter specifies the drive and path of the folder in which to create the shortcut. The network printer must already have been installed on the local computer.</para>
      <h4>PRINTACTION_TESTPAGE (4)</h4>
      <para>0x4. Print a test page on the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_OPENNETPRN (5)</h4>
      <para>0x5. Open the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_DOCUMENTDEFAULTS (6)</h4>
      <para>0x6. Display the default document properties for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_SERVERPROPERTIES (7)</h4>
      <para>0x7. Display the properties for the printer server specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
    </param>
    <param name="lpBuf1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="lpBuf2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="fModal">
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>When a printer name is specified by <i>lpBuf1</i>, the name can either be the name of a local printer or the server and share name of a network printer. When specifying a network printer name, the name must be specified in this format:</para>
      <code>"\\&lt;server&gt;&lt;shared printer name&gt;"
</code>
      <para>This function is implemented in <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell versions 4.71</a> and later. In order to maintain backward compatibility with previous Shell versions, this function should not be used explicitly. Instead, the <see cref="LoadLibrary" /> and <see cref="GetProcAddress" /> functions should be used to obtain the function address.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHInvokePrinterCommand as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHInvokePrinterCommandW">
    <summary>
      <para>Executes a command on a printer object.</para>
      <para>
        <b>Note</b>  This function has been deprecated as of Windows Vista. It is recommended that, in its place, you invoke verbs on printers through <see cref="IContextMenu" /> or <see cref="ShellExecute" />.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>The handle of the parent window of any windows or dialog boxes that are created during the operation.</para>
    </param>
    <param name="uAction">
      <para>Type: <b>UINT</b></para>
      <para>The type of printer operation to perform. One of the following values:</para>
      <h4>PRINTACTION_OPEN (0)</h4>
      <para>0x0. Open the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_PROPERTIES (1)</h4>
      <para>0x1. Display the property pages for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter can be <b>NULL</b> or can name a specific property sheet to display, either by name or number. If the high <b>WORD</b> of <i>lpBuf2</i> is nonzero, it is assumed that this parameter is a pointer to a buffer that contains the name of the sheet to open. Otherwise, <i>lpBuf2</i> is seen as the zero-based index of the property sheet to open.</para>
      <h4>PRINTACTION_NETINSTALL (2)</h4>
      <para>0x2. Install the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_NETINSTALLLINK (3)</h4>
      <para>0x3. Create a shortcut to the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter specifies the drive and path of the folder in which to create the shortcut. The network printer must already have been installed on the local computer.</para>
      <h4>PRINTACTION_TESTPAGE (4)</h4>
      <para>0x4. Print a test page on the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_OPENNETPRN (5)</h4>
      <para>0x5. Open the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_DOCUMENTDEFAULTS (6)</h4>
      <para>0x6. Display the default document properties for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_SERVERPROPERTIES (7)</h4>
      <para>0x7. Display the properties for the printer server specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
    </param>
    <param name="lpBuf1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="lpBuf2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="fModal">
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>When a printer name is specified by <i>lpBuf1</i>, the name can either be the name of a local printer or the server and share name of a network printer. When specifying a network printer name, the name must be specified in this format:</para>
      <code>"\\&lt;server&gt;&lt;shared printer name&gt;"
</code>
      <para>This function is implemented in <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell versions 4.71</a> and later. In order to maintain backward compatibility with previous Shell versions, this function should not be used explicitly. Instead, the <see cref="LoadLibrary" /> and <see cref="GetProcAddress" /> functions should be used to obtain the function address.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHInvokePrinterCommand as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHInvokePrinterCommand">
    <summary>
      <para>Executes a command on a printer object.</para>
      <para>
        <b>Note</b>  This function has been deprecated as of Windows Vista. It is recommended that, in its place, you invoke verbs on printers through <see cref="IContextMenu" /> or <see cref="ShellExecute" />.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>The handle of the parent window of any windows or dialog boxes that are created during the operation.</para>
    </param>
    <param name="uAction">
      <para>Type: <b>UINT</b></para>
      <para>The type of printer operation to perform. One of the following values:</para>
      <h4>PRINTACTION_OPEN (0)</h4>
      <para>0x0. Open the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_PROPERTIES (1)</h4>
      <para>0x1. Display the property pages for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter can be <b>NULL</b> or can name a specific property sheet to display, either by name or number. If the high <b>WORD</b> of <i>lpBuf2</i> is nonzero, it is assumed that this parameter is a pointer to a buffer that contains the name of the sheet to open. Otherwise, <i>lpBuf2</i> is seen as the zero-based index of the property sheet to open.</para>
      <h4>PRINTACTION_NETINSTALL (2)</h4>
      <para>0x2. Install the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_NETINSTALLLINK (3)</h4>
      <para>0x3. Create a shortcut to the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter specifies the drive and path of the folder in which to create the shortcut. The network printer must already have been installed on the local computer.</para>
      <h4>PRINTACTION_TESTPAGE (4)</h4>
      <para>0x4. Print a test page on the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_OPENNETPRN (5)</h4>
      <para>0x5. Open the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_DOCUMENTDEFAULTS (6)</h4>
      <para>0x6. Display the default document properties for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_SERVERPROPERTIES (7)</h4>
      <para>0x7. Display the properties for the printer server specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
    </param>
    <param name="lpBuf1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="lpBuf2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="fModal">
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.</para>
      <h5>- uAction.PRINTACTION_DOCUMENTDEFAULTS (6)</h5>
      <para>0x6. Display the default document properties for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_NETINSTALL (2)</h5>
      <para>0x2. Install the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_NETINSTALLLINK (3)</h5>
      <para>0x3. Create a shortcut to the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter specifies the drive and path of the folder in which to create the shortcut. The network printer must already have been installed on the local computer.</para>
      <h5>- uAction.PRINTACTION_OPEN (0)</h5>
      <para>0x0. Open the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_OPENNETPRN (5)</h5>
      <para>0x5. Open the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_PROPERTIES (1)</h5>
      <para>0x1. Display the property pages for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter can be <b>NULL</b> or can name a specific property sheet to display, either by name or number. If the high <b>WORD</b> of <i>lpBuf2</i> is nonzero, it is assumed that this parameter is a pointer to a buffer that contains the name of the sheet to open. Otherwise, <i>lpBuf2</i> is seen as the zero-based index of the property sheet to open.</para>
      <h5>- uAction.PRINTACTION_SERVERPROPERTIES (7)</h5>
      <para>0x7. Display the properties for the printer server specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_TESTPAGE (4)</h5>
      <para>0x4. Print a test page on the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>When a printer name is specified by <i>lpBuf1</i>, the name can either be the name of a local printer or the server and share name of a network printer. When specifying a network printer name, the name must be specified in this format:</para>
      <code>"\\&lt;server&gt;&lt;shared printer name&gt;"
</code>
      <para>This function is implemented in <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell versions 4.71</a> and later. In order to maintain backward compatibility with previous Shell versions, this function should not be used explicitly. Instead, the <see cref="LoadLibrary" /> and <see cref="GetProcAddress" /> functions should be used to obtain the function address.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHInvokePrinterCommand as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHInvokePrinterCommandA">
    <summary>
      <para>Executes a command on a printer object.</para>
      <para>
        <b>Note</b>  This function has been deprecated as of Windows Vista. It is recommended that, in its place, you invoke verbs on printers through <see cref="IContextMenu" /> or <see cref="ShellExecute" />.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>The handle of the parent window of any windows or dialog boxes that are created during the operation.</para>
    </param>
    <param name="uAction">
      <para>Type: <b>UINT</b></para>
      <para>The type of printer operation to perform. One of the following values:</para>
      <h4>PRINTACTION_OPEN (0)</h4>
      <para>0x0. Open the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_PROPERTIES (1)</h4>
      <para>0x1. Display the property pages for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter can be <b>NULL</b> or can name a specific property sheet to display, either by name or number. If the high <b>WORD</b> of <i>lpBuf2</i> is nonzero, it is assumed that this parameter is a pointer to a buffer that contains the name of the sheet to open. Otherwise, <i>lpBuf2</i> is seen as the zero-based index of the property sheet to open.</para>
      <h4>PRINTACTION_NETINSTALL (2)</h4>
      <para>0x2. Install the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_NETINSTALLLINK (3)</h4>
      <para>0x3. Create a shortcut to the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter specifies the drive and path of the folder in which to create the shortcut. The network printer must already have been installed on the local computer.</para>
      <h4>PRINTACTION_TESTPAGE (4)</h4>
      <para>0x4. Print a test page on the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_OPENNETPRN (5)</h4>
      <para>0x5. Open the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_DOCUMENTDEFAULTS (6)</h4>
      <para>0x6. Display the default document properties for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_SERVERPROPERTIES (7)</h4>
      <para>0x7. Display the properties for the printer server specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
    </param>
    <param name="lpBuf1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="lpBuf2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="fModal">
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.</para>
      <h5>- uAction.PRINTACTION_DOCUMENTDEFAULTS (6)</h5>
      <para>0x6. Display the default document properties for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_NETINSTALL (2)</h5>
      <para>0x2. Install the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_NETINSTALLLINK (3)</h5>
      <para>0x3. Create a shortcut to the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter specifies the drive and path of the folder in which to create the shortcut. The network printer must already have been installed on the local computer.</para>
      <h5>- uAction.PRINTACTION_OPEN (0)</h5>
      <para>0x0. Open the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_OPENNETPRN (5)</h5>
      <para>0x5. Open the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_PROPERTIES (1)</h5>
      <para>0x1. Display the property pages for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter can be <b>NULL</b> or can name a specific property sheet to display, either by name or number. If the high <b>WORD</b> of <i>lpBuf2</i> is nonzero, it is assumed that this parameter is a pointer to a buffer that contains the name of the sheet to open. Otherwise, <i>lpBuf2</i> is seen as the zero-based index of the property sheet to open.</para>
      <h5>- uAction.PRINTACTION_SERVERPROPERTIES (7)</h5>
      <para>0x7. Display the properties for the printer server specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_TESTPAGE (4)</h5>
      <para>0x4. Print a test page on the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>When a printer name is specified by <i>lpBuf1</i>, the name can either be the name of a local printer or the server and share name of a network printer. When specifying a network printer name, the name must be specified in this format:</para>
      <code>"\\&lt;server&gt;&lt;shared printer name&gt;"
</code>
      <para>This function is implemented in <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell versions 4.71</a> and later. In order to maintain backward compatibility with previous Shell versions, this function should not be used explicitly. Instead, the <see cref="LoadLibrary" /> and <see cref="GetProcAddress" /> functions should be used to obtain the function address.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHInvokePrinterCommand as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHInvokePrinterCommandW">
    <summary>
      <para>Executes a command on a printer object.</para>
      <para>
        <b>Note</b>  This function has been deprecated as of Windows Vista. It is recommended that, in its place, you invoke verbs on printers through <see cref="IContextMenu" /> or <see cref="ShellExecute" />.</para>
    </summary>
    <param name="hwnd">
      <para>Type: <b>HWND</b></para>
      <para>The handle of the parent window of any windows or dialog boxes that are created during the operation.</para>
    </param>
    <param name="uAction">
      <para>Type: <b>UINT</b></para>
      <para>The type of printer operation to perform. One of the following values:</para>
      <h4>PRINTACTION_OPEN (0)</h4>
      <para>0x0. Open the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_PROPERTIES (1)</h4>
      <para>0x1. Display the property pages for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter can be <b>NULL</b> or can name a specific property sheet to display, either by name or number. If the high <b>WORD</b> of <i>lpBuf2</i> is nonzero, it is assumed that this parameter is a pointer to a buffer that contains the name of the sheet to open. Otherwise, <i>lpBuf2</i> is seen as the zero-based index of the property sheet to open.</para>
      <h4>PRINTACTION_NETINSTALL (2)</h4>
      <para>0x2. Install the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_NETINSTALLLINK (3)</h4>
      <para>0x3. Create a shortcut to the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter specifies the drive and path of the folder in which to create the shortcut. The network printer must already have been installed on the local computer.</para>
      <h4>PRINTACTION_TESTPAGE (4)</h4>
      <para>0x4. Print a test page on the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_OPENNETPRN (5)</h4>
      <para>0x5. Open the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_DOCUMENTDEFAULTS (6)</h4>
      <para>0x6. Display the default document properties for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h4>PRINTACTION_SERVERPROPERTIES (7)</h4>
      <para>0x7. Display the properties for the printer server specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
    </param>
    <param name="lpBuf1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="lpBuf2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.</para>
    </param>
    <param name="fModal">
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.</para>
      <h5>- uAction.PRINTACTION_DOCUMENTDEFAULTS (6)</h5>
      <para>0x6. Display the default document properties for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_NETINSTALL (2)</h5>
      <para>0x2. Install the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_NETINSTALLLINK (3)</h5>
      <para>0x3. Create a shortcut to the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter specifies the drive and path of the folder in which to create the shortcut. The network printer must already have been installed on the local computer.</para>
      <h5>- uAction.PRINTACTION_OPEN (0)</h5>
      <para>0x0. Open the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_OPENNETPRN (5)</h5>
      <para>0x5. Open the network printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_PROPERTIES (1)</h5>
      <para>0x1. Display the property pages for the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter can be <b>NULL</b> or can name a specific property sheet to display, either by name or number. If the high <b>WORD</b> of <i>lpBuf2</i> is nonzero, it is assumed that this parameter is a pointer to a buffer that contains the name of the sheet to open. Otherwise, <i>lpBuf2</i> is seen as the zero-based index of the property sheet to open.</para>
      <h5>- uAction.PRINTACTION_SERVERPROPERTIES (7)</h5>
      <para>0x7. Display the properties for the printer server specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
      <h5>- uAction.PRINTACTION_TESTPAGE (4)</h5>
      <para>0x4. Print a test page on the printer specified by <i>lpBuf1</i>. The <i>lpBuf2</i> parameter is ignored.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>When a printer name is specified by <i>lpBuf1</i>, the name can either be the name of a local printer or the server and share name of a network printer. When specifying a network printer name, the name must be specified in this format:</para>
      <code>"\\&lt;server&gt;&lt;shared printer name&gt;"
</code>
      <para>This function is implemented in <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell versions 4.71</a> and later. In order to maintain backward compatibility with previous Shell versions, this function should not be used explicitly. Instead, the <see cref="LoadLibrary" /> and <see cref="GetProcAddress" /> functions should be used to obtain the function address.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHInvokePrinterCommand as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHIsFileAvailableOffline">
    <summary>
      <para>Determines whether a file or folder is available for offline use. This function also determines whether the file would be opened from the network, from the local Offline Files cache, or from both locations.</para>
    </summary>
    <param name="pwszPath">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to a string value that specifies the full path to a network file or directory. This path does not need to be in UNC form. If <i>pszPath</i> is not a network path, the function returns E_INVALIDARG.</para>
    </param>
    <param name="pdwStatus">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a variable of type <b>DWORD</b> that receives one or more of the following flags if the function succeeds.</para>
      <h4>OFFLINE_STATUS_LOCAL (0x01)</h4>
      <para>If the file is open, it is open in the cache.</para>
      <h4>OFFLINE_STATUS_REMOTE (0x02)</h4>
      <para>If the file is open, it is open on the server.</para>
      <h4>OFFLINE_STATUS_INCOMPLETE (0x04)</h4>
      <para>The local copy is currently incomplete. The file cannot be opened in offline mode until it has been synchronized.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>This function can return one of these values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The file or directory is cached.  It is available offline unless <b>OFFLINE_STATUS_INCOMPLETE</b> is set.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>The path is invalid or not a network path. The file or directory is not cached.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>The file or directory is not cached.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If <i>pszPath</i> is a directory, <b>SHIsFileAvailableOffline</b> will not return the <b>OFFLINE_STATUS_INCOMPLETE</b> flag.</para>
      <para>If <b>SHIsFileAvailableOffline</b> returns both <b>OFFLINE_STATUS_LOCAL</b> and <b>OFFLINE_STATUS_REMOTE</b>, the file or directory is open in both places.  This is common when the server is online.</para>
    </remarks>
  </member>
  <member name="Windows.SHLoadNonloadedIconOverlayIdentifiers">
    <summary>
      <para>Signals the Shell that during the next operation requiring overlay information, it should load icon overlay identifiers that either failed creation or were not present for creation at startup. Identifiers that have already been loaded are not affected.</para>
    </summary>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Always returns S_OK.</para>
    </returns>
    <remarks>
      <para>A call to <b>SHLoadNonloadedIconOverlayIdentifiers</b> does not result in the immediate loading of a Shell extension, nor does it cause an icon overlay handler to be loaded. A call to <b>SHLoadNonloadedIconOverlayIdentifiers</b> results in a situation such that the next code to ask for icon overlay information triggers a comparison of icon overlays in the registry to those that are already loaded. If an icon overlay is newly registered and the system has not already reached its upper limit of fifteen icon overlays, the new overlay is loaded. <b>SHLoadNonloadedIconOverlayIdentifiers</b> alone does not load a new icon overlay; you also need to trigger an action that uses the overlay, such as a refresh of a Windows Explorer view.</para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/how-to-implement-icon-overlay-handlers">How to Implement Icon Overlay Handlers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.SHQueryRecycleBin">
    <summary>
      <para>Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.</para>
    </summary>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names (C:\Windows\System...).</para>
    </param>
    <param name="pSHQueryRBInfo">
      <para>Type: <b>LPSHQUERYRBINFO</b></para>
      <para>The address of a <see cref="SHQUERYRBINFO" /> structure that receives the Recycle Bin information. The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>With Windows 2000, if <b>NULL</b> is passed in the <i>pszRootPath</i> parameter, the function fails and returns an E_INVALIDARG error code. In earlier versions of the operating system, you can pass an empty string or <b>NULL</b>. If <i>pszRootPath</i> contains an empty string or <b>NULL</b>, information is retrieved for all Recycle Bins on all drives.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHQueryRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHEmptyRecycleBin" />
  </member>
  <member name="Windows.SHQueryRecycleBinA">
    <summary>
      <para>Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.</para>
    </summary>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names (C:\Windows\System...).</para>
    </param>
    <param name="pSHQueryRBInfo">
      <para>Type: <b>LPSHQUERYRBINFO</b></para>
      <para>The address of a <see cref="SHQUERYRBINFO" /> structure that receives the Recycle Bin information. The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>With Windows 2000, if <b>NULL</b> is passed in the <i>pszRootPath</i> parameter, the function fails and returns an E_INVALIDARG error code. In earlier versions of the operating system, you can pass an empty string or <b>NULL</b>. If <i>pszRootPath</i> contains an empty string or <b>NULL</b>, information is retrieved for all Recycle Bins on all drives.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHQueryRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHEmptyRecycleBin" />
  </member>
  <member name="Windows.SHQueryRecycleBinW">
    <summary>
      <para>Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.</para>
    </summary>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names (C:\Windows\System...).</para>
    </param>
    <param name="pSHQueryRBInfo">
      <para>Type: <b>LPSHQUERYRBINFO</b></para>
      <para>The address of a <see cref="SHQUERYRBINFO" /> structure that receives the Recycle Bin information. The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>With Windows 2000, if <b>NULL</b> is passed in the <i>pszRootPath</i> parameter, the function fails and returns an E_INVALIDARG error code. In earlier versions of the operating system, you can pass an empty string or <b>NULL</b>. If <i>pszRootPath</i> contains an empty string or <b>NULL</b>, information is retrieved for all Recycle Bins on all drives.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHQueryRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHEmptyRecycleBin" />
  </member>
  <member name="Windows.SHQueryRecycleBin">
    <summary>
      <para>Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.</para>
    </summary>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names (C:\Windows\System...).</para>
    </param>
    <param name="pSHQueryRBInfo">
      <para>Type: <b>LPSHQUERYRBINFO</b></para>
      <para>The address of a <see cref="SHQUERYRBINFO" /> structure that receives the Recycle Bin information. The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>With Windows 2000, if <b>NULL</b> is passed in the <i>pszRootPath</i> parameter, the function fails and returns an E_INVALIDARG error code. In earlier versions of the operating system, you can pass an empty string or <b>NULL</b>. If <i>pszRootPath</i> contains an empty string or <b>NULL</b>, information is retrieved for all Recycle Bins on all drives.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHQueryRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHEmptyRecycleBin" />
  </member>
  <member name="Windows.SHQueryRecycleBinA">
    <summary>
      <para>Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.</para>
    </summary>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names (C:\Windows\System...).</para>
    </param>
    <param name="pSHQueryRBInfo">
      <para>Type: <b>LPSHQUERYRBINFO</b></para>
      <para>The address of a <see cref="SHQUERYRBINFO" /> structure that receives the Recycle Bin information. The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>With Windows 2000, if <b>NULL</b> is passed in the <i>pszRootPath</i> parameter, the function fails and returns an E_INVALIDARG error code. In earlier versions of the operating system, you can pass an empty string or <b>NULL</b>. If <i>pszRootPath</i> contains an empty string or <b>NULL</b>, information is retrieved for all Recycle Bins on all drives.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHQueryRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHEmptyRecycleBin" />
  </member>
  <member name="Windows.SHQueryRecycleBinW">
    <summary>
      <para>Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.</para>
    </summary>
    <param name="pszRootPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names (C:\Windows\System...).</para>
    </param>
    <param name="pSHQueryRBInfo">
      <para>Type: <b>LPSHQUERYRBINFO</b></para>
      <para>The address of a <see cref="SHQUERYRBINFO" /> structure that receives the Recycle Bin information. The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>With Windows 2000, if <b>NULL</b> is passed in the <i>pszRootPath</i> parameter, the function fails and returns an E_INVALIDARG error code. In earlier versions of the operating system, you can pass an empty string or <b>NULL</b>. If <i>pszRootPath</i> contains an empty string or <b>NULL</b>, information is retrieved for all Recycle Bins on all drives.</para>
      <blockquote>
        <para>[!NOTE]
The shellapi.h header defines SHQueryRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHEmptyRecycleBin" />
  </member>
  <member name="Windows.SHQueryUserNotificationState">
    <summary>
      <para>Checks the state of the computer for the current user to determine whether sending a notification is appropriate.</para>
    </summary>
    <param name="pquns">
      <para>Type: <b><see cref="QUERY_USER_NOTIFICATION_STATE" />*</b></para>
      <para>When this function returns, contains a pointer to one of the values of the <see cref="QUERY_USER_NOTIFICATION_STATE" /> enumeration.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>Applications should call <b>SHQueryUserNotificationState</b> and test the return value before displaying any notification UI that is similar to the balloon notifications generated by <see cref="Shell_NotifyIcon" />. Notifications should only be displayed if this API returns <see cref="QNS_ACCEPTS_NOTIFICATIONS" />. This informs the application whether the user is running processes that should not be interrupted. Top-level windows receive a <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message when the user turns presentation settings on or off, and also when the user's session is locked or unlocked. Note that there are no notifications sent when the user starts or stops a full-screen application.</para>
      <para>If this function returns <see cref="QUNS_QUIET_TIME" />, notifications should be displayed only if critical.</para>
    </remarks>
  </member>
  <member name="Windows.SHRemoveLocalizedName">
    <summary>
      <para>Removes the localized name of a file in a Shell folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to a null-terminated, Unicode string that specifies the fully qualified path of the target file.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>When a display name string is set by <see cref="SHSetLocalizedName" />, Windows Explorer uses that string for display instead of the file name. The path to the file is unchanged.</para>
      <para>Applications can use the <see cref="IShellFolder.GetDisplayNameOf" /> method to get the display (localized) name through with the SIGDN_NORMALDISPLAY flag and the parsing (non-localized) name with SIGDN_DESKTOPABSOLUTEPARSING.</para>
      <para>Calling <b>SHRemoveLocalizedName</b> makes the display name identical to the parsing name.</para>
    </remarks>
  </member>
  <member name="Windows.SHSetLocalizedName">
    <summary>
      <para>Sets the localized name of a file in a Shell folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to a string that specifies the fully qualified path of the target file.</para>
    </param>
    <param name="pszResModule">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to a string resource that specifies the localized version of the file name.</para>
    </param>
    <param name="idsRes">
      <para>Type: <b>int</b></para>
      <para>An integer ID that specifies the localized file name in the string resource.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>When this string is set, Explorer displays this string instead of the file name. The path to the file is unchanged.</para>
      <para>Applications can get the display (localized) name with <see cref="IShellFolder.GetDisplayNameOf" /> with the <see cref="SIGDN_NORMALDISPLAY" /> flag and the parsing (non-localized) name with <see cref="IShellItem.GetDisplayName" /> using the <see cref="SIGDN_DESKTOPABSOLUTEPARSING" /> flag.</para>
      <para>Calling <see cref="SHRemoveLocalizedName" /> makes the display name identical to the parsing name.</para>
    </remarks>
  </member>
  <member name="Windows.SHSetUnreadMailCount">
    <summary>
      <para>Stores the current user's unread message count for a specified email account in the registry.</para>
    </summary>
    <param name="pszMailAddress">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that contains the current user's full email address.</para>
    </param>
    <param name="dwCount">
      <para>Type: <b>DWORD</b></para>
      <para>The number of unread messages.</para>
    </param>
    <param name="pszShellExecuteCommand">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that contains the full text of a command that can be passed to ShellExecute. This command should start the email application that owns the account referenced by <i>pszMailAddress</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>
        <b>HRESULT</b>, which includes the following possible values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The call completed successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_OUTOFMEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory available.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Invalid string argument in either the <i>pszMailAddress</i> or <i>pszShellExecuteCommand</i> parameters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>When this function updates the registry, the new registry entry is automatically stamped with the current time and date.</para>
      <para>If this function is called by different independent software vendors (ISVs) that specify the same email name, only the last call is saved. That is, calls to this function overwrite any previously saved value for the same email address, even if the calls are made by different ISVs.</para>
      <para>It is recommended that the count of unread messages be set only for the main Inbox of the users account. Mail in sub-folders such as Drafts or Deleted Items should be ignored.</para>
      <para>It is important that email clients do not set the number of unread messages to 0 when the application exits, because this causes the number of unread messages to be erroneously reported as 0.</para>
      <para>Because this function uses HKEY_CURRENT_USER, it should not be called by a system process impersonating a user.</para>
    </remarks>
  </member>
  <member name="Windows.SHSetUnreadMailCountA">
    <summary>
      <para>Stores the current user's unread message count for a specified email account in the registry.</para>
    </summary>
    <param name="pszMailAddress">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that contains the current user's full email address.</para>
    </param>
    <param name="dwCount">
      <para>Type: <b>DWORD</b></para>
      <para>The number of unread messages.</para>
    </param>
    <param name="pszShellExecuteCommand">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that contains the full text of a command that can be passed to ShellExecute. This command should start the email application that owns the account referenced by <i>pszMailAddress</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>
        <b>HRESULT</b>, which includes the following possible values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The call completed successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_OUTOFMEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory available.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Invalid string argument in either the <i>pszMailAddress</i> or <i>pszShellExecuteCommand</i> parameters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>When this function updates the registry, the new registry entry is automatically stamped with the current time and date.</para>
      <para>If this function is called by different independent software vendors (ISVs) that specify the same email name, only the last call is saved. That is, calls to this function overwrite any previously saved value for the same email address, even if the calls are made by different ISVs.</para>
      <para>It is recommended that the count of unread messages be set only for the main Inbox of the users account. Mail in sub-folders such as Drafts or Deleted Items should be ignored.</para>
      <para>It is important that email clients do not set the number of unread messages to 0 when the application exits, because this causes the number of unread messages to be erroneously reported as 0.</para>
      <para>Because this function uses HKEY_CURRENT_USER, it should not be called by a system process impersonating a user.</para>
    </remarks>
  </member>
  <member name="Windows.SHSetUnreadMailCount">
    <summary>
      <para>Stores the current user's unread message count for a specified email account in the registry.</para>
    </summary>
    <param name="pszMailAddress">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that contains the current user's full email address.</para>
    </param>
    <param name="dwCount">
      <para>Type: <b>DWORD</b></para>
      <para>The number of unread messages.</para>
    </param>
    <param name="pszShellExecuteCommand">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that contains the full text of a command that can be passed to ShellExecute. This command should start the email application that owns the account referenced by <i>pszMailAddress</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>
        <b>HRESULT</b>, which includes the following possible values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The call completed successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_OUTOFMEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory available.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Invalid string argument in either the <i>pszMailAddress</i> or <i>pszShellExecuteCommand</i> parameters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>When this function updates the registry, the new registry entry is automatically stamped with the current time and date.</para>
      <para>If this function is called by different independent software vendors (ISVs) that specify the same email name, only the last call is saved. That is, calls to this function overwrite any previously saved value for the same email address, even if the calls are made by different ISVs.</para>
      <para>It is recommended that the count of unread messages be set only for the main Inbox of the users account. Mail in sub-folders such as Drafts or Deleted Items should be ignored.</para>
      <para>It is important that email clients do not set the number of unread messages to 0 when the application exits, because this causes the number of unread messages to be erroneously reported as 0.</para>
      <para>Because this function uses HKEY_CURRENT_USER, it should not be called by a system process impersonating a user.</para>
    </remarks>
  </member>
  <member name="Windows.SHSetUnreadMailCountW">
    <summary>
      <para>Stores the current user's unread message count for a specified email account in the registry.</para>
    </summary>
    <param name="pszMailAddress">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that contains the current user's full email address.</para>
    </param>
    <param name="dwCount">
      <para>Type: <b>DWORD</b></para>
      <para>The number of unread messages.</para>
    </param>
    <param name="pszShellExecuteCommand">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a string in Unicode that contains the full text of a command that can be passed to ShellExecute. This command should start the email application that owns the account referenced by <i>pszMailAddress</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>
        <b>HRESULT</b>, which includes the following possible values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The call completed successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_OUTOFMEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory available.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>Invalid string argument in either the <i>pszMailAddress</i> or <i>pszShellExecuteCommand</i> parameters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>When this function updates the registry, the new registry entry is automatically stamped with the current time and date.</para>
      <para>If this function is called by different independent software vendors (ISVs) that specify the same email name, only the last call is saved. That is, calls to this function overwrite any previously saved value for the same email address, even if the calls are made by different ISVs.</para>
      <para>It is recommended that the count of unread messages be set only for the main Inbox of the users account. Mail in sub-folders such as Drafts or Deleted Items should be ignored.</para>
      <para>It is important that email clients do not set the number of unread messages to 0 when the application exits, because this causes the number of unread messages to be erroneously reported as 0.</para>
      <para>Because this function uses HKEY_CURRENT_USER, it should not be called by a system process impersonating a user.</para>
    </remarks>
  </member>
  <member name="Windows.SHTestTokenMembership">
    <summary>
      <para>Uses <see cref="CheckTokenMembership" /> to test whether the given token is a member of the local group with the specified RID.</para>
    </summary>
    <param name="hToken">
      <para>Type: <b>HANDLE</b></para>
      <para>A handle to the token. This value can be <b>NULL</b>.</para>
    </param>
    <param name="ulRID">
      <para>Type: <b>ULONG</b></para>
      <para>The RID of the local group for which membership is tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> on success, <b>FALSE</b> on failure.</para>
    </returns>
    <remarks>
      <para>This function wraps <see cref="CheckTokenMembership" /> and only checks local groups.</para>
    </remarks>
  </member>
</doc>